# ! [doc = "Peripheral access API for ATSAMDA1E14B microcontrollers (generated using svd2rust v0.24.0 (b9a7b92 2022-05-12))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.24.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
# ! [deny (const_err)]
# ! [deny (dead_code)]
# ! [deny (improper_ctypes)]
# ! [deny (missing_docs)]
# ! [deny (no_mangle_generic_items)]
# ! [deny (non_shorthand_field_patterns)]
# ! [deny (overflowing_literals)]
# ! [deny (path_statements)]
# ! [deny (patterns_in_fns_without_body)]
# ! [deny (private_in_public)]
# ! [deny (unconditional_recursion)]
# ! [deny (unused_allocation)]
# ! [deny (unused_comparisons)]
# ! [deny (unused_parens)]
# ! [deny (while_true)]
# ! [allow (non_camel_case_types)]
# ! [allow (non_snake_case)]
# ! [no_std]
use core :: ops :: Deref ; use core :: marker :: PhantomData ; # [doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS : u8 = 2 ; pub use cortex_m :: peripheral :: Peripherals as CorePeripherals ; # [cfg (feature = "rt")]
pub use cortex_m_rt :: interrupt ; # [cfg (feature = "rt")]
pub use self :: Interrupt as interrupt ; pub use cortex_m :: peripheral :: { CBP , CPUID , DCB , DWT , FPB , ITM , MPU , NVIC , SCB , SYST , TPIU , } ; # [allow (unused_imports)]
use generic :: * ; # [doc = r"Common register and bit access and modify traits"]
pub mod generic { use core :: marker ; # [doc = " Raw register type"]
pub trait RegisterSpec { # [doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
type Ux : Copy ; } # [doc = " Trait implemented by readable registers to enable the `read` method."]
# [doc = ""]
# [doc = " Registers marked with `Writable` can be also `modify`'ed."]
pub trait Readable : RegisterSpec { # [doc = " Result from a call to `read` and argument to `modify`."]
type Reader : From < R < Self > > + core :: ops :: Deref < Target = R < Self > > ; } # [doc = " Trait implemented by writeable registers."]
# [doc = ""]
# [doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
# [doc = ""]
# [doc = " Registers marked with `Readable` can be also `modify`'ed."]
pub trait Writable : RegisterSpec { # [doc = " Writer type argument to `write`, et al."]
type Writer : From < W < Self > > + core :: ops :: DerefMut < Target = W < Self > > ; } # [doc = " Reset value of the register."]
# [doc = ""]
# [doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
# [doc = " register by using the `reset` method."]
pub trait Resettable : RegisterSpec { # [doc = " Reset value of the register."]
fn reset_value () -> Self :: Ux ; } # [doc = " This structure provides volatile access to registers."]
# [repr (transparent)]
pub struct Reg < REG : RegisterSpec > { register : vcell :: VolatileCell < REG :: Ux > , _marker : marker :: PhantomData < REG > , } unsafe impl < REG : RegisterSpec > Send for Reg < REG > where REG :: Ux : Send { } impl < REG : RegisterSpec > Reg < REG > { # [doc = " Returns the underlying memory address of register."]
# [doc = ""]
# [doc = " ```ignore"]
# [doc = " let reg_ptr = periph.reg.as_ptr();"]
# [doc = " ```"]
# [inline (always)]
pub fn as_ptr (& self) -> * mut REG :: Ux { self . register . as_ptr () } } impl < REG : Readable > Reg < REG > { # [doc = " Reads the contents of a `Readable` register."]
# [doc = ""]
# [doc = " You can read the raw contents of a register by using `bits`:"]
# [doc = " ```ignore"]
# [doc = " let bits = periph.reg.read().bits();"]
# [doc = " ```"]
# [doc = " or get the content of a particular field of a register:"]
# [doc = " ```ignore"]
# [doc = " let reader = periph.reg.read();"]
# [doc = " let bits = reader.field1().bits();"]
# [doc = " let flag = reader.field2().bit_is_set();"]
# [doc = " ```"]
# [inline (always)]
pub fn read (& self) -> REG :: Reader { REG :: Reader :: from (R { bits : self . register . get () , _reg : marker :: PhantomData , }) } } impl < REG : Resettable + Writable > Reg < REG > { # [doc = " Writes the reset value to `Writable` register."]
# [doc = ""]
# [doc = " Resets the register to its initial state."]
# [inline (always)]
pub fn reset (& self) { self . register . set (REG :: reset_value ()) } # [doc = " Writes bits to a `Writable` register."]
# [doc = ""]
# [doc = " You can write raw bits into a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
# [doc = " ```"]
# [doc = " or write only the fields you need:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| w"]
# [doc = "     .field1().bits(newfield1bits)"]
# [doc = "     .field2().set_bit()"]
# [doc = "     .field3().variant(VARIANT)"]
# [doc = " );"]
# [doc = " ```"]
# [doc = " In the latter case, other fields will be set to their reset value."]
# [inline (always)]
pub fn write < F > (& self , f : F) where F : FnOnce (& mut REG :: Writer) -> & mut W < REG > { self . register . set (f (& mut REG :: Writer :: from (W { bits : REG :: reset_value () , _reg : marker :: PhantomData , })) . bits ,) ; } } impl < REG : Writable > Reg < REG > where REG :: Ux : Default , { # [doc = " Writes 0 to a `Writable` register."]
# [doc = ""]
# [doc = " Similar to `write`, but unused bits will contain 0."]
# [inline (always)]
pub unsafe fn write_with_zero < F > (& self , f : F) where F : FnOnce (& mut REG :: Writer) -> & mut W < REG > { self . register . set ((* f (& mut REG :: Writer :: from (W { bits : REG :: Ux :: default () , _reg : marker :: PhantomData , }))) . bits ,) ; } } impl < REG : Readable + Writable > Reg < REG > { # [doc = " Modifies the contents of the register by reading and then writing it."]
# [doc = ""]
# [doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
# [doc = "    r.bits() | 3"]
# [doc = " ) });"]
# [doc = " ```"]
# [doc = " or"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|_, w| w"]
# [doc = "     .field1().bits(newfield1bits)"]
# [doc = "     .field2().set_bit()"]
# [doc = "     .field3().variant(VARIANT)"]
# [doc = " );"]
# [doc = " ```"]
# [doc = " Other fields will have the value they had before the call to `modify`."]
# [inline (always)]
pub fn modify < F > (& self , f : F) where for < 'w > F : FnOnce (& REG :: Reader , & 'w mut REG :: Writer) -> & 'w mut W < REG > { let bits = self . register . get () ; self . register . set (f (& REG :: Reader :: from (R { bits , _reg : marker :: PhantomData , }) , & mut REG :: Writer :: from (W { bits , _reg : marker :: PhantomData , }) ,) . bits ,) ; } } # [doc = " Register reader."]
# [doc = ""]
# [doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
# [doc = " method."]
pub struct R < REG : RegisterSpec + ? Sized > { pub (crate) bits : REG :: Ux , _reg : marker :: PhantomData < REG > , } impl < REG : RegisterSpec > R < REG > { # [doc = " Reads raw bits from register."]
# [inline (always)]
pub fn bits (& self) -> REG :: Ux { self . bits } } impl < REG : RegisterSpec , FI > PartialEq < FI > for R < REG > where REG :: Ux : PartialEq , FI : Copy + Into < REG :: Ux > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& (* other) . into ()) } } # [doc = " Register writer."]
# [doc = ""]
# [doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
pub struct W < REG : RegisterSpec + ? Sized > { # [doc = "Writable bits"]
pub (crate) bits : REG :: Ux , _reg : marker :: PhantomData < REG > , } impl < REG : RegisterSpec > W < REG > { # [doc = " Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : REG :: Ux) -> & mut Self { self . bits = bits ; self } } # [doc (hidden)]
pub struct FieldReaderRaw < U , T > { pub (crate) bits : U , _reg : marker :: PhantomData < T > , } impl < U , FI > FieldReaderRaw < U , FI > where U : Copy , { # [doc = " Creates a new instance of the reader."]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (bits : U) -> Self { Self { bits , _reg : marker :: PhantomData , } } } # [doc (hidden)]
pub struct BitReaderRaw < T > { pub (crate) bits : bool , _reg : marker :: PhantomData < T > , } impl < FI > BitReaderRaw < FI > { # [doc = " Creates a new instance of the reader."]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (bits : bool) -> Self { Self { bits , _reg : marker :: PhantomData , } } } # [doc = " Field reader."]
# [doc = ""]
# [doc = " Result of the `read` methods of fields."]
pub type FieldReader < U , FI > = FieldReaderRaw < U , FI > ; # [doc = " Bit-wise field reader"]
pub type BitReader < FI > = BitReaderRaw < FI > ; impl < U , FI > FieldReader < U , FI > where U : Copy , { # [doc = " Reads raw bits from field."]
# [inline (always)]
pub fn bits (& self) -> U { self . bits } } impl < U , FI > PartialEq < FI > for FieldReader < U , FI > where U : PartialEq , FI : Copy + Into < U > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& (* other) . into ()) } } impl < FI > PartialEq < FI > for BitReader < FI > where FI : Copy + Into < bool > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& (* other) . into ()) } } impl < FI > BitReader < FI > { # [doc = " Value of the field as raw bits."]
# [inline (always)]
pub fn bit (& self) -> bool { self . bits } # [doc = " Returns `true` if the bit is clear (0)."]
# [inline (always)]
pub fn bit_is_clear (& self) -> bool { ! self . bit () } # [doc = " Returns `true` if the bit is set (1)."]
# [inline (always)]
pub fn bit_is_set (& self) -> bool { self . bit () } } # [doc (hidden)]
pub struct Safe ; # [doc (hidden)]
pub struct Unsafe ; # [doc (hidden)]
pub struct FieldWriterRaw < 'a , U , REG , N , FI , Safety , const WI : u8 , const O : u8 > where REG : Writable + RegisterSpec < Ux = U > , FI : Into < N > , { pub (crate) w : & 'a mut REG :: Writer , _field : marker :: PhantomData < (N , FI , Safety) > , } impl < 'a , U , REG , N , FI , Safety , const WI : u8 , const O : u8 > FieldWriterRaw < 'a , U , REG , N , FI , Safety , WI , O > where REG : Writable + RegisterSpec < Ux = U > , FI : Into < N > , { # [doc = " Creates a new instance of the writer"]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (w : & 'a mut REG :: Writer) -> Self { Self { w , _field : marker :: PhantomData , } } } # [doc (hidden)]
pub struct BitWriterRaw < 'a , U , REG , FI , M , const O : u8 > where REG : Writable + RegisterSpec < Ux = U > , FI : Into < bool > , { pub (crate) w : & 'a mut REG :: Writer , _field : marker :: PhantomData < (FI , M) > , } impl < 'a , U , REG , FI , M , const O : u8 > BitWriterRaw < 'a , U , REG , FI , M , O > where REG : Writable + RegisterSpec < Ux = U > , FI : Into < bool > , { # [doc = " Creates a new instance of the writer"]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (w : & 'a mut REG :: Writer) -> Self { Self { w , _field : marker :: PhantomData , } } } # [doc = " Write field Proxy with unsafe `bits`"]
pub type FieldWriter < 'a , U , REG , N , FI , const WI : u8 , const O : u8 > = FieldWriterRaw < 'a , U , REG , N , FI , Unsafe , WI , O > ; # [doc = " Write field Proxy with safe `bits`"]
pub type FieldWriterSafe < 'a , U , REG , N , FI , const WI : u8 , const O : u8 > = FieldWriterRaw < 'a , U , REG , N , FI , Safe , WI , O > ; impl < 'a , U , REG , N , FI , const WI : u8 , const OF : u8 > FieldWriter < 'a , U , REG , N , FI , WI , OF > where REG : Writable + RegisterSpec < Ux = U > , FI : Into < N > , { # [doc = " Field width"]
pub const WIDTH : u8 = WI ; # [doc = " Field offset"]
pub const OFFSET : u8 = OF ; } impl < 'a , U , REG , N , FI , const WI : u8 , const OF : u8 > FieldWriterSafe < 'a , U , REG , N , FI , WI , OF > where REG : Writable + RegisterSpec < Ux = U > , FI : Into < N > , { # [doc = " Field width"]
pub const WIDTH : u8 = WI ; # [doc = " Field offset"]
pub const OFFSET : u8 = OF ; } macro_rules ! bit_proxy { ($ writer : ident , $ mwv : ident) => { # [doc (hidden)]
pub struct $ mwv ; # [doc = " Bit-wise write field proxy"]
pub type $ writer <'a , U , REG , FI , const O : u8 > = BitWriterRaw <'a , U , REG , FI , $ mwv , O >; impl <'a , U , REG , FI , const OF : u8 > $ writer <'a , U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = U >, FI : Into < bool >, { # [doc = " Field width"]
pub const WIDTH : u8 = 1 ; # [doc = " Field offset"]
pub const OFFSET : u8 = OF ; } } } macro_rules ! impl_bit_proxy { ($ writer : ident , $ U : ty) => { impl <'a , REG , FI , const OF : u8 > $ writer <'a , $ U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = $ U >, FI : Into < bool >, { # [doc = " Writes bit to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> &'a mut REG :: Writer { self . w . bits = (self . w . bits & ! (1 << { OF })) | ((<$ U >:: from (value) & 1) << { OF }) ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> &'a mut REG :: Writer { self . bit (variant . into ()) } } } } bit_proxy ! (BitWriter , BitM) ; bit_proxy ! (BitWriter1S , Bit1S) ; bit_proxy ! (BitWriter0C , Bit0C) ; bit_proxy ! (BitWriter1C , Bit1C) ; bit_proxy ! (BitWriter0S , Bit0S) ; bit_proxy ! (BitWriter1T , Bit1T) ; bit_proxy ! (BitWriter0T , Bit0T) ; macro_rules ! impl_proxy { ($ U : ty) => { impl <'a , REG , N , FI , const WI : u8 , const OF : u8 > FieldWriter <'a , $ U , REG , N , FI , WI , OF > where REG : Writable + RegisterSpec < Ux = $ U >, N : Into <$ U >, FI : Into < N >, { const MASK : $ U = <$ U >:: MAX >> (<$ U >:: MAX . leading_ones () as u8 - { WI }) ; # [doc = " Writes raw bits to the field"]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (self , value : N) -> &'a mut REG :: Writer { self . w . bits = (self . w . bits & ! (Self :: MASK << { OF })) | ((value . into () & Self :: MASK) << { OF }) ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> &'a mut REG :: Writer { unsafe { self . bits (variant . into ()) } } } impl <'a , REG , N , FI , const WI : u8 , const OF : u8 > FieldWriterSafe <'a , $ U , REG , N , FI , WI , OF > where REG : Writable + RegisterSpec < Ux = $ U >, N : Into <$ U >, FI : Into < N >, { const MASK : $ U = <$ U >:: MAX >> (<$ U >:: MAX . leading_ones () as u8 - { WI }) ; # [doc = " Writes raw bits to the field"]
# [inline (always)]
pub fn bits (self , value : N) -> &'a mut REG :: Writer { self . w . bits = (self . w . bits & ! (Self :: MASK << { OF })) | ((value . into () & Self :: MASK) << { OF }) ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> &'a mut REG :: Writer { self . bits (variant . into ()) } } impl_bit_proxy ! (BitWriter , $ U) ; impl_bit_proxy ! (BitWriter1S , $ U) ; impl_bit_proxy ! (BitWriter0C , $ U) ; impl_bit_proxy ! (BitWriter1C , $ U) ; impl_bit_proxy ! (BitWriter0S , $ U) ; impl_bit_proxy ! (BitWriter1T , $ U) ; impl_bit_proxy ! (BitWriter0T , $ U) ; impl <'a , REG , FI , const OF : u8 > BitWriter <'a , $ U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = $ U >, FI : Into < bool >, { # [doc = " Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> &'a mut REG :: Writer { self . bit (true) } # [doc = " Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> &'a mut REG :: Writer { self . bit (false) } } impl <'a , REG , FI , const OF : u8 > BitWriter1S <'a , $ U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = $ U >, FI : Into < bool >, { # [doc = " Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> &'a mut REG :: Writer { self . bit (true) } } impl <'a , REG , FI , const OF : u8 > BitWriter0C <'a , $ U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = $ U >, FI : Into < bool >, { # [doc = " Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> &'a mut REG :: Writer { self . bit (false) } } impl <'a , REG , FI , const OF : u8 > BitWriter1C <'a , $ U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = $ U >, FI : Into < bool >, { # [doc = "Clears the field bit by passing one"]
# [inline (always)]
pub fn clear_bit_by_one (self) -> &'a mut REG :: Writer { self . bit (true) } } impl <'a , REG , FI , const OF : u8 > BitWriter0S <'a , $ U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = $ U >, FI : Into < bool >, { # [doc = "Sets the field bit by passing zero"]
# [inline (always)]
pub fn set_bit_by_zero (self) -> &'a mut REG :: Writer { self . bit (false) } } impl <'a , REG , FI , const OF : u8 > BitWriter1T <'a , $ U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = $ U >, FI : Into < bool >, { # [doc = "Toggle the field bit by passing one"]
# [inline (always)]
pub fn toggle_bit (self) -> &'a mut REG :: Writer { self . bit (true) } } impl <'a , REG , FI , const OF : u8 > BitWriter0T <'a , $ U , REG , FI , OF > where REG : Writable + RegisterSpec < Ux = $ U >, FI : Into < bool >, { # [doc = "Toggle the field bit by passing zero"]
# [inline (always)]
pub fn toggle_bit (self) -> &'a mut REG :: Writer { self . bit (false) } } } } impl_proxy ! (u32) ; impl_proxy ! (u16) ; impl_proxy ! (u8) ; } # [cfg (feature = "rt")]
extern "C" { fn PM_INTREQ () ; fn SYSCTRL_INTREQ () ; fn WDT_INTREQ () ; fn RTC_INTREQ () ; fn EIC_INTREQ () ; fn NVMCTRL_INTREQ () ; fn DMAC_INTREQ () ; fn USB_INTREQ () ; fn EVSYS_INTREQ () ; fn SERCOM0_INTREQ () ; fn SERCOM1_INTREQ () ; fn SERCOM2_INTREQ () ; fn SERCOM3_INTREQ () ; fn SERCOM4_INTREQ () ; fn SERCOM5_INTREQ () ; fn TCC0_INTREQ () ; fn TCC1_INTREQ () ; fn TCC2_INTREQ () ; fn TC3_INTREQ () ; fn TC4_INTREQ () ; fn TC5_INTREQ () ; fn TC6_INTREQ () ; fn TC7_INTREQ () ; fn ADC_INTREQ () ; fn AC_INTREQ () ; fn DAC_INTREQ () ; fn I2S_INTREQ () ; } # [doc (hidden)]
pub union Vector { _handler : unsafe extern "C" fn () , _reserved : u32 , } # [cfg (feature = "rt")]
# [doc (hidden)]
# [link_section = ".vector_table.interrupts"]
# [no_mangle]
pub static __INTERRUPTS : [Vector ; 28]
= [Vector { _handler : PM_INTREQ } , Vector { _handler : SYSCTRL_INTREQ } , Vector { _handler : WDT_INTREQ } , Vector { _handler : RTC_INTREQ } , Vector { _handler : EIC_INTREQ } , Vector { _handler : NVMCTRL_INTREQ } , Vector { _handler : DMAC_INTREQ } , Vector { _handler : USB_INTREQ } , Vector { _handler : EVSYS_INTREQ } , Vector { _handler : SERCOM0_INTREQ } , Vector { _handler : SERCOM1_INTREQ } , Vector { _handler : SERCOM2_INTREQ } , Vector { _handler : SERCOM3_INTREQ } , Vector { _handler : SERCOM4_INTREQ } , Vector { _handler : SERCOM5_INTREQ } , Vector { _handler : TCC0_INTREQ } , Vector { _handler : TCC1_INTREQ } , Vector { _handler : TCC2_INTREQ } , Vector { _handler : TC3_INTREQ } , Vector { _handler : TC4_INTREQ } , Vector { _handler : TC5_INTREQ } , Vector { _handler : TC6_INTREQ } , Vector { _handler : TC7_INTREQ } , Vector { _handler : ADC_INTREQ } , Vector { _handler : AC_INTREQ } , Vector { _handler : DAC_INTREQ } , Vector { _reserved : 0 } , Vector { _handler : I2S_INTREQ } ,]
; # [doc = r"Enumeration of all the interrupts."]
# [derive (Copy , Clone , Debug , PartialEq , Eq)]
# [repr (u16)]
pub enum Interrupt { # [doc = "0 - PM_INTREQ"]
PM_INTREQ = 0 , # [doc = "1 - SYSCTRL_INTREQ"]
SYSCTRL_INTREQ = 1 , # [doc = "2 - WDT_INTREQ"]
WDT_INTREQ = 2 , # [doc = "3 - RTC_INTREQ"]
RTC_INTREQ = 3 , # [doc = "4 - EIC_INTREQ"]
EIC_INTREQ = 4 , # [doc = "5 - NVMCTRL_INTREQ"]
NVMCTRL_INTREQ = 5 , # [doc = "6 - DMAC_INTREQ"]
DMAC_INTREQ = 6 , # [doc = "7 - USB_INTREQ"]
USB_INTREQ = 7 , # [doc = "8 - EVSYS_INTREQ"]
EVSYS_INTREQ = 8 , # [doc = "9 - SERCOM0_INTREQ"]
SERCOM0_INTREQ = 9 , # [doc = "10 - SERCOM1_INTREQ"]
SERCOM1_INTREQ = 10 , # [doc = "11 - SERCOM2_INTREQ"]
SERCOM2_INTREQ = 11 , # [doc = "12 - SERCOM3_INTREQ"]
SERCOM3_INTREQ = 12 , # [doc = "13 - SERCOM4_INTREQ"]
SERCOM4_INTREQ = 13 , # [doc = "14 - SERCOM5_INTREQ"]
SERCOM5_INTREQ = 14 , # [doc = "15 - TCC0_INTREQ"]
TCC0_INTREQ = 15 , # [doc = "16 - TCC1_INTREQ"]
TCC1_INTREQ = 16 , # [doc = "17 - TCC2_INTREQ"]
TCC2_INTREQ = 17 , # [doc = "18 - TC3_INTREQ"]
TC3_INTREQ = 18 , # [doc = "19 - TC4_INTREQ"]
TC4_INTREQ = 19 , # [doc = "20 - TC5_INTREQ"]
TC5_INTREQ = 20 , # [doc = "21 - TC6_INTREQ"]
TC6_INTREQ = 21 , # [doc = "22 - TC7_INTREQ"]
TC7_INTREQ = 22 , # [doc = "23 - ADC_INTREQ"]
ADC_INTREQ = 23 , # [doc = "24 - AC_INTREQ"]
AC_INTREQ = 24 , # [doc = "25 - DAC_INTREQ"]
DAC_INTREQ = 25 , # [doc = "27 - I2S_INTREQ"]
I2S_INTREQ = 27 , } unsafe impl cortex_m :: interrupt :: InterruptNumber for Interrupt { # [inline (always)]
fn number (self) -> u16 { self as u16 } } # [doc = "Analog Comparators"]
pub struct AC { _marker : PhantomData < * const () > } unsafe impl Send for AC { } impl AC { # [doc = r"Pointer to the register block"]
pub const PTR : * const ac :: RegisterBlock = 0x4200_4400 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const ac :: RegisterBlock { Self :: PTR } } impl Deref for AC { type Target = ac :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for AC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("AC") . finish () } } # [doc = "Analog Comparators"]
pub mod ac { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : crate :: Reg < ctrla :: CTRLA_SPEC > , # [doc = "0x01 - Control B"]
pub ctrlb : crate :: Reg < ctrlb :: CTRLB_SPEC > , # [doc = "0x02 - Event Control"]
pub evctrl : crate :: Reg < evctrl :: EVCTRL_SPEC > , # [doc = "0x04 - Interrupt Enable Clear"]
pub intenclr : crate :: Reg < intenclr :: INTENCLR_SPEC > , # [doc = "0x05 - Interrupt Enable Set"]
pub intenset : crate :: Reg < intenset :: INTENSET_SPEC > , # [doc = "0x06 - Interrupt Flag Status and Clear"]
pub intflag : crate :: Reg < intflag :: INTFLAG_SPEC > , _reserved6 : [u8 ; 0x01]
, # [doc = "0x08 - Status A"]
pub statusa : crate :: Reg < statusa :: STATUSA_SPEC > , # [doc = "0x09 - Status B"]
pub statusb : crate :: Reg < statusb :: STATUSB_SPEC > , # [doc = "0x0a - Status C"]
pub statusc : crate :: Reg < statusc :: STATUSC_SPEC > , _reserved9 : [u8 ; 0x01]
, # [doc = "0x0c - Window Control"]
pub winctrl : crate :: Reg < winctrl :: WINCTRL_SPEC > , _reserved10 : [u8 ; 0x03]
, # [doc = "0x10..0x18 - Comparator Control n"]
pub compctrl : [crate :: Reg < compctrl :: COMPCTRL_SPEC > ; 2]
, _reserved11 : [u8 ; 0x08]
, # [doc = "0x20 - Scaler n"]
pub scaler : [crate :: Reg < scaler :: SCALER_SPEC > ; 2]
, } # [doc = "CTRLA register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWRST` writer - Software Reset"]
pub type SWRST_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , 0 > ; # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , 1 > ; # [doc = "Field `RUNSTDBY` reader - Run in Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run in Standby"]
pub type RUNSTDBY_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , 2 > ; # [doc = "Field `LPMUX` reader - Low-Power Mux"]
pub type LPMUX_R = crate :: BitReader < bool > ; # [doc = "Field `LPMUX` writer - Low-Power Mux"]
pub type LPMUX_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , 7 > ; impl R { # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 7 - Low-Power Mux"]
# [inline (always)]
pub fn lpmux (& self) -> LPMUX_R { LPMUX_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& mut self) -> SWRST_W { SWRST_W :: new (self) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Bit 2 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& mut self) -> RUNSTDBY_W { RUNSTDBY_W :: new (self) } # [doc = "Bit 7 - Low-Power Mux"]
# [inline (always)]
pub fn lpmux (& mut self) -> LPMUX_W { LPMUX_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CTRLB register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `START0` writer - Comparator 0 Start Comparison"]
pub type START0_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , 0 > ; # [doc = "Field `START1` writer - Comparator 1 Start Comparison"]
pub type START1_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , 1 > ; impl W { # [doc = "Bit 0 - Comparator 0 Start Comparison"]
# [inline (always)]
pub fn start0 (& mut self) -> START0_W { START0_W :: new (self) } # [doc = "Bit 1 - Comparator 1 Start Comparison"]
# [inline (always)]
pub fn start1 (& mut self) -> START1_W { START1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "EVCTRL register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "Event Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `COMPEO0` reader - Comparator 0 Event Output Enable"]
pub type COMPEO0_R = crate :: BitReader < bool > ; # [doc = "Field `COMPEO0` writer - Comparator 0 Event Output Enable"]
pub type COMPEO0_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 0 > ; # [doc = "Field `COMPEO1` reader - Comparator 1 Event Output Enable"]
pub type COMPEO1_R = crate :: BitReader < bool > ; # [doc = "Field `COMPEO1` writer - Comparator 1 Event Output Enable"]
pub type COMPEO1_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 1 > ; # [doc = "Field `WINEO0` reader - Window 0 Event Output Enable"]
pub type WINEO0_R = crate :: BitReader < bool > ; # [doc = "Field `WINEO0` writer - Window 0 Event Output Enable"]
pub type WINEO0_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 4 > ; # [doc = "Field `COMPEI0` reader - Comparator 0 Event Input"]
pub type COMPEI0_R = crate :: BitReader < bool > ; # [doc = "Field `COMPEI0` writer - Comparator 0 Event Input"]
pub type COMPEI0_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 8 > ; # [doc = "Field `COMPEI1` reader - Comparator 1 Event Input"]
pub type COMPEI1_R = crate :: BitReader < bool > ; # [doc = "Field `COMPEI1` writer - Comparator 1 Event Input"]
pub type COMPEI1_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 9 > ; impl R { # [doc = "Bit 0 - Comparator 0 Event Output Enable"]
# [inline (always)]
pub fn compeo0 (& self) -> COMPEO0_R { COMPEO0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Comparator 1 Event Output Enable"]
# [inline (always)]
pub fn compeo1 (& self) -> COMPEO1_R { COMPEO1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - Window 0 Event Output Enable"]
# [inline (always)]
pub fn wineo0 (& self) -> WINEO0_R { WINEO0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 8 - Comparator 0 Event Input"]
# [inline (always)]
pub fn compei0 (& self) -> COMPEI0_R { COMPEI0_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Comparator 1 Event Input"]
# [inline (always)]
pub fn compei1 (& self) -> COMPEI1_R { COMPEI1_R :: new (((self . bits >> 9) & 1) != 0) } } impl W { # [doc = "Bit 0 - Comparator 0 Event Output Enable"]
# [inline (always)]
pub fn compeo0 (& mut self) -> COMPEO0_W { COMPEO0_W :: new (self) } # [doc = "Bit 1 - Comparator 1 Event Output Enable"]
# [inline (always)]
pub fn compeo1 (& mut self) -> COMPEO1_W { COMPEO1_W :: new (self) } # [doc = "Bit 4 - Window 0 Event Output Enable"]
# [inline (always)]
pub fn wineo0 (& mut self) -> WINEO0_W { WINEO0_W :: new (self) } # [doc = "Bit 8 - Comparator 0 Event Input"]
# [inline (always)]
pub fn compei0 (& mut self) -> COMPEI0_W { COMPEI0_W :: new (self) } # [doc = "Bit 9 - Comparator 1 Event Input"]
# [inline (always)]
pub fn compei1 (& mut self) -> COMPEI1_W { COMPEI1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENCLR register accessor: an alias for `Reg<INTENCLR_SPEC>`"]
pub type INTENCLR = crate :: Reg < intenclr :: INTENCLR_SPEC > ; # [doc = "Interrupt Enable Clear"]
pub mod intenclr { # [doc = "Register `INTENCLR` reader"]
pub struct R (crate :: R < INTENCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENCLR` writer"]
pub struct W (crate :: W < INTENCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `COMP0` reader - Comparator 0 Interrupt Enable"]
pub type COMP0_R = crate :: BitReader < bool > ; # [doc = "Field `COMP0` writer - Comparator 0 Interrupt Enable"]
pub type COMP0_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 0 > ; # [doc = "Field `COMP1` reader - Comparator 1 Interrupt Enable"]
pub type COMP1_R = crate :: BitReader < bool > ; # [doc = "Field `COMP1` writer - Comparator 1 Interrupt Enable"]
pub type COMP1_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 1 > ; # [doc = "Field `WIN0` reader - Window 0 Interrupt Enable"]
pub type WIN0_R = crate :: BitReader < bool > ; # [doc = "Field `WIN0` writer - Window 0 Interrupt Enable"]
pub type WIN0_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 4 > ; impl R { # [doc = "Bit 0 - Comparator 0 Interrupt Enable"]
# [inline (always)]
pub fn comp0 (& self) -> COMP0_R { COMP0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Comparator 1 Interrupt Enable"]
# [inline (always)]
pub fn comp1 (& self) -> COMP1_R { COMP1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - Window 0 Interrupt Enable"]
# [inline (always)]
pub fn win0 (& self) -> WIN0_R { WIN0_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Comparator 0 Interrupt Enable"]
# [inline (always)]
pub fn comp0 (& mut self) -> COMP0_W { COMP0_W :: new (self) } # [doc = "Bit 1 - Comparator 1 Interrupt Enable"]
# [inline (always)]
pub fn comp1 (& mut self) -> COMP1_W { COMP1_W :: new (self) } # [doc = "Bit 4 - Window 0 Interrupt Enable"]
# [inline (always)]
pub fn win0 (& mut self) -> WIN0_W { WIN0_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenclr](index.html) module"]
pub struct INTENCLR_SPEC ; impl crate :: RegisterSpec for INTENCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenclr::R](R) reader structure"]
impl crate :: Readable for INTENCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenclr::W](W) writer structure"]
impl crate :: Writable for INTENCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENCLR to value 0"]
impl crate :: Resettable for INTENCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENSET register accessor: an alias for `Reg<INTENSET_SPEC>`"]
pub type INTENSET = crate :: Reg < intenset :: INTENSET_SPEC > ; # [doc = "Interrupt Enable Set"]
pub mod intenset { # [doc = "Register `INTENSET` reader"]
pub struct R (crate :: R < INTENSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENSET` writer"]
pub struct W (crate :: W < INTENSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `COMP0` reader - Comparator 0 Interrupt Enable"]
pub type COMP0_R = crate :: BitReader < bool > ; # [doc = "Field `COMP0` writer - Comparator 0 Interrupt Enable"]
pub type COMP0_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 0 > ; # [doc = "Field `COMP1` reader - Comparator 1 Interrupt Enable"]
pub type COMP1_R = crate :: BitReader < bool > ; # [doc = "Field `COMP1` writer - Comparator 1 Interrupt Enable"]
pub type COMP1_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 1 > ; # [doc = "Field `WIN0` reader - Window 0 Interrupt Enable"]
pub type WIN0_R = crate :: BitReader < bool > ; # [doc = "Field `WIN0` writer - Window 0 Interrupt Enable"]
pub type WIN0_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 4 > ; impl R { # [doc = "Bit 0 - Comparator 0 Interrupt Enable"]
# [inline (always)]
pub fn comp0 (& self) -> COMP0_R { COMP0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Comparator 1 Interrupt Enable"]
# [inline (always)]
pub fn comp1 (& self) -> COMP1_R { COMP1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - Window 0 Interrupt Enable"]
# [inline (always)]
pub fn win0 (& self) -> WIN0_R { WIN0_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Comparator 0 Interrupt Enable"]
# [inline (always)]
pub fn comp0 (& mut self) -> COMP0_W { COMP0_W :: new (self) } # [doc = "Bit 1 - Comparator 1 Interrupt Enable"]
# [inline (always)]
pub fn comp1 (& mut self) -> COMP1_W { COMP1_W :: new (self) } # [doc = "Bit 4 - Window 0 Interrupt Enable"]
# [inline (always)]
pub fn win0 (& mut self) -> WIN0_W { WIN0_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenset](index.html) module"]
pub struct INTENSET_SPEC ; impl crate :: RegisterSpec for INTENSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenset::R](R) reader structure"]
impl crate :: Readable for INTENSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenset::W](W) writer structure"]
impl crate :: Writable for INTENSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENSET to value 0"]
impl crate :: Resettable for INTENSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTFLAG register accessor: an alias for `Reg<INTFLAG_SPEC>`"]
pub type INTFLAG = crate :: Reg < intflag :: INTFLAG_SPEC > ; # [doc = "Interrupt Flag Status and Clear"]
pub mod intflag { # [doc = "Register `INTFLAG` reader"]
pub struct R (crate :: R < INTFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAG` writer"]
pub struct W (crate :: W < INTFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `COMP0` reader - Comparator 0"]
pub type COMP0_R = crate :: BitReader < bool > ; # [doc = "Field `COMP0` writer - Comparator 0"]
pub type COMP0_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 0 > ; # [doc = "Field `COMP1` reader - Comparator 1"]
pub type COMP1_R = crate :: BitReader < bool > ; # [doc = "Field `COMP1` writer - Comparator 1"]
pub type COMP1_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 1 > ; # [doc = "Field `WIN0` reader - Window 0"]
pub type WIN0_R = crate :: BitReader < bool > ; # [doc = "Field `WIN0` writer - Window 0"]
pub type WIN0_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 4 > ; impl R { # [doc = "Bit 0 - Comparator 0"]
# [inline (always)]
pub fn comp0 (& self) -> COMP0_R { COMP0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Comparator 1"]
# [inline (always)]
pub fn comp1 (& self) -> COMP1_R { COMP1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - Window 0"]
# [inline (always)]
pub fn win0 (& self) -> WIN0_R { WIN0_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Comparator 0"]
# [inline (always)]
pub fn comp0 (& mut self) -> COMP0_W { COMP0_W :: new (self) } # [doc = "Bit 1 - Comparator 1"]
# [inline (always)]
pub fn comp1 (& mut self) -> COMP1_W { COMP1_W :: new (self) } # [doc = "Bit 4 - Window 0"]
# [inline (always)]
pub fn win0 (& mut self) -> WIN0_W { WIN0_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflag](index.html) module"]
pub struct INTFLAG_SPEC ; impl crate :: RegisterSpec for INTFLAG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflag::R](R) reader structure"]
impl crate :: Readable for INTFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflag::W](W) writer structure"]
impl crate :: Writable for INTFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTFLAG to value 0"]
impl crate :: Resettable for INTFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATUSA register accessor: an alias for `Reg<STATUSA_SPEC>`"]
pub type STATUSA = crate :: Reg < statusa :: STATUSA_SPEC > ; # [doc = "Status A"]
pub mod statusa { # [doc = "Register `STATUSA` reader"]
pub struct R (crate :: R < STATUSA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUSA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUSA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUSA_SPEC >) -> Self { R (reader) } } # [doc = "Field `STATE0` reader - Comparator 0 Current State"]
pub type STATE0_R = crate :: BitReader < bool > ; # [doc = "Field `STATE1` reader - Comparator 1 Current State"]
pub type STATE1_R = crate :: BitReader < bool > ; # [doc = "Window 0 Current State\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum WSTATE0_A { # [doc = "0: Signal is above window"]
ABOVE = 0 , # [doc = "1: Signal is inside window"]
INSIDE = 1 , # [doc = "2: Signal is below window"]
BELOW = 2 , } impl From < WSTATE0_A > for u8 { # [inline (always)]
fn from (variant : WSTATE0_A) -> Self { variant as _ } } # [doc = "Field `WSTATE0` reader - Window 0 Current State"]
pub type WSTATE0_R = crate :: FieldReader < u8 , WSTATE0_A > ; impl WSTATE0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WSTATE0_A > { match self . bits { 0 => Some (WSTATE0_A :: ABOVE) , 1 => Some (WSTATE0_A :: INSIDE) , 2 => Some (WSTATE0_A :: BELOW) , _ => None , } } # [doc = "Checks if the value of the field is `ABOVE`"]
# [inline (always)]
pub fn is_above (& self) -> bool { * self == WSTATE0_A :: ABOVE } # [doc = "Checks if the value of the field is `INSIDE`"]
# [inline (always)]
pub fn is_inside (& self) -> bool { * self == WSTATE0_A :: INSIDE } # [doc = "Checks if the value of the field is `BELOW`"]
# [inline (always)]
pub fn is_below (& self) -> bool { * self == WSTATE0_A :: BELOW } } impl R { # [doc = "Bit 0 - Comparator 0 Current State"]
# [inline (always)]
pub fn state0 (& self) -> STATE0_R { STATE0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Comparator 1 Current State"]
# [inline (always)]
pub fn state1 (& self) -> STATE1_R { STATE1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 4:5 - Window 0 Current State"]
# [inline (always)]
pub fn wstate0 (& self) -> WSTATE0_R { WSTATE0_R :: new (((self . bits >> 4) & 3) as u8) } } # [doc = "Status A\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [statusa](index.html) module"]
pub struct STATUSA_SPEC ; impl crate :: RegisterSpec for STATUSA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [statusa::R](R) reader structure"]
impl crate :: Readable for STATUSA_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATUSA to value 0"]
impl crate :: Resettable for STATUSA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATUSB register accessor: an alias for `Reg<STATUSB_SPEC>`"]
pub type STATUSB = crate :: Reg < statusb :: STATUSB_SPEC > ; # [doc = "Status B"]
pub mod statusb { # [doc = "Register `STATUSB` reader"]
pub struct R (crate :: R < STATUSB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUSB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUSB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUSB_SPEC >) -> Self { R (reader) } } # [doc = "Field `READY0` reader - Comparator 0 Ready"]
pub type READY0_R = crate :: BitReader < bool > ; # [doc = "Field `READY1` reader - Comparator 1 Ready"]
pub type READY1_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCBUSY` reader - Synchronization Busy"]
pub type SYNCBUSY_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Comparator 0 Ready"]
# [inline (always)]
pub fn ready0 (& self) -> READY0_R { READY0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Comparator 1 Ready"]
# [inline (always)]
pub fn ready1 (& self) -> READY1_R { READY1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 7 - Synchronization Busy"]
# [inline (always)]
pub fn syncbusy (& self) -> SYNCBUSY_R { SYNCBUSY_R :: new (((self . bits >> 7) & 1) != 0) } } # [doc = "Status B\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [statusb](index.html) module"]
pub struct STATUSB_SPEC ; impl crate :: RegisterSpec for STATUSB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [statusb::R](R) reader structure"]
impl crate :: Readable for STATUSB_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATUSB to value 0"]
impl crate :: Resettable for STATUSB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATUSC register accessor: an alias for `Reg<STATUSC_SPEC>`"]
pub type STATUSC = crate :: Reg < statusc :: STATUSC_SPEC > ; # [doc = "Status C"]
pub mod statusc { # [doc = "Register `STATUSC` reader"]
pub struct R (crate :: R < STATUSC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUSC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUSC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUSC_SPEC >) -> Self { R (reader) } } # [doc = "Field `STATE0` reader - Comparator 0 Current State"]
pub type STATE0_R = crate :: BitReader < bool > ; # [doc = "Field `STATE1` reader - Comparator 1 Current State"]
pub type STATE1_R = crate :: BitReader < bool > ; # [doc = "Window 0 Current State\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum WSTATE0_A { # [doc = "0: Signal is above window"]
ABOVE = 0 , # [doc = "1: Signal is inside window"]
INSIDE = 1 , # [doc = "2: Signal is below window"]
BELOW = 2 , } impl From < WSTATE0_A > for u8 { # [inline (always)]
fn from (variant : WSTATE0_A) -> Self { variant as _ } } # [doc = "Field `WSTATE0` reader - Window 0 Current State"]
pub type WSTATE0_R = crate :: FieldReader < u8 , WSTATE0_A > ; impl WSTATE0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WSTATE0_A > { match self . bits { 0 => Some (WSTATE0_A :: ABOVE) , 1 => Some (WSTATE0_A :: INSIDE) , 2 => Some (WSTATE0_A :: BELOW) , _ => None , } } # [doc = "Checks if the value of the field is `ABOVE`"]
# [inline (always)]
pub fn is_above (& self) -> bool { * self == WSTATE0_A :: ABOVE } # [doc = "Checks if the value of the field is `INSIDE`"]
# [inline (always)]
pub fn is_inside (& self) -> bool { * self == WSTATE0_A :: INSIDE } # [doc = "Checks if the value of the field is `BELOW`"]
# [inline (always)]
pub fn is_below (& self) -> bool { * self == WSTATE0_A :: BELOW } } impl R { # [doc = "Bit 0 - Comparator 0 Current State"]
# [inline (always)]
pub fn state0 (& self) -> STATE0_R { STATE0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Comparator 1 Current State"]
# [inline (always)]
pub fn state1 (& self) -> STATE1_R { STATE1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 4:5 - Window 0 Current State"]
# [inline (always)]
pub fn wstate0 (& self) -> WSTATE0_R { WSTATE0_R :: new (((self . bits >> 4) & 3) as u8) } } # [doc = "Status C\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [statusc](index.html) module"]
pub struct STATUSC_SPEC ; impl crate :: RegisterSpec for STATUSC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [statusc::R](R) reader structure"]
impl crate :: Readable for STATUSC_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATUSC to value 0"]
impl crate :: Resettable for STATUSC_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "WINCTRL register accessor: an alias for `Reg<WINCTRL_SPEC>`"]
pub type WINCTRL = crate :: Reg < winctrl :: WINCTRL_SPEC > ; # [doc = "Window Control"]
pub mod winctrl { # [doc = "Register `WINCTRL` reader"]
pub struct R (crate :: R < WINCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < WINCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < WINCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < WINCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `WINCTRL` writer"]
pub struct W (crate :: W < WINCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < WINCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < WINCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < WINCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `WEN0` reader - Window 0 Mode Enable"]
pub type WEN0_R = crate :: BitReader < bool > ; # [doc = "Field `WEN0` writer - Window 0 Mode Enable"]
pub type WEN0_W < 'a > = crate :: BitWriter < 'a , u8 , WINCTRL_SPEC , bool , 0 > ; # [doc = "Window 0 Interrupt Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum WINTSEL0_A { # [doc = "0: Interrupt on signal above window"]
ABOVE = 0 , # [doc = "1: Interrupt on signal inside window"]
INSIDE = 1 , # [doc = "2: Interrupt on signal below window"]
BELOW = 2 , # [doc = "3: Interrupt on signal outside window"]
OUTSIDE = 3 , } impl From < WINTSEL0_A > for u8 { # [inline (always)]
fn from (variant : WINTSEL0_A) -> Self { variant as _ } } # [doc = "Field `WINTSEL0` reader - Window 0 Interrupt Selection"]
pub type WINTSEL0_R = crate :: FieldReader < u8 , WINTSEL0_A > ; impl WINTSEL0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> WINTSEL0_A { match self . bits { 0 => WINTSEL0_A :: ABOVE , 1 => WINTSEL0_A :: INSIDE , 2 => WINTSEL0_A :: BELOW , 3 => WINTSEL0_A :: OUTSIDE , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ABOVE`"]
# [inline (always)]
pub fn is_above (& self) -> bool { * self == WINTSEL0_A :: ABOVE } # [doc = "Checks if the value of the field is `INSIDE`"]
# [inline (always)]
pub fn is_inside (& self) -> bool { * self == WINTSEL0_A :: INSIDE } # [doc = "Checks if the value of the field is `BELOW`"]
# [inline (always)]
pub fn is_below (& self) -> bool { * self == WINTSEL0_A :: BELOW } # [doc = "Checks if the value of the field is `OUTSIDE`"]
# [inline (always)]
pub fn is_outside (& self) -> bool { * self == WINTSEL0_A :: OUTSIDE } } # [doc = "Field `WINTSEL0` writer - Window 0 Interrupt Selection"]
pub type WINTSEL0_W < 'a > = crate :: FieldWriterSafe < 'a , u8 , WINCTRL_SPEC , u8 , WINTSEL0_A , 2 , 1 > ; impl < 'a > WINTSEL0_W < 'a > { # [doc = "Interrupt on signal above window"]
# [inline (always)]
pub fn above (self) -> & 'a mut W { self . variant (WINTSEL0_A :: ABOVE) } # [doc = "Interrupt on signal inside window"]
# [inline (always)]
pub fn inside (self) -> & 'a mut W { self . variant (WINTSEL0_A :: INSIDE) } # [doc = "Interrupt on signal below window"]
# [inline (always)]
pub fn below (self) -> & 'a mut W { self . variant (WINTSEL0_A :: BELOW) } # [doc = "Interrupt on signal outside window"]
# [inline (always)]
pub fn outside (self) -> & 'a mut W { self . variant (WINTSEL0_A :: OUTSIDE) } } impl R { # [doc = "Bit 0 - Window 0 Mode Enable"]
# [inline (always)]
pub fn wen0 (& self) -> WEN0_R { WEN0_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Window 0 Interrupt Selection"]
# [inline (always)]
pub fn wintsel0 (& self) -> WINTSEL0_R { WINTSEL0_R :: new (((self . bits >> 1) & 3) as u8) } } impl W { # [doc = "Bit 0 - Window 0 Mode Enable"]
# [inline (always)]
pub fn wen0 (& mut self) -> WEN0_W { WEN0_W :: new (self) } # [doc = "Bits 1:2 - Window 0 Interrupt Selection"]
# [inline (always)]
pub fn wintsel0 (& mut self) -> WINTSEL0_W { WINTSEL0_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Window Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [winctrl](index.html) module"]
pub struct WINCTRL_SPEC ; impl crate :: RegisterSpec for WINCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [winctrl::R](R) reader structure"]
impl crate :: Readable for WINCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [winctrl::W](W) writer structure"]
impl crate :: Writable for WINCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets WINCTRL to value 0"]
impl crate :: Resettable for WINCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "COMPCTRL register accessor: an alias for `Reg<COMPCTRL_SPEC>`"]
pub type COMPCTRL = crate :: Reg < compctrl :: COMPCTRL_SPEC > ; # [doc = "Comparator Control n"]
pub mod compctrl { # [doc = "Register `COMPCTRL%s` reader"]
pub struct R (crate :: R < COMPCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < COMPCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < COMPCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < COMPCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `COMPCTRL%s` writer"]
pub struct W (crate :: W < COMPCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < COMPCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < COMPCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < COMPCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u32 , COMPCTRL_SPEC , bool , 0 > ; # [doc = "Field `SINGLE` reader - Single-Shot Mode"]
pub type SINGLE_R = crate :: BitReader < bool > ; # [doc = "Field `SINGLE` writer - Single-Shot Mode"]
pub type SINGLE_W < 'a > = crate :: BitWriter < 'a , u32 , COMPCTRL_SPEC , bool , 1 > ; # [doc = "Speed Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum SPEED_A { # [doc = "0: Low speed"]
LOW = 0 , # [doc = "1: High speed"]
HIGH = 1 , } impl From < SPEED_A > for u8 { # [inline (always)]
fn from (variant : SPEED_A) -> Self { variant as _ } } # [doc = "Field `SPEED` reader - Speed Selection"]
pub type SPEED_R = crate :: FieldReader < u8 , SPEED_A > ; impl SPEED_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SPEED_A > { match self . bits { 0 => Some (SPEED_A :: LOW) , 1 => Some (SPEED_A :: HIGH) , _ => None , } } # [doc = "Checks if the value of the field is `LOW`"]
# [inline (always)]
pub fn is_low (& self) -> bool { * self == SPEED_A :: LOW } # [doc = "Checks if the value of the field is `HIGH`"]
# [inline (always)]
pub fn is_high (& self) -> bool { * self == SPEED_A :: HIGH } } # [doc = "Field `SPEED` writer - Speed Selection"]
pub type SPEED_W < 'a > = crate :: FieldWriter < 'a , u32 , COMPCTRL_SPEC , u8 , SPEED_A , 2 , 2 > ; impl < 'a > SPEED_W < 'a > { # [doc = "Low speed"]
# [inline (always)]
pub fn low (self) -> & 'a mut W { self . variant (SPEED_A :: LOW) } # [doc = "High speed"]
# [inline (always)]
pub fn high (self) -> & 'a mut W { self . variant (SPEED_A :: HIGH) } } # [doc = "Interrupt Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum INTSEL_A { # [doc = "0: Interrupt on comparator output toggle"]
TOGGLE = 0 , # [doc = "1: Interrupt on comparator output rising"]
RISING = 1 , # [doc = "2: Interrupt on comparator output falling"]
FALLING = 2 , # [doc = "3: Interrupt on end of comparison (single-shot mode only)"]
EOC = 3 , } impl From < INTSEL_A > for u8 { # [inline (always)]
fn from (variant : INTSEL_A) -> Self { variant as _ } } # [doc = "Field `INTSEL` reader - Interrupt Selection"]
pub type INTSEL_R = crate :: FieldReader < u8 , INTSEL_A > ; impl INTSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> INTSEL_A { match self . bits { 0 => INTSEL_A :: TOGGLE , 1 => INTSEL_A :: RISING , 2 => INTSEL_A :: FALLING , 3 => INTSEL_A :: EOC , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `TOGGLE`"]
# [inline (always)]
pub fn is_toggle (& self) -> bool { * self == INTSEL_A :: TOGGLE } # [doc = "Checks if the value of the field is `RISING`"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == INTSEL_A :: RISING } # [doc = "Checks if the value of the field is `FALLING`"]
# [inline (always)]
pub fn is_falling (& self) -> bool { * self == INTSEL_A :: FALLING } # [doc = "Checks if the value of the field is `EOC`"]
# [inline (always)]
pub fn is_eoc (& self) -> bool { * self == INTSEL_A :: EOC } } # [doc = "Field `INTSEL` writer - Interrupt Selection"]
pub type INTSEL_W < 'a > = crate :: FieldWriterSafe < 'a , u32 , COMPCTRL_SPEC , u8 , INTSEL_A , 2 , 5 > ; impl < 'a > INTSEL_W < 'a > { # [doc = "Interrupt on comparator output toggle"]
# [inline (always)]
pub fn toggle (self) -> & 'a mut W { self . variant (INTSEL_A :: TOGGLE) } # [doc = "Interrupt on comparator output rising"]
# [inline (always)]
pub fn rising (self) -> & 'a mut W { self . variant (INTSEL_A :: RISING) } # [doc = "Interrupt on comparator output falling"]
# [inline (always)]
pub fn falling (self) -> & 'a mut W { self . variant (INTSEL_A :: FALLING) } # [doc = "Interrupt on end of comparison (single-shot mode only)"]
# [inline (always)]
pub fn eoc (self) -> & 'a mut W { self . variant (INTSEL_A :: EOC) } } # [doc = "Negative Input Mux Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum MUXNEG_A { # [doc = "0: I/O pin 0"]
PIN0 = 0 , # [doc = "1: I/O pin 1"]
PIN1 = 1 , # [doc = "2: I/O pin 2"]
PIN2 = 2 , # [doc = "3: I/O pin 3"]
PIN3 = 3 , # [doc = "4: Ground"]
GND = 4 , # [doc = "5: VDD scaler"]
VSCALE = 5 , # [doc = "6: Internal bandgap voltage"]
BANDGAP = 6 , # [doc = "7: DAC output"]
DAC = 7 , } impl From < MUXNEG_A > for u8 { # [inline (always)]
fn from (variant : MUXNEG_A) -> Self { variant as _ } } # [doc = "Field `MUXNEG` reader - Negative Input Mux Selection"]
pub type MUXNEG_R = crate :: FieldReader < u8 , MUXNEG_A > ; impl MUXNEG_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MUXNEG_A { match self . bits { 0 => MUXNEG_A :: PIN0 , 1 => MUXNEG_A :: PIN1 , 2 => MUXNEG_A :: PIN2 , 3 => MUXNEG_A :: PIN3 , 4 => MUXNEG_A :: GND , 5 => MUXNEG_A :: VSCALE , 6 => MUXNEG_A :: BANDGAP , 7 => MUXNEG_A :: DAC , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `PIN0`"]
# [inline (always)]
pub fn is_pin0 (& self) -> bool { * self == MUXNEG_A :: PIN0 } # [doc = "Checks if the value of the field is `PIN1`"]
# [inline (always)]
pub fn is_pin1 (& self) -> bool { * self == MUXNEG_A :: PIN1 } # [doc = "Checks if the value of the field is `PIN2`"]
# [inline (always)]
pub fn is_pin2 (& self) -> bool { * self == MUXNEG_A :: PIN2 } # [doc = "Checks if the value of the field is `PIN3`"]
# [inline (always)]
pub fn is_pin3 (& self) -> bool { * self == MUXNEG_A :: PIN3 } # [doc = "Checks if the value of the field is `GND`"]
# [inline (always)]
pub fn is_gnd (& self) -> bool { * self == MUXNEG_A :: GND } # [doc = "Checks if the value of the field is `VSCALE`"]
# [inline (always)]
pub fn is_vscale (& self) -> bool { * self == MUXNEG_A :: VSCALE } # [doc = "Checks if the value of the field is `BANDGAP`"]
# [inline (always)]
pub fn is_bandgap (& self) -> bool { * self == MUXNEG_A :: BANDGAP } # [doc = "Checks if the value of the field is `DAC`"]
# [inline (always)]
pub fn is_dac (& self) -> bool { * self == MUXNEG_A :: DAC } } # [doc = "Field `MUXNEG` writer - Negative Input Mux Selection"]
pub type MUXNEG_W < 'a > = crate :: FieldWriterSafe < 'a , u32 , COMPCTRL_SPEC , u8 , MUXNEG_A , 3 , 8 > ; impl < 'a > MUXNEG_W < 'a > { # [doc = "I/O pin 0"]
# [inline (always)]
pub fn pin0 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN0) } # [doc = "I/O pin 1"]
# [inline (always)]
pub fn pin1 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN1) } # [doc = "I/O pin 2"]
# [inline (always)]
pub fn pin2 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN2) } # [doc = "I/O pin 3"]
# [inline (always)]
pub fn pin3 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN3) } # [doc = "Ground"]
# [inline (always)]
pub fn gnd (self) -> & 'a mut W { self . variant (MUXNEG_A :: GND) } # [doc = "VDD scaler"]
# [inline (always)]
pub fn vscale (self) -> & 'a mut W { self . variant (MUXNEG_A :: VSCALE) } # [doc = "Internal bandgap voltage"]
# [inline (always)]
pub fn bandgap (self) -> & 'a mut W { self . variant (MUXNEG_A :: BANDGAP) } # [doc = "DAC output"]
# [inline (always)]
pub fn dac (self) -> & 'a mut W { self . variant (MUXNEG_A :: DAC) } } # [doc = "Positive Input Mux Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum MUXPOS_A { # [doc = "0: I/O pin 0"]
PIN0 = 0 , # [doc = "1: I/O pin 1"]
PIN1 = 1 , # [doc = "2: I/O pin 2"]
PIN2 = 2 , # [doc = "3: I/O pin 3"]
PIN3 = 3 , } impl From < MUXPOS_A > for u8 { # [inline (always)]
fn from (variant : MUXPOS_A) -> Self { variant as _ } } # [doc = "Field `MUXPOS` reader - Positive Input Mux Selection"]
pub type MUXPOS_R = crate :: FieldReader < u8 , MUXPOS_A > ; impl MUXPOS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MUXPOS_A { match self . bits { 0 => MUXPOS_A :: PIN0 , 1 => MUXPOS_A :: PIN1 , 2 => MUXPOS_A :: PIN2 , 3 => MUXPOS_A :: PIN3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `PIN0`"]
# [inline (always)]
pub fn is_pin0 (& self) -> bool { * self == MUXPOS_A :: PIN0 } # [doc = "Checks if the value of the field is `PIN1`"]
# [inline (always)]
pub fn is_pin1 (& self) -> bool { * self == MUXPOS_A :: PIN1 } # [doc = "Checks if the value of the field is `PIN2`"]
# [inline (always)]
pub fn is_pin2 (& self) -> bool { * self == MUXPOS_A :: PIN2 } # [doc = "Checks if the value of the field is `PIN3`"]
# [inline (always)]
pub fn is_pin3 (& self) -> bool { * self == MUXPOS_A :: PIN3 } } # [doc = "Field `MUXPOS` writer - Positive Input Mux Selection"]
pub type MUXPOS_W < 'a > = crate :: FieldWriterSafe < 'a , u32 , COMPCTRL_SPEC , u8 , MUXPOS_A , 2 , 12 > ; impl < 'a > MUXPOS_W < 'a > { # [doc = "I/O pin 0"]
# [inline (always)]
pub fn pin0 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN0) } # [doc = "I/O pin 1"]
# [inline (always)]
pub fn pin1 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN1) } # [doc = "I/O pin 2"]
# [inline (always)]
pub fn pin2 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN2) } # [doc = "I/O pin 3"]
# [inline (always)]
pub fn pin3 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN3) } } # [doc = "Field `SWAP` reader - Swap Inputs and Invert"]
pub type SWAP_R = crate :: BitReader < bool > ; # [doc = "Field `SWAP` writer - Swap Inputs and Invert"]
pub type SWAP_W < 'a > = crate :: BitWriter < 'a , u32 , COMPCTRL_SPEC , bool , 15 > ; # [doc = "Output\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum OUT_A { # [doc = "0: The output of COMPn is not routed to the COMPn I/O port"]
OFF = 0 , # [doc = "1: The asynchronous output of COMPn is routed to the COMPn I/O port"]
ASYNC = 1 , # [doc = "2: The synchronous output (including filtering) of COMPn is routed to the COMPn I/O port"]
SYNC = 2 , } impl From < OUT_A > for u8 { # [inline (always)]
fn from (variant : OUT_A) -> Self { variant as _ } } # [doc = "Field `OUT` reader - Output"]
pub type OUT_R = crate :: FieldReader < u8 , OUT_A > ; impl OUT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < OUT_A > { match self . bits { 0 => Some (OUT_A :: OFF) , 1 => Some (OUT_A :: ASYNC) , 2 => Some (OUT_A :: SYNC) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == OUT_A :: OFF } # [doc = "Checks if the value of the field is `ASYNC`"]
# [inline (always)]
pub fn is_async (& self) -> bool { * self == OUT_A :: ASYNC } # [doc = "Checks if the value of the field is `SYNC`"]
# [inline (always)]
pub fn is_sync (& self) -> bool { * self == OUT_A :: SYNC } } # [doc = "Field `OUT` writer - Output"]
pub type OUT_W < 'a > = crate :: FieldWriter < 'a , u32 , COMPCTRL_SPEC , u8 , OUT_A , 2 , 16 > ; impl < 'a > OUT_W < 'a > { # [doc = "The output of COMPn is not routed to the COMPn I/O port"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (OUT_A :: OFF) } # [doc = "The asynchronous output of COMPn is routed to the COMPn I/O port"]
# [inline (always)]
pub fn async_ (self) -> & 'a mut W { self . variant (OUT_A :: ASYNC) } # [doc = "The synchronous output (including filtering) of COMPn is routed to the COMPn I/O port"]
# [inline (always)]
pub fn sync (self) -> & 'a mut W { self . variant (OUT_A :: SYNC) } } # [doc = "Field `HYST` reader - Hysteresis Enable"]
pub type HYST_R = crate :: BitReader < bool > ; # [doc = "Field `HYST` writer - Hysteresis Enable"]
pub type HYST_W < 'a > = crate :: BitWriter < 'a , u32 , COMPCTRL_SPEC , bool , 19 > ; # [doc = "Filter Length\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum FLEN_A { # [doc = "0: No filtering"]
OFF = 0 , # [doc = "1: 3-bit majority function (2 of 3)"]
MAJ3 = 1 , # [doc = "2: 5-bit majority function (3 of 5)"]
MAJ5 = 2 , } impl From < FLEN_A > for u8 { # [inline (always)]
fn from (variant : FLEN_A) -> Self { variant as _ } } # [doc = "Field `FLEN` reader - Filter Length"]
pub type FLEN_R = crate :: FieldReader < u8 , FLEN_A > ; impl FLEN_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < FLEN_A > { match self . bits { 0 => Some (FLEN_A :: OFF) , 1 => Some (FLEN_A :: MAJ3) , 2 => Some (FLEN_A :: MAJ5) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == FLEN_A :: OFF } # [doc = "Checks if the value of the field is `MAJ3`"]
# [inline (always)]
pub fn is_maj3 (& self) -> bool { * self == FLEN_A :: MAJ3 } # [doc = "Checks if the value of the field is `MAJ5`"]
# [inline (always)]
pub fn is_maj5 (& self) -> bool { * self == FLEN_A :: MAJ5 } } # [doc = "Field `FLEN` writer - Filter Length"]
pub type FLEN_W < 'a > = crate :: FieldWriter < 'a , u32 , COMPCTRL_SPEC , u8 , FLEN_A , 3 , 24 > ; impl < 'a > FLEN_W < 'a > { # [doc = "No filtering"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (FLEN_A :: OFF) } # [doc = "3-bit majority function (2 of 3)"]
# [inline (always)]
pub fn maj3 (self) -> & 'a mut W { self . variant (FLEN_A :: MAJ3) } # [doc = "5-bit majority function (3 of 5)"]
# [inline (always)]
pub fn maj5 (self) -> & 'a mut W { self . variant (FLEN_A :: MAJ5) } } impl R { # [doc = "Bit 0 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Single-Shot Mode"]
# [inline (always)]
pub fn single (& self) -> SINGLE_R { SINGLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Speed Selection"]
# [inline (always)]
pub fn speed (& self) -> SPEED_R { SPEED_R :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bits 5:6 - Interrupt Selection"]
# [inline (always)]
pub fn intsel (& self) -> INTSEL_R { INTSEL_R :: new (((self . bits >> 5) & 3) as u8) } # [doc = "Bits 8:10 - Negative Input Mux Selection"]
# [inline (always)]
pub fn muxneg (& self) -> MUXNEG_R { MUXNEG_R :: new (((self . bits >> 8) & 7) as u8) } # [doc = "Bits 12:13 - Positive Input Mux Selection"]
# [inline (always)]
pub fn muxpos (& self) -> MUXPOS_R { MUXPOS_R :: new (((self . bits >> 12) & 3) as u8) } # [doc = "Bit 15 - Swap Inputs and Invert"]
# [inline (always)]
pub fn swap (& self) -> SWAP_R { SWAP_R :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bits 16:17 - Output"]
# [inline (always)]
pub fn out (& self) -> OUT_R { OUT_R :: new (((self . bits >> 16) & 3) as u8) } # [doc = "Bit 19 - Hysteresis Enable"]
# [inline (always)]
pub fn hyst (& self) -> HYST_R { HYST_R :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bits 24:26 - Filter Length"]
# [inline (always)]
pub fn flen (& self) -> FLEN_R { FLEN_R :: new (((self . bits >> 24) & 7) as u8) } } impl W { # [doc = "Bit 0 - Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Bit 1 - Single-Shot Mode"]
# [inline (always)]
pub fn single (& mut self) -> SINGLE_W { SINGLE_W :: new (self) } # [doc = "Bits 2:3 - Speed Selection"]
# [inline (always)]
pub fn speed (& mut self) -> SPEED_W { SPEED_W :: new (self) } # [doc = "Bits 5:6 - Interrupt Selection"]
# [inline (always)]
pub fn intsel (& mut self) -> INTSEL_W { INTSEL_W :: new (self) } # [doc = "Bits 8:10 - Negative Input Mux Selection"]
# [inline (always)]
pub fn muxneg (& mut self) -> MUXNEG_W { MUXNEG_W :: new (self) } # [doc = "Bits 12:13 - Positive Input Mux Selection"]
# [inline (always)]
pub fn muxpos (& mut self) -> MUXPOS_W { MUXPOS_W :: new (self) } # [doc = "Bit 15 - Swap Inputs and Invert"]
# [inline (always)]
pub fn swap (& mut self) -> SWAP_W { SWAP_W :: new (self) } # [doc = "Bits 16:17 - Output"]
# [inline (always)]
pub fn out (& mut self) -> OUT_W { OUT_W :: new (self) } # [doc = "Bit 19 - Hysteresis Enable"]
# [inline (always)]
pub fn hyst (& mut self) -> HYST_W { HYST_W :: new (self) } # [doc = "Bits 24:26 - Filter Length"]
# [inline (always)]
pub fn flen (& mut self) -> FLEN_W { FLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Comparator Control n\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [compctrl](index.html) module"]
pub struct COMPCTRL_SPEC ; impl crate :: RegisterSpec for COMPCTRL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [compctrl::R](R) reader structure"]
impl crate :: Readable for COMPCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [compctrl::W](W) writer structure"]
impl crate :: Writable for COMPCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets COMPCTRL%s to value 0"]
impl crate :: Resettable for COMPCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SCALER register accessor: an alias for `Reg<SCALER_SPEC>`"]
pub type SCALER = crate :: Reg < scaler :: SCALER_SPEC > ; # [doc = "Scaler n"]
pub mod scaler { # [doc = "Register `SCALER%s` reader"]
pub struct R (crate :: R < SCALER_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SCALER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SCALER_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SCALER_SPEC >) -> Self { R (reader) } } # [doc = "Register `SCALER%s` writer"]
pub struct W (crate :: W < SCALER_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SCALER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SCALER_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SCALER_SPEC >) -> Self { W (writer) } } # [doc = "Field `VALUE` reader - Scaler Value"]
pub type VALUE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `VALUE` writer - Scaler Value"]
pub type VALUE_W < 'a > = crate :: FieldWriter < 'a , u8 , SCALER_SPEC , u8 , u8 , 6 , 0 > ; impl R { # [doc = "Bits 0:5 - Scaler Value"]
# [inline (always)]
pub fn value (& self) -> VALUE_R { VALUE_R :: new ((self . bits & 0x3f) as u8) } } impl W { # [doc = "Bits 0:5 - Scaler Value"]
# [inline (always)]
pub fn value (& mut self) -> VALUE_W { VALUE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Scaler n\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [scaler](index.html) module"]
pub struct SCALER_SPEC ; impl crate :: RegisterSpec for SCALER_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [scaler::R](R) reader structure"]
impl crate :: Readable for SCALER_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [scaler::W](W) writer structure"]
impl crate :: Writable for SCALER_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SCALER%s to value 0"]
impl crate :: Resettable for SCALER_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "Analog Digital Converter"]
pub struct ADC { _marker : PhantomData < * const () > } unsafe impl Send for ADC { } impl ADC { # [doc = r"Pointer to the register block"]
pub const PTR : * const adc :: RegisterBlock = 0x4200_4000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const adc :: RegisterBlock { Self :: PTR } } impl Deref for ADC { type Target = adc :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for ADC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("ADC") . finish () } } # [doc = "Analog Digital Converter"]
pub mod adc { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : crate :: Reg < ctrla :: CTRLA_SPEC > , # [doc = "0x01 - Reference Control"]
pub refctrl : crate :: Reg < refctrl :: REFCTRL_SPEC > , # [doc = "0x02 - Average Control"]
pub avgctrl : crate :: Reg < avgctrl :: AVGCTRL_SPEC > , # [doc = "0x03 - Sampling Time Control"]
pub sampctrl : crate :: Reg < sampctrl :: SAMPCTRL_SPEC > , # [doc = "0x04 - Control B"]
pub ctrlb : crate :: Reg < ctrlb :: CTRLB_SPEC > , _reserved5 : [u8 ; 0x02]
, # [doc = "0x08 - Window Monitor Control"]
pub winctrl : crate :: Reg < winctrl :: WINCTRL_SPEC > , _reserved6 : [u8 ; 0x03]
, # [doc = "0x0c - Software Trigger"]
pub swtrig : crate :: Reg < swtrig :: SWTRIG_SPEC > , _reserved7 : [u8 ; 0x03]
, # [doc = "0x10 - Input Control"]
pub inputctrl : crate :: Reg < inputctrl :: INPUTCTRL_SPEC > , # [doc = "0x14 - Event Control"]
pub evctrl : crate :: Reg < evctrl :: EVCTRL_SPEC > , _reserved9 : [u8 ; 0x01]
, # [doc = "0x16 - Interrupt Enable Clear"]
pub intenclr : crate :: Reg < intenclr :: INTENCLR_SPEC > , # [doc = "0x17 - Interrupt Enable Set"]
pub intenset : crate :: Reg < intenset :: INTENSET_SPEC > , # [doc = "0x18 - Interrupt Flag Status and Clear"]
pub intflag : crate :: Reg < intflag :: INTFLAG_SPEC > , # [doc = "0x19 - Status"]
pub status : crate :: Reg < status :: STATUS_SPEC > , # [doc = "0x1a - Result"]
pub result : crate :: Reg < result :: RESULT_SPEC > , # [doc = "0x1c - Window Monitor Lower Threshold"]
pub winlt : crate :: Reg < winlt :: WINLT_SPEC > , _reserved15 : [u8 ; 0x02]
, # [doc = "0x20 - Window Monitor Upper Threshold"]
pub winut : crate :: Reg < winut :: WINUT_SPEC > , _reserved16 : [u8 ; 0x02]
, # [doc = "0x24 - Gain Correction"]
pub gaincorr : crate :: Reg < gaincorr :: GAINCORR_SPEC > , # [doc = "0x26 - Offset Correction"]
pub offsetcorr : crate :: Reg < offsetcorr :: OFFSETCORR_SPEC > , # [doc = "0x28 - Calibration"]
pub calib : crate :: Reg < calib :: CALIB_SPEC > , # [doc = "0x2a - Debug Control"]
pub dbgctrl : crate :: Reg < dbgctrl :: DBGCTRL_SPEC > , } # [doc = "CTRLA register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWRST` reader - Software Reset"]
pub type SWRST_R = crate :: BitReader < bool > ; # [doc = "Field `SWRST` writer - Software Reset"]
pub type SWRST_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , 0 > ; # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , 1 > ; # [doc = "Field `RUNSTDBY` reader - Run in Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run in Standby"]
pub type RUNSTDBY_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , 2 > ; impl R { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& self) -> SWRST_R { SWRST_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& mut self) -> SWRST_W { SWRST_W :: new (self) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Bit 2 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& mut self) -> RUNSTDBY_W { RUNSTDBY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "REFCTRL register accessor: an alias for `Reg<REFCTRL_SPEC>`"]
pub type REFCTRL = crate :: Reg < refctrl :: REFCTRL_SPEC > ; # [doc = "Reference Control"]
pub mod refctrl { # [doc = "Register `REFCTRL` reader"]
pub struct R (crate :: R < REFCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < REFCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < REFCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < REFCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `REFCTRL` writer"]
pub struct W (crate :: W < REFCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < REFCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < REFCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < REFCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Reference Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum REFSEL_A { # [doc = "0: 1.0V voltage reference"]
INT1V = 0 , # [doc = "1: 1/1.48 VDDANA"]
INTVCC0 = 1 , # [doc = "2: 1/2 VDDANA (only for VDDANA > 2.0V)"]
INTVCC1 = 2 , # [doc = "3: External reference"]
AREFA = 3 , # [doc = "4: External reference"]
AREFB = 4 , } impl From < REFSEL_A > for u8 { # [inline (always)]
fn from (variant : REFSEL_A) -> Self { variant as _ } } # [doc = "Field `REFSEL` reader - Reference Selection"]
pub type REFSEL_R = crate :: FieldReader < u8 , REFSEL_A > ; impl REFSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < REFSEL_A > { match self . bits { 0 => Some (REFSEL_A :: INT1V) , 1 => Some (REFSEL_A :: INTVCC0) , 2 => Some (REFSEL_A :: INTVCC1) , 3 => Some (REFSEL_A :: AREFA) , 4 => Some (REFSEL_A :: AREFB) , _ => None , } } # [doc = "Checks if the value of the field is `INT1V`"]
# [inline (always)]
pub fn is_int1v (& self) -> bool { * self == REFSEL_A :: INT1V } # [doc = "Checks if the value of the field is `INTVCC0`"]
# [inline (always)]
pub fn is_intvcc0 (& self) -> bool { * self == REFSEL_A :: INTVCC0 } # [doc = "Checks if the value of the field is `INTVCC1`"]
# [inline (always)]
pub fn is_intvcc1 (& self) -> bool { * self == REFSEL_A :: INTVCC1 } # [doc = "Checks if the value of the field is `AREFA`"]
# [inline (always)]
pub fn is_arefa (& self) -> bool { * self == REFSEL_A :: AREFA } # [doc = "Checks if the value of the field is `AREFB`"]
# [inline (always)]
pub fn is_arefb (& self) -> bool { * self == REFSEL_A :: AREFB } } # [doc = "Field `REFSEL` writer - Reference Selection"]
pub type REFSEL_W < 'a > = crate :: FieldWriter < 'a , u8 , REFCTRL_SPEC , u8 , REFSEL_A , 4 , 0 > ; impl < 'a > REFSEL_W < 'a > { # [doc = "1.0V voltage reference"]
# [inline (always)]
pub fn int1v (self) -> & 'a mut W { self . variant (REFSEL_A :: INT1V) } # [doc = "1/1.48 VDDANA"]
# [inline (always)]
pub fn intvcc0 (self) -> & 'a mut W { self . variant (REFSEL_A :: INTVCC0) } # [doc = "1/2 VDDANA (only for VDDANA > 2.0V)"]
# [inline (always)]
pub fn intvcc1 (self) -> & 'a mut W { self . variant (REFSEL_A :: INTVCC1) } # [doc = "External reference"]
# [inline (always)]
pub fn arefa (self) -> & 'a mut W { self . variant (REFSEL_A :: AREFA) } # [doc = "External reference"]
# [inline (always)]
pub fn arefb (self) -> & 'a mut W { self . variant (REFSEL_A :: AREFB) } } # [doc = "Field `REFCOMP` reader - Reference Buffer Offset Compensation Enable"]
pub type REFCOMP_R = crate :: BitReader < bool > ; # [doc = "Field `REFCOMP` writer - Reference Buffer Offset Compensation Enable"]
pub type REFCOMP_W < 'a > = crate :: BitWriter < 'a , u8 , REFCTRL_SPEC , bool , 7 > ; impl R { # [doc = "Bits 0:3 - Reference Selection"]
# [inline (always)]
pub fn refsel (& self) -> REFSEL_R { REFSEL_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bit 7 - Reference Buffer Offset Compensation Enable"]
# [inline (always)]
pub fn refcomp (& self) -> REFCOMP_R { REFCOMP_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:3 - Reference Selection"]
# [inline (always)]
pub fn refsel (& mut self) -> REFSEL_W { REFSEL_W :: new (self) } # [doc = "Bit 7 - Reference Buffer Offset Compensation Enable"]
# [inline (always)]
pub fn refcomp (& mut self) -> REFCOMP_W { REFCOMP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Reference Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [refctrl](index.html) module"]
pub struct REFCTRL_SPEC ; impl crate :: RegisterSpec for REFCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [refctrl::R](R) reader structure"]
impl crate :: Readable for REFCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [refctrl::W](W) writer structure"]
impl crate :: Writable for REFCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets REFCTRL to value 0"]
impl crate :: Resettable for REFCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "AVGCTRL register accessor: an alias for `Reg<AVGCTRL_SPEC>`"]
pub type AVGCTRL = crate :: Reg < avgctrl :: AVGCTRL_SPEC > ; # [doc = "Average Control"]
pub mod avgctrl { # [doc = "Register `AVGCTRL` reader"]
pub struct R (crate :: R < AVGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < AVGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < AVGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < AVGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `AVGCTRL` writer"]
pub struct W (crate :: W < AVGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < AVGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < AVGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < AVGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Number of Samples to be Collected\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum SAMPLENUM_A { # [doc = "0: 1 sample"]
_1 = 0 , # [doc = "1: 2 samples"]
_2 = 1 , # [doc = "2: 4 samples"]
_4 = 2 , # [doc = "3: 8 samples"]
_8 = 3 , # [doc = "4: 16 samples"]
_16 = 4 , # [doc = "5: 32 samples"]
_32 = 5 , # [doc = "6: 64 samples"]
_64 = 6 , # [doc = "7: 128 samples"]
_128 = 7 , # [doc = "8: 256 samples"]
_256 = 8 , # [doc = "9: 512 samples"]
_512 = 9 , # [doc = "10: 1024 samples"]
_1024 = 10 , } impl From < SAMPLENUM_A > for u8 { # [inline (always)]
fn from (variant : SAMPLENUM_A) -> Self { variant as _ } } # [doc = "Field `SAMPLENUM` reader - Number of Samples to be Collected"]
pub type SAMPLENUM_R = crate :: FieldReader < u8 , SAMPLENUM_A > ; impl SAMPLENUM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SAMPLENUM_A > { match self . bits { 0 => Some (SAMPLENUM_A :: _1) , 1 => Some (SAMPLENUM_A :: _2) , 2 => Some (SAMPLENUM_A :: _4) , 3 => Some (SAMPLENUM_A :: _8) , 4 => Some (SAMPLENUM_A :: _16) , 5 => Some (SAMPLENUM_A :: _32) , 6 => Some (SAMPLENUM_A :: _64) , 7 => Some (SAMPLENUM_A :: _128) , 8 => Some (SAMPLENUM_A :: _256) , 9 => Some (SAMPLENUM_A :: _512) , 10 => Some (SAMPLENUM_A :: _1024) , _ => None , } } # [doc = "Checks if the value of the field is `_1`"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == SAMPLENUM_A :: _1 } # [doc = "Checks if the value of the field is `_2`"]
# [inline (always)]
pub fn is_2 (& self) -> bool { * self == SAMPLENUM_A :: _2 } # [doc = "Checks if the value of the field is `_4`"]
# [inline (always)]
pub fn is_4 (& self) -> bool { * self == SAMPLENUM_A :: _4 } # [doc = "Checks if the value of the field is `_8`"]
# [inline (always)]
pub fn is_8 (& self) -> bool { * self == SAMPLENUM_A :: _8 } # [doc = "Checks if the value of the field is `_16`"]
# [inline (always)]
pub fn is_16 (& self) -> bool { * self == SAMPLENUM_A :: _16 } # [doc = "Checks if the value of the field is `_32`"]
# [inline (always)]
pub fn is_32 (& self) -> bool { * self == SAMPLENUM_A :: _32 } # [doc = "Checks if the value of the field is `_64`"]
# [inline (always)]
pub fn is_64 (& self) -> bool { * self == SAMPLENUM_A :: _64 } # [doc = "Checks if the value of the field is `_128`"]
# [inline (always)]
pub fn is_128 (& self) -> bool { * self == SAMPLENUM_A :: _128 } # [doc = "Checks if the value of the field is `_256`"]
# [inline (always)]
pub fn is_256 (& self) -> bool { * self == SAMPLENUM_A :: _256 } # [doc = "Checks if the value of the field is `_512`"]
# [inline (always)]
pub fn is_512 (& self) -> bool { * self == SAMPLENUM_A :: _512 } # [doc = "Checks if the value of the field is `_1024`"]
# [inline (always)]
pub fn is_1024 (& self) -> bool { * self == SAMPLENUM_A :: _1024 } } # [doc = "Field `SAMPLENUM` writer - Number of Samples to be Collected"]
pub type SAMPLENUM_W < 'a > = crate :: FieldWriter < 'a , u8 , AVGCTRL_SPEC , u8 , SAMPLENUM_A , 4 , 0 > ; impl < 'a > SAMPLENUM_W < 'a > { # [doc = "1 sample"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut W { self . variant (SAMPLENUM_A :: _1) } # [doc = "2 samples"]
# [inline (always)]
pub fn _2 (self) -> & 'a mut W { self . variant (SAMPLENUM_A :: _2) } # [doc = "4 samples"]
# [inline (always)]
pub fn _4 (self) -> & 'a mut W { self . variant (SAMPLENUM_A :: _4) } # [doc = "8 samples"]
# [inline (always)]
pub fn _8 (self) -> & 'a mut W { self . variant (SAMPLENUM_A :: _8) } # [doc = "16 samples"]
# [inline (always)]
pub fn _16 (self) -> & 'a mut W { self . variant (SAMPLENUM_A :: _16) } # [doc = "32 samples"]
# [inline (always)]
pub fn _32 (self) -> & 'a mut W { self . variant (SAMPLENUM_A :: _32) } # [doc = "64 samples"]
# [inline (always)]
pub fn _64 (self) -> & 'a mut W { self . variant (SAMPLENUM_A :: _64) } # [doc = "128 samples"]
# [inline (always)]
pub fn _128 (self) -> & 'a mut W { self . variant (SAMPLENUM_A :: _128) } # [doc = "256 samples"]
# [inline (always)]
pub fn _256 (self) -> & 'a mut W { self . variant (SAMPLENUM_A :: _256) } # [doc = "512 samples"]
# [inline (always)]
pub fn _512 (self) -> & 'a mut W { self . variant (SAMPLENUM_A :: _512) } # [doc = "1024 samples"]
# [inline (always)]
pub fn _1024 (self) -> & 'a mut W { self . variant (SAMPLENUM_A :: _1024) } } # [doc = "Field `ADJRES` reader - Adjusting Result / Division Coefficient"]
pub type ADJRES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `ADJRES` writer - Adjusting Result / Division Coefficient"]
pub type ADJRES_W < 'a > = crate :: FieldWriter < 'a , u8 , AVGCTRL_SPEC , u8 , u8 , 3 , 4 > ; impl R { # [doc = "Bits 0:3 - Number of Samples to be Collected"]
# [inline (always)]
pub fn samplenum (& self) -> SAMPLENUM_R { SAMPLENUM_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bits 4:6 - Adjusting Result / Division Coefficient"]
# [inline (always)]
pub fn adjres (& self) -> ADJRES_R { ADJRES_R :: new (((self . bits >> 4) & 7) as u8) } } impl W { # [doc = "Bits 0:3 - Number of Samples to be Collected"]
# [inline (always)]
pub fn samplenum (& mut self) -> SAMPLENUM_W { SAMPLENUM_W :: new (self) } # [doc = "Bits 4:6 - Adjusting Result / Division Coefficient"]
# [inline (always)]
pub fn adjres (& mut self) -> ADJRES_W { ADJRES_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Average Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [avgctrl](index.html) module"]
pub struct AVGCTRL_SPEC ; impl crate :: RegisterSpec for AVGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [avgctrl::R](R) reader structure"]
impl crate :: Readable for AVGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [avgctrl::W](W) writer structure"]
impl crate :: Writable for AVGCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets AVGCTRL to value 0"]
impl crate :: Resettable for AVGCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SAMPCTRL register accessor: an alias for `Reg<SAMPCTRL_SPEC>`"]
pub type SAMPCTRL = crate :: Reg < sampctrl :: SAMPCTRL_SPEC > ; # [doc = "Sampling Time Control"]
pub mod sampctrl { # [doc = "Register `SAMPCTRL` reader"]
pub struct R (crate :: R < SAMPCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SAMPCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SAMPCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SAMPCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `SAMPCTRL` writer"]
pub struct W (crate :: W < SAMPCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SAMPCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SAMPCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SAMPCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SAMPLEN` reader - Sampling Time Length"]
pub type SAMPLEN_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SAMPLEN` writer - Sampling Time Length"]
pub type SAMPLEN_W < 'a > = crate :: FieldWriter < 'a , u8 , SAMPCTRL_SPEC , u8 , u8 , 6 , 0 > ; impl R { # [doc = "Bits 0:5 - Sampling Time Length"]
# [inline (always)]
pub fn samplen (& self) -> SAMPLEN_R { SAMPLEN_R :: new ((self . bits & 0x3f) as u8) } } impl W { # [doc = "Bits 0:5 - Sampling Time Length"]
# [inline (always)]
pub fn samplen (& mut self) -> SAMPLEN_W { SAMPLEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Sampling Time Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sampctrl](index.html) module"]
pub struct SAMPCTRL_SPEC ; impl crate :: RegisterSpec for SAMPCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sampctrl::R](R) reader structure"]
impl crate :: Readable for SAMPCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sampctrl::W](W) writer structure"]
impl crate :: Writable for SAMPCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SAMPCTRL to value 0"]
impl crate :: Resettable for SAMPCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CTRLB register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIFFMODE` reader - Differential Mode"]
pub type DIFFMODE_R = crate :: BitReader < bool > ; # [doc = "Field `DIFFMODE` writer - Differential Mode"]
pub type DIFFMODE_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLB_SPEC , bool , 0 > ; # [doc = "Field `LEFTADJ` reader - Left-Adjusted Result"]
pub type LEFTADJ_R = crate :: BitReader < bool > ; # [doc = "Field `LEFTADJ` writer - Left-Adjusted Result"]
pub type LEFTADJ_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLB_SPEC , bool , 1 > ; # [doc = "Field `FREERUN` reader - Free Running Mode"]
pub type FREERUN_R = crate :: BitReader < bool > ; # [doc = "Field `FREERUN` writer - Free Running Mode"]
pub type FREERUN_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLB_SPEC , bool , 2 > ; # [doc = "Field `CORREN` reader - Digital Correction Logic Enabled"]
pub type CORREN_R = crate :: BitReader < bool > ; # [doc = "Field `CORREN` writer - Digital Correction Logic Enabled"]
pub type CORREN_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLB_SPEC , bool , 3 > ; # [doc = "Conversion Result Resolution\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum RESSEL_A { # [doc = "0: 12-bit result"]
_12BIT = 0 , # [doc = "1: For averaging mode output"]
_16BIT = 1 , # [doc = "2: 10-bit result"]
_10BIT = 2 , # [doc = "3: 8-bit result"]
_8BIT = 3 , } impl From < RESSEL_A > for u8 { # [inline (always)]
fn from (variant : RESSEL_A) -> Self { variant as _ } } # [doc = "Field `RESSEL` reader - Conversion Result Resolution"]
pub type RESSEL_R = crate :: FieldReader < u8 , RESSEL_A > ; impl RESSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> RESSEL_A { match self . bits { 0 => RESSEL_A :: _12BIT , 1 => RESSEL_A :: _16BIT , 2 => RESSEL_A :: _10BIT , 3 => RESSEL_A :: _8BIT , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_12BIT`"]
# [inline (always)]
pub fn is_12bit (& self) -> bool { * self == RESSEL_A :: _12BIT } # [doc = "Checks if the value of the field is `_16BIT`"]
# [inline (always)]
pub fn is_16bit (& self) -> bool { * self == RESSEL_A :: _16BIT } # [doc = "Checks if the value of the field is `_10BIT`"]
# [inline (always)]
pub fn is_10bit (& self) -> bool { * self == RESSEL_A :: _10BIT } # [doc = "Checks if the value of the field is `_8BIT`"]
# [inline (always)]
pub fn is_8bit (& self) -> bool { * self == RESSEL_A :: _8BIT } } # [doc = "Field `RESSEL` writer - Conversion Result Resolution"]
pub type RESSEL_W < 'a > = crate :: FieldWriterSafe < 'a , u16 , CTRLB_SPEC , u8 , RESSEL_A , 2 , 4 > ; impl < 'a > RESSEL_W < 'a > { # [doc = "12-bit result"]
# [inline (always)]
pub fn _12bit (self) -> & 'a mut W { self . variant (RESSEL_A :: _12BIT) } # [doc = "For averaging mode output"]
# [inline (always)]
pub fn _16bit (self) -> & 'a mut W { self . variant (RESSEL_A :: _16BIT) } # [doc = "10-bit result"]
# [inline (always)]
pub fn _10bit (self) -> & 'a mut W { self . variant (RESSEL_A :: _10BIT) } # [doc = "8-bit result"]
# [inline (always)]
pub fn _8bit (self) -> & 'a mut W { self . variant (RESSEL_A :: _8BIT) } } # [doc = "Prescaler Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum PRESCALER_A { # [doc = "0: Peripheral clock divided by 4"]
DIV4 = 0 , # [doc = "1: Peripheral clock divided by 8"]
DIV8 = 1 , # [doc = "2: Peripheral clock divided by 16"]
DIV16 = 2 , # [doc = "3: Peripheral clock divided by 32"]
DIV32 = 3 , # [doc = "4: Peripheral clock divided by 64"]
DIV64 = 4 , # [doc = "5: Peripheral clock divided by 128"]
DIV128 = 5 , # [doc = "6: Peripheral clock divided by 256"]
DIV256 = 6 , # [doc = "7: Peripheral clock divided by 512"]
DIV512 = 7 , } impl From < PRESCALER_A > for u8 { # [inline (always)]
fn from (variant : PRESCALER_A) -> Self { variant as _ } } # [doc = "Field `PRESCALER` reader - Prescaler Configuration"]
pub type PRESCALER_R = crate :: FieldReader < u8 , PRESCALER_A > ; impl PRESCALER_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PRESCALER_A { match self . bits { 0 => PRESCALER_A :: DIV4 , 1 => PRESCALER_A :: DIV8 , 2 => PRESCALER_A :: DIV16 , 3 => PRESCALER_A :: DIV32 , 4 => PRESCALER_A :: DIV64 , 5 => PRESCALER_A :: DIV128 , 6 => PRESCALER_A :: DIV256 , 7 => PRESCALER_A :: DIV512 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == PRESCALER_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == PRESCALER_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == PRESCALER_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV32`"]
# [inline (always)]
pub fn is_div32 (& self) -> bool { * self == PRESCALER_A :: DIV32 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == PRESCALER_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV128`"]
# [inline (always)]
pub fn is_div128 (& self) -> bool { * self == PRESCALER_A :: DIV128 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == PRESCALER_A :: DIV256 } # [doc = "Checks if the value of the field is `DIV512`"]
# [inline (always)]
pub fn is_div512 (& self) -> bool { * self == PRESCALER_A :: DIV512 } } # [doc = "Field `PRESCALER` writer - Prescaler Configuration"]
pub type PRESCALER_W < 'a > = crate :: FieldWriterSafe < 'a , u16 , CTRLB_SPEC , u8 , PRESCALER_A , 3 , 8 > ; impl < 'a > PRESCALER_W < 'a > { # [doc = "Peripheral clock divided by 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV4) } # [doc = "Peripheral clock divided by 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV8) } # [doc = "Peripheral clock divided by 16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV16) } # [doc = "Peripheral clock divided by 32"]
# [inline (always)]
pub fn div32 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV32) } # [doc = "Peripheral clock divided by 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV64) } # [doc = "Peripheral clock divided by 128"]
# [inline (always)]
pub fn div128 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV128) } # [doc = "Peripheral clock divided by 256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV256) } # [doc = "Peripheral clock divided by 512"]
# [inline (always)]
pub fn div512 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV512) } } impl R { # [doc = "Bit 0 - Differential Mode"]
# [inline (always)]
pub fn diffmode (& self) -> DIFFMODE_R { DIFFMODE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Left-Adjusted Result"]
# [inline (always)]
pub fn leftadj (& self) -> LEFTADJ_R { LEFTADJ_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Free Running Mode"]
# [inline (always)]
pub fn freerun (& self) -> FREERUN_R { FREERUN_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Digital Correction Logic Enabled"]
# [inline (always)]
pub fn corren (& self) -> CORREN_R { CORREN_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Conversion Result Resolution"]
# [inline (always)]
pub fn ressel (& self) -> RESSEL_R { RESSEL_R :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bits 8:10 - Prescaler Configuration"]
# [inline (always)]
pub fn prescaler (& self) -> PRESCALER_R { PRESCALER_R :: new (((self . bits >> 8) & 7) as u8) } } impl W { # [doc = "Bit 0 - Differential Mode"]
# [inline (always)]
pub fn diffmode (& mut self) -> DIFFMODE_W { DIFFMODE_W :: new (self) } # [doc = "Bit 1 - Left-Adjusted Result"]
# [inline (always)]
pub fn leftadj (& mut self) -> LEFTADJ_W { LEFTADJ_W :: new (self) } # [doc = "Bit 2 - Free Running Mode"]
# [inline (always)]
pub fn freerun (& mut self) -> FREERUN_W { FREERUN_W :: new (self) } # [doc = "Bit 3 - Digital Correction Logic Enabled"]
# [inline (always)]
pub fn corren (& mut self) -> CORREN_W { CORREN_W :: new (self) } # [doc = "Bits 4:5 - Conversion Result Resolution"]
# [inline (always)]
pub fn ressel (& mut self) -> RESSEL_W { RESSEL_W :: new (self) } # [doc = "Bits 8:10 - Prescaler Configuration"]
# [inline (always)]
pub fn prescaler (& mut self) -> PRESCALER_W { PRESCALER_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "WINCTRL register accessor: an alias for `Reg<WINCTRL_SPEC>`"]
pub type WINCTRL = crate :: Reg < winctrl :: WINCTRL_SPEC > ; # [doc = "Window Monitor Control"]
pub mod winctrl { # [doc = "Register `WINCTRL` reader"]
pub struct R (crate :: R < WINCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < WINCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < WINCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < WINCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `WINCTRL` writer"]
pub struct W (crate :: W < WINCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < WINCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < WINCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < WINCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Window Monitor Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum WINMODE_A { # [doc = "0: No window mode (default)"]
DISABLE = 0 , # [doc = "1: Mode 1: RESULT > WINLT"]
MODE1 = 1 , # [doc = "2: Mode 2: RESULT < WINUT"]
MODE2 = 2 , # [doc = "3: Mode 3: WINLT < RESULT < WINUT"]
MODE3 = 3 , # [doc = "4: Mode 4: !(WINLT < RESULT < WINUT)"]
MODE4 = 4 , } impl From < WINMODE_A > for u8 { # [inline (always)]
fn from (variant : WINMODE_A) -> Self { variant as _ } } # [doc = "Field `WINMODE` reader - Window Monitor Mode"]
pub type WINMODE_R = crate :: FieldReader < u8 , WINMODE_A > ; impl WINMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WINMODE_A > { match self . bits { 0 => Some (WINMODE_A :: DISABLE) , 1 => Some (WINMODE_A :: MODE1) , 2 => Some (WINMODE_A :: MODE2) , 3 => Some (WINMODE_A :: MODE3) , 4 => Some (WINMODE_A :: MODE4) , _ => None , } } # [doc = "Checks if the value of the field is `DISABLE`"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == WINMODE_A :: DISABLE } # [doc = "Checks if the value of the field is `MODE1`"]
# [inline (always)]
pub fn is_mode1 (& self) -> bool { * self == WINMODE_A :: MODE1 } # [doc = "Checks if the value of the field is `MODE2`"]
# [inline (always)]
pub fn is_mode2 (& self) -> bool { * self == WINMODE_A :: MODE2 } # [doc = "Checks if the value of the field is `MODE3`"]
# [inline (always)]
pub fn is_mode3 (& self) -> bool { * self == WINMODE_A :: MODE3 } # [doc = "Checks if the value of the field is `MODE4`"]
# [inline (always)]
pub fn is_mode4 (& self) -> bool { * self == WINMODE_A :: MODE4 } } # [doc = "Field `WINMODE` writer - Window Monitor Mode"]
pub type WINMODE_W < 'a > = crate :: FieldWriter < 'a , u8 , WINCTRL_SPEC , u8 , WINMODE_A , 3 , 0 > ; impl < 'a > WINMODE_W < 'a > { # [doc = "No window mode (default)"]
# [inline (always)]
pub fn disable (self) -> & 'a mut W { self . variant (WINMODE_A :: DISABLE) } # [doc = "Mode 1: RESULT > WINLT"]
# [inline (always)]
pub fn mode1 (self) -> & 'a mut W { self . variant (WINMODE_A :: MODE1) } # [doc = "Mode 2: RESULT < WINUT"]
# [inline (always)]
pub fn mode2 (self) -> & 'a mut W { self . variant (WINMODE_A :: MODE2) } # [doc = "Mode 3: WINLT < RESULT < WINUT"]
# [inline (always)]
pub fn mode3 (self) -> & 'a mut W { self . variant (WINMODE_A :: MODE3) } # [doc = "Mode 4: !(WINLT < RESULT < WINUT)"]
# [inline (always)]
pub fn mode4 (self) -> & 'a mut W { self . variant (WINMODE_A :: MODE4) } } impl R { # [doc = "Bits 0:2 - Window Monitor Mode"]
# [inline (always)]
pub fn winmode (& self) -> WINMODE_R { WINMODE_R :: new ((self . bits & 7) as u8) } } impl W { # [doc = "Bits 0:2 - Window Monitor Mode"]
# [inline (always)]
pub fn winmode (& mut self) -> WINMODE_W { WINMODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Window Monitor Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [winctrl](index.html) module"]
pub struct WINCTRL_SPEC ; impl crate :: RegisterSpec for WINCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [winctrl::R](R) reader structure"]
impl crate :: Readable for WINCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [winctrl::W](W) writer structure"]
impl crate :: Writable for WINCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets WINCTRL to value 0"]
impl crate :: Resettable for WINCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SWTRIG register accessor: an alias for `Reg<SWTRIG_SPEC>`"]
pub type SWTRIG = crate :: Reg < swtrig :: SWTRIG_SPEC > ; # [doc = "Software Trigger"]
pub mod swtrig { # [doc = "Register `SWTRIG` reader"]
pub struct R (crate :: R < SWTRIG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SWTRIG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SWTRIG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SWTRIG_SPEC >) -> Self { R (reader) } } # [doc = "Register `SWTRIG` writer"]
pub struct W (crate :: W < SWTRIG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SWTRIG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SWTRIG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SWTRIG_SPEC >) -> Self { W (writer) } } # [doc = "Field `FLUSH` reader - ADC Conversion Flush"]
pub type FLUSH_R = crate :: BitReader < bool > ; # [doc = "Field `FLUSH` writer - ADC Conversion Flush"]
pub type FLUSH_W < 'a > = crate :: BitWriter < 'a , u8 , SWTRIG_SPEC , bool , 0 > ; # [doc = "Field `START` reader - ADC Start Conversion"]
pub type START_R = crate :: BitReader < bool > ; # [doc = "Field `START` writer - ADC Start Conversion"]
pub type START_W < 'a > = crate :: BitWriter < 'a , u8 , SWTRIG_SPEC , bool , 1 > ; impl R { # [doc = "Bit 0 - ADC Conversion Flush"]
# [inline (always)]
pub fn flush (& self) -> FLUSH_R { FLUSH_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - ADC Start Conversion"]
# [inline (always)]
pub fn start (& self) -> START_R { START_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - ADC Conversion Flush"]
# [inline (always)]
pub fn flush (& mut self) -> FLUSH_W { FLUSH_W :: new (self) } # [doc = "Bit 1 - ADC Start Conversion"]
# [inline (always)]
pub fn start (& mut self) -> START_W { START_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Software Trigger\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [swtrig](index.html) module"]
pub struct SWTRIG_SPEC ; impl crate :: RegisterSpec for SWTRIG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [swtrig::R](R) reader structure"]
impl crate :: Readable for SWTRIG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [swtrig::W](W) writer structure"]
impl crate :: Writable for SWTRIG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SWTRIG to value 0"]
impl crate :: Resettable for SWTRIG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INPUTCTRL register accessor: an alias for `Reg<INPUTCTRL_SPEC>`"]
pub type INPUTCTRL = crate :: Reg < inputctrl :: INPUTCTRL_SPEC > ; # [doc = "Input Control"]
pub mod inputctrl { # [doc = "Register `INPUTCTRL` reader"]
pub struct R (crate :: R < INPUTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INPUTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INPUTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INPUTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `INPUTCTRL` writer"]
pub struct W (crate :: W < INPUTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INPUTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INPUTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INPUTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Positive Mux Input Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum MUXPOS_A { # [doc = "0: ADC AIN0 Pin"]
PIN0 = 0 , # [doc = "1: ADC AIN1 Pin"]
PIN1 = 1 , # [doc = "2: ADC AIN2 Pin"]
PIN2 = 2 , # [doc = "3: ADC AIN3 Pin"]
PIN3 = 3 , # [doc = "4: ADC AIN4 Pin"]
PIN4 = 4 , # [doc = "5: ADC AIN5 Pin"]
PIN5 = 5 , # [doc = "6: ADC AIN6 Pin"]
PIN6 = 6 , # [doc = "7: ADC AIN7 Pin"]
PIN7 = 7 , # [doc = "8: ADC AIN8 Pin"]
PIN8 = 8 , # [doc = "9: ADC AIN9 Pin"]
PIN9 = 9 , # [doc = "10: ADC AIN10 Pin"]
PIN10 = 10 , # [doc = "11: ADC AIN11 Pin"]
PIN11 = 11 , # [doc = "12: ADC AIN12 Pin"]
PIN12 = 12 , # [doc = "13: ADC AIN13 Pin"]
PIN13 = 13 , # [doc = "14: ADC AIN14 Pin"]
PIN14 = 14 , # [doc = "15: ADC AIN15 Pin"]
PIN15 = 15 , # [doc = "16: ADC AIN16 Pin"]
PIN16 = 16 , # [doc = "17: ADC AIN17 Pin"]
PIN17 = 17 , # [doc = "18: ADC AIN18 Pin"]
PIN18 = 18 , # [doc = "19: ADC AIN19 Pin"]
PIN19 = 19 , # [doc = "24: Temperature Reference"]
TEMP = 24 , # [doc = "25: Bandgap Voltage"]
BANDGAP = 25 , # [doc = "26: 1/4 Scaled Core Supply"]
SCALEDCOREVCC = 26 , # [doc = "27: 1/4 Scaled I/O Supply"]
SCALEDIOVCC = 27 , # [doc = "28: DAC Output"]
DAC = 28 , } impl From < MUXPOS_A > for u8 { # [inline (always)]
fn from (variant : MUXPOS_A) -> Self { variant as _ } } # [doc = "Field `MUXPOS` reader - Positive Mux Input Selection"]
pub type MUXPOS_R = crate :: FieldReader < u8 , MUXPOS_A > ; impl MUXPOS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < MUXPOS_A > { match self . bits { 0 => Some (MUXPOS_A :: PIN0) , 1 => Some (MUXPOS_A :: PIN1) , 2 => Some (MUXPOS_A :: PIN2) , 3 => Some (MUXPOS_A :: PIN3) , 4 => Some (MUXPOS_A :: PIN4) , 5 => Some (MUXPOS_A :: PIN5) , 6 => Some (MUXPOS_A :: PIN6) , 7 => Some (MUXPOS_A :: PIN7) , 8 => Some (MUXPOS_A :: PIN8) , 9 => Some (MUXPOS_A :: PIN9) , 10 => Some (MUXPOS_A :: PIN10) , 11 => Some (MUXPOS_A :: PIN11) , 12 => Some (MUXPOS_A :: PIN12) , 13 => Some (MUXPOS_A :: PIN13) , 14 => Some (MUXPOS_A :: PIN14) , 15 => Some (MUXPOS_A :: PIN15) , 16 => Some (MUXPOS_A :: PIN16) , 17 => Some (MUXPOS_A :: PIN17) , 18 => Some (MUXPOS_A :: PIN18) , 19 => Some (MUXPOS_A :: PIN19) , 24 => Some (MUXPOS_A :: TEMP) , 25 => Some (MUXPOS_A :: BANDGAP) , 26 => Some (MUXPOS_A :: SCALEDCOREVCC) , 27 => Some (MUXPOS_A :: SCALEDIOVCC) , 28 => Some (MUXPOS_A :: DAC) , _ => None , } } # [doc = "Checks if the value of the field is `PIN0`"]
# [inline (always)]
pub fn is_pin0 (& self) -> bool { * self == MUXPOS_A :: PIN0 } # [doc = "Checks if the value of the field is `PIN1`"]
# [inline (always)]
pub fn is_pin1 (& self) -> bool { * self == MUXPOS_A :: PIN1 } # [doc = "Checks if the value of the field is `PIN2`"]
# [inline (always)]
pub fn is_pin2 (& self) -> bool { * self == MUXPOS_A :: PIN2 } # [doc = "Checks if the value of the field is `PIN3`"]
# [inline (always)]
pub fn is_pin3 (& self) -> bool { * self == MUXPOS_A :: PIN3 } # [doc = "Checks if the value of the field is `PIN4`"]
# [inline (always)]
pub fn is_pin4 (& self) -> bool { * self == MUXPOS_A :: PIN4 } # [doc = "Checks if the value of the field is `PIN5`"]
# [inline (always)]
pub fn is_pin5 (& self) -> bool { * self == MUXPOS_A :: PIN5 } # [doc = "Checks if the value of the field is `PIN6`"]
# [inline (always)]
pub fn is_pin6 (& self) -> bool { * self == MUXPOS_A :: PIN6 } # [doc = "Checks if the value of the field is `PIN7`"]
# [inline (always)]
pub fn is_pin7 (& self) -> bool { * self == MUXPOS_A :: PIN7 } # [doc = "Checks if the value of the field is `PIN8`"]
# [inline (always)]
pub fn is_pin8 (& self) -> bool { * self == MUXPOS_A :: PIN8 } # [doc = "Checks if the value of the field is `PIN9`"]
# [inline (always)]
pub fn is_pin9 (& self) -> bool { * self == MUXPOS_A :: PIN9 } # [doc = "Checks if the value of the field is `PIN10`"]
# [inline (always)]
pub fn is_pin10 (& self) -> bool { * self == MUXPOS_A :: PIN10 } # [doc = "Checks if the value of the field is `PIN11`"]
# [inline (always)]
pub fn is_pin11 (& self) -> bool { * self == MUXPOS_A :: PIN11 } # [doc = "Checks if the value of the field is `PIN12`"]
# [inline (always)]
pub fn is_pin12 (& self) -> bool { * self == MUXPOS_A :: PIN12 } # [doc = "Checks if the value of the field is `PIN13`"]
# [inline (always)]
pub fn is_pin13 (& self) -> bool { * self == MUXPOS_A :: PIN13 } # [doc = "Checks if the value of the field is `PIN14`"]
# [inline (always)]
pub fn is_pin14 (& self) -> bool { * self == MUXPOS_A :: PIN14 } # [doc = "Checks if the value of the field is `PIN15`"]
# [inline (always)]
pub fn is_pin15 (& self) -> bool { * self == MUXPOS_A :: PIN15 } # [doc = "Checks if the value of the field is `PIN16`"]
# [inline (always)]
pub fn is_pin16 (& self) -> bool { * self == MUXPOS_A :: PIN16 } # [doc = "Checks if the value of the field is `PIN17`"]
# [inline (always)]
pub fn is_pin17 (& self) -> bool { * self == MUXPOS_A :: PIN17 } # [doc = "Checks if the value of the field is `PIN18`"]
# [inline (always)]
pub fn is_pin18 (& self) -> bool { * self == MUXPOS_A :: PIN18 } # [doc = "Checks if the value of the field is `PIN19`"]
# [inline (always)]
pub fn is_pin19 (& self) -> bool { * self == MUXPOS_A :: PIN19 } # [doc = "Checks if the value of the field is `TEMP`"]
# [inline (always)]
pub fn is_temp (& self) -> bool { * self == MUXPOS_A :: TEMP } # [doc = "Checks if the value of the field is `BANDGAP`"]
# [inline (always)]
pub fn is_bandgap (& self) -> bool { * self == MUXPOS_A :: BANDGAP } # [doc = "Checks if the value of the field is `SCALEDCOREVCC`"]
# [inline (always)]
pub fn is_scaledcorevcc (& self) -> bool { * self == MUXPOS_A :: SCALEDCOREVCC } # [doc = "Checks if the value of the field is `SCALEDIOVCC`"]
# [inline (always)]
pub fn is_scalediovcc (& self) -> bool { * self == MUXPOS_A :: SCALEDIOVCC } # [doc = "Checks if the value of the field is `DAC`"]
# [inline (always)]
pub fn is_dac (& self) -> bool { * self == MUXPOS_A :: DAC } } # [doc = "Field `MUXPOS` writer - Positive Mux Input Selection"]
pub type MUXPOS_W < 'a > = crate :: FieldWriter < 'a , u32 , INPUTCTRL_SPEC , u8 , MUXPOS_A , 5 , 0 > ; impl < 'a > MUXPOS_W < 'a > { # [doc = "ADC AIN0 Pin"]
# [inline (always)]
pub fn pin0 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN0) } # [doc = "ADC AIN1 Pin"]
# [inline (always)]
pub fn pin1 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN1) } # [doc = "ADC AIN2 Pin"]
# [inline (always)]
pub fn pin2 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN2) } # [doc = "ADC AIN3 Pin"]
# [inline (always)]
pub fn pin3 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN3) } # [doc = "ADC AIN4 Pin"]
# [inline (always)]
pub fn pin4 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN4) } # [doc = "ADC AIN5 Pin"]
# [inline (always)]
pub fn pin5 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN5) } # [doc = "ADC AIN6 Pin"]
# [inline (always)]
pub fn pin6 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN6) } # [doc = "ADC AIN7 Pin"]
# [inline (always)]
pub fn pin7 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN7) } # [doc = "ADC AIN8 Pin"]
# [inline (always)]
pub fn pin8 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN8) } # [doc = "ADC AIN9 Pin"]
# [inline (always)]
pub fn pin9 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN9) } # [doc = "ADC AIN10 Pin"]
# [inline (always)]
pub fn pin10 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN10) } # [doc = "ADC AIN11 Pin"]
# [inline (always)]
pub fn pin11 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN11) } # [doc = "ADC AIN12 Pin"]
# [inline (always)]
pub fn pin12 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN12) } # [doc = "ADC AIN13 Pin"]
# [inline (always)]
pub fn pin13 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN13) } # [doc = "ADC AIN14 Pin"]
# [inline (always)]
pub fn pin14 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN14) } # [doc = "ADC AIN15 Pin"]
# [inline (always)]
pub fn pin15 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN15) } # [doc = "ADC AIN16 Pin"]
# [inline (always)]
pub fn pin16 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN16) } # [doc = "ADC AIN17 Pin"]
# [inline (always)]
pub fn pin17 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN17) } # [doc = "ADC AIN18 Pin"]
# [inline (always)]
pub fn pin18 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN18) } # [doc = "ADC AIN19 Pin"]
# [inline (always)]
pub fn pin19 (self) -> & 'a mut W { self . variant (MUXPOS_A :: PIN19) } # [doc = "Temperature Reference"]
# [inline (always)]
pub fn temp (self) -> & 'a mut W { self . variant (MUXPOS_A :: TEMP) } # [doc = "Bandgap Voltage"]
# [inline (always)]
pub fn bandgap (self) -> & 'a mut W { self . variant (MUXPOS_A :: BANDGAP) } # [doc = "1/4 Scaled Core Supply"]
# [inline (always)]
pub fn scaledcorevcc (self) -> & 'a mut W { self . variant (MUXPOS_A :: SCALEDCOREVCC) } # [doc = "1/4 Scaled I/O Supply"]
# [inline (always)]
pub fn scalediovcc (self) -> & 'a mut W { self . variant (MUXPOS_A :: SCALEDIOVCC) } # [doc = "DAC Output"]
# [inline (always)]
pub fn dac (self) -> & 'a mut W { self . variant (MUXPOS_A :: DAC) } } # [doc = "Negative Mux Input Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum MUXNEG_A { # [doc = "0: ADC AIN0 Pin"]
PIN0 = 0 , # [doc = "1: ADC AIN1 Pin"]
PIN1 = 1 , # [doc = "2: ADC AIN2 Pin"]
PIN2 = 2 , # [doc = "3: ADC AIN3 Pin"]
PIN3 = 3 , # [doc = "4: ADC AIN4 Pin"]
PIN4 = 4 , # [doc = "5: ADC AIN5 Pin"]
PIN5 = 5 , # [doc = "6: ADC AIN6 Pin"]
PIN6 = 6 , # [doc = "7: ADC AIN7 Pin"]
PIN7 = 7 , # [doc = "24: Internal Ground"]
GND = 24 , # [doc = "25: I/O Ground"]
IOGND = 25 , } impl From < MUXNEG_A > for u8 { # [inline (always)]
fn from (variant : MUXNEG_A) -> Self { variant as _ } } # [doc = "Field `MUXNEG` reader - Negative Mux Input Selection"]
pub type MUXNEG_R = crate :: FieldReader < u8 , MUXNEG_A > ; impl MUXNEG_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < MUXNEG_A > { match self . bits { 0 => Some (MUXNEG_A :: PIN0) , 1 => Some (MUXNEG_A :: PIN1) , 2 => Some (MUXNEG_A :: PIN2) , 3 => Some (MUXNEG_A :: PIN3) , 4 => Some (MUXNEG_A :: PIN4) , 5 => Some (MUXNEG_A :: PIN5) , 6 => Some (MUXNEG_A :: PIN6) , 7 => Some (MUXNEG_A :: PIN7) , 24 => Some (MUXNEG_A :: GND) , 25 => Some (MUXNEG_A :: IOGND) , _ => None , } } # [doc = "Checks if the value of the field is `PIN0`"]
# [inline (always)]
pub fn is_pin0 (& self) -> bool { * self == MUXNEG_A :: PIN0 } # [doc = "Checks if the value of the field is `PIN1`"]
# [inline (always)]
pub fn is_pin1 (& self) -> bool { * self == MUXNEG_A :: PIN1 } # [doc = "Checks if the value of the field is `PIN2`"]
# [inline (always)]
pub fn is_pin2 (& self) -> bool { * self == MUXNEG_A :: PIN2 } # [doc = "Checks if the value of the field is `PIN3`"]
# [inline (always)]
pub fn is_pin3 (& self) -> bool { * self == MUXNEG_A :: PIN3 } # [doc = "Checks if the value of the field is `PIN4`"]
# [inline (always)]
pub fn is_pin4 (& self) -> bool { * self == MUXNEG_A :: PIN4 } # [doc = "Checks if the value of the field is `PIN5`"]
# [inline (always)]
pub fn is_pin5 (& self) -> bool { * self == MUXNEG_A :: PIN5 } # [doc = "Checks if the value of the field is `PIN6`"]
# [inline (always)]
pub fn is_pin6 (& self) -> bool { * self == MUXNEG_A :: PIN6 } # [doc = "Checks if the value of the field is `PIN7`"]
# [inline (always)]
pub fn is_pin7 (& self) -> bool { * self == MUXNEG_A :: PIN7 } # [doc = "Checks if the value of the field is `GND`"]
# [inline (always)]
pub fn is_gnd (& self) -> bool { * self == MUXNEG_A :: GND } # [doc = "Checks if the value of the field is `IOGND`"]
# [inline (always)]
pub fn is_iognd (& self) -> bool { * self == MUXNEG_A :: IOGND } } # [doc = "Field `MUXNEG` writer - Negative Mux Input Selection"]
pub type MUXNEG_W < 'a > = crate :: FieldWriter < 'a , u32 , INPUTCTRL_SPEC , u8 , MUXNEG_A , 5 , 8 > ; impl < 'a > MUXNEG_W < 'a > { # [doc = "ADC AIN0 Pin"]
# [inline (always)]
pub fn pin0 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN0) } # [doc = "ADC AIN1 Pin"]
# [inline (always)]
pub fn pin1 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN1) } # [doc = "ADC AIN2 Pin"]
# [inline (always)]
pub fn pin2 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN2) } # [doc = "ADC AIN3 Pin"]
# [inline (always)]
pub fn pin3 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN3) } # [doc = "ADC AIN4 Pin"]
# [inline (always)]
pub fn pin4 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN4) } # [doc = "ADC AIN5 Pin"]
# [inline (always)]
pub fn pin5 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN5) } # [doc = "ADC AIN6 Pin"]
# [inline (always)]
pub fn pin6 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN6) } # [doc = "ADC AIN7 Pin"]
# [inline (always)]
pub fn pin7 (self) -> & 'a mut W { self . variant (MUXNEG_A :: PIN7) } # [doc = "Internal Ground"]
# [inline (always)]
pub fn gnd (self) -> & 'a mut W { self . variant (MUXNEG_A :: GND) } # [doc = "I/O Ground"]
# [inline (always)]
pub fn iognd (self) -> & 'a mut W { self . variant (MUXNEG_A :: IOGND) } } # [doc = "Field `INPUTSCAN` reader - Number of Input Channels Included in Scan"]
pub type INPUTSCAN_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `INPUTSCAN` writer - Number of Input Channels Included in Scan"]
pub type INPUTSCAN_W < 'a > = crate :: FieldWriter < 'a , u32 , INPUTCTRL_SPEC , u8 , u8 , 4 , 16 > ; # [doc = "Field `INPUTOFFSET` reader - Positive Mux Setting Offset"]
pub type INPUTOFFSET_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `INPUTOFFSET` writer - Positive Mux Setting Offset"]
pub type INPUTOFFSET_W < 'a > = crate :: FieldWriter < 'a , u32 , INPUTCTRL_SPEC , u8 , u8 , 4 , 20 > ; # [doc = "Gain Factor Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum GAIN_A { # [doc = "0: 1x"]
_1X = 0 , # [doc = "1: 2x"]
_2X = 1 , # [doc = "2: 4x"]
_4X = 2 , # [doc = "3: 8x"]
_8X = 3 , # [doc = "4: 16x"]
_16X = 4 , # [doc = "15: 1/2x"]
DIV2 = 15 , } impl From < GAIN_A > for u8 { # [inline (always)]
fn from (variant : GAIN_A) -> Self { variant as _ } } # [doc = "Field `GAIN` reader - Gain Factor Selection"]
pub type GAIN_R = crate :: FieldReader < u8 , GAIN_A > ; impl GAIN_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < GAIN_A > { match self . bits { 0 => Some (GAIN_A :: _1X) , 1 => Some (GAIN_A :: _2X) , 2 => Some (GAIN_A :: _4X) , 3 => Some (GAIN_A :: _8X) , 4 => Some (GAIN_A :: _16X) , 15 => Some (GAIN_A :: DIV2) , _ => None , } } # [doc = "Checks if the value of the field is `_1X`"]
# [inline (always)]
pub fn is_1x (& self) -> bool { * self == GAIN_A :: _1X } # [doc = "Checks if the value of the field is `_2X`"]
# [inline (always)]
pub fn is_2x (& self) -> bool { * self == GAIN_A :: _2X } # [doc = "Checks if the value of the field is `_4X`"]
# [inline (always)]
pub fn is_4x (& self) -> bool { * self == GAIN_A :: _4X } # [doc = "Checks if the value of the field is `_8X`"]
# [inline (always)]
pub fn is_8x (& self) -> bool { * self == GAIN_A :: _8X } # [doc = "Checks if the value of the field is `_16X`"]
# [inline (always)]
pub fn is_16x (& self) -> bool { * self == GAIN_A :: _16X } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == GAIN_A :: DIV2 } } # [doc = "Field `GAIN` writer - Gain Factor Selection"]
pub type GAIN_W < 'a > = crate :: FieldWriter < 'a , u32 , INPUTCTRL_SPEC , u8 , GAIN_A , 4 , 24 > ; impl < 'a > GAIN_W < 'a > { # [doc = "1x"]
# [inline (always)]
pub fn _1x (self) -> & 'a mut W { self . variant (GAIN_A :: _1X) } # [doc = "2x"]
# [inline (always)]
pub fn _2x (self) -> & 'a mut W { self . variant (GAIN_A :: _2X) } # [doc = "4x"]
# [inline (always)]
pub fn _4x (self) -> & 'a mut W { self . variant (GAIN_A :: _4X) } # [doc = "8x"]
# [inline (always)]
pub fn _8x (self) -> & 'a mut W { self . variant (GAIN_A :: _8X) } # [doc = "16x"]
# [inline (always)]
pub fn _16x (self) -> & 'a mut W { self . variant (GAIN_A :: _16X) } # [doc = "1/2x"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (GAIN_A :: DIV2) } } impl R { # [doc = "Bits 0:4 - Positive Mux Input Selection"]
# [inline (always)]
pub fn muxpos (& self) -> MUXPOS_R { MUXPOS_R :: new ((self . bits & 0x1f) as u8) } # [doc = "Bits 8:12 - Negative Mux Input Selection"]
# [inline (always)]
pub fn muxneg (& self) -> MUXNEG_R { MUXNEG_R :: new (((self . bits >> 8) & 0x1f) as u8) } # [doc = "Bits 16:19 - Number of Input Channels Included in Scan"]
# [inline (always)]
pub fn inputscan (& self) -> INPUTSCAN_R { INPUTSCAN_R :: new (((self . bits >> 16) & 0x0f) as u8) } # [doc = "Bits 20:23 - Positive Mux Setting Offset"]
# [inline (always)]
pub fn inputoffset (& self) -> INPUTOFFSET_R { INPUTOFFSET_R :: new (((self . bits >> 20) & 0x0f) as u8) } # [doc = "Bits 24:27 - Gain Factor Selection"]
# [inline (always)]
pub fn gain (& self) -> GAIN_R { GAIN_R :: new (((self . bits >> 24) & 0x0f) as u8) } } impl W { # [doc = "Bits 0:4 - Positive Mux Input Selection"]
# [inline (always)]
pub fn muxpos (& mut self) -> MUXPOS_W { MUXPOS_W :: new (self) } # [doc = "Bits 8:12 - Negative Mux Input Selection"]
# [inline (always)]
pub fn muxneg (& mut self) -> MUXNEG_W { MUXNEG_W :: new (self) } # [doc = "Bits 16:19 - Number of Input Channels Included in Scan"]
# [inline (always)]
pub fn inputscan (& mut self) -> INPUTSCAN_W { INPUTSCAN_W :: new (self) } # [doc = "Bits 20:23 - Positive Mux Setting Offset"]
# [inline (always)]
pub fn inputoffset (& mut self) -> INPUTOFFSET_W { INPUTOFFSET_W :: new (self) } # [doc = "Bits 24:27 - Gain Factor Selection"]
# [inline (always)]
pub fn gain (& mut self) -> GAIN_W { GAIN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Input Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [inputctrl](index.html) module"]
pub struct INPUTCTRL_SPEC ; impl crate :: RegisterSpec for INPUTCTRL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [inputctrl::R](R) reader structure"]
impl crate :: Readable for INPUTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [inputctrl::W](W) writer structure"]
impl crate :: Writable for INPUTCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INPUTCTRL to value 0"]
impl crate :: Resettable for INPUTCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "EVCTRL register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "Event Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `STARTEI` reader - Start Conversion Event In"]
pub type STARTEI_R = crate :: BitReader < bool > ; # [doc = "Field `STARTEI` writer - Start Conversion Event In"]
pub type STARTEI_W < 'a > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , 0 > ; # [doc = "Field `SYNCEI` reader - Synchronization Event In"]
pub type SYNCEI_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCEI` writer - Synchronization Event In"]
pub type SYNCEI_W < 'a > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , 1 > ; # [doc = "Field `RESRDYEO` reader - Result Ready Event Out"]
pub type RESRDYEO_R = crate :: BitReader < bool > ; # [doc = "Field `RESRDYEO` writer - Result Ready Event Out"]
pub type RESRDYEO_W < 'a > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , 4 > ; # [doc = "Field `WINMONEO` reader - Window Monitor Event Out"]
pub type WINMONEO_R = crate :: BitReader < bool > ; # [doc = "Field `WINMONEO` writer - Window Monitor Event Out"]
pub type WINMONEO_W < 'a > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , 5 > ; impl R { # [doc = "Bit 0 - Start Conversion Event In"]
# [inline (always)]
pub fn startei (& self) -> STARTEI_R { STARTEI_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Synchronization Event In"]
# [inline (always)]
pub fn syncei (& self) -> SYNCEI_R { SYNCEI_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - Result Ready Event Out"]
# [inline (always)]
pub fn resrdyeo (& self) -> RESRDYEO_R { RESRDYEO_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Window Monitor Event Out"]
# [inline (always)]
pub fn winmoneo (& self) -> WINMONEO_R { WINMONEO_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Start Conversion Event In"]
# [inline (always)]
pub fn startei (& mut self) -> STARTEI_W { STARTEI_W :: new (self) } # [doc = "Bit 1 - Synchronization Event In"]
# [inline (always)]
pub fn syncei (& mut self) -> SYNCEI_W { SYNCEI_W :: new (self) } # [doc = "Bit 4 - Result Ready Event Out"]
# [inline (always)]
pub fn resrdyeo (& mut self) -> RESRDYEO_W { RESRDYEO_W :: new (self) } # [doc = "Bit 5 - Window Monitor Event Out"]
# [inline (always)]
pub fn winmoneo (& mut self) -> WINMONEO_W { WINMONEO_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENCLR register accessor: an alias for `Reg<INTENCLR_SPEC>`"]
pub type INTENCLR = crate :: Reg < intenclr :: INTENCLR_SPEC > ; # [doc = "Interrupt Enable Clear"]
pub mod intenclr { # [doc = "Register `INTENCLR` reader"]
pub struct R (crate :: R < INTENCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENCLR` writer"]
pub struct W (crate :: W < INTENCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `RESRDY` reader - Result Ready Interrupt Enable"]
pub type RESRDY_R = crate :: BitReader < bool > ; # [doc = "Field `RESRDY` writer - Result Ready Interrupt Enable"]
pub type RESRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 0 > ; # [doc = "Field `OVERRUN` reader - Overrun Interrupt Enable"]
pub type OVERRUN_R = crate :: BitReader < bool > ; # [doc = "Field `OVERRUN` writer - Overrun Interrupt Enable"]
pub type OVERRUN_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 1 > ; # [doc = "Field `WINMON` reader - Window Monitor Interrupt Enable"]
pub type WINMON_R = crate :: BitReader < bool > ; # [doc = "Field `WINMON` writer - Window Monitor Interrupt Enable"]
pub type WINMON_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 2 > ; # [doc = "Field `SYNCRDY` reader - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCRDY` writer - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 3 > ; impl R { # [doc = "Bit 0 - Result Ready Interrupt Enable"]
# [inline (always)]
pub fn resrdy (& self) -> RESRDY_R { RESRDY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Overrun Interrupt Enable"]
# [inline (always)]
pub fn overrun (& self) -> OVERRUN_R { OVERRUN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Window Monitor Interrupt Enable"]
# [inline (always)]
pub fn winmon (& self) -> WINMON_R { WINMON_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& self) -> SYNCRDY_R { SYNCRDY_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Result Ready Interrupt Enable"]
# [inline (always)]
pub fn resrdy (& mut self) -> RESRDY_W { RESRDY_W :: new (self) } # [doc = "Bit 1 - Overrun Interrupt Enable"]
# [inline (always)]
pub fn overrun (& mut self) -> OVERRUN_W { OVERRUN_W :: new (self) } # [doc = "Bit 2 - Window Monitor Interrupt Enable"]
# [inline (always)]
pub fn winmon (& mut self) -> WINMON_W { WINMON_W :: new (self) } # [doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& mut self) -> SYNCRDY_W { SYNCRDY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenclr](index.html) module"]
pub struct INTENCLR_SPEC ; impl crate :: RegisterSpec for INTENCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenclr::R](R) reader structure"]
impl crate :: Readable for INTENCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenclr::W](W) writer structure"]
impl crate :: Writable for INTENCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENCLR to value 0"]
impl crate :: Resettable for INTENCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENSET register accessor: an alias for `Reg<INTENSET_SPEC>`"]
pub type INTENSET = crate :: Reg < intenset :: INTENSET_SPEC > ; # [doc = "Interrupt Enable Set"]
pub mod intenset { # [doc = "Register `INTENSET` reader"]
pub struct R (crate :: R < INTENSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENSET` writer"]
pub struct W (crate :: W < INTENSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `RESRDY` reader - Result Ready Interrupt Enable"]
pub type RESRDY_R = crate :: BitReader < bool > ; # [doc = "Field `RESRDY` writer - Result Ready Interrupt Enable"]
pub type RESRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 0 > ; # [doc = "Field `OVERRUN` reader - Overrun Interrupt Enable"]
pub type OVERRUN_R = crate :: BitReader < bool > ; # [doc = "Field `OVERRUN` writer - Overrun Interrupt Enable"]
pub type OVERRUN_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 1 > ; # [doc = "Field `WINMON` reader - Window Monitor Interrupt Enable"]
pub type WINMON_R = crate :: BitReader < bool > ; # [doc = "Field `WINMON` writer - Window Monitor Interrupt Enable"]
pub type WINMON_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 2 > ; # [doc = "Field `SYNCRDY` reader - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCRDY` writer - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 3 > ; impl R { # [doc = "Bit 0 - Result Ready Interrupt Enable"]
# [inline (always)]
pub fn resrdy (& self) -> RESRDY_R { RESRDY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Overrun Interrupt Enable"]
# [inline (always)]
pub fn overrun (& self) -> OVERRUN_R { OVERRUN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Window Monitor Interrupt Enable"]
# [inline (always)]
pub fn winmon (& self) -> WINMON_R { WINMON_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& self) -> SYNCRDY_R { SYNCRDY_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Result Ready Interrupt Enable"]
# [inline (always)]
pub fn resrdy (& mut self) -> RESRDY_W { RESRDY_W :: new (self) } # [doc = "Bit 1 - Overrun Interrupt Enable"]
# [inline (always)]
pub fn overrun (& mut self) -> OVERRUN_W { OVERRUN_W :: new (self) } # [doc = "Bit 2 - Window Monitor Interrupt Enable"]
# [inline (always)]
pub fn winmon (& mut self) -> WINMON_W { WINMON_W :: new (self) } # [doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& mut self) -> SYNCRDY_W { SYNCRDY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenset](index.html) module"]
pub struct INTENSET_SPEC ; impl crate :: RegisterSpec for INTENSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenset::R](R) reader structure"]
impl crate :: Readable for INTENSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenset::W](W) writer structure"]
impl crate :: Writable for INTENSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENSET to value 0"]
impl crate :: Resettable for INTENSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTFLAG register accessor: an alias for `Reg<INTFLAG_SPEC>`"]
pub type INTFLAG = crate :: Reg < intflag :: INTFLAG_SPEC > ; # [doc = "Interrupt Flag Status and Clear"]
pub mod intflag { # [doc = "Register `INTFLAG` reader"]
pub struct R (crate :: R < INTFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAG` writer"]
pub struct W (crate :: W < INTFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `RESRDY` reader - Result Ready"]
pub type RESRDY_R = crate :: BitReader < bool > ; # [doc = "Field `RESRDY` writer - Result Ready"]
pub type RESRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 0 > ; # [doc = "Field `OVERRUN` reader - Overrun"]
pub type OVERRUN_R = crate :: BitReader < bool > ; # [doc = "Field `OVERRUN` writer - Overrun"]
pub type OVERRUN_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 1 > ; # [doc = "Field `WINMON` reader - Window Monitor"]
pub type WINMON_R = crate :: BitReader < bool > ; # [doc = "Field `WINMON` writer - Window Monitor"]
pub type WINMON_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 2 > ; # [doc = "Field `SYNCRDY` reader - Synchronization Ready"]
pub type SYNCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCRDY` writer - Synchronization Ready"]
pub type SYNCRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 3 > ; impl R { # [doc = "Bit 0 - Result Ready"]
# [inline (always)]
pub fn resrdy (& self) -> RESRDY_R { RESRDY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Overrun"]
# [inline (always)]
pub fn overrun (& self) -> OVERRUN_R { OVERRUN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Window Monitor"]
# [inline (always)]
pub fn winmon (& self) -> WINMON_R { WINMON_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Synchronization Ready"]
# [inline (always)]
pub fn syncrdy (& self) -> SYNCRDY_R { SYNCRDY_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Result Ready"]
# [inline (always)]
pub fn resrdy (& mut self) -> RESRDY_W { RESRDY_W :: new (self) } # [doc = "Bit 1 - Overrun"]
# [inline (always)]
pub fn overrun (& mut self) -> OVERRUN_W { OVERRUN_W :: new (self) } # [doc = "Bit 2 - Window Monitor"]
# [inline (always)]
pub fn winmon (& mut self) -> WINMON_W { WINMON_W :: new (self) } # [doc = "Bit 3 - Synchronization Ready"]
# [inline (always)]
pub fn syncrdy (& mut self) -> SYNCRDY_W { SYNCRDY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflag](index.html) module"]
pub struct INTFLAG_SPEC ; impl crate :: RegisterSpec for INTFLAG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflag::R](R) reader structure"]
impl crate :: Readable for INTFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflag::W](W) writer structure"]
impl crate :: Writable for INTFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTFLAG to value 0"]
impl crate :: Resettable for INTFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATUS register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `SYNCBUSY` reader - Synchronization Busy"]
pub type SYNCBUSY_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 7 - Synchronization Busy"]
# [inline (always)]
pub fn syncbusy (& self) -> SYNCBUSY_R { SYNCBUSY_R :: new (((self . bits >> 7) & 1) != 0) } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "RESULT register accessor: an alias for `Reg<RESULT_SPEC>`"]
pub type RESULT = crate :: Reg < result :: RESULT_SPEC > ; # [doc = "Result"]
pub mod result { # [doc = "Register `RESULT` reader"]
pub struct R (crate :: R < RESULT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RESULT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RESULT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RESULT_SPEC >) -> Self { R (reader) } } # [doc = "Field `RESULT` reader - Result Conversion Value"]
pub type RESULT_R = crate :: FieldReader < u16 , u16 > ; impl R { # [doc = "Bits 0:15 - Result Conversion Value"]
# [inline (always)]
pub fn result (& self) -> RESULT_R { RESULT_R :: new (self . bits) } } # [doc = "Result\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [result](index.html) module"]
pub struct RESULT_SPEC ; impl crate :: RegisterSpec for RESULT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [result::R](R) reader structure"]
impl crate :: Readable for RESULT_SPEC { type Reader = R ; } # [doc = "`reset()` method sets RESULT to value 0"]
impl crate :: Resettable for RESULT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "WINLT register accessor: an alias for `Reg<WINLT_SPEC>`"]
pub type WINLT = crate :: Reg < winlt :: WINLT_SPEC > ; # [doc = "Window Monitor Lower Threshold"]
pub mod winlt { # [doc = "Register `WINLT` reader"]
pub struct R (crate :: R < WINLT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < WINLT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < WINLT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < WINLT_SPEC >) -> Self { R (reader) } } # [doc = "Register `WINLT` writer"]
pub struct W (crate :: W < WINLT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < WINLT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < WINLT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < WINLT_SPEC >) -> Self { W (writer) } } # [doc = "Field `WINLT` reader - Window Lower Threshold"]
pub type WINLT_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `WINLT` writer - Window Lower Threshold"]
pub type WINLT_W < 'a > = crate :: FieldWriter < 'a , u16 , WINLT_SPEC , u16 , u16 , 16 , 0 > ; impl R { # [doc = "Bits 0:15 - Window Lower Threshold"]
# [inline (always)]
pub fn winlt (& self) -> WINLT_R { WINLT_R :: new (self . bits) } } impl W { # [doc = "Bits 0:15 - Window Lower Threshold"]
# [inline (always)]
pub fn winlt (& mut self) -> WINLT_W { WINLT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Window Monitor Lower Threshold\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [winlt](index.html) module"]
pub struct WINLT_SPEC ; impl crate :: RegisterSpec for WINLT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [winlt::R](R) reader structure"]
impl crate :: Readable for WINLT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [winlt::W](W) writer structure"]
impl crate :: Writable for WINLT_SPEC { type Writer = W ; } # [doc = "`reset()` method sets WINLT to value 0"]
impl crate :: Resettable for WINLT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "WINUT register accessor: an alias for `Reg<WINUT_SPEC>`"]
pub type WINUT = crate :: Reg < winut :: WINUT_SPEC > ; # [doc = "Window Monitor Upper Threshold"]
pub mod winut { # [doc = "Register `WINUT` reader"]
pub struct R (crate :: R < WINUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < WINUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < WINUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < WINUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `WINUT` writer"]
pub struct W (crate :: W < WINUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < WINUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < WINUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < WINUT_SPEC >) -> Self { W (writer) } } # [doc = "Field `WINUT` reader - Window Upper Threshold"]
pub type WINUT_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `WINUT` writer - Window Upper Threshold"]
pub type WINUT_W < 'a > = crate :: FieldWriter < 'a , u16 , WINUT_SPEC , u16 , u16 , 16 , 0 > ; impl R { # [doc = "Bits 0:15 - Window Upper Threshold"]
# [inline (always)]
pub fn winut (& self) -> WINUT_R { WINUT_R :: new (self . bits) } } impl W { # [doc = "Bits 0:15 - Window Upper Threshold"]
# [inline (always)]
pub fn winut (& mut self) -> WINUT_W { WINUT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Window Monitor Upper Threshold\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [winut](index.html) module"]
pub struct WINUT_SPEC ; impl crate :: RegisterSpec for WINUT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [winut::R](R) reader structure"]
impl crate :: Readable for WINUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [winut::W](W) writer structure"]
impl crate :: Writable for WINUT_SPEC { type Writer = W ; } # [doc = "`reset()` method sets WINUT to value 0"]
impl crate :: Resettable for WINUT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "GAINCORR register accessor: an alias for `Reg<GAINCORR_SPEC>`"]
pub type GAINCORR = crate :: Reg < gaincorr :: GAINCORR_SPEC > ; # [doc = "Gain Correction"]
pub mod gaincorr { # [doc = "Register `GAINCORR` reader"]
pub struct R (crate :: R < GAINCORR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GAINCORR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GAINCORR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GAINCORR_SPEC >) -> Self { R (reader) } } # [doc = "Register `GAINCORR` writer"]
pub struct W (crate :: W < GAINCORR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GAINCORR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GAINCORR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GAINCORR_SPEC >) -> Self { W (writer) } } # [doc = "Field `GAINCORR` reader - Gain Correction Value"]
pub type GAINCORR_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `GAINCORR` writer - Gain Correction Value"]
pub type GAINCORR_W < 'a > = crate :: FieldWriter < 'a , u16 , GAINCORR_SPEC , u16 , u16 , 12 , 0 > ; impl R { # [doc = "Bits 0:11 - Gain Correction Value"]
# [inline (always)]
pub fn gaincorr (& self) -> GAINCORR_R { GAINCORR_R :: new ((self . bits & 0x0fff) as u16) } } impl W { # [doc = "Bits 0:11 - Gain Correction Value"]
# [inline (always)]
pub fn gaincorr (& mut self) -> GAINCORR_W { GAINCORR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Gain Correction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gaincorr](index.html) module"]
pub struct GAINCORR_SPEC ; impl crate :: RegisterSpec for GAINCORR_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [gaincorr::R](R) reader structure"]
impl crate :: Readable for GAINCORR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gaincorr::W](W) writer structure"]
impl crate :: Writable for GAINCORR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets GAINCORR to value 0"]
impl crate :: Resettable for GAINCORR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "OFFSETCORR register accessor: an alias for `Reg<OFFSETCORR_SPEC>`"]
pub type OFFSETCORR = crate :: Reg < offsetcorr :: OFFSETCORR_SPEC > ; # [doc = "Offset Correction"]
pub mod offsetcorr { # [doc = "Register `OFFSETCORR` reader"]
pub struct R (crate :: R < OFFSETCORR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OFFSETCORR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OFFSETCORR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OFFSETCORR_SPEC >) -> Self { R (reader) } } # [doc = "Register `OFFSETCORR` writer"]
pub struct W (crate :: W < OFFSETCORR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OFFSETCORR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OFFSETCORR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OFFSETCORR_SPEC >) -> Self { W (writer) } } # [doc = "Field `OFFSETCORR` reader - Offset Correction Value"]
pub type OFFSETCORR_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `OFFSETCORR` writer - Offset Correction Value"]
pub type OFFSETCORR_W < 'a > = crate :: FieldWriter < 'a , u16 , OFFSETCORR_SPEC , u16 , u16 , 12 , 0 > ; impl R { # [doc = "Bits 0:11 - Offset Correction Value"]
# [inline (always)]
pub fn offsetcorr (& self) -> OFFSETCORR_R { OFFSETCORR_R :: new ((self . bits & 0x0fff) as u16) } } impl W { # [doc = "Bits 0:11 - Offset Correction Value"]
# [inline (always)]
pub fn offsetcorr (& mut self) -> OFFSETCORR_W { OFFSETCORR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Offset Correction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [offsetcorr](index.html) module"]
pub struct OFFSETCORR_SPEC ; impl crate :: RegisterSpec for OFFSETCORR_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [offsetcorr::R](R) reader structure"]
impl crate :: Readable for OFFSETCORR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [offsetcorr::W](W) writer structure"]
impl crate :: Writable for OFFSETCORR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets OFFSETCORR to value 0"]
impl crate :: Resettable for OFFSETCORR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CALIB register accessor: an alias for `Reg<CALIB_SPEC>`"]
pub type CALIB = crate :: Reg < calib :: CALIB_SPEC > ; # [doc = "Calibration"]
pub mod calib { # [doc = "Register `CALIB` reader"]
pub struct R (crate :: R < CALIB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CALIB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CALIB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CALIB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CALIB` writer"]
pub struct W (crate :: W < CALIB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CALIB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CALIB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CALIB_SPEC >) -> Self { W (writer) } } # [doc = "Field `LINEARITY_CAL` reader - Linearity Calibration Value"]
pub type LINEARITY_CAL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `LINEARITY_CAL` writer - Linearity Calibration Value"]
pub type LINEARITY_CAL_W < 'a > = crate :: FieldWriter < 'a , u16 , CALIB_SPEC , u8 , u8 , 8 , 0 > ; # [doc = "Field `BIAS_CAL` reader - Bias Calibration Value"]
pub type BIAS_CAL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BIAS_CAL` writer - Bias Calibration Value"]
pub type BIAS_CAL_W < 'a > = crate :: FieldWriter < 'a , u16 , CALIB_SPEC , u8 , u8 , 3 , 8 > ; impl R { # [doc = "Bits 0:7 - Linearity Calibration Value"]
# [inline (always)]
pub fn linearity_cal (& self) -> LINEARITY_CAL_R { LINEARITY_CAL_R :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:10 - Bias Calibration Value"]
# [inline (always)]
pub fn bias_cal (& self) -> BIAS_CAL_R { BIAS_CAL_R :: new (((self . bits >> 8) & 7) as u8) } } impl W { # [doc = "Bits 0:7 - Linearity Calibration Value"]
# [inline (always)]
pub fn linearity_cal (& mut self) -> LINEARITY_CAL_W { LINEARITY_CAL_W :: new (self) } # [doc = "Bits 8:10 - Bias Calibration Value"]
# [inline (always)]
pub fn bias_cal (& mut self) -> BIAS_CAL_W { BIAS_CAL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Calibration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [calib](index.html) module"]
pub struct CALIB_SPEC ; impl crate :: RegisterSpec for CALIB_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [calib::R](R) reader structure"]
impl crate :: Readable for CALIB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [calib::W](W) writer structure"]
impl crate :: Writable for CALIB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CALIB to value 0"]
impl crate :: Resettable for CALIB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DBGCTRL register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Debug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Debug Run"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Debug Run"]
pub type DBGRUN_W < 'a > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , 0 > ; impl R { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
pub fn dbgrun (& mut self) -> DBGRUN_W { DBGRUN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "Digital Analog Converter"]
pub struct DAC { _marker : PhantomData < * const () > } unsafe impl Send for DAC { } impl DAC { # [doc = r"Pointer to the register block"]
pub const PTR : * const dac :: RegisterBlock = 0x4200_4800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const dac :: RegisterBlock { Self :: PTR } } impl Deref for DAC { type Target = dac :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for DAC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("DAC") . finish () } } # [doc = "Digital Analog Converter"]
pub mod dac { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : crate :: Reg < ctrla :: CTRLA_SPEC > , # [doc = "0x01 - Control B"]
pub ctrlb : crate :: Reg < ctrlb :: CTRLB_SPEC > , # [doc = "0x02 - Event Control"]
pub evctrl : crate :: Reg < evctrl :: EVCTRL_SPEC > , _reserved3 : [u8 ; 0x01]
, # [doc = "0x04 - Interrupt Enable Clear"]
pub intenclr : crate :: Reg < intenclr :: INTENCLR_SPEC > , # [doc = "0x05 - Interrupt Enable Set"]
pub intenset : crate :: Reg < intenset :: INTENSET_SPEC > , # [doc = "0x06 - Interrupt Flag Status and Clear"]
pub intflag : crate :: Reg < intflag :: INTFLAG_SPEC > , # [doc = "0x07 - Status"]
pub status : crate :: Reg < status :: STATUS_SPEC > , # [doc = "0x08 - Data"]
pub data : crate :: Reg < data :: DATA_SPEC > , _reserved8 : [u8 ; 0x02]
, # [doc = "0x0c - Data Buffer"]
pub databuf : crate :: Reg < databuf :: DATABUF_SPEC > , } # [doc = "CTRLA register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWRST` reader - Software Reset"]
pub type SWRST_R = crate :: BitReader < bool > ; # [doc = "Field `SWRST` writer - Software Reset"]
pub type SWRST_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , 0 > ; # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , 1 > ; # [doc = "Field `RUNSTDBY` reader - Run in Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run in Standby"]
pub type RUNSTDBY_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , 2 > ; impl R { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& self) -> SWRST_R { SWRST_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& mut self) -> SWRST_W { SWRST_W :: new (self) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Bit 2 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& mut self) -> RUNSTDBY_W { RUNSTDBY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CTRLB register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `EOEN` reader - External Output Enable"]
pub type EOEN_R = crate :: BitReader < bool > ; # [doc = "Field `EOEN` writer - External Output Enable"]
pub type EOEN_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , 0 > ; # [doc = "Field `IOEN` reader - Internal Output Enable"]
pub type IOEN_R = crate :: BitReader < bool > ; # [doc = "Field `IOEN` writer - Internal Output Enable"]
pub type IOEN_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , 1 > ; # [doc = "Field `LEFTADJ` reader - Left Adjusted Data"]
pub type LEFTADJ_R = crate :: BitReader < bool > ; # [doc = "Field `LEFTADJ` writer - Left Adjusted Data"]
pub type LEFTADJ_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , 2 > ; # [doc = "Field `VPD` reader - Voltage Pump Disable"]
pub type VPD_R = crate :: BitReader < bool > ; # [doc = "Field `VPD` writer - Voltage Pump Disable"]
pub type VPD_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , 3 > ; # [doc = "Field `BDWP` reader - Bypass DATABUF Write Protection"]
pub type BDWP_R = crate :: BitReader < bool > ; # [doc = "Field `BDWP` writer - Bypass DATABUF Write Protection"]
pub type BDWP_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLB_SPEC , bool , 4 > ; # [doc = "Reference Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum REFSEL_A { # [doc = "0: Internal 1.0V reference"]
INT1V = 0 , # [doc = "1: AVCC"]
AVCC = 1 , # [doc = "2: External reference"]
VREFP = 2 , } impl From < REFSEL_A > for u8 { # [inline (always)]
fn from (variant : REFSEL_A) -> Self { variant as _ } } # [doc = "Field `REFSEL` reader - Reference Selection"]
pub type REFSEL_R = crate :: FieldReader < u8 , REFSEL_A > ; impl REFSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < REFSEL_A > { match self . bits { 0 => Some (REFSEL_A :: INT1V) , 1 => Some (REFSEL_A :: AVCC) , 2 => Some (REFSEL_A :: VREFP) , _ => None , } } # [doc = "Checks if the value of the field is `INT1V`"]
# [inline (always)]
pub fn is_int1v (& self) -> bool { * self == REFSEL_A :: INT1V } # [doc = "Checks if the value of the field is `AVCC`"]
# [inline (always)]
pub fn is_avcc (& self) -> bool { * self == REFSEL_A :: AVCC } # [doc = "Checks if the value of the field is `VREFP`"]
# [inline (always)]
pub fn is_vrefp (& self) -> bool { * self == REFSEL_A :: VREFP } } # [doc = "Field `REFSEL` writer - Reference Selection"]
pub type REFSEL_W < 'a > = crate :: FieldWriter < 'a , u8 , CTRLB_SPEC , u8 , REFSEL_A , 2 , 6 > ; impl < 'a > REFSEL_W < 'a > { # [doc = "Internal 1.0V reference"]
# [inline (always)]
pub fn int1v (self) -> & 'a mut W { self . variant (REFSEL_A :: INT1V) } # [doc = "AVCC"]
# [inline (always)]
pub fn avcc (self) -> & 'a mut W { self . variant (REFSEL_A :: AVCC) } # [doc = "External reference"]
# [inline (always)]
pub fn vrefp (self) -> & 'a mut W { self . variant (REFSEL_A :: VREFP) } } impl R { # [doc = "Bit 0 - External Output Enable"]
# [inline (always)]
pub fn eoen (& self) -> EOEN_R { EOEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Internal Output Enable"]
# [inline (always)]
pub fn ioen (& self) -> IOEN_R { IOEN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Left Adjusted Data"]
# [inline (always)]
pub fn leftadj (& self) -> LEFTADJ_R { LEFTADJ_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Voltage Pump Disable"]
# [inline (always)]
pub fn vpd (& self) -> VPD_R { VPD_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Bypass DATABUF Write Protection"]
# [inline (always)]
pub fn bdwp (& self) -> BDWP_R { BDWP_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 6:7 - Reference Selection"]
# [inline (always)]
pub fn refsel (& self) -> REFSEL_R { REFSEL_R :: new (((self . bits >> 6) & 3) as u8) } } impl W { # [doc = "Bit 0 - External Output Enable"]
# [inline (always)]
pub fn eoen (& mut self) -> EOEN_W { EOEN_W :: new (self) } # [doc = "Bit 1 - Internal Output Enable"]
# [inline (always)]
pub fn ioen (& mut self) -> IOEN_W { IOEN_W :: new (self) } # [doc = "Bit 2 - Left Adjusted Data"]
# [inline (always)]
pub fn leftadj (& mut self) -> LEFTADJ_W { LEFTADJ_W :: new (self) } # [doc = "Bit 3 - Voltage Pump Disable"]
# [inline (always)]
pub fn vpd (& mut self) -> VPD_W { VPD_W :: new (self) } # [doc = "Bit 4 - Bypass DATABUF Write Protection"]
# [inline (always)]
pub fn bdwp (& mut self) -> BDWP_W { BDWP_W :: new (self) } # [doc = "Bits 6:7 - Reference Selection"]
# [inline (always)]
pub fn refsel (& mut self) -> REFSEL_W { REFSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "EVCTRL register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "Event Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `STARTEI` reader - Start Conversion Event Input"]
pub type STARTEI_R = crate :: BitReader < bool > ; # [doc = "Field `STARTEI` writer - Start Conversion Event Input"]
pub type STARTEI_W < 'a > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , 0 > ; # [doc = "Field `EMPTYEO` reader - Data Buffer Empty Event Output"]
pub type EMPTYEO_R = crate :: BitReader < bool > ; # [doc = "Field `EMPTYEO` writer - Data Buffer Empty Event Output"]
pub type EMPTYEO_W < 'a > = crate :: BitWriter < 'a , u8 , EVCTRL_SPEC , bool , 1 > ; impl R { # [doc = "Bit 0 - Start Conversion Event Input"]
# [inline (always)]
pub fn startei (& self) -> STARTEI_R { STARTEI_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Data Buffer Empty Event Output"]
# [inline (always)]
pub fn emptyeo (& self) -> EMPTYEO_R { EMPTYEO_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Start Conversion Event Input"]
# [inline (always)]
pub fn startei (& mut self) -> STARTEI_W { STARTEI_W :: new (self) } # [doc = "Bit 1 - Data Buffer Empty Event Output"]
# [inline (always)]
pub fn emptyeo (& mut self) -> EMPTYEO_W { EMPTYEO_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENCLR register accessor: an alias for `Reg<INTENCLR_SPEC>`"]
pub type INTENCLR = crate :: Reg < intenclr :: INTENCLR_SPEC > ; # [doc = "Interrupt Enable Clear"]
pub mod intenclr { # [doc = "Register `INTENCLR` reader"]
pub struct R (crate :: R < INTENCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENCLR` writer"]
pub struct W (crate :: W < INTENCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `UNDERRUN` reader - Underrun Interrupt Enable"]
pub type UNDERRUN_R = crate :: BitReader < bool > ; # [doc = "Field `UNDERRUN` writer - Underrun Interrupt Enable"]
pub type UNDERRUN_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 0 > ; # [doc = "Field `EMPTY` reader - Data Buffer Empty Interrupt Enable"]
pub type EMPTY_R = crate :: BitReader < bool > ; # [doc = "Field `EMPTY` writer - Data Buffer Empty Interrupt Enable"]
pub type EMPTY_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 1 > ; # [doc = "Field `SYNCRDY` reader - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCRDY` writer - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 2 > ; impl R { # [doc = "Bit 0 - Underrun Interrupt Enable"]
# [inline (always)]
pub fn underrun (& self) -> UNDERRUN_R { UNDERRUN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Data Buffer Empty Interrupt Enable"]
# [inline (always)]
pub fn empty (& self) -> EMPTY_R { EMPTY_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& self) -> SYNCRDY_R { SYNCRDY_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Underrun Interrupt Enable"]
# [inline (always)]
pub fn underrun (& mut self) -> UNDERRUN_W { UNDERRUN_W :: new (self) } # [doc = "Bit 1 - Data Buffer Empty Interrupt Enable"]
# [inline (always)]
pub fn empty (& mut self) -> EMPTY_W { EMPTY_W :: new (self) } # [doc = "Bit 2 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& mut self) -> SYNCRDY_W { SYNCRDY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenclr](index.html) module"]
pub struct INTENCLR_SPEC ; impl crate :: RegisterSpec for INTENCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenclr::R](R) reader structure"]
impl crate :: Readable for INTENCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenclr::W](W) writer structure"]
impl crate :: Writable for INTENCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENCLR to value 0"]
impl crate :: Resettable for INTENCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENSET register accessor: an alias for `Reg<INTENSET_SPEC>`"]
pub type INTENSET = crate :: Reg < intenset :: INTENSET_SPEC > ; # [doc = "Interrupt Enable Set"]
pub mod intenset { # [doc = "Register `INTENSET` reader"]
pub struct R (crate :: R < INTENSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENSET` writer"]
pub struct W (crate :: W < INTENSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `UNDERRUN` reader - Underrun Interrupt Enable"]
pub type UNDERRUN_R = crate :: BitReader < bool > ; # [doc = "Field `UNDERRUN` writer - Underrun Interrupt Enable"]
pub type UNDERRUN_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 0 > ; # [doc = "Field `EMPTY` reader - Data Buffer Empty Interrupt Enable"]
pub type EMPTY_R = crate :: BitReader < bool > ; # [doc = "Field `EMPTY` writer - Data Buffer Empty Interrupt Enable"]
pub type EMPTY_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 1 > ; # [doc = "Field `SYNCRDY` reader - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCRDY` writer - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 2 > ; impl R { # [doc = "Bit 0 - Underrun Interrupt Enable"]
# [inline (always)]
pub fn underrun (& self) -> UNDERRUN_R { UNDERRUN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Data Buffer Empty Interrupt Enable"]
# [inline (always)]
pub fn empty (& self) -> EMPTY_R { EMPTY_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& self) -> SYNCRDY_R { SYNCRDY_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Underrun Interrupt Enable"]
# [inline (always)]
pub fn underrun (& mut self) -> UNDERRUN_W { UNDERRUN_W :: new (self) } # [doc = "Bit 1 - Data Buffer Empty Interrupt Enable"]
# [inline (always)]
pub fn empty (& mut self) -> EMPTY_W { EMPTY_W :: new (self) } # [doc = "Bit 2 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& mut self) -> SYNCRDY_W { SYNCRDY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenset](index.html) module"]
pub struct INTENSET_SPEC ; impl crate :: RegisterSpec for INTENSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenset::R](R) reader structure"]
impl crate :: Readable for INTENSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenset::W](W) writer structure"]
impl crate :: Writable for INTENSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENSET to value 0"]
impl crate :: Resettable for INTENSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTFLAG register accessor: an alias for `Reg<INTFLAG_SPEC>`"]
pub type INTFLAG = crate :: Reg < intflag :: INTFLAG_SPEC > ; # [doc = "Interrupt Flag Status and Clear"]
pub mod intflag { # [doc = "Register `INTFLAG` reader"]
pub struct R (crate :: R < INTFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAG` writer"]
pub struct W (crate :: W < INTFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `UNDERRUN` reader - Underrun"]
pub type UNDERRUN_R = crate :: BitReader < bool > ; # [doc = "Field `UNDERRUN` writer - Underrun"]
pub type UNDERRUN_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 0 > ; # [doc = "Field `EMPTY` reader - Data Buffer Empty"]
pub type EMPTY_R = crate :: BitReader < bool > ; # [doc = "Field `EMPTY` writer - Data Buffer Empty"]
pub type EMPTY_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 1 > ; # [doc = "Field `SYNCRDY` reader - Synchronization Ready"]
pub type SYNCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCRDY` writer - Synchronization Ready"]
pub type SYNCRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 2 > ; impl R { # [doc = "Bit 0 - Underrun"]
# [inline (always)]
pub fn underrun (& self) -> UNDERRUN_R { UNDERRUN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Data Buffer Empty"]
# [inline (always)]
pub fn empty (& self) -> EMPTY_R { EMPTY_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Synchronization Ready"]
# [inline (always)]
pub fn syncrdy (& self) -> SYNCRDY_R { SYNCRDY_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Underrun"]
# [inline (always)]
pub fn underrun (& mut self) -> UNDERRUN_W { UNDERRUN_W :: new (self) } # [doc = "Bit 1 - Data Buffer Empty"]
# [inline (always)]
pub fn empty (& mut self) -> EMPTY_W { EMPTY_W :: new (self) } # [doc = "Bit 2 - Synchronization Ready"]
# [inline (always)]
pub fn syncrdy (& mut self) -> SYNCRDY_W { SYNCRDY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflag](index.html) module"]
pub struct INTFLAG_SPEC ; impl crate :: RegisterSpec for INTFLAG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflag::R](R) reader structure"]
impl crate :: Readable for INTFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflag::W](W) writer structure"]
impl crate :: Writable for INTFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTFLAG to value 0"]
impl crate :: Resettable for INTFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATUS register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `SYNCBUSY` reader - Synchronization Busy Status"]
pub type SYNCBUSY_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 7 - Synchronization Busy Status"]
# [inline (always)]
pub fn syncbusy (& self) -> SYNCBUSY_R { SYNCBUSY_R :: new (((self . bits >> 7) & 1) != 0) } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DATA register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "Data"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } # [doc = "Field `DATA` reader - Data value to be converted"]
pub type DATA_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `DATA` writer - Data value to be converted"]
pub type DATA_W < 'a > = crate :: FieldWriter < 'a , u16 , DATA_SPEC , u16 , u16 , 16 , 0 > ; impl R { # [doc = "Bits 0:15 - Data value to be converted"]
# [inline (always)]
pub fn data (& self) -> DATA_R { DATA_R :: new (self . bits) } } impl W { # [doc = "Bits 0:15 - Data value to be converted"]
# [inline (always)]
pub fn data (& mut self) -> DATA_W { DATA_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DATABUF register accessor: an alias for `Reg<DATABUF_SPEC>`"]
pub type DATABUF = crate :: Reg < databuf :: DATABUF_SPEC > ; # [doc = "Data Buffer"]
pub mod databuf { # [doc = "Register `DATABUF` reader"]
pub struct R (crate :: R < DATABUF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATABUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATABUF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATABUF_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATABUF` writer"]
pub struct W (crate :: W < DATABUF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATABUF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATABUF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATABUF_SPEC >) -> Self { W (writer) } } # [doc = "Field `DATABUF` reader - Data Buffer"]
pub type DATABUF_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `DATABUF` writer - Data Buffer"]
pub type DATABUF_W < 'a > = crate :: FieldWriter < 'a , u16 , DATABUF_SPEC , u16 , u16 , 16 , 0 > ; impl R { # [doc = "Bits 0:15 - Data Buffer"]
# [inline (always)]
pub fn databuf (& self) -> DATABUF_R { DATABUF_R :: new (self . bits) } } impl W { # [doc = "Bits 0:15 - Data Buffer"]
# [inline (always)]
pub fn databuf (& mut self) -> DATABUF_W { DATABUF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [databuf](index.html) module"]
pub struct DATABUF_SPEC ; impl crate :: RegisterSpec for DATABUF_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [databuf::R](R) reader structure"]
impl crate :: Readable for DATABUF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [databuf::W](W) writer structure"]
impl crate :: Writable for DATABUF_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DATABUF to value 0"]
impl crate :: Resettable for DATABUF_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "Direct Memory Access Controller"]
pub struct DMAC { _marker : PhantomData < * const () > } unsafe impl Send for DMAC { } impl DMAC { # [doc = r"Pointer to the register block"]
pub const PTR : * const dmac :: RegisterBlock = 0x4100_4800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const dmac :: RegisterBlock { Self :: PTR } } impl Deref for DMAC { type Target = dmac :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for DMAC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("DMAC") . finish () } } # [doc = "Direct Memory Access Controller"]
pub mod dmac { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control"]
pub ctrl : crate :: Reg < ctrl :: CTRL_SPEC > , # [doc = "0x02 - CRC Control"]
pub crcctrl : crate :: Reg < crcctrl :: CRCCTRL_SPEC > , # [doc = "0x04 - CRC Data Input"]
pub crcdatain : crate :: Reg < crcdatain :: CRCDATAIN_SPEC > , # [doc = "0x08 - CRC Checksum"]
pub crcchksum : crate :: Reg < crcchksum :: CRCCHKSUM_SPEC > , # [doc = "0x0c - CRC Status"]
pub crcstatus : crate :: Reg < crcstatus :: CRCSTATUS_SPEC > , # [doc = "0x0d - Debug Control"]
pub dbgctrl : crate :: Reg < dbgctrl :: DBGCTRL_SPEC > , # [doc = "0x0e - QOS Control"]
pub qosctrl : crate :: Reg < qosctrl :: QOSCTRL_SPEC > , _reserved7 : [u8 ; 0x01]
, # [doc = "0x10 - Software Trigger Control"]
pub swtrigctrl : crate :: Reg < swtrigctrl :: SWTRIGCTRL_SPEC > , # [doc = "0x14 - Priority Control 0"]
pub prictrl0 : crate :: Reg < prictrl0 :: PRICTRL0_SPEC > , _reserved9 : [u8 ; 0x08]
, # [doc = "0x20 - Interrupt Pending"]
pub intpend : crate :: Reg < intpend :: INTPEND_SPEC > , _reserved10 : [u8 ; 0x02]
, # [doc = "0x24 - Interrupt Status"]
pub intstatus : crate :: Reg < intstatus :: INTSTATUS_SPEC > , # [doc = "0x28 - Busy Channels"]
pub busych : crate :: Reg < busych :: BUSYCH_SPEC > , # [doc = "0x2c - Pending Channels"]
pub pendch : crate :: Reg < pendch :: PENDCH_SPEC > , # [doc = "0x30 - Active Channel and Levels"]
pub active : crate :: Reg < active :: ACTIVE_SPEC > , # [doc = "0x34 - Descriptor Memory Section Base Address"]
pub baseaddr : crate :: Reg < baseaddr :: BASEADDR_SPEC > , # [doc = "0x38 - Write-Back Memory Section Base Address"]
pub wrbaddr : crate :: Reg < wrbaddr :: WRBADDR_SPEC > , _reserved16 : [u8 ; 0x03]
, # [doc = "0x3f - Channel ID"]
pub chid : crate :: Reg < chid :: CHID_SPEC > , # [doc = "0x40 - Channel Control A"]
pub chctrla : crate :: Reg < chctrla :: CHCTRLA_SPEC > , _reserved18 : [u8 ; 0x03]
, # [doc = "0x44 - Channel Control B"]
pub chctrlb : crate :: Reg < chctrlb :: CHCTRLB_SPEC > , _reserved19 : [u8 ; 0x04]
, # [doc = "0x4c - Channel Interrupt Enable Clear"]
pub chintenclr : crate :: Reg < chintenclr :: CHINTENCLR_SPEC > , # [doc = "0x4d - Channel Interrupt Enable Set"]
pub chintenset : crate :: Reg < chintenset :: CHINTENSET_SPEC > , # [doc = "0x4e - Channel Interrupt Flag Status and Clear"]
pub chintflag : crate :: Reg < chintflag :: CHINTFLAG_SPEC > , # [doc = "0x4f - Channel Status"]
pub chstatus : crate :: Reg < chstatus :: CHSTATUS_SPEC > , } # [doc = "CTRL register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWRST` reader - Software Reset"]
pub type SWRST_R = crate :: BitReader < bool > ; # [doc = "Field `SWRST` writer - Software Reset"]
pub type SWRST_W < 'a > = crate :: BitWriter < 'a , u16 , CTRL_SPEC , bool , 0 > ; # [doc = "Field `DMAENABLE` reader - DMA Enable"]
pub type DMAENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `DMAENABLE` writer - DMA Enable"]
pub type DMAENABLE_W < 'a > = crate :: BitWriter < 'a , u16 , CTRL_SPEC , bool , 1 > ; # [doc = "Field `CRCENABLE` reader - CRC Enable"]
pub type CRCENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `CRCENABLE` writer - CRC Enable"]
pub type CRCENABLE_W < 'a > = crate :: BitWriter < 'a , u16 , CTRL_SPEC , bool , 2 > ; # [doc = "Field `LVLEN0` reader - Priority Level 0 Enable"]
pub type LVLEN0_R = crate :: BitReader < bool > ; # [doc = "Field `LVLEN0` writer - Priority Level 0 Enable"]
pub type LVLEN0_W < 'a > = crate :: BitWriter < 'a , u16 , CTRL_SPEC , bool , 8 > ; # [doc = "Field `LVLEN1` reader - Priority Level 1 Enable"]
pub type LVLEN1_R = crate :: BitReader < bool > ; # [doc = "Field `LVLEN1` writer - Priority Level 1 Enable"]
pub type LVLEN1_W < 'a > = crate :: BitWriter < 'a , u16 , CTRL_SPEC , bool , 9 > ; # [doc = "Field `LVLEN2` reader - Priority Level 2 Enable"]
pub type LVLEN2_R = crate :: BitReader < bool > ; # [doc = "Field `LVLEN2` writer - Priority Level 2 Enable"]
pub type LVLEN2_W < 'a > = crate :: BitWriter < 'a , u16 , CTRL_SPEC , bool , 10 > ; # [doc = "Field `LVLEN3` reader - Priority Level 3 Enable"]
pub type LVLEN3_R = crate :: BitReader < bool > ; # [doc = "Field `LVLEN3` writer - Priority Level 3 Enable"]
pub type LVLEN3_W < 'a > = crate :: BitWriter < 'a , u16 , CTRL_SPEC , bool , 11 > ; impl R { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& self) -> SWRST_R { SWRST_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - DMA Enable"]
# [inline (always)]
pub fn dmaenable (& self) -> DMAENABLE_R { DMAENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - CRC Enable"]
# [inline (always)]
pub fn crcenable (& self) -> CRCENABLE_R { CRCENABLE_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 8 - Priority Level 0 Enable"]
# [inline (always)]
pub fn lvlen0 (& self) -> LVLEN0_R { LVLEN0_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Priority Level 1 Enable"]
# [inline (always)]
pub fn lvlen1 (& self) -> LVLEN1_R { LVLEN1_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Priority Level 2 Enable"]
# [inline (always)]
pub fn lvlen2 (& self) -> LVLEN2_R { LVLEN2_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Priority Level 3 Enable"]
# [inline (always)]
pub fn lvlen3 (& self) -> LVLEN3_R { LVLEN3_R :: new (((self . bits >> 11) & 1) != 0) } } impl W { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& mut self) -> SWRST_W { SWRST_W :: new (self) } # [doc = "Bit 1 - DMA Enable"]
# [inline (always)]
pub fn dmaenable (& mut self) -> DMAENABLE_W { DMAENABLE_W :: new (self) } # [doc = "Bit 2 - CRC Enable"]
# [inline (always)]
pub fn crcenable (& mut self) -> CRCENABLE_W { CRCENABLE_W :: new (self) } # [doc = "Bit 8 - Priority Level 0 Enable"]
# [inline (always)]
pub fn lvlen0 (& mut self) -> LVLEN0_W { LVLEN0_W :: new (self) } # [doc = "Bit 9 - Priority Level 1 Enable"]
# [inline (always)]
pub fn lvlen1 (& mut self) -> LVLEN1_W { LVLEN1_W :: new (self) } # [doc = "Bit 10 - Priority Level 2 Enable"]
# [inline (always)]
pub fn lvlen2 (& mut self) -> LVLEN2_W { LVLEN2_W :: new (self) } # [doc = "Bit 11 - Priority Level 3 Enable"]
# [inline (always)]
pub fn lvlen3 (& mut self) -> LVLEN3_W { LVLEN3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CRCCTRL register accessor: an alias for `Reg<CRCCTRL_SPEC>`"]
pub type CRCCTRL = crate :: Reg < crcctrl :: CRCCTRL_SPEC > ; # [doc = "CRC Control"]
pub mod crcctrl { # [doc = "Register `CRCCTRL` reader"]
pub struct R (crate :: R < CRCCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CRCCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CRCCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CRCCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CRCCTRL` writer"]
pub struct W (crate :: W < CRCCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CRCCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CRCCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CRCCTRL_SPEC >) -> Self { W (writer) } } # [doc = "CRC Beat Size\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CRCBEATSIZE_A { # [doc = "0: Byte bus access"]
BYTE = 0 , # [doc = "1: Half-word bus access"]
HWORD = 1 , # [doc = "2: Word bus access"]
WORD = 2 , } impl From < CRCBEATSIZE_A > for u8 { # [inline (always)]
fn from (variant : CRCBEATSIZE_A) -> Self { variant as _ } } # [doc = "Field `CRCBEATSIZE` reader - CRC Beat Size"]
pub type CRCBEATSIZE_R = crate :: FieldReader < u8 , CRCBEATSIZE_A > ; impl CRCBEATSIZE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CRCBEATSIZE_A > { match self . bits { 0 => Some (CRCBEATSIZE_A :: BYTE) , 1 => Some (CRCBEATSIZE_A :: HWORD) , 2 => Some (CRCBEATSIZE_A :: WORD) , _ => None , } } # [doc = "Checks if the value of the field is `BYTE`"]
# [inline (always)]
pub fn is_byte (& self) -> bool { * self == CRCBEATSIZE_A :: BYTE } # [doc = "Checks if the value of the field is `HWORD`"]
# [inline (always)]
pub fn is_hword (& self) -> bool { * self == CRCBEATSIZE_A :: HWORD } # [doc = "Checks if the value of the field is `WORD`"]
# [inline (always)]
pub fn is_word (& self) -> bool { * self == CRCBEATSIZE_A :: WORD } } # [doc = "Field `CRCBEATSIZE` writer - CRC Beat Size"]
pub type CRCBEATSIZE_W < 'a > = crate :: FieldWriter < 'a , u16 , CRCCTRL_SPEC , u8 , CRCBEATSIZE_A , 2 , 0 > ; impl < 'a > CRCBEATSIZE_W < 'a > { # [doc = "Byte bus access"]
# [inline (always)]
pub fn byte (self) -> & 'a mut W { self . variant (CRCBEATSIZE_A :: BYTE) } # [doc = "Half-word bus access"]
# [inline (always)]
pub fn hword (self) -> & 'a mut W { self . variant (CRCBEATSIZE_A :: HWORD) } # [doc = "Word bus access"]
# [inline (always)]
pub fn word (self) -> & 'a mut W { self . variant (CRCBEATSIZE_A :: WORD) } } # [doc = "CRC Polynomial Type\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CRCPOLY_A { # [doc = "0: CRC-16 (CRC-CCITT)"]
CRC16 = 0 , # [doc = "1: CRC32 (IEEE 802.3)"]
CRC32 = 1 , } impl From < CRCPOLY_A > for u8 { # [inline (always)]
fn from (variant : CRCPOLY_A) -> Self { variant as _ } } # [doc = "Field `CRCPOLY` reader - CRC Polynomial Type"]
pub type CRCPOLY_R = crate :: FieldReader < u8 , CRCPOLY_A > ; impl CRCPOLY_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CRCPOLY_A > { match self . bits { 0 => Some (CRCPOLY_A :: CRC16) , 1 => Some (CRCPOLY_A :: CRC32) , _ => None , } } # [doc = "Checks if the value of the field is `CRC16`"]
# [inline (always)]
pub fn is_crc16 (& self) -> bool { * self == CRCPOLY_A :: CRC16 } # [doc = "Checks if the value of the field is `CRC32`"]
# [inline (always)]
pub fn is_crc32 (& self) -> bool { * self == CRCPOLY_A :: CRC32 } } # [doc = "Field `CRCPOLY` writer - CRC Polynomial Type"]
pub type CRCPOLY_W < 'a > = crate :: FieldWriter < 'a , u16 , CRCCTRL_SPEC , u8 , CRCPOLY_A , 2 , 2 > ; impl < 'a > CRCPOLY_W < 'a > { # [doc = "CRC-16 (CRC-CCITT)"]
# [inline (always)]
pub fn crc16 (self) -> & 'a mut W { self . variant (CRCPOLY_A :: CRC16) } # [doc = "CRC32 (IEEE 802.3)"]
# [inline (always)]
pub fn crc32 (self) -> & 'a mut W { self . variant (CRCPOLY_A :: CRC32) } } # [doc = "CRC Input Source\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CRCSRC_A { # [doc = "0: No action"]
NOACT = 0 , # [doc = "1: I/O interface"]
IO = 1 , } impl From < CRCSRC_A > for u8 { # [inline (always)]
fn from (variant : CRCSRC_A) -> Self { variant as _ } } # [doc = "Field `CRCSRC` reader - CRC Input Source"]
pub type CRCSRC_R = crate :: FieldReader < u8 , CRCSRC_A > ; impl CRCSRC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CRCSRC_A > { match self . bits { 0 => Some (CRCSRC_A :: NOACT) , 1 => Some (CRCSRC_A :: IO) , _ => None , } } # [doc = "Checks if the value of the field is `NOACT`"]
# [inline (always)]
pub fn is_noact (& self) -> bool { * self == CRCSRC_A :: NOACT } # [doc = "Checks if the value of the field is `IO`"]
# [inline (always)]
pub fn is_io (& self) -> bool { * self == CRCSRC_A :: IO } } # [doc = "Field `CRCSRC` writer - CRC Input Source"]
pub type CRCSRC_W < 'a > = crate :: FieldWriter < 'a , u16 , CRCCTRL_SPEC , u8 , CRCSRC_A , 6 , 8 > ; impl < 'a > CRCSRC_W < 'a > { # [doc = "No action"]
# [inline (always)]
pub fn noact (self) -> & 'a mut W { self . variant (CRCSRC_A :: NOACT) } # [doc = "I/O interface"]
# [inline (always)]
pub fn io (self) -> & 'a mut W { self . variant (CRCSRC_A :: IO) } } impl R { # [doc = "Bits 0:1 - CRC Beat Size"]
# [inline (always)]
pub fn crcbeatsize (& self) -> CRCBEATSIZE_R { CRCBEATSIZE_R :: new ((self . bits & 3) as u8) } # [doc = "Bits 2:3 - CRC Polynomial Type"]
# [inline (always)]
pub fn crcpoly (& self) -> CRCPOLY_R { CRCPOLY_R :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bits 8:13 - CRC Input Source"]
# [inline (always)]
pub fn crcsrc (& self) -> CRCSRC_R { CRCSRC_R :: new (((self . bits >> 8) & 0x3f) as u8) } } impl W { # [doc = "Bits 0:1 - CRC Beat Size"]
# [inline (always)]
pub fn crcbeatsize (& mut self) -> CRCBEATSIZE_W { CRCBEATSIZE_W :: new (self) } # [doc = "Bits 2:3 - CRC Polynomial Type"]
# [inline (always)]
pub fn crcpoly (& mut self) -> CRCPOLY_W { CRCPOLY_W :: new (self) } # [doc = "Bits 8:13 - CRC Input Source"]
# [inline (always)]
pub fn crcsrc (& mut self) -> CRCSRC_W { CRCSRC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "CRC Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [crcctrl](index.html) module"]
pub struct CRCCTRL_SPEC ; impl crate :: RegisterSpec for CRCCTRL_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [crcctrl::R](R) reader structure"]
impl crate :: Readable for CRCCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [crcctrl::W](W) writer structure"]
impl crate :: Writable for CRCCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CRCCTRL to value 0"]
impl crate :: Resettable for CRCCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CRCDATAIN register accessor: an alias for `Reg<CRCDATAIN_SPEC>`"]
pub type CRCDATAIN = crate :: Reg < crcdatain :: CRCDATAIN_SPEC > ; # [doc = "CRC Data Input"]
pub mod crcdatain { # [doc = "Register `CRCDATAIN` reader"]
pub struct R (crate :: R < CRCDATAIN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CRCDATAIN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CRCDATAIN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CRCDATAIN_SPEC >) -> Self { R (reader) } } # [doc = "Register `CRCDATAIN` writer"]
pub struct W (crate :: W < CRCDATAIN_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CRCDATAIN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CRCDATAIN_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CRCDATAIN_SPEC >) -> Self { W (writer) } } # [doc = "Field `CRCDATAIN` reader - CRC Data Input"]
pub type CRCDATAIN_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `CRCDATAIN` writer - CRC Data Input"]
pub type CRCDATAIN_W < 'a > = crate :: FieldWriter < 'a , u32 , CRCDATAIN_SPEC , u32 , u32 , 32 , 0 > ; impl R { # [doc = "Bits 0:31 - CRC Data Input"]
# [inline (always)]
pub fn crcdatain (& self) -> CRCDATAIN_R { CRCDATAIN_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - CRC Data Input"]
# [inline (always)]
pub fn crcdatain (& mut self) -> CRCDATAIN_W { CRCDATAIN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "CRC Data Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [crcdatain](index.html) module"]
pub struct CRCDATAIN_SPEC ; impl crate :: RegisterSpec for CRCDATAIN_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [crcdatain::R](R) reader structure"]
impl crate :: Readable for CRCDATAIN_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [crcdatain::W](W) writer structure"]
impl crate :: Writable for CRCDATAIN_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CRCDATAIN to value 0"]
impl crate :: Resettable for CRCDATAIN_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CRCCHKSUM register accessor: an alias for `Reg<CRCCHKSUM_SPEC>`"]
pub type CRCCHKSUM = crate :: Reg < crcchksum :: CRCCHKSUM_SPEC > ; # [doc = "CRC Checksum"]
pub mod crcchksum { # [doc = "Register `CRCCHKSUM` reader"]
pub struct R (crate :: R < CRCCHKSUM_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CRCCHKSUM_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CRCCHKSUM_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CRCCHKSUM_SPEC >) -> Self { R (reader) } } # [doc = "Register `CRCCHKSUM` writer"]
pub struct W (crate :: W < CRCCHKSUM_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CRCCHKSUM_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CRCCHKSUM_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CRCCHKSUM_SPEC >) -> Self { W (writer) } } # [doc = "Field `CRCCHKSUM` reader - CRC Checksum"]
pub type CRCCHKSUM_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `CRCCHKSUM` writer - CRC Checksum"]
pub type CRCCHKSUM_W < 'a > = crate :: FieldWriter < 'a , u32 , CRCCHKSUM_SPEC , u32 , u32 , 32 , 0 > ; impl R { # [doc = "Bits 0:31 - CRC Checksum"]
# [inline (always)]
pub fn crcchksum (& self) -> CRCCHKSUM_R { CRCCHKSUM_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - CRC Checksum"]
# [inline (always)]
pub fn crcchksum (& mut self) -> CRCCHKSUM_W { CRCCHKSUM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "CRC Checksum\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [crcchksum](index.html) module"]
pub struct CRCCHKSUM_SPEC ; impl crate :: RegisterSpec for CRCCHKSUM_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [crcchksum::R](R) reader structure"]
impl crate :: Readable for CRCCHKSUM_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [crcchksum::W](W) writer structure"]
impl crate :: Writable for CRCCHKSUM_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CRCCHKSUM to value 0"]
impl crate :: Resettable for CRCCHKSUM_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CRCSTATUS register accessor: an alias for `Reg<CRCSTATUS_SPEC>`"]
pub type CRCSTATUS = crate :: Reg < crcstatus :: CRCSTATUS_SPEC > ; # [doc = "CRC Status"]
pub mod crcstatus { # [doc = "Register `CRCSTATUS` reader"]
pub struct R (crate :: R < CRCSTATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CRCSTATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CRCSTATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CRCSTATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `CRCSTATUS` writer"]
pub struct W (crate :: W < CRCSTATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CRCSTATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CRCSTATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CRCSTATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `CRCBUSY` reader - CRC Module Busy"]
pub type CRCBUSY_R = crate :: BitReader < bool > ; # [doc = "Field `CRCBUSY` writer - CRC Module Busy"]
pub type CRCBUSY_W < 'a > = crate :: BitWriter < 'a , u8 , CRCSTATUS_SPEC , bool , 0 > ; # [doc = "Field `CRCZERO` reader - CRC Zero"]
pub type CRCZERO_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - CRC Module Busy"]
# [inline (always)]
pub fn crcbusy (& self) -> CRCBUSY_R { CRCBUSY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - CRC Zero"]
# [inline (always)]
pub fn crczero (& self) -> CRCZERO_R { CRCZERO_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - CRC Module Busy"]
# [inline (always)]
pub fn crcbusy (& mut self) -> CRCBUSY_W { CRCBUSY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "CRC Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [crcstatus](index.html) module"]
pub struct CRCSTATUS_SPEC ; impl crate :: RegisterSpec for CRCSTATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [crcstatus::R](R) reader structure"]
impl crate :: Readable for CRCSTATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [crcstatus::W](W) writer structure"]
impl crate :: Writable for CRCSTATUS_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CRCSTATUS to value 0"]
impl crate :: Resettable for CRCSTATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DBGCTRL register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Debug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Debug Run"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Debug Run"]
pub type DBGRUN_W < 'a > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , 0 > ; impl R { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug Run"]
# [inline (always)]
pub fn dbgrun (& mut self) -> DBGRUN_W { DBGRUN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "QOSCTRL register accessor: an alias for `Reg<QOSCTRL_SPEC>`"]
pub type QOSCTRL = crate :: Reg < qosctrl :: QOSCTRL_SPEC > ; # [doc = "QOS Control"]
pub mod qosctrl { # [doc = "Register `QOSCTRL` reader"]
pub struct R (crate :: R < QOSCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < QOSCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < QOSCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < QOSCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `QOSCTRL` writer"]
pub struct W (crate :: W < QOSCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < QOSCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < QOSCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < QOSCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Write-Back Quality of Service\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum WRBQOS_A { # [doc = "0: Background (no sensitive operation)"]
DISABLE = 0 , # [doc = "1: Sensitive Bandwidth"]
LOW = 1 , # [doc = "2: Sensitive Latency"]
MEDIUM = 2 , # [doc = "3: Critical Latency"]
HIGH = 3 , } impl From < WRBQOS_A > for u8 { # [inline (always)]
fn from (variant : WRBQOS_A) -> Self { variant as _ } } # [doc = "Field `WRBQOS` reader - Write-Back Quality of Service"]
pub type WRBQOS_R = crate :: FieldReader < u8 , WRBQOS_A > ; impl WRBQOS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> WRBQOS_A { match self . bits { 0 => WRBQOS_A :: DISABLE , 1 => WRBQOS_A :: LOW , 2 => WRBQOS_A :: MEDIUM , 3 => WRBQOS_A :: HIGH , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DISABLE`"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == WRBQOS_A :: DISABLE } # [doc = "Checks if the value of the field is `LOW`"]
# [inline (always)]
pub fn is_low (& self) -> bool { * self == WRBQOS_A :: LOW } # [doc = "Checks if the value of the field is `MEDIUM`"]
# [inline (always)]
pub fn is_medium (& self) -> bool { * self == WRBQOS_A :: MEDIUM } # [doc = "Checks if the value of the field is `HIGH`"]
# [inline (always)]
pub fn is_high (& self) -> bool { * self == WRBQOS_A :: HIGH } } # [doc = "Field `WRBQOS` writer - Write-Back Quality of Service"]
pub type WRBQOS_W < 'a > = crate :: FieldWriterSafe < 'a , u8 , QOSCTRL_SPEC , u8 , WRBQOS_A , 2 , 0 > ; impl < 'a > WRBQOS_W < 'a > { # [doc = "Background (no sensitive operation)"]
# [inline (always)]
pub fn disable (self) -> & 'a mut W { self . variant (WRBQOS_A :: DISABLE) } # [doc = "Sensitive Bandwidth"]
# [inline (always)]
pub fn low (self) -> & 'a mut W { self . variant (WRBQOS_A :: LOW) } # [doc = "Sensitive Latency"]
# [inline (always)]
pub fn medium (self) -> & 'a mut W { self . variant (WRBQOS_A :: MEDIUM) } # [doc = "Critical Latency"]
# [inline (always)]
pub fn high (self) -> & 'a mut W { self . variant (WRBQOS_A :: HIGH) } } # [doc = "Fetch Quality of Service\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum FQOS_A { # [doc = "0: Background (no sensitive operation)"]
DISABLE = 0 , # [doc = "1: Sensitive Bandwidth"]
LOW = 1 , # [doc = "2: Sensitive Latency"]
MEDIUM = 2 , # [doc = "3: Critical Latency"]
HIGH = 3 , } impl From < FQOS_A > for u8 { # [inline (always)]
fn from (variant : FQOS_A) -> Self { variant as _ } } # [doc = "Field `FQOS` reader - Fetch Quality of Service"]
pub type FQOS_R = crate :: FieldReader < u8 , FQOS_A > ; impl FQOS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> FQOS_A { match self . bits { 0 => FQOS_A :: DISABLE , 1 => FQOS_A :: LOW , 2 => FQOS_A :: MEDIUM , 3 => FQOS_A :: HIGH , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DISABLE`"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == FQOS_A :: DISABLE } # [doc = "Checks if the value of the field is `LOW`"]
# [inline (always)]
pub fn is_low (& self) -> bool { * self == FQOS_A :: LOW } # [doc = "Checks if the value of the field is `MEDIUM`"]
# [inline (always)]
pub fn is_medium (& self) -> bool { * self == FQOS_A :: MEDIUM } # [doc = "Checks if the value of the field is `HIGH`"]
# [inline (always)]
pub fn is_high (& self) -> bool { * self == FQOS_A :: HIGH } } # [doc = "Field `FQOS` writer - Fetch Quality of Service"]
pub type FQOS_W < 'a > = crate :: FieldWriterSafe < 'a , u8 , QOSCTRL_SPEC , u8 , FQOS_A , 2 , 2 > ; impl < 'a > FQOS_W < 'a > { # [doc = "Background (no sensitive operation)"]
# [inline (always)]
pub fn disable (self) -> & 'a mut W { self . variant (FQOS_A :: DISABLE) } # [doc = "Sensitive Bandwidth"]
# [inline (always)]
pub fn low (self) -> & 'a mut W { self . variant (FQOS_A :: LOW) } # [doc = "Sensitive Latency"]
# [inline (always)]
pub fn medium (self) -> & 'a mut W { self . variant (FQOS_A :: MEDIUM) } # [doc = "Critical Latency"]
# [inline (always)]
pub fn high (self) -> & 'a mut W { self . variant (FQOS_A :: HIGH) } } # [doc = "Data Transfer Quality of Service\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum DQOS_A { # [doc = "0: Background (no sensitive operation)"]
DISABLE = 0 , # [doc = "1: Sensitive Bandwidth"]
LOW = 1 , # [doc = "2: Sensitive Latency"]
MEDIUM = 2 , # [doc = "3: Critical Latency"]
HIGH = 3 , } impl From < DQOS_A > for u8 { # [inline (always)]
fn from (variant : DQOS_A) -> Self { variant as _ } } # [doc = "Field `DQOS` reader - Data Transfer Quality of Service"]
pub type DQOS_R = crate :: FieldReader < u8 , DQOS_A > ; impl DQOS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DQOS_A { match self . bits { 0 => DQOS_A :: DISABLE , 1 => DQOS_A :: LOW , 2 => DQOS_A :: MEDIUM , 3 => DQOS_A :: HIGH , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DISABLE`"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == DQOS_A :: DISABLE } # [doc = "Checks if the value of the field is `LOW`"]
# [inline (always)]
pub fn is_low (& self) -> bool { * self == DQOS_A :: LOW } # [doc = "Checks if the value of the field is `MEDIUM`"]
# [inline (always)]
pub fn is_medium (& self) -> bool { * self == DQOS_A :: MEDIUM } # [doc = "Checks if the value of the field is `HIGH`"]
# [inline (always)]
pub fn is_high (& self) -> bool { * self == DQOS_A :: HIGH } } # [doc = "Field `DQOS` writer - Data Transfer Quality of Service"]
pub type DQOS_W < 'a > = crate :: FieldWriterSafe < 'a , u8 , QOSCTRL_SPEC , u8 , DQOS_A , 2 , 4 > ; impl < 'a > DQOS_W < 'a > { # [doc = "Background (no sensitive operation)"]
# [inline (always)]
pub fn disable (self) -> & 'a mut W { self . variant (DQOS_A :: DISABLE) } # [doc = "Sensitive Bandwidth"]
# [inline (always)]
pub fn low (self) -> & 'a mut W { self . variant (DQOS_A :: LOW) } # [doc = "Sensitive Latency"]
# [inline (always)]
pub fn medium (self) -> & 'a mut W { self . variant (DQOS_A :: MEDIUM) } # [doc = "Critical Latency"]
# [inline (always)]
pub fn high (self) -> & 'a mut W { self . variant (DQOS_A :: HIGH) } } impl R { # [doc = "Bits 0:1 - Write-Back Quality of Service"]
# [inline (always)]
pub fn wrbqos (& self) -> WRBQOS_R { WRBQOS_R :: new ((self . bits & 3) as u8) } # [doc = "Bits 2:3 - Fetch Quality of Service"]
# [inline (always)]
pub fn fqos (& self) -> FQOS_R { FQOS_R :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bits 4:5 - Data Transfer Quality of Service"]
# [inline (always)]
pub fn dqos (& self) -> DQOS_R { DQOS_R :: new (((self . bits >> 4) & 3) as u8) } } impl W { # [doc = "Bits 0:1 - Write-Back Quality of Service"]
# [inline (always)]
pub fn wrbqos (& mut self) -> WRBQOS_W { WRBQOS_W :: new (self) } # [doc = "Bits 2:3 - Fetch Quality of Service"]
# [inline (always)]
pub fn fqos (& mut self) -> FQOS_W { FQOS_W :: new (self) } # [doc = "Bits 4:5 - Data Transfer Quality of Service"]
# [inline (always)]
pub fn dqos (& mut self) -> DQOS_W { DQOS_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "QOS Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [qosctrl](index.html) module"]
pub struct QOSCTRL_SPEC ; impl crate :: RegisterSpec for QOSCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [qosctrl::R](R) reader structure"]
impl crate :: Readable for QOSCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [qosctrl::W](W) writer structure"]
impl crate :: Writable for QOSCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets QOSCTRL to value 0x15"]
impl crate :: Resettable for QOSCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x15 } } } # [doc = "SWTRIGCTRL register accessor: an alias for `Reg<SWTRIGCTRL_SPEC>`"]
pub type SWTRIGCTRL = crate :: Reg < swtrigctrl :: SWTRIGCTRL_SPEC > ; # [doc = "Software Trigger Control"]
pub mod swtrigctrl { # [doc = "Register `SWTRIGCTRL` reader"]
pub struct R (crate :: R < SWTRIGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SWTRIGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SWTRIGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SWTRIGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `SWTRIGCTRL` writer"]
pub struct W (crate :: W < SWTRIGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SWTRIGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SWTRIGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SWTRIGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWTRIG0` reader - Channel 0 Software Trigger"]
pub type SWTRIG0_R = crate :: BitReader < bool > ; # [doc = "Field `SWTRIG0` writer - Channel 0 Software Trigger"]
pub type SWTRIG0_W < 'a > = crate :: BitWriter < 'a , u32 , SWTRIGCTRL_SPEC , bool , 0 > ; # [doc = "Field `SWTRIG1` reader - Channel 1 Software Trigger"]
pub type SWTRIG1_R = crate :: BitReader < bool > ; # [doc = "Field `SWTRIG1` writer - Channel 1 Software Trigger"]
pub type SWTRIG1_W < 'a > = crate :: BitWriter < 'a , u32 , SWTRIGCTRL_SPEC , bool , 1 > ; # [doc = "Field `SWTRIG2` reader - Channel 2 Software Trigger"]
pub type SWTRIG2_R = crate :: BitReader < bool > ; # [doc = "Field `SWTRIG2` writer - Channel 2 Software Trigger"]
pub type SWTRIG2_W < 'a > = crate :: BitWriter < 'a , u32 , SWTRIGCTRL_SPEC , bool , 2 > ; # [doc = "Field `SWTRIG3` reader - Channel 3 Software Trigger"]
pub type SWTRIG3_R = crate :: BitReader < bool > ; # [doc = "Field `SWTRIG3` writer - Channel 3 Software Trigger"]
pub type SWTRIG3_W < 'a > = crate :: BitWriter < 'a , u32 , SWTRIGCTRL_SPEC , bool , 3 > ; # [doc = "Field `SWTRIG4` reader - Channel 4 Software Trigger"]
pub type SWTRIG4_R = crate :: BitReader < bool > ; # [doc = "Field `SWTRIG4` writer - Channel 4 Software Trigger"]
pub type SWTRIG4_W < 'a > = crate :: BitWriter < 'a , u32 , SWTRIGCTRL_SPEC , bool , 4 > ; # [doc = "Field `SWTRIG5` reader - Channel 5 Software Trigger"]
pub type SWTRIG5_R = crate :: BitReader < bool > ; # [doc = "Field `SWTRIG5` writer - Channel 5 Software Trigger"]
pub type SWTRIG5_W < 'a > = crate :: BitWriter < 'a , u32 , SWTRIGCTRL_SPEC , bool , 5 > ; # [doc = "Field `SWTRIG6` reader - Channel 6 Software Trigger"]
pub type SWTRIG6_R = crate :: BitReader < bool > ; # [doc = "Field `SWTRIG6` writer - Channel 6 Software Trigger"]
pub type SWTRIG6_W < 'a > = crate :: BitWriter < 'a , u32 , SWTRIGCTRL_SPEC , bool , 6 > ; # [doc = "Field `SWTRIG7` reader - Channel 7 Software Trigger"]
pub type SWTRIG7_R = crate :: BitReader < bool > ; # [doc = "Field `SWTRIG7` writer - Channel 7 Software Trigger"]
pub type SWTRIG7_W < 'a > = crate :: BitWriter < 'a , u32 , SWTRIGCTRL_SPEC , bool , 7 > ; # [doc = "Field `SWTRIG8` reader - Channel 8 Software Trigger"]
pub type SWTRIG8_R = crate :: BitReader < bool > ; # [doc = "Field `SWTRIG8` writer - Channel 8 Software Trigger"]
pub type SWTRIG8_W < 'a > = crate :: BitWriter < 'a , u32 , SWTRIGCTRL_SPEC , bool , 8 > ; # [doc = "Field `SWTRIG9` reader - Channel 9 Software Trigger"]
pub type SWTRIG9_R = crate :: BitReader < bool > ; # [doc = "Field `SWTRIG9` writer - Channel 9 Software Trigger"]
pub type SWTRIG9_W < 'a > = crate :: BitWriter < 'a , u32 , SWTRIGCTRL_SPEC , bool , 9 > ; # [doc = "Field `SWTRIG10` reader - Channel 10 Software Trigger"]
pub type SWTRIG10_R = crate :: BitReader < bool > ; # [doc = "Field `SWTRIG10` writer - Channel 10 Software Trigger"]
pub type SWTRIG10_W < 'a > = crate :: BitWriter < 'a , u32 , SWTRIGCTRL_SPEC , bool , 10 > ; # [doc = "Field `SWTRIG11` reader - Channel 11 Software Trigger"]
pub type SWTRIG11_R = crate :: BitReader < bool > ; # [doc = "Field `SWTRIG11` writer - Channel 11 Software Trigger"]
pub type SWTRIG11_W < 'a > = crate :: BitWriter < 'a , u32 , SWTRIGCTRL_SPEC , bool , 11 > ; impl R { # [doc = "Bit 0 - Channel 0 Software Trigger"]
# [inline (always)]
pub fn swtrig0 (& self) -> SWTRIG0_R { SWTRIG0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Channel 1 Software Trigger"]
# [inline (always)]
pub fn swtrig1 (& self) -> SWTRIG1_R { SWTRIG1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Channel 2 Software Trigger"]
# [inline (always)]
pub fn swtrig2 (& self) -> SWTRIG2_R { SWTRIG2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Channel 3 Software Trigger"]
# [inline (always)]
pub fn swtrig3 (& self) -> SWTRIG3_R { SWTRIG3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Channel 4 Software Trigger"]
# [inline (always)]
pub fn swtrig4 (& self) -> SWTRIG4_R { SWTRIG4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Channel 5 Software Trigger"]
# [inline (always)]
pub fn swtrig5 (& self) -> SWTRIG5_R { SWTRIG5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Channel 6 Software Trigger"]
# [inline (always)]
pub fn swtrig6 (& self) -> SWTRIG6_R { SWTRIG6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Channel 7 Software Trigger"]
# [inline (always)]
pub fn swtrig7 (& self) -> SWTRIG7_R { SWTRIG7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Channel 8 Software Trigger"]
# [inline (always)]
pub fn swtrig8 (& self) -> SWTRIG8_R { SWTRIG8_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Channel 9 Software Trigger"]
# [inline (always)]
pub fn swtrig9 (& self) -> SWTRIG9_R { SWTRIG9_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Channel 10 Software Trigger"]
# [inline (always)]
pub fn swtrig10 (& self) -> SWTRIG10_R { SWTRIG10_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Channel 11 Software Trigger"]
# [inline (always)]
pub fn swtrig11 (& self) -> SWTRIG11_R { SWTRIG11_R :: new (((self . bits >> 11) & 1) != 0) } } impl W { # [doc = "Bit 0 - Channel 0 Software Trigger"]
# [inline (always)]
pub fn swtrig0 (& mut self) -> SWTRIG0_W { SWTRIG0_W :: new (self) } # [doc = "Bit 1 - Channel 1 Software Trigger"]
# [inline (always)]
pub fn swtrig1 (& mut self) -> SWTRIG1_W { SWTRIG1_W :: new (self) } # [doc = "Bit 2 - Channel 2 Software Trigger"]
# [inline (always)]
pub fn swtrig2 (& mut self) -> SWTRIG2_W { SWTRIG2_W :: new (self) } # [doc = "Bit 3 - Channel 3 Software Trigger"]
# [inline (always)]
pub fn swtrig3 (& mut self) -> SWTRIG3_W { SWTRIG3_W :: new (self) } # [doc = "Bit 4 - Channel 4 Software Trigger"]
# [inline (always)]
pub fn swtrig4 (& mut self) -> SWTRIG4_W { SWTRIG4_W :: new (self) } # [doc = "Bit 5 - Channel 5 Software Trigger"]
# [inline (always)]
pub fn swtrig5 (& mut self) -> SWTRIG5_W { SWTRIG5_W :: new (self) } # [doc = "Bit 6 - Channel 6 Software Trigger"]
# [inline (always)]
pub fn swtrig6 (& mut self) -> SWTRIG6_W { SWTRIG6_W :: new (self) } # [doc = "Bit 7 - Channel 7 Software Trigger"]
# [inline (always)]
pub fn swtrig7 (& mut self) -> SWTRIG7_W { SWTRIG7_W :: new (self) } # [doc = "Bit 8 - Channel 8 Software Trigger"]
# [inline (always)]
pub fn swtrig8 (& mut self) -> SWTRIG8_W { SWTRIG8_W :: new (self) } # [doc = "Bit 9 - Channel 9 Software Trigger"]
# [inline (always)]
pub fn swtrig9 (& mut self) -> SWTRIG9_W { SWTRIG9_W :: new (self) } # [doc = "Bit 10 - Channel 10 Software Trigger"]
# [inline (always)]
pub fn swtrig10 (& mut self) -> SWTRIG10_W { SWTRIG10_W :: new (self) } # [doc = "Bit 11 - Channel 11 Software Trigger"]
# [inline (always)]
pub fn swtrig11 (& mut self) -> SWTRIG11_W { SWTRIG11_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Software Trigger Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [swtrigctrl](index.html) module"]
pub struct SWTRIGCTRL_SPEC ; impl crate :: RegisterSpec for SWTRIGCTRL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [swtrigctrl::R](R) reader structure"]
impl crate :: Readable for SWTRIGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [swtrigctrl::W](W) writer structure"]
impl crate :: Writable for SWTRIGCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SWTRIGCTRL to value 0"]
impl crate :: Resettable for SWTRIGCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PRICTRL0 register accessor: an alias for `Reg<PRICTRL0_SPEC>`"]
pub type PRICTRL0 = crate :: Reg < prictrl0 :: PRICTRL0_SPEC > ; # [doc = "Priority Control 0"]
pub mod prictrl0 { # [doc = "Register `PRICTRL0` reader"]
pub struct R (crate :: R < PRICTRL0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PRICTRL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PRICTRL0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PRICTRL0_SPEC >) -> Self { R (reader) } } # [doc = "Register `PRICTRL0` writer"]
pub struct W (crate :: W < PRICTRL0_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PRICTRL0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PRICTRL0_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PRICTRL0_SPEC >) -> Self { W (writer) } } # [doc = "Field `LVLPRI0` reader - Level 0 Channel Priority Number"]
pub type LVLPRI0_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `LVLPRI0` writer - Level 0 Channel Priority Number"]
pub type LVLPRI0_W < 'a > = crate :: FieldWriter < 'a , u32 , PRICTRL0_SPEC , u8 , u8 , 4 , 0 > ; # [doc = "Field `RRLVLEN0` reader - Level 0 Round-Robin Scheduling Enable"]
pub type RRLVLEN0_R = crate :: BitReader < bool > ; # [doc = "Field `RRLVLEN0` writer - Level 0 Round-Robin Scheduling Enable"]
pub type RRLVLEN0_W < 'a > = crate :: BitWriter < 'a , u32 , PRICTRL0_SPEC , bool , 7 > ; # [doc = "Field `LVLPRI1` reader - Level 1 Channel Priority Number"]
pub type LVLPRI1_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `LVLPRI1` writer - Level 1 Channel Priority Number"]
pub type LVLPRI1_W < 'a > = crate :: FieldWriter < 'a , u32 , PRICTRL0_SPEC , u8 , u8 , 4 , 8 > ; # [doc = "Field `RRLVLEN1` reader - Level 1 Round-Robin Scheduling Enable"]
pub type RRLVLEN1_R = crate :: BitReader < bool > ; # [doc = "Field `RRLVLEN1` writer - Level 1 Round-Robin Scheduling Enable"]
pub type RRLVLEN1_W < 'a > = crate :: BitWriter < 'a , u32 , PRICTRL0_SPEC , bool , 15 > ; # [doc = "Field `LVLPRI2` reader - Level 2 Channel Priority Number"]
pub type LVLPRI2_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `LVLPRI2` writer - Level 2 Channel Priority Number"]
pub type LVLPRI2_W < 'a > = crate :: FieldWriter < 'a , u32 , PRICTRL0_SPEC , u8 , u8 , 4 , 16 > ; # [doc = "Field `RRLVLEN2` reader - Level 2 Round-Robin Scheduling Enable"]
pub type RRLVLEN2_R = crate :: BitReader < bool > ; # [doc = "Field `RRLVLEN2` writer - Level 2 Round-Robin Scheduling Enable"]
pub type RRLVLEN2_W < 'a > = crate :: BitWriter < 'a , u32 , PRICTRL0_SPEC , bool , 23 > ; # [doc = "Field `LVLPRI3` reader - Level 3 Channel Priority Number"]
pub type LVLPRI3_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `LVLPRI3` writer - Level 3 Channel Priority Number"]
pub type LVLPRI3_W < 'a > = crate :: FieldWriter < 'a , u32 , PRICTRL0_SPEC , u8 , u8 , 4 , 24 > ; # [doc = "Field `RRLVLEN3` reader - Level 3 Round-Robin Scheduling Enable"]
pub type RRLVLEN3_R = crate :: BitReader < bool > ; # [doc = "Field `RRLVLEN3` writer - Level 3 Round-Robin Scheduling Enable"]
pub type RRLVLEN3_W < 'a > = crate :: BitWriter < 'a , u32 , PRICTRL0_SPEC , bool , 31 > ; impl R { # [doc = "Bits 0:3 - Level 0 Channel Priority Number"]
# [inline (always)]
pub fn lvlpri0 (& self) -> LVLPRI0_R { LVLPRI0_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bit 7 - Level 0 Round-Robin Scheduling Enable"]
# [inline (always)]
pub fn rrlvlen0 (& self) -> RRLVLEN0_R { RRLVLEN0_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bits 8:11 - Level 1 Channel Priority Number"]
# [inline (always)]
pub fn lvlpri1 (& self) -> LVLPRI1_R { LVLPRI1_R :: new (((self . bits >> 8) & 0x0f) as u8) } # [doc = "Bit 15 - Level 1 Round-Robin Scheduling Enable"]
# [inline (always)]
pub fn rrlvlen1 (& self) -> RRLVLEN1_R { RRLVLEN1_R :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bits 16:19 - Level 2 Channel Priority Number"]
# [inline (always)]
pub fn lvlpri2 (& self) -> LVLPRI2_R { LVLPRI2_R :: new (((self . bits >> 16) & 0x0f) as u8) } # [doc = "Bit 23 - Level 2 Round-Robin Scheduling Enable"]
# [inline (always)]
pub fn rrlvlen2 (& self) -> RRLVLEN2_R { RRLVLEN2_R :: new (((self . bits >> 23) & 1) != 0) } # [doc = "Bits 24:27 - Level 3 Channel Priority Number"]
# [inline (always)]
pub fn lvlpri3 (& self) -> LVLPRI3_R { LVLPRI3_R :: new (((self . bits >> 24) & 0x0f) as u8) } # [doc = "Bit 31 - Level 3 Round-Robin Scheduling Enable"]
# [inline (always)]
pub fn rrlvlen3 (& self) -> RRLVLEN3_R { RRLVLEN3_R :: new (((self . bits >> 31) & 1) != 0) } } impl W { # [doc = "Bits 0:3 - Level 0 Channel Priority Number"]
# [inline (always)]
pub fn lvlpri0 (& mut self) -> LVLPRI0_W { LVLPRI0_W :: new (self) } # [doc = "Bit 7 - Level 0 Round-Robin Scheduling Enable"]
# [inline (always)]
pub fn rrlvlen0 (& mut self) -> RRLVLEN0_W { RRLVLEN0_W :: new (self) } # [doc = "Bits 8:11 - Level 1 Channel Priority Number"]
# [inline (always)]
pub fn lvlpri1 (& mut self) -> LVLPRI1_W { LVLPRI1_W :: new (self) } # [doc = "Bit 15 - Level 1 Round-Robin Scheduling Enable"]
# [inline (always)]
pub fn rrlvlen1 (& mut self) -> RRLVLEN1_W { RRLVLEN1_W :: new (self) } # [doc = "Bits 16:19 - Level 2 Channel Priority Number"]
# [inline (always)]
pub fn lvlpri2 (& mut self) -> LVLPRI2_W { LVLPRI2_W :: new (self) } # [doc = "Bit 23 - Level 2 Round-Robin Scheduling Enable"]
# [inline (always)]
pub fn rrlvlen2 (& mut self) -> RRLVLEN2_W { RRLVLEN2_W :: new (self) } # [doc = "Bits 24:27 - Level 3 Channel Priority Number"]
# [inline (always)]
pub fn lvlpri3 (& mut self) -> LVLPRI3_W { LVLPRI3_W :: new (self) } # [doc = "Bit 31 - Level 3 Round-Robin Scheduling Enable"]
# [inline (always)]
pub fn rrlvlen3 (& mut self) -> RRLVLEN3_W { RRLVLEN3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Priority Control 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prictrl0](index.html) module"]
pub struct PRICTRL0_SPEC ; impl crate :: RegisterSpec for PRICTRL0_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [prictrl0::R](R) reader structure"]
impl crate :: Readable for PRICTRL0_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [prictrl0::W](W) writer structure"]
impl crate :: Writable for PRICTRL0_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PRICTRL0 to value 0"]
impl crate :: Resettable for PRICTRL0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTPEND register accessor: an alias for `Reg<INTPEND_SPEC>`"]
pub type INTPEND = crate :: Reg < intpend :: INTPEND_SPEC > ; # [doc = "Interrupt Pending"]
pub mod intpend { # [doc = "Register `INTPEND` reader"]
pub struct R (crate :: R < INTPEND_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTPEND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTPEND_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTPEND_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTPEND` writer"]
pub struct W (crate :: W < INTPEND_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTPEND_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTPEND_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTPEND_SPEC >) -> Self { W (writer) } } # [doc = "Field `ID` reader - Channel ID"]
pub type ID_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `ID` writer - Channel ID"]
pub type ID_W < 'a > = crate :: FieldWriter < 'a , u16 , INTPEND_SPEC , u8 , u8 , 4 , 0 > ; # [doc = "Field `TERR` reader - Transfer Error"]
pub type TERR_R = crate :: BitReader < bool > ; # [doc = "Field `TERR` writer - Transfer Error"]
pub type TERR_W < 'a > = crate :: BitWriter < 'a , u16 , INTPEND_SPEC , bool , 8 > ; # [doc = "Field `TCMPL` reader - Transfer Complete"]
pub type TCMPL_R = crate :: BitReader < bool > ; # [doc = "Field `TCMPL` writer - Transfer Complete"]
pub type TCMPL_W < 'a > = crate :: BitWriter < 'a , u16 , INTPEND_SPEC , bool , 9 > ; # [doc = "Field `SUSP` reader - Channel Suspend"]
pub type SUSP_R = crate :: BitReader < bool > ; # [doc = "Field `SUSP` writer - Channel Suspend"]
pub type SUSP_W < 'a > = crate :: BitWriter < 'a , u16 , INTPEND_SPEC , bool , 10 > ; # [doc = "Field `FERR` reader - Fetch Error"]
pub type FERR_R = crate :: BitReader < bool > ; # [doc = "Field `BUSY` reader - Busy"]
pub type BUSY_R = crate :: BitReader < bool > ; # [doc = "Field `PEND` reader - Pending"]
pub type PEND_R = crate :: BitReader < bool > ; impl R { # [doc = "Bits 0:3 - Channel ID"]
# [inline (always)]
pub fn id (& self) -> ID_R { ID_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bit 8 - Transfer Error"]
# [inline (always)]
pub fn terr (& self) -> TERR_R { TERR_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Transfer Complete"]
# [inline (always)]
pub fn tcmpl (& self) -> TCMPL_R { TCMPL_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Channel Suspend"]
# [inline (always)]
pub fn susp (& self) -> SUSP_R { SUSP_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 13 - Fetch Error"]
# [inline (always)]
pub fn ferr (& self) -> FERR_R { FERR_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Busy"]
# [inline (always)]
pub fn busy (& self) -> BUSY_R { BUSY_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Pending"]
# [inline (always)]
pub fn pend (& self) -> PEND_R { PEND_R :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bits 0:3 - Channel ID"]
# [inline (always)]
pub fn id (& mut self) -> ID_W { ID_W :: new (self) } # [doc = "Bit 8 - Transfer Error"]
# [inline (always)]
pub fn terr (& mut self) -> TERR_W { TERR_W :: new (self) } # [doc = "Bit 9 - Transfer Complete"]
# [inline (always)]
pub fn tcmpl (& mut self) -> TCMPL_W { TCMPL_W :: new (self) } # [doc = "Bit 10 - Channel Suspend"]
# [inline (always)]
pub fn susp (& mut self) -> SUSP_W { SUSP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Pending\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intpend](index.html) module"]
pub struct INTPEND_SPEC ; impl crate :: RegisterSpec for INTPEND_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [intpend::R](R) reader structure"]
impl crate :: Readable for INTPEND_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intpend::W](W) writer structure"]
impl crate :: Writable for INTPEND_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTPEND to value 0"]
impl crate :: Resettable for INTPEND_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTSTATUS register accessor: an alias for `Reg<INTSTATUS_SPEC>`"]
pub type INTSTATUS = crate :: Reg < intstatus :: INTSTATUS_SPEC > ; # [doc = "Interrupt Status"]
pub mod intstatus { # [doc = "Register `INTSTATUS` reader"]
pub struct R (crate :: R < INTSTATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTSTATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTSTATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTSTATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `CHINT0` reader - Channel 0 Pending Interrupt"]
pub type CHINT0_R = crate :: BitReader < bool > ; # [doc = "Field `CHINT1` reader - Channel 1 Pending Interrupt"]
pub type CHINT1_R = crate :: BitReader < bool > ; # [doc = "Field `CHINT2` reader - Channel 2 Pending Interrupt"]
pub type CHINT2_R = crate :: BitReader < bool > ; # [doc = "Field `CHINT3` reader - Channel 3 Pending Interrupt"]
pub type CHINT3_R = crate :: BitReader < bool > ; # [doc = "Field `CHINT4` reader - Channel 4 Pending Interrupt"]
pub type CHINT4_R = crate :: BitReader < bool > ; # [doc = "Field `CHINT5` reader - Channel 5 Pending Interrupt"]
pub type CHINT5_R = crate :: BitReader < bool > ; # [doc = "Field `CHINT6` reader - Channel 6 Pending Interrupt"]
pub type CHINT6_R = crate :: BitReader < bool > ; # [doc = "Field `CHINT7` reader - Channel 7 Pending Interrupt"]
pub type CHINT7_R = crate :: BitReader < bool > ; # [doc = "Field `CHINT8` reader - Channel 8 Pending Interrupt"]
pub type CHINT8_R = crate :: BitReader < bool > ; # [doc = "Field `CHINT9` reader - Channel 9 Pending Interrupt"]
pub type CHINT9_R = crate :: BitReader < bool > ; # [doc = "Field `CHINT10` reader - Channel 10 Pending Interrupt"]
pub type CHINT10_R = crate :: BitReader < bool > ; # [doc = "Field `CHINT11` reader - Channel 11 Pending Interrupt"]
pub type CHINT11_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Channel 0 Pending Interrupt"]
# [inline (always)]
pub fn chint0 (& self) -> CHINT0_R { CHINT0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Channel 1 Pending Interrupt"]
# [inline (always)]
pub fn chint1 (& self) -> CHINT1_R { CHINT1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Channel 2 Pending Interrupt"]
# [inline (always)]
pub fn chint2 (& self) -> CHINT2_R { CHINT2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Channel 3 Pending Interrupt"]
# [inline (always)]
pub fn chint3 (& self) -> CHINT3_R { CHINT3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Channel 4 Pending Interrupt"]
# [inline (always)]
pub fn chint4 (& self) -> CHINT4_R { CHINT4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Channel 5 Pending Interrupt"]
# [inline (always)]
pub fn chint5 (& self) -> CHINT5_R { CHINT5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Channel 6 Pending Interrupt"]
# [inline (always)]
pub fn chint6 (& self) -> CHINT6_R { CHINT6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Channel 7 Pending Interrupt"]
# [inline (always)]
pub fn chint7 (& self) -> CHINT7_R { CHINT7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Channel 8 Pending Interrupt"]
# [inline (always)]
pub fn chint8 (& self) -> CHINT8_R { CHINT8_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Channel 9 Pending Interrupt"]
# [inline (always)]
pub fn chint9 (& self) -> CHINT9_R { CHINT9_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Channel 10 Pending Interrupt"]
# [inline (always)]
pub fn chint10 (& self) -> CHINT10_R { CHINT10_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Channel 11 Pending Interrupt"]
# [inline (always)]
pub fn chint11 (& self) -> CHINT11_R { CHINT11_R :: new (((self . bits >> 11) & 1) != 0) } } # [doc = "Interrupt Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intstatus](index.html) module"]
pub struct INTSTATUS_SPEC ; impl crate :: RegisterSpec for INTSTATUS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [intstatus::R](R) reader structure"]
impl crate :: Readable for INTSTATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets INTSTATUS to value 0"]
impl crate :: Resettable for INTSTATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "BUSYCH register accessor: an alias for `Reg<BUSYCH_SPEC>`"]
pub type BUSYCH = crate :: Reg < busych :: BUSYCH_SPEC > ; # [doc = "Busy Channels"]
pub mod busych { # [doc = "Register `BUSYCH` reader"]
pub struct R (crate :: R < BUSYCH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BUSYCH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BUSYCH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BUSYCH_SPEC >) -> Self { R (reader) } } # [doc = "Field `BUSYCH0` reader - Busy Channel 0"]
pub type BUSYCH0_R = crate :: BitReader < bool > ; # [doc = "Field `BUSYCH1` reader - Busy Channel 1"]
pub type BUSYCH1_R = crate :: BitReader < bool > ; # [doc = "Field `BUSYCH2` reader - Busy Channel 2"]
pub type BUSYCH2_R = crate :: BitReader < bool > ; # [doc = "Field `BUSYCH3` reader - Busy Channel 3"]
pub type BUSYCH3_R = crate :: BitReader < bool > ; # [doc = "Field `BUSYCH4` reader - Busy Channel 4"]
pub type BUSYCH4_R = crate :: BitReader < bool > ; # [doc = "Field `BUSYCH5` reader - Busy Channel 5"]
pub type BUSYCH5_R = crate :: BitReader < bool > ; # [doc = "Field `BUSYCH6` reader - Busy Channel 6"]
pub type BUSYCH6_R = crate :: BitReader < bool > ; # [doc = "Field `BUSYCH7` reader - Busy Channel 7"]
pub type BUSYCH7_R = crate :: BitReader < bool > ; # [doc = "Field `BUSYCH8` reader - Busy Channel 8"]
pub type BUSYCH8_R = crate :: BitReader < bool > ; # [doc = "Field `BUSYCH9` reader - Busy Channel 9"]
pub type BUSYCH9_R = crate :: BitReader < bool > ; # [doc = "Field `BUSYCH10` reader - Busy Channel 10"]
pub type BUSYCH10_R = crate :: BitReader < bool > ; # [doc = "Field `BUSYCH11` reader - Busy Channel 11"]
pub type BUSYCH11_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Busy Channel 0"]
# [inline (always)]
pub fn busych0 (& self) -> BUSYCH0_R { BUSYCH0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Busy Channel 1"]
# [inline (always)]
pub fn busych1 (& self) -> BUSYCH1_R { BUSYCH1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Busy Channel 2"]
# [inline (always)]
pub fn busych2 (& self) -> BUSYCH2_R { BUSYCH2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Busy Channel 3"]
# [inline (always)]
pub fn busych3 (& self) -> BUSYCH3_R { BUSYCH3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Busy Channel 4"]
# [inline (always)]
pub fn busych4 (& self) -> BUSYCH4_R { BUSYCH4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Busy Channel 5"]
# [inline (always)]
pub fn busych5 (& self) -> BUSYCH5_R { BUSYCH5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Busy Channel 6"]
# [inline (always)]
pub fn busych6 (& self) -> BUSYCH6_R { BUSYCH6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Busy Channel 7"]
# [inline (always)]
pub fn busych7 (& self) -> BUSYCH7_R { BUSYCH7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Busy Channel 8"]
# [inline (always)]
pub fn busych8 (& self) -> BUSYCH8_R { BUSYCH8_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Busy Channel 9"]
# [inline (always)]
pub fn busych9 (& self) -> BUSYCH9_R { BUSYCH9_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Busy Channel 10"]
# [inline (always)]
pub fn busych10 (& self) -> BUSYCH10_R { BUSYCH10_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Busy Channel 11"]
# [inline (always)]
pub fn busych11 (& self) -> BUSYCH11_R { BUSYCH11_R :: new (((self . bits >> 11) & 1) != 0) } } # [doc = "Busy Channels\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [busych](index.html) module"]
pub struct BUSYCH_SPEC ; impl crate :: RegisterSpec for BUSYCH_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [busych::R](R) reader structure"]
impl crate :: Readable for BUSYCH_SPEC { type Reader = R ; } # [doc = "`reset()` method sets BUSYCH to value 0"]
impl crate :: Resettable for BUSYCH_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PENDCH register accessor: an alias for `Reg<PENDCH_SPEC>`"]
pub type PENDCH = crate :: Reg < pendch :: PENDCH_SPEC > ; # [doc = "Pending Channels"]
pub mod pendch { # [doc = "Register `PENDCH` reader"]
pub struct R (crate :: R < PENDCH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PENDCH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PENDCH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PENDCH_SPEC >) -> Self { R (reader) } } # [doc = "Field `PENDCH0` reader - Pending Channel 0"]
pub type PENDCH0_R = crate :: BitReader < bool > ; # [doc = "Field `PENDCH1` reader - Pending Channel 1"]
pub type PENDCH1_R = crate :: BitReader < bool > ; # [doc = "Field `PENDCH2` reader - Pending Channel 2"]
pub type PENDCH2_R = crate :: BitReader < bool > ; # [doc = "Field `PENDCH3` reader - Pending Channel 3"]
pub type PENDCH3_R = crate :: BitReader < bool > ; # [doc = "Field `PENDCH4` reader - Pending Channel 4"]
pub type PENDCH4_R = crate :: BitReader < bool > ; # [doc = "Field `PENDCH5` reader - Pending Channel 5"]
pub type PENDCH5_R = crate :: BitReader < bool > ; # [doc = "Field `PENDCH6` reader - Pending Channel 6"]
pub type PENDCH6_R = crate :: BitReader < bool > ; # [doc = "Field `PENDCH7` reader - Pending Channel 7"]
pub type PENDCH7_R = crate :: BitReader < bool > ; # [doc = "Field `PENDCH8` reader - Pending Channel 8"]
pub type PENDCH8_R = crate :: BitReader < bool > ; # [doc = "Field `PENDCH9` reader - Pending Channel 9"]
pub type PENDCH9_R = crate :: BitReader < bool > ; # [doc = "Field `PENDCH10` reader - Pending Channel 10"]
pub type PENDCH10_R = crate :: BitReader < bool > ; # [doc = "Field `PENDCH11` reader - Pending Channel 11"]
pub type PENDCH11_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Pending Channel 0"]
# [inline (always)]
pub fn pendch0 (& self) -> PENDCH0_R { PENDCH0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pending Channel 1"]
# [inline (always)]
pub fn pendch1 (& self) -> PENDCH1_R { PENDCH1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pending Channel 2"]
# [inline (always)]
pub fn pendch2 (& self) -> PENDCH2_R { PENDCH2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pending Channel 3"]
# [inline (always)]
pub fn pendch3 (& self) -> PENDCH3_R { PENDCH3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pending Channel 4"]
# [inline (always)]
pub fn pendch4 (& self) -> PENDCH4_R { PENDCH4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pending Channel 5"]
# [inline (always)]
pub fn pendch5 (& self) -> PENDCH5_R { PENDCH5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pending Channel 6"]
# [inline (always)]
pub fn pendch6 (& self) -> PENDCH6_R { PENDCH6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pending Channel 7"]
# [inline (always)]
pub fn pendch7 (& self) -> PENDCH7_R { PENDCH7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Pending Channel 8"]
# [inline (always)]
pub fn pendch8 (& self) -> PENDCH8_R { PENDCH8_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Pending Channel 9"]
# [inline (always)]
pub fn pendch9 (& self) -> PENDCH9_R { PENDCH9_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Pending Channel 10"]
# [inline (always)]
pub fn pendch10 (& self) -> PENDCH10_R { PENDCH10_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Pending Channel 11"]
# [inline (always)]
pub fn pendch11 (& self) -> PENDCH11_R { PENDCH11_R :: new (((self . bits >> 11) & 1) != 0) } } # [doc = "Pending Channels\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pendch](index.html) module"]
pub struct PENDCH_SPEC ; impl crate :: RegisterSpec for PENDCH_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [pendch::R](R) reader structure"]
impl crate :: Readable for PENDCH_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PENDCH to value 0"]
impl crate :: Resettable for PENDCH_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "ACTIVE register accessor: an alias for `Reg<ACTIVE_SPEC>`"]
pub type ACTIVE = crate :: Reg < active :: ACTIVE_SPEC > ; # [doc = "Active Channel and Levels"]
pub mod active { # [doc = "Register `ACTIVE` reader"]
pub struct R (crate :: R < ACTIVE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ACTIVE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ACTIVE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ACTIVE_SPEC >) -> Self { R (reader) } } # [doc = "Field `LVLEX0` reader - Level 0 Channel Trigger Request Executing"]
pub type LVLEX0_R = crate :: BitReader < bool > ; # [doc = "Field `LVLEX1` reader - Level 1 Channel Trigger Request Executing"]
pub type LVLEX1_R = crate :: BitReader < bool > ; # [doc = "Field `LVLEX2` reader - Level 2 Channel Trigger Request Executing"]
pub type LVLEX2_R = crate :: BitReader < bool > ; # [doc = "Field `LVLEX3` reader - Level 3 Channel Trigger Request Executing"]
pub type LVLEX3_R = crate :: BitReader < bool > ; # [doc = "Field `ID` reader - Active Channel ID"]
pub type ID_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `ABUSY` reader - Active Channel Busy"]
pub type ABUSY_R = crate :: BitReader < bool > ; # [doc = "Field `BTCNT` reader - Active Channel Block Transfer Count"]
pub type BTCNT_R = crate :: FieldReader < u16 , u16 > ; impl R { # [doc = "Bit 0 - Level 0 Channel Trigger Request Executing"]
# [inline (always)]
pub fn lvlex0 (& self) -> LVLEX0_R { LVLEX0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Level 1 Channel Trigger Request Executing"]
# [inline (always)]
pub fn lvlex1 (& self) -> LVLEX1_R { LVLEX1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Level 2 Channel Trigger Request Executing"]
# [inline (always)]
pub fn lvlex2 (& self) -> LVLEX2_R { LVLEX2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Level 3 Channel Trigger Request Executing"]
# [inline (always)]
pub fn lvlex3 (& self) -> LVLEX3_R { LVLEX3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 8:12 - Active Channel ID"]
# [inline (always)]
pub fn id (& self) -> ID_R { ID_R :: new (((self . bits >> 8) & 0x1f) as u8) } # [doc = "Bit 15 - Active Channel Busy"]
# [inline (always)]
pub fn abusy (& self) -> ABUSY_R { ABUSY_R :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bits 16:31 - Active Channel Block Transfer Count"]
# [inline (always)]
pub fn btcnt (& self) -> BTCNT_R { BTCNT_R :: new (((self . bits >> 16) & 0xffff) as u16) } } # [doc = "Active Channel and Levels\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [active](index.html) module"]
pub struct ACTIVE_SPEC ; impl crate :: RegisterSpec for ACTIVE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [active::R](R) reader structure"]
impl crate :: Readable for ACTIVE_SPEC { type Reader = R ; } # [doc = "`reset()` method sets ACTIVE to value 0"]
impl crate :: Resettable for ACTIVE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "BASEADDR register accessor: an alias for `Reg<BASEADDR_SPEC>`"]
pub type BASEADDR = crate :: Reg < baseaddr :: BASEADDR_SPEC > ; # [doc = "Descriptor Memory Section Base Address"]
pub mod baseaddr { # [doc = "Register `BASEADDR` reader"]
pub struct R (crate :: R < BASEADDR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BASEADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BASEADDR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BASEADDR_SPEC >) -> Self { R (reader) } } # [doc = "Register `BASEADDR` writer"]
pub struct W (crate :: W < BASEADDR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BASEADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BASEADDR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BASEADDR_SPEC >) -> Self { W (writer) } } # [doc = "Field `BASEADDR` reader - Descriptor Memory Base Address"]
pub type BASEADDR_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `BASEADDR` writer - Descriptor Memory Base Address"]
pub type BASEADDR_W < 'a > = crate :: FieldWriter < 'a , u32 , BASEADDR_SPEC , u32 , u32 , 32 , 0 > ; impl R { # [doc = "Bits 0:31 - Descriptor Memory Base Address"]
# [inline (always)]
pub fn baseaddr (& self) -> BASEADDR_R { BASEADDR_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Descriptor Memory Base Address"]
# [inline (always)]
pub fn baseaddr (& mut self) -> BASEADDR_W { BASEADDR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Descriptor Memory Section Base Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baseaddr](index.html) module"]
pub struct BASEADDR_SPEC ; impl crate :: RegisterSpec for BASEADDR_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [baseaddr::R](R) reader structure"]
impl crate :: Readable for BASEADDR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baseaddr::W](W) writer structure"]
impl crate :: Writable for BASEADDR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets BASEADDR to value 0"]
impl crate :: Resettable for BASEADDR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "WRBADDR register accessor: an alias for `Reg<WRBADDR_SPEC>`"]
pub type WRBADDR = crate :: Reg < wrbaddr :: WRBADDR_SPEC > ; # [doc = "Write-Back Memory Section Base Address"]
pub mod wrbaddr { # [doc = "Register `WRBADDR` reader"]
pub struct R (crate :: R < WRBADDR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < WRBADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < WRBADDR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < WRBADDR_SPEC >) -> Self { R (reader) } } # [doc = "Register `WRBADDR` writer"]
pub struct W (crate :: W < WRBADDR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < WRBADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < WRBADDR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < WRBADDR_SPEC >) -> Self { W (writer) } } # [doc = "Field `WRBADDR` reader - Write-Back Memory Base Address"]
pub type WRBADDR_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `WRBADDR` writer - Write-Back Memory Base Address"]
pub type WRBADDR_W < 'a > = crate :: FieldWriter < 'a , u32 , WRBADDR_SPEC , u32 , u32 , 32 , 0 > ; impl R { # [doc = "Bits 0:31 - Write-Back Memory Base Address"]
# [inline (always)]
pub fn wrbaddr (& self) -> WRBADDR_R { WRBADDR_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Write-Back Memory Base Address"]
# [inline (always)]
pub fn wrbaddr (& mut self) -> WRBADDR_W { WRBADDR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Write-Back Memory Section Base Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [wrbaddr](index.html) module"]
pub struct WRBADDR_SPEC ; impl crate :: RegisterSpec for WRBADDR_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [wrbaddr::R](R) reader structure"]
impl crate :: Readable for WRBADDR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [wrbaddr::W](W) writer structure"]
impl crate :: Writable for WRBADDR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets WRBADDR to value 0"]
impl crate :: Resettable for WRBADDR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CHID register accessor: an alias for `Reg<CHID_SPEC>`"]
pub type CHID = crate :: Reg < chid :: CHID_SPEC > ; # [doc = "Channel ID"]
pub mod chid { # [doc = "Register `CHID` reader"]
pub struct R (crate :: R < CHID_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CHID_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CHID_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CHID_SPEC >) -> Self { R (reader) } } # [doc = "Register `CHID` writer"]
pub struct W (crate :: W < CHID_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CHID_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CHID_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CHID_SPEC >) -> Self { W (writer) } } # [doc = "Field `ID` reader - Channel ID"]
pub type ID_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `ID` writer - Channel ID"]
pub type ID_W < 'a > = crate :: FieldWriter < 'a , u8 , CHID_SPEC , u8 , u8 , 4 , 0 > ; impl R { # [doc = "Bits 0:3 - Channel ID"]
# [inline (always)]
pub fn id (& self) -> ID_R { ID_R :: new ((self . bits & 0x0f) as u8) } } impl W { # [doc = "Bits 0:3 - Channel ID"]
# [inline (always)]
pub fn id (& mut self) -> ID_W { ID_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Channel ID\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [chid](index.html) module"]
pub struct CHID_SPEC ; impl crate :: RegisterSpec for CHID_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [chid::R](R) reader structure"]
impl crate :: Readable for CHID_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [chid::W](W) writer structure"]
impl crate :: Writable for CHID_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CHID to value 0"]
impl crate :: Resettable for CHID_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CHCTRLA register accessor: an alias for `Reg<CHCTRLA_SPEC>`"]
pub type CHCTRLA = crate :: Reg < chctrla :: CHCTRLA_SPEC > ; # [doc = "Channel Control A"]
pub mod chctrla { # [doc = "Register `CHCTRLA` reader"]
pub struct R (crate :: R < CHCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CHCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CHCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CHCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CHCTRLA` writer"]
pub struct W (crate :: W < CHCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CHCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CHCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CHCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWRST` reader - Channel Software Reset"]
pub type SWRST_R = crate :: BitReader < bool > ; # [doc = "Field `SWRST` writer - Channel Software Reset"]
pub type SWRST_W < 'a > = crate :: BitWriter < 'a , u8 , CHCTRLA_SPEC , bool , 0 > ; # [doc = "Field `ENABLE` reader - Channel Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Channel Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u8 , CHCTRLA_SPEC , bool , 1 > ; impl R { # [doc = "Bit 0 - Channel Software Reset"]
# [inline (always)]
pub fn swrst (& self) -> SWRST_R { SWRST_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Channel Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Channel Software Reset"]
# [inline (always)]
pub fn swrst (& mut self) -> SWRST_W { SWRST_W :: new (self) } # [doc = "Bit 1 - Channel Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Channel Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [chctrla](index.html) module"]
pub struct CHCTRLA_SPEC ; impl crate :: RegisterSpec for CHCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [chctrla::R](R) reader structure"]
impl crate :: Readable for CHCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [chctrla::W](W) writer structure"]
impl crate :: Writable for CHCTRLA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CHCTRLA to value 0"]
impl crate :: Resettable for CHCTRLA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CHCTRLB register accessor: an alias for `Reg<CHCTRLB_SPEC>`"]
pub type CHCTRLB = crate :: Reg < chctrlb :: CHCTRLB_SPEC > ; # [doc = "Channel Control B"]
pub mod chctrlb { # [doc = "Register `CHCTRLB` reader"]
pub struct R (crate :: R < CHCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CHCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CHCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CHCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CHCTRLB` writer"]
pub struct W (crate :: W < CHCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CHCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CHCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CHCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Event Input Action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum EVACT_A { # [doc = "0: No action"]
NOACT = 0 , # [doc = "1: Transfer and periodic transfer trigger"]
TRIG = 1 , # [doc = "2: Conditional transfer trigger"]
CTRIG = 2 , # [doc = "3: Conditional block transfer"]
CBLOCK = 3 , # [doc = "4: Channel suspend operation"]
SUSPEND = 4 , # [doc = "5: Channel resume operation"]
RESUME = 5 , # [doc = "6: Skip next block suspend action"]
SSKIP = 6 , } impl From < EVACT_A > for u8 { # [inline (always)]
fn from (variant : EVACT_A) -> Self { variant as _ } } # [doc = "Field `EVACT` reader - Event Input Action"]
pub type EVACT_R = crate :: FieldReader < u8 , EVACT_A > ; impl EVACT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < EVACT_A > { match self . bits { 0 => Some (EVACT_A :: NOACT) , 1 => Some (EVACT_A :: TRIG) , 2 => Some (EVACT_A :: CTRIG) , 3 => Some (EVACT_A :: CBLOCK) , 4 => Some (EVACT_A :: SUSPEND) , 5 => Some (EVACT_A :: RESUME) , 6 => Some (EVACT_A :: SSKIP) , _ => None , } } # [doc = "Checks if the value of the field is `NOACT`"]
# [inline (always)]
pub fn is_noact (& self) -> bool { * self == EVACT_A :: NOACT } # [doc = "Checks if the value of the field is `TRIG`"]
# [inline (always)]
pub fn is_trig (& self) -> bool { * self == EVACT_A :: TRIG } # [doc = "Checks if the value of the field is `CTRIG`"]
# [inline (always)]
pub fn is_ctrig (& self) -> bool { * self == EVACT_A :: CTRIG } # [doc = "Checks if the value of the field is `CBLOCK`"]
# [inline (always)]
pub fn is_cblock (& self) -> bool { * self == EVACT_A :: CBLOCK } # [doc = "Checks if the value of the field is `SUSPEND`"]
# [inline (always)]
pub fn is_suspend (& self) -> bool { * self == EVACT_A :: SUSPEND } # [doc = "Checks if the value of the field is `RESUME`"]
# [inline (always)]
pub fn is_resume (& self) -> bool { * self == EVACT_A :: RESUME } # [doc = "Checks if the value of the field is `SSKIP`"]
# [inline (always)]
pub fn is_sskip (& self) -> bool { * self == EVACT_A :: SSKIP } } # [doc = "Field `EVACT` writer - Event Input Action"]
pub type EVACT_W < 'a > = crate :: FieldWriter < 'a , u32 , CHCTRLB_SPEC , u8 , EVACT_A , 3 , 0 > ; impl < 'a > EVACT_W < 'a > { # [doc = "No action"]
# [inline (always)]
pub fn noact (self) -> & 'a mut W { self . variant (EVACT_A :: NOACT) } # [doc = "Transfer and periodic transfer trigger"]
# [inline (always)]
pub fn trig (self) -> & 'a mut W { self . variant (EVACT_A :: TRIG) } # [doc = "Conditional transfer trigger"]
# [inline (always)]
pub fn ctrig (self) -> & 'a mut W { self . variant (EVACT_A :: CTRIG) } # [doc = "Conditional block transfer"]
# [inline (always)]
pub fn cblock (self) -> & 'a mut W { self . variant (EVACT_A :: CBLOCK) } # [doc = "Channel suspend operation"]
# [inline (always)]
pub fn suspend (self) -> & 'a mut W { self . variant (EVACT_A :: SUSPEND) } # [doc = "Channel resume operation"]
# [inline (always)]
pub fn resume (self) -> & 'a mut W { self . variant (EVACT_A :: RESUME) } # [doc = "Skip next block suspend action"]
# [inline (always)]
pub fn sskip (self) -> & 'a mut W { self . variant (EVACT_A :: SSKIP) } } # [doc = "Field `EVIE` reader - Channel Event Input Enable"]
pub type EVIE_R = crate :: BitReader < bool > ; # [doc = "Field `EVIE` writer - Channel Event Input Enable"]
pub type EVIE_W < 'a > = crate :: BitWriter < 'a , u32 , CHCTRLB_SPEC , bool , 3 > ; # [doc = "Field `EVOE` reader - Channel Event Output Enable"]
pub type EVOE_R = crate :: BitReader < bool > ; # [doc = "Field `EVOE` writer - Channel Event Output Enable"]
pub type EVOE_W < 'a > = crate :: BitWriter < 'a , u32 , CHCTRLB_SPEC , bool , 4 > ; # [doc = "Channel Arbitration Level\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum LVL_A { # [doc = "0: Channel Priority Level 0"]
LVL0 = 0 , # [doc = "1: Channel Priority Level 1"]
LVL1 = 1 , # [doc = "2: Channel Priority Level 2"]
LVL2 = 2 , # [doc = "3: Channel Priority Level 3"]
LVL3 = 3 , } impl From < LVL_A > for u8 { # [inline (always)]
fn from (variant : LVL_A) -> Self { variant as _ } } # [doc = "Field `LVL` reader - Channel Arbitration Level"]
pub type LVL_R = crate :: FieldReader < u8 , LVL_A > ; impl LVL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> LVL_A { match self . bits { 0 => LVL_A :: LVL0 , 1 => LVL_A :: LVL1 , 2 => LVL_A :: LVL2 , 3 => LVL_A :: LVL3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `LVL0`"]
# [inline (always)]
pub fn is_lvl0 (& self) -> bool { * self == LVL_A :: LVL0 } # [doc = "Checks if the value of the field is `LVL1`"]
# [inline (always)]
pub fn is_lvl1 (& self) -> bool { * self == LVL_A :: LVL1 } # [doc = "Checks if the value of the field is `LVL2`"]
# [inline (always)]
pub fn is_lvl2 (& self) -> bool { * self == LVL_A :: LVL2 } # [doc = "Checks if the value of the field is `LVL3`"]
# [inline (always)]
pub fn is_lvl3 (& self) -> bool { * self == LVL_A :: LVL3 } } # [doc = "Field `LVL` writer - Channel Arbitration Level"]
pub type LVL_W < 'a > = crate :: FieldWriterSafe < 'a , u32 , CHCTRLB_SPEC , u8 , LVL_A , 2 , 5 > ; impl < 'a > LVL_W < 'a > { # [doc = "Channel Priority Level 0"]
# [inline (always)]
pub fn lvl0 (self) -> & 'a mut W { self . variant (LVL_A :: LVL0) } # [doc = "Channel Priority Level 1"]
# [inline (always)]
pub fn lvl1 (self) -> & 'a mut W { self . variant (LVL_A :: LVL1) } # [doc = "Channel Priority Level 2"]
# [inline (always)]
pub fn lvl2 (self) -> & 'a mut W { self . variant (LVL_A :: LVL2) } # [doc = "Channel Priority Level 3"]
# [inline (always)]
pub fn lvl3 (self) -> & 'a mut W { self . variant (LVL_A :: LVL3) } } # [doc = "Peripheral Trigger Source\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum TRIGSRC_A { # [doc = "0: Only software/event triggers"]
DISABLE = 0 , } impl From < TRIGSRC_A > for u8 { # [inline (always)]
fn from (variant : TRIGSRC_A) -> Self { variant as _ } } # [doc = "Field `TRIGSRC` reader - Peripheral Trigger Source"]
pub type TRIGSRC_R = crate :: FieldReader < u8 , TRIGSRC_A > ; impl TRIGSRC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < TRIGSRC_A > { match self . bits { 0 => Some (TRIGSRC_A :: DISABLE) , _ => None , } } # [doc = "Checks if the value of the field is `DISABLE`"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == TRIGSRC_A :: DISABLE } } # [doc = "Field `TRIGSRC` writer - Peripheral Trigger Source"]
pub type TRIGSRC_W < 'a > = crate :: FieldWriter < 'a , u32 , CHCTRLB_SPEC , u8 , TRIGSRC_A , 6 , 8 > ; impl < 'a > TRIGSRC_W < 'a > { # [doc = "Only software/event triggers"]
# [inline (always)]
pub fn disable (self) -> & 'a mut W { self . variant (TRIGSRC_A :: DISABLE) } } # [doc = "Trigger Action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum TRIGACT_A { # [doc = "0: One trigger required for each block transfer"]
BLOCK = 0 , # [doc = "2: One trigger required for each beat transfer"]
BEAT = 2 , # [doc = "3: One trigger required for each transaction"]
TRANSACTION = 3 , } impl From < TRIGACT_A > for u8 { # [inline (always)]
fn from (variant : TRIGACT_A) -> Self { variant as _ } } # [doc = "Field `TRIGACT` reader - Trigger Action"]
pub type TRIGACT_R = crate :: FieldReader < u8 , TRIGACT_A > ; impl TRIGACT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < TRIGACT_A > { match self . bits { 0 => Some (TRIGACT_A :: BLOCK) , 2 => Some (TRIGACT_A :: BEAT) , 3 => Some (TRIGACT_A :: TRANSACTION) , _ => None , } } # [doc = "Checks if the value of the field is `BLOCK`"]
# [inline (always)]
pub fn is_block (& self) -> bool { * self == TRIGACT_A :: BLOCK } # [doc = "Checks if the value of the field is `BEAT`"]
# [inline (always)]
pub fn is_beat (& self) -> bool { * self == TRIGACT_A :: BEAT } # [doc = "Checks if the value of the field is `TRANSACTION`"]
# [inline (always)]
pub fn is_transaction (& self) -> bool { * self == TRIGACT_A :: TRANSACTION } } # [doc = "Field `TRIGACT` writer - Trigger Action"]
pub type TRIGACT_W < 'a > = crate :: FieldWriter < 'a , u32 , CHCTRLB_SPEC , u8 , TRIGACT_A , 2 , 22 > ; impl < 'a > TRIGACT_W < 'a > { # [doc = "One trigger required for each block transfer"]
# [inline (always)]
pub fn block (self) -> & 'a mut W { self . variant (TRIGACT_A :: BLOCK) } # [doc = "One trigger required for each beat transfer"]
# [inline (always)]
pub fn beat (self) -> & 'a mut W { self . variant (TRIGACT_A :: BEAT) } # [doc = "One trigger required for each transaction"]
# [inline (always)]
pub fn transaction (self) -> & 'a mut W { self . variant (TRIGACT_A :: TRANSACTION) } } # [doc = "Software Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No action"]
NOACT = 0 , # [doc = "1: Channel suspend operation"]
SUSPEND = 1 , # [doc = "2: Channel resume operation"]
RESUME = 2 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } # [doc = "Field `CMD` reader - Software Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CMD_A > { match self . bits { 0 => Some (CMD_A :: NOACT) , 1 => Some (CMD_A :: SUSPEND) , 2 => Some (CMD_A :: RESUME) , _ => None , } } # [doc = "Checks if the value of the field is `NOACT`"]
# [inline (always)]
pub fn is_noact (& self) -> bool { * self == CMD_A :: NOACT } # [doc = "Checks if the value of the field is `SUSPEND`"]
# [inline (always)]
pub fn is_suspend (& self) -> bool { * self == CMD_A :: SUSPEND } # [doc = "Checks if the value of the field is `RESUME`"]
# [inline (always)]
pub fn is_resume (& self) -> bool { * self == CMD_A :: RESUME } } # [doc = "Field `CMD` writer - Software Command"]
pub type CMD_W < 'a > = crate :: FieldWriter < 'a , u32 , CHCTRLB_SPEC , u8 , CMD_A , 2 , 24 > ; impl < 'a > CMD_W < 'a > { # [doc = "No action"]
# [inline (always)]
pub fn noact (self) -> & 'a mut W { self . variant (CMD_A :: NOACT) } # [doc = "Channel suspend operation"]
# [inline (always)]
pub fn suspend (self) -> & 'a mut W { self . variant (CMD_A :: SUSPEND) } # [doc = "Channel resume operation"]
# [inline (always)]
pub fn resume (self) -> & 'a mut W { self . variant (CMD_A :: RESUME) } } impl R { # [doc = "Bits 0:2 - Event Input Action"]
# [inline (always)]
pub fn evact (& self) -> EVACT_R { EVACT_R :: new ((self . bits & 7) as u8) } # [doc = "Bit 3 - Channel Event Input Enable"]
# [inline (always)]
pub fn evie (& self) -> EVIE_R { EVIE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Channel Event Output Enable"]
# [inline (always)]
pub fn evoe (& self) -> EVOE_R { EVOE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:6 - Channel Arbitration Level"]
# [inline (always)]
pub fn lvl (& self) -> LVL_R { LVL_R :: new (((self . bits >> 5) & 3) as u8) } # [doc = "Bits 8:13 - Peripheral Trigger Source"]
# [inline (always)]
pub fn trigsrc (& self) -> TRIGSRC_R { TRIGSRC_R :: new (((self . bits >> 8) & 0x3f) as u8) } # [doc = "Bits 22:23 - Trigger Action"]
# [inline (always)]
pub fn trigact (& self) -> TRIGACT_R { TRIGACT_R :: new (((self . bits >> 22) & 3) as u8) } # [doc = "Bits 24:25 - Software Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new (((self . bits >> 24) & 3) as u8) } } impl W { # [doc = "Bits 0:2 - Event Input Action"]
# [inline (always)]
pub fn evact (& mut self) -> EVACT_W { EVACT_W :: new (self) } # [doc = "Bit 3 - Channel Event Input Enable"]
# [inline (always)]
pub fn evie (& mut self) -> EVIE_W { EVIE_W :: new (self) } # [doc = "Bit 4 - Channel Event Output Enable"]
# [inline (always)]
pub fn evoe (& mut self) -> EVOE_W { EVOE_W :: new (self) } # [doc = "Bits 5:6 - Channel Arbitration Level"]
# [inline (always)]
pub fn lvl (& mut self) -> LVL_W { LVL_W :: new (self) } # [doc = "Bits 8:13 - Peripheral Trigger Source"]
# [inline (always)]
pub fn trigsrc (& mut self) -> TRIGSRC_W { TRIGSRC_W :: new (self) } # [doc = "Bits 22:23 - Trigger Action"]
# [inline (always)]
pub fn trigact (& mut self) -> TRIGACT_W { TRIGACT_W :: new (self) } # [doc = "Bits 24:25 - Software Command"]
# [inline (always)]
pub fn cmd (& mut self) -> CMD_W { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Channel Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [chctrlb](index.html) module"]
pub struct CHCTRLB_SPEC ; impl crate :: RegisterSpec for CHCTRLB_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [chctrlb::R](R) reader structure"]
impl crate :: Readable for CHCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [chctrlb::W](W) writer structure"]
impl crate :: Writable for CHCTRLB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CHCTRLB to value 0"]
impl crate :: Resettable for CHCTRLB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CHINTENCLR register accessor: an alias for `Reg<CHINTENCLR_SPEC>`"]
pub type CHINTENCLR = crate :: Reg < chintenclr :: CHINTENCLR_SPEC > ; # [doc = "Channel Interrupt Enable Clear"]
pub mod chintenclr { # [doc = "Register `CHINTENCLR` reader"]
pub struct R (crate :: R < CHINTENCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CHINTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CHINTENCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CHINTENCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CHINTENCLR` writer"]
pub struct W (crate :: W < CHINTENCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CHINTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CHINTENCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CHINTENCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `TERR` reader - Transfer Error Interrupt Enable"]
pub type TERR_R = crate :: BitReader < bool > ; # [doc = "Field `TERR` writer - Transfer Error Interrupt Enable"]
pub type TERR_W < 'a > = crate :: BitWriter < 'a , u8 , CHINTENCLR_SPEC , bool , 0 > ; # [doc = "Field `TCMPL` reader - Transfer Complete Interrupt Enable"]
pub type TCMPL_R = crate :: BitReader < bool > ; # [doc = "Field `TCMPL` writer - Transfer Complete Interrupt Enable"]
pub type TCMPL_W < 'a > = crate :: BitWriter < 'a , u8 , CHINTENCLR_SPEC , bool , 1 > ; # [doc = "Field `SUSP` reader - Channel Suspend Interrupt Enable"]
pub type SUSP_R = crate :: BitReader < bool > ; # [doc = "Field `SUSP` writer - Channel Suspend Interrupt Enable"]
pub type SUSP_W < 'a > = crate :: BitWriter < 'a , u8 , CHINTENCLR_SPEC , bool , 2 > ; impl R { # [doc = "Bit 0 - Transfer Error Interrupt Enable"]
# [inline (always)]
pub fn terr (& self) -> TERR_R { TERR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Transfer Complete Interrupt Enable"]
# [inline (always)]
pub fn tcmpl (& self) -> TCMPL_R { TCMPL_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Channel Suspend Interrupt Enable"]
# [inline (always)]
pub fn susp (& self) -> SUSP_R { SUSP_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Transfer Error Interrupt Enable"]
# [inline (always)]
pub fn terr (& mut self) -> TERR_W { TERR_W :: new (self) } # [doc = "Bit 1 - Transfer Complete Interrupt Enable"]
# [inline (always)]
pub fn tcmpl (& mut self) -> TCMPL_W { TCMPL_W :: new (self) } # [doc = "Bit 2 - Channel Suspend Interrupt Enable"]
# [inline (always)]
pub fn susp (& mut self) -> SUSP_W { SUSP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Channel Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [chintenclr](index.html) module"]
pub struct CHINTENCLR_SPEC ; impl crate :: RegisterSpec for CHINTENCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [chintenclr::R](R) reader structure"]
impl crate :: Readable for CHINTENCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [chintenclr::W](W) writer structure"]
impl crate :: Writable for CHINTENCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CHINTENCLR to value 0"]
impl crate :: Resettable for CHINTENCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CHINTENSET register accessor: an alias for `Reg<CHINTENSET_SPEC>`"]
pub type CHINTENSET = crate :: Reg < chintenset :: CHINTENSET_SPEC > ; # [doc = "Channel Interrupt Enable Set"]
pub mod chintenset { # [doc = "Register `CHINTENSET` reader"]
pub struct R (crate :: R < CHINTENSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CHINTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CHINTENSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CHINTENSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CHINTENSET` writer"]
pub struct W (crate :: W < CHINTENSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CHINTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CHINTENSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CHINTENSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `TERR` reader - Transfer Error Interrupt Enable"]
pub type TERR_R = crate :: BitReader < bool > ; # [doc = "Field `TERR` writer - Transfer Error Interrupt Enable"]
pub type TERR_W < 'a > = crate :: BitWriter < 'a , u8 , CHINTENSET_SPEC , bool , 0 > ; # [doc = "Field `TCMPL` reader - Transfer Complete Interrupt Enable"]
pub type TCMPL_R = crate :: BitReader < bool > ; # [doc = "Field `TCMPL` writer - Transfer Complete Interrupt Enable"]
pub type TCMPL_W < 'a > = crate :: BitWriter < 'a , u8 , CHINTENSET_SPEC , bool , 1 > ; # [doc = "Field `SUSP` reader - Channel Suspend Interrupt Enable"]
pub type SUSP_R = crate :: BitReader < bool > ; # [doc = "Field `SUSP` writer - Channel Suspend Interrupt Enable"]
pub type SUSP_W < 'a > = crate :: BitWriter < 'a , u8 , CHINTENSET_SPEC , bool , 2 > ; impl R { # [doc = "Bit 0 - Transfer Error Interrupt Enable"]
# [inline (always)]
pub fn terr (& self) -> TERR_R { TERR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Transfer Complete Interrupt Enable"]
# [inline (always)]
pub fn tcmpl (& self) -> TCMPL_R { TCMPL_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Channel Suspend Interrupt Enable"]
# [inline (always)]
pub fn susp (& self) -> SUSP_R { SUSP_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Transfer Error Interrupt Enable"]
# [inline (always)]
pub fn terr (& mut self) -> TERR_W { TERR_W :: new (self) } # [doc = "Bit 1 - Transfer Complete Interrupt Enable"]
# [inline (always)]
pub fn tcmpl (& mut self) -> TCMPL_W { TCMPL_W :: new (self) } # [doc = "Bit 2 - Channel Suspend Interrupt Enable"]
# [inline (always)]
pub fn susp (& mut self) -> SUSP_W { SUSP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Channel Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [chintenset](index.html) module"]
pub struct CHINTENSET_SPEC ; impl crate :: RegisterSpec for CHINTENSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [chintenset::R](R) reader structure"]
impl crate :: Readable for CHINTENSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [chintenset::W](W) writer structure"]
impl crate :: Writable for CHINTENSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CHINTENSET to value 0"]
impl crate :: Resettable for CHINTENSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CHINTFLAG register accessor: an alias for `Reg<CHINTFLAG_SPEC>`"]
pub type CHINTFLAG = crate :: Reg < chintflag :: CHINTFLAG_SPEC > ; # [doc = "Channel Interrupt Flag Status and Clear"]
pub mod chintflag { # [doc = "Register `CHINTFLAG` reader"]
pub struct R (crate :: R < CHINTFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CHINTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CHINTFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CHINTFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `CHINTFLAG` writer"]
pub struct W (crate :: W < CHINTFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CHINTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CHINTFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CHINTFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `TERR` reader - Transfer Error"]
pub type TERR_R = crate :: BitReader < bool > ; # [doc = "Field `TERR` writer - Transfer Error"]
pub type TERR_W < 'a > = crate :: BitWriter < 'a , u8 , CHINTFLAG_SPEC , bool , 0 > ; # [doc = "Field `TCMPL` reader - Transfer Complete"]
pub type TCMPL_R = crate :: BitReader < bool > ; # [doc = "Field `TCMPL` writer - Transfer Complete"]
pub type TCMPL_W < 'a > = crate :: BitWriter < 'a , u8 , CHINTFLAG_SPEC , bool , 1 > ; # [doc = "Field `SUSP` reader - Channel Suspend"]
pub type SUSP_R = crate :: BitReader < bool > ; # [doc = "Field `SUSP` writer - Channel Suspend"]
pub type SUSP_W < 'a > = crate :: BitWriter < 'a , u8 , CHINTFLAG_SPEC , bool , 2 > ; impl R { # [doc = "Bit 0 - Transfer Error"]
# [inline (always)]
pub fn terr (& self) -> TERR_R { TERR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Transfer Complete"]
# [inline (always)]
pub fn tcmpl (& self) -> TCMPL_R { TCMPL_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Channel Suspend"]
# [inline (always)]
pub fn susp (& self) -> SUSP_R { SUSP_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Transfer Error"]
# [inline (always)]
pub fn terr (& mut self) -> TERR_W { TERR_W :: new (self) } # [doc = "Bit 1 - Transfer Complete"]
# [inline (always)]
pub fn tcmpl (& mut self) -> TCMPL_W { TCMPL_W :: new (self) } # [doc = "Bit 2 - Channel Suspend"]
# [inline (always)]
pub fn susp (& mut self) -> SUSP_W { SUSP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Channel Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [chintflag](index.html) module"]
pub struct CHINTFLAG_SPEC ; impl crate :: RegisterSpec for CHINTFLAG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [chintflag::R](R) reader structure"]
impl crate :: Readable for CHINTFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [chintflag::W](W) writer structure"]
impl crate :: Writable for CHINTFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CHINTFLAG to value 0"]
impl crate :: Resettable for CHINTFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CHSTATUS register accessor: an alias for `Reg<CHSTATUS_SPEC>`"]
pub type CHSTATUS = crate :: Reg < chstatus :: CHSTATUS_SPEC > ; # [doc = "Channel Status"]
pub mod chstatus { # [doc = "Register `CHSTATUS` reader"]
pub struct R (crate :: R < CHSTATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CHSTATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CHSTATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CHSTATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `PEND` reader - Channel Pending"]
pub type PEND_R = crate :: BitReader < bool > ; # [doc = "Field `BUSY` reader - Channel Busy"]
pub type BUSY_R = crate :: BitReader < bool > ; # [doc = "Field `FERR` reader - Fetch Error"]
pub type FERR_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Channel Pending"]
# [inline (always)]
pub fn pend (& self) -> PEND_R { PEND_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Channel Busy"]
# [inline (always)]
pub fn busy (& self) -> BUSY_R { BUSY_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Fetch Error"]
# [inline (always)]
pub fn ferr (& self) -> FERR_R { FERR_R :: new (((self . bits >> 2) & 1) != 0) } } # [doc = "Channel Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [chstatus](index.html) module"]
pub struct CHSTATUS_SPEC ; impl crate :: RegisterSpec for CHSTATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [chstatus::R](R) reader structure"]
impl crate :: Readable for CHSTATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets CHSTATUS to value 0"]
impl crate :: Resettable for CHSTATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "Device Service Unit"]
pub struct DSU { _marker : PhantomData < * const () > } unsafe impl Send for DSU { } impl DSU { # [doc = r"Pointer to the register block"]
pub const PTR : * const dsu :: RegisterBlock = 0x4100_2000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const dsu :: RegisterBlock { Self :: PTR } } impl Deref for DSU { type Target = dsu :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for DSU { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("DSU") . finish () } } # [doc = "Device Service Unit"]
pub mod dsu { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control"]
pub ctrl : crate :: Reg < ctrl :: CTRL_SPEC > , # [doc = "0x01 - Status A"]
pub statusa : crate :: Reg < statusa :: STATUSA_SPEC > , # [doc = "0x02 - Status B"]
pub statusb : crate :: Reg < statusb :: STATUSB_SPEC > , _reserved3 : [u8 ; 0x01]
, # [doc = "0x04 - Address"]
pub addr : crate :: Reg < addr :: ADDR_SPEC > , # [doc = "0x08 - Length"]
pub length : crate :: Reg < length :: LENGTH_SPEC > , # [doc = "0x0c - Data"]
pub data : crate :: Reg < data :: DATA_SPEC > , # [doc = "0x10..0x18 - Debug Communication Channel n"]
pub dcc : [crate :: Reg < dcc :: DCC_SPEC > ; 2]
, # [doc = "0x18 - Device Identification"]
pub did : crate :: Reg < did :: DID_SPEC > , _reserved8 : [u8 ; 0x0fe4]
, # [doc = "0x1000..0x1008 - Coresight ROM Table Entry n"]
pub entry : [crate :: Reg < entry :: ENTRY_SPEC > ; 2]
, # [doc = "0x1008 - Coresight ROM Table End"]
pub end : crate :: Reg < end :: END_SPEC > , _reserved10 : [u8 ; 0x0fc0]
, # [doc = "0x1fcc - Coresight ROM Table Memory Type"]
pub memtype : crate :: Reg < memtype :: MEMTYPE_SPEC > , # [doc = "0x1fd0 - Peripheral Identification 4"]
pub pid4 : crate :: Reg < pid4 :: PID4_SPEC > , _reserved12 : [u8 ; 0x0c]
, # [doc = "0x1fe0 - Peripheral Identification 0"]
pub pid0 : crate :: Reg < pid0 :: PID0_SPEC > , # [doc = "0x1fe4 - Peripheral Identification 1"]
pub pid1 : crate :: Reg < pid1 :: PID1_SPEC > , # [doc = "0x1fe8 - Peripheral Identification 2"]
pub pid2 : crate :: Reg < pid2 :: PID2_SPEC > , # [doc = "0x1fec - Peripheral Identification 3"]
pub pid3 : crate :: Reg < pid3 :: PID3_SPEC > , # [doc = "0x1ff0 - Component Identification 0"]
pub cid0 : crate :: Reg < cid0 :: CID0_SPEC > , # [doc = "0x1ff4 - Component Identification 1"]
pub cid1 : crate :: Reg < cid1 :: CID1_SPEC > , # [doc = "0x1ff8 - Component Identification 2"]
pub cid2 : crate :: Reg < cid2 :: CID2_SPEC > , # [doc = "0x1ffc - Component Identification 3"]
pub cid3 : crate :: Reg < cid3 :: CID3_SPEC > , } # [doc = "CTRL register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control"]
pub mod ctrl { # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWRST` writer - Software Reset"]
pub type SWRST_W < 'a > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , 0 > ; # [doc = "Field `CRC` writer - 32-bit Cyclic Redundancy Check"]
pub type CRC_W < 'a > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , 2 > ; # [doc = "Field `MBIST` writer - Memory Built-In Self-Test"]
pub type MBIST_W < 'a > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , 3 > ; # [doc = "Field `CE` writer - Chip Erase"]
pub type CE_W < 'a > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , 4 > ; impl W { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& mut self) -> SWRST_W { SWRST_W :: new (self) } # [doc = "Bit 2 - 32-bit Cyclic Redundancy Check"]
# [inline (always)]
pub fn crc (& mut self) -> CRC_W { CRC_W :: new (self) } # [doc = "Bit 3 - Memory Built-In Self-Test"]
# [inline (always)]
pub fn mbist (& mut self) -> MBIST_W { MBIST_W :: new (self) } # [doc = "Bit 4 - Chip Erase"]
# [inline (always)]
pub fn ce (& mut self) -> CE_W { CE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATUSA register accessor: an alias for `Reg<STATUSA_SPEC>`"]
pub type STATUSA = crate :: Reg < statusa :: STATUSA_SPEC > ; # [doc = "Status A"]
pub mod statusa { # [doc = "Register `STATUSA` reader"]
pub struct R (crate :: R < STATUSA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUSA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUSA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUSA_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUSA` writer"]
pub struct W (crate :: W < STATUSA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUSA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUSA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUSA_SPEC >) -> Self { W (writer) } } # [doc = "Field `DONE` reader - Done"]
pub type DONE_R = crate :: BitReader < bool > ; # [doc = "Field `DONE` writer - Done"]
pub type DONE_W < 'a > = crate :: BitWriter < 'a , u8 , STATUSA_SPEC , bool , 0 > ; # [doc = "Field `CRSTEXT` reader - CPU Reset Phase Extension"]
pub type CRSTEXT_R = crate :: BitReader < bool > ; # [doc = "Field `CRSTEXT` writer - CPU Reset Phase Extension"]
pub type CRSTEXT_W < 'a > = crate :: BitWriter < 'a , u8 , STATUSA_SPEC , bool , 1 > ; # [doc = "Field `BERR` reader - Bus Error"]
pub type BERR_R = crate :: BitReader < bool > ; # [doc = "Field `BERR` writer - Bus Error"]
pub type BERR_W < 'a > = crate :: BitWriter < 'a , u8 , STATUSA_SPEC , bool , 2 > ; # [doc = "Field `FAIL` reader - Failure"]
pub type FAIL_R = crate :: BitReader < bool > ; # [doc = "Field `FAIL` writer - Failure"]
pub type FAIL_W < 'a > = crate :: BitWriter < 'a , u8 , STATUSA_SPEC , bool , 3 > ; # [doc = "Field `PERR` reader - Protection Error"]
pub type PERR_R = crate :: BitReader < bool > ; # [doc = "Field `PERR` writer - Protection Error"]
pub type PERR_W < 'a > = crate :: BitWriter < 'a , u8 , STATUSA_SPEC , bool , 4 > ; impl R { # [doc = "Bit 0 - Done"]
# [inline (always)]
pub fn done (& self) -> DONE_R { DONE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - CPU Reset Phase Extension"]
# [inline (always)]
pub fn crstext (& self) -> CRSTEXT_R { CRSTEXT_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Bus Error"]
# [inline (always)]
pub fn berr (& self) -> BERR_R { BERR_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Failure"]
# [inline (always)]
pub fn fail (& self) -> FAIL_R { FAIL_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Protection Error"]
# [inline (always)]
pub fn perr (& self) -> PERR_R { PERR_R :: new (((self . bits >> 4) & 1) != 0) } } impl W { # [doc = "Bit 0 - Done"]
# [inline (always)]
pub fn done (& mut self) -> DONE_W { DONE_W :: new (self) } # [doc = "Bit 1 - CPU Reset Phase Extension"]
# [inline (always)]
pub fn crstext (& mut self) -> CRSTEXT_W { CRSTEXT_W :: new (self) } # [doc = "Bit 2 - Bus Error"]
# [inline (always)]
pub fn berr (& mut self) -> BERR_W { BERR_W :: new (self) } # [doc = "Bit 3 - Failure"]
# [inline (always)]
pub fn fail (& mut self) -> FAIL_W { FAIL_W :: new (self) } # [doc = "Bit 4 - Protection Error"]
# [inline (always)]
pub fn perr (& mut self) -> PERR_W { PERR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [statusa](index.html) module"]
pub struct STATUSA_SPEC ; impl crate :: RegisterSpec for STATUSA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [statusa::R](R) reader structure"]
impl crate :: Readable for STATUSA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [statusa::W](W) writer structure"]
impl crate :: Writable for STATUSA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets STATUSA to value 0"]
impl crate :: Resettable for STATUSA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATUSB register accessor: an alias for `Reg<STATUSB_SPEC>`"]
pub type STATUSB = crate :: Reg < statusb :: STATUSB_SPEC > ; # [doc = "Status B"]
pub mod statusb { # [doc = "Register `STATUSB` reader"]
pub struct R (crate :: R < STATUSB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUSB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUSB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUSB_SPEC >) -> Self { R (reader) } } # [doc = "Field `PROT` reader - Protected"]
pub type PROT_R = crate :: BitReader < bool > ; # [doc = "Field `DBGPRES` reader - Debugger Present"]
pub type DBGPRES_R = crate :: BitReader < bool > ; # [doc = "Field `DCCD0` reader - Debug Communication Channel 0 Dirty"]
pub type DCCD0_R = crate :: BitReader < bool > ; # [doc = "Field `DCCD1` reader - Debug Communication Channel 1 Dirty"]
pub type DCCD1_R = crate :: BitReader < bool > ; # [doc = "Field `HPE` reader - Hot-Plugging Enable"]
pub type HPE_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Protected"]
# [inline (always)]
pub fn prot (& self) -> PROT_R { PROT_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Debugger Present"]
# [inline (always)]
pub fn dbgpres (& self) -> DBGPRES_R { DBGPRES_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Debug Communication Channel 0 Dirty"]
# [inline (always)]
pub fn dccd0 (& self) -> DCCD0_R { DCCD0_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Debug Communication Channel 1 Dirty"]
# [inline (always)]
pub fn dccd1 (& self) -> DCCD1_R { DCCD1_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Hot-Plugging Enable"]
# [inline (always)]
pub fn hpe (& self) -> HPE_R { HPE_R :: new (((self . bits >> 4) & 1) != 0) } } # [doc = "Status B\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [statusb](index.html) module"]
pub struct STATUSB_SPEC ; impl crate :: RegisterSpec for STATUSB_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [statusb::R](R) reader structure"]
impl crate :: Readable for STATUSB_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATUSB to value 0x10"]
impl crate :: Resettable for STATUSB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x10 } } } # [doc = "ADDR register accessor: an alias for `Reg<ADDR_SPEC>`"]
pub type ADDR = crate :: Reg < addr :: ADDR_SPEC > ; # [doc = "Address"]
pub mod addr { # [doc = "Register `ADDR` reader"]
pub struct R (crate :: R < ADDR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADDR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADDR_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADDR` writer"]
pub struct W (crate :: W < ADDR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADDR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADDR_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADDR` reader - Address"]
pub type ADDR_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `ADDR` writer - Address"]
pub type ADDR_W < 'a > = crate :: FieldWriter < 'a , u32 , ADDR_SPEC , u32 , u32 , 30 , 2 > ; impl R { # [doc = "Bits 2:31 - Address"]
# [inline (always)]
pub fn addr (& self) -> ADDR_R { ADDR_R :: new (((self . bits >> 2) & 0x3fff_ffff) as u32) } } impl W { # [doc = "Bits 2:31 - Address"]
# [inline (always)]
pub fn addr (& mut self) -> ADDR_W { ADDR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [addr](index.html) module"]
pub struct ADDR_SPEC ; impl crate :: RegisterSpec for ADDR_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [addr::R](R) reader structure"]
impl crate :: Readable for ADDR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [addr::W](W) writer structure"]
impl crate :: Writable for ADDR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ADDR to value 0"]
impl crate :: Resettable for ADDR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "LENGTH register accessor: an alias for `Reg<LENGTH_SPEC>`"]
pub type LENGTH = crate :: Reg < length :: LENGTH_SPEC > ; # [doc = "Length"]
pub mod length { # [doc = "Register `LENGTH` reader"]
pub struct R (crate :: R < LENGTH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LENGTH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LENGTH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LENGTH_SPEC >) -> Self { R (reader) } } # [doc = "Register `LENGTH` writer"]
pub struct W (crate :: W < LENGTH_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LENGTH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LENGTH_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LENGTH_SPEC >) -> Self { W (writer) } } # [doc = "Field `LENGTH` reader - Length"]
pub type LENGTH_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `LENGTH` writer - Length"]
pub type LENGTH_W < 'a > = crate :: FieldWriter < 'a , u32 , LENGTH_SPEC , u32 , u32 , 30 , 2 > ; impl R { # [doc = "Bits 2:31 - Length"]
# [inline (always)]
pub fn length (& self) -> LENGTH_R { LENGTH_R :: new (((self . bits >> 2) & 0x3fff_ffff) as u32) } } impl W { # [doc = "Bits 2:31 - Length"]
# [inline (always)]
pub fn length (& mut self) -> LENGTH_W { LENGTH_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Length\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [length](index.html) module"]
pub struct LENGTH_SPEC ; impl crate :: RegisterSpec for LENGTH_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [length::R](R) reader structure"]
impl crate :: Readable for LENGTH_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [length::W](W) writer structure"]
impl crate :: Writable for LENGTH_SPEC { type Writer = W ; } # [doc = "`reset()` method sets LENGTH to value 0"]
impl crate :: Resettable for LENGTH_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DATA register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "Data"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } # [doc = "Field `DATA` reader - Data"]
pub type DATA_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `DATA` writer - Data"]
pub type DATA_W < 'a > = crate :: FieldWriter < 'a , u32 , DATA_SPEC , u32 , u32 , 32 , 0 > ; impl R { # [doc = "Bits 0:31 - Data"]
# [inline (always)]
pub fn data (& self) -> DATA_R { DATA_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Data"]
# [inline (always)]
pub fn data (& mut self) -> DATA_W { DATA_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DCC register accessor: an alias for `Reg<DCC_SPEC>`"]
pub type DCC = crate :: Reg < dcc :: DCC_SPEC > ; # [doc = "Debug Communication Channel n"]
pub mod dcc { # [doc = "Register `DCC%s` reader"]
pub struct R (crate :: R < DCC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DCC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DCC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DCC_SPEC >) -> Self { R (reader) } } # [doc = "Register `DCC%s` writer"]
pub struct W (crate :: W < DCC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DCC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DCC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DCC_SPEC >) -> Self { W (writer) } } # [doc = "Field `DATA` reader - Data"]
pub type DATA_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `DATA` writer - Data"]
pub type DATA_W < 'a > = crate :: FieldWriter < 'a , u32 , DCC_SPEC , u32 , u32 , 32 , 0 > ; impl R { # [doc = "Bits 0:31 - Data"]
# [inline (always)]
pub fn data (& self) -> DATA_R { DATA_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Data"]
# [inline (always)]
pub fn data (& mut self) -> DATA_W { DATA_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug Communication Channel n\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dcc](index.html) module"]
pub struct DCC_SPEC ; impl crate :: RegisterSpec for DCC_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [dcc::R](R) reader structure"]
impl crate :: Readable for DCC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dcc::W](W) writer structure"]
impl crate :: Writable for DCC_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DCC%s to value 0"]
impl crate :: Resettable for DCC_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DID register accessor: an alias for `Reg<DID_SPEC>`"]
pub type DID = crate :: Reg < did :: DID_SPEC > ; # [doc = "Device Identification"]
pub mod did { # [doc = "Register `DID` reader"]
pub struct R (crate :: R < DID_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DID_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DID_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DID_SPEC >) -> Self { R (reader) } } # [doc = "Field `DEVSEL` reader - Device Select"]
pub type DEVSEL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `REVISION` reader - Revision"]
pub type REVISION_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DIE` reader - Die Identification"]
pub type DIE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SERIES` reader - Product Series"]
pub type SERIES_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `FAMILY` reader - Product Family"]
pub type FAMILY_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `PROCESSOR` reader - Processor"]
pub type PROCESSOR_R = crate :: FieldReader < u8 , u8 > ; impl R { # [doc = "Bits 0:7 - Device Select"]
# [inline (always)]
pub fn devsel (& self) -> DEVSEL_R { DEVSEL_R :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:11 - Revision"]
# [inline (always)]
pub fn revision (& self) -> REVISION_R { REVISION_R :: new (((self . bits >> 8) & 0x0f) as u8) } # [doc = "Bits 12:15 - Die Identification"]
# [inline (always)]
pub fn die (& self) -> DIE_R { DIE_R :: new (((self . bits >> 12) & 0x0f) as u8) } # [doc = "Bits 16:21 - Product Series"]
# [inline (always)]
pub fn series (& self) -> SERIES_R { SERIES_R :: new (((self . bits >> 16) & 0x3f) as u8) } # [doc = "Bits 23:27 - Product Family"]
# [inline (always)]
pub fn family (& self) -> FAMILY_R { FAMILY_R :: new (((self . bits >> 23) & 0x1f) as u8) } # [doc = "Bits 28:31 - Processor"]
# [inline (always)]
pub fn processor (& self) -> PROCESSOR_R { PROCESSOR_R :: new (((self . bits >> 28) & 0x0f) as u8) } } # [doc = "Device Identification\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [did](index.html) module"]
pub struct DID_SPEC ; impl crate :: RegisterSpec for DID_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [did::R](R) reader structure"]
impl crate :: Readable for DID_SPEC { type Reader = R ; } # [doc = "`reset()` method sets DID to value 0x1001_156c"]
impl crate :: Resettable for DID_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x1001_156c } } } # [doc = "ENTRY register accessor: an alias for `Reg<ENTRY_SPEC>`"]
pub type ENTRY = crate :: Reg < entry :: ENTRY_SPEC > ; # [doc = "Coresight ROM Table Entry n"]
pub mod entry { # [doc = "Register `ENTRY%s` reader"]
pub struct R (crate :: R < ENTRY_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ENTRY_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ENTRY_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ENTRY_SPEC >) -> Self { R (reader) } } # [doc = "Field `EPRES` reader - Entry Present"]
pub type EPRES_R = crate :: BitReader < bool > ; # [doc = "Field `FMT` reader - Format"]
pub type FMT_R = crate :: BitReader < bool > ; # [doc = "Field `ADDOFF` reader - Address Offset"]
pub type ADDOFF_R = crate :: FieldReader < u32 , u32 > ; impl R { # [doc = "Bit 0 - Entry Present"]
# [inline (always)]
pub fn epres (& self) -> EPRES_R { EPRES_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Format"]
# [inline (always)]
pub fn fmt (& self) -> FMT_R { FMT_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 12:31 - Address Offset"]
# [inline (always)]
pub fn addoff (& self) -> ADDOFF_R { ADDOFF_R :: new (((self . bits >> 12) & 0x000f_ffff) as u32) } } # [doc = "Coresight ROM Table Entry n\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [entry](index.html) module"]
pub struct ENTRY_SPEC ; impl crate :: RegisterSpec for ENTRY_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [entry::R](R) reader structure"]
impl crate :: Readable for ENTRY_SPEC { type Reader = R ; } # [doc = "`reset()` method sets ENTRY%s to value 0x02"]
impl crate :: Resettable for ENTRY_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x02 } } } # [doc = "END register accessor: an alias for `Reg<END_SPEC>`"]
pub type END = crate :: Reg < end :: END_SPEC > ; # [doc = "Coresight ROM Table End"]
pub mod end { # [doc = "Register `END` reader"]
pub struct R (crate :: R < END_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < END_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < END_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < END_SPEC >) -> Self { R (reader) } } # [doc = "Field `END` reader - End Marker"]
pub type END_R = crate :: FieldReader < u32 , u32 > ; impl R { # [doc = "Bits 0:31 - End Marker"]
# [inline (always)]
pub fn end (& self) -> END_R { END_R :: new (self . bits) } } # [doc = "Coresight ROM Table End\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [end](index.html) module"]
pub struct END_SPEC ; impl crate :: RegisterSpec for END_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [end::R](R) reader structure"]
impl crate :: Readable for END_SPEC { type Reader = R ; } # [doc = "`reset()` method sets END to value 0"]
impl crate :: Resettable for END_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "MEMTYPE register accessor: an alias for `Reg<MEMTYPE_SPEC>`"]
pub type MEMTYPE = crate :: Reg < memtype :: MEMTYPE_SPEC > ; # [doc = "Coresight ROM Table Memory Type"]
pub mod memtype { # [doc = "Register `MEMTYPE` reader"]
pub struct R (crate :: R < MEMTYPE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MEMTYPE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MEMTYPE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MEMTYPE_SPEC >) -> Self { R (reader) } } # [doc = "Field `SMEMP` reader - System Memory Present"]
pub type SMEMP_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - System Memory Present"]
# [inline (always)]
pub fn smemp (& self) -> SMEMP_R { SMEMP_R :: new ((self . bits & 1) != 0) } } # [doc = "Coresight ROM Table Memory Type\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [memtype](index.html) module"]
pub struct MEMTYPE_SPEC ; impl crate :: RegisterSpec for MEMTYPE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [memtype::R](R) reader structure"]
impl crate :: Readable for MEMTYPE_SPEC { type Reader = R ; } # [doc = "`reset()` method sets MEMTYPE to value 0"]
impl crate :: Resettable for MEMTYPE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PID4 register accessor: an alias for `Reg<PID4_SPEC>`"]
pub type PID4 = crate :: Reg < pid4 :: PID4_SPEC > ; # [doc = "Peripheral Identification 4"]
pub mod pid4 { # [doc = "Register `PID4` reader"]
pub struct R (crate :: R < PID4_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PID4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PID4_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PID4_SPEC >) -> Self { R (reader) } } # [doc = "Field `JEPCC` reader - JEP-106 Continuation Code"]
pub type JEPCC_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `FKBC` reader - 4KB Count"]
pub type FKBC_R = crate :: FieldReader < u8 , u8 > ; impl R { # [doc = "Bits 0:3 - JEP-106 Continuation Code"]
# [inline (always)]
pub fn jepcc (& self) -> JEPCC_R { JEPCC_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bits 4:7 - 4KB Count"]
# [inline (always)]
pub fn fkbc (& self) -> FKBC_R { FKBC_R :: new (((self . bits >> 4) & 0x0f) as u8) } } # [doc = "Peripheral Identification 4\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pid4](index.html) module"]
pub struct PID4_SPEC ; impl crate :: RegisterSpec for PID4_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [pid4::R](R) reader structure"]
impl crate :: Readable for PID4_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PID4 to value 0"]
impl crate :: Resettable for PID4_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PID0 register accessor: an alias for `Reg<PID0_SPEC>`"]
pub type PID0 = crate :: Reg < pid0 :: PID0_SPEC > ; # [doc = "Peripheral Identification 0"]
pub mod pid0 { # [doc = "Register `PID0` reader"]
pub struct R (crate :: R < PID0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PID0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PID0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PID0_SPEC >) -> Self { R (reader) } } # [doc = "Field `PARTNBL` reader - Part Number Low"]
pub type PARTNBL_R = crate :: FieldReader < u8 , u8 > ; impl R { # [doc = "Bits 0:7 - Part Number Low"]
# [inline (always)]
pub fn partnbl (& self) -> PARTNBL_R { PARTNBL_R :: new ((self . bits & 0xff) as u8) } } # [doc = "Peripheral Identification 0\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pid0](index.html) module"]
pub struct PID0_SPEC ; impl crate :: RegisterSpec for PID0_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [pid0::R](R) reader structure"]
impl crate :: Readable for PID0_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PID0 to value 0xd0"]
impl crate :: Resettable for PID0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0xd0 } } } # [doc = "PID1 register accessor: an alias for `Reg<PID1_SPEC>`"]
pub type PID1 = crate :: Reg < pid1 :: PID1_SPEC > ; # [doc = "Peripheral Identification 1"]
pub mod pid1 { # [doc = "Register `PID1` reader"]
pub struct R (crate :: R < PID1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PID1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PID1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PID1_SPEC >) -> Self { R (reader) } } # [doc = "Field `PARTNBH` reader - Part Number High"]
pub type PARTNBH_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `JEPIDCL` reader - Low part of the JEP-106 Identity Code"]
pub type JEPIDCL_R = crate :: FieldReader < u8 , u8 > ; impl R { # [doc = "Bits 0:3 - Part Number High"]
# [inline (always)]
pub fn partnbh (& self) -> PARTNBH_R { PARTNBH_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bits 4:7 - Low part of the JEP-106 Identity Code"]
# [inline (always)]
pub fn jepidcl (& self) -> JEPIDCL_R { JEPIDCL_R :: new (((self . bits >> 4) & 0x0f) as u8) } } # [doc = "Peripheral Identification 1\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pid1](index.html) module"]
pub struct PID1_SPEC ; impl crate :: RegisterSpec for PID1_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [pid1::R](R) reader structure"]
impl crate :: Readable for PID1_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PID1 to value 0xfc"]
impl crate :: Resettable for PID1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0xfc } } } # [doc = "PID2 register accessor: an alias for `Reg<PID2_SPEC>`"]
pub type PID2 = crate :: Reg < pid2 :: PID2_SPEC > ; # [doc = "Peripheral Identification 2"]
pub mod pid2 { # [doc = "Register `PID2` reader"]
pub struct R (crate :: R < PID2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PID2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PID2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PID2_SPEC >) -> Self { R (reader) } } # [doc = "Field `JEPIDCH` reader - JEP-106 Identity Code High"]
pub type JEPIDCH_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `JEPU` reader - JEP-106 Identity Code is used"]
pub type JEPU_R = crate :: BitReader < bool > ; # [doc = "Field `REVISION` reader - Revision Number"]
pub type REVISION_R = crate :: FieldReader < u8 , u8 > ; impl R { # [doc = "Bits 0:2 - JEP-106 Identity Code High"]
# [inline (always)]
pub fn jepidch (& self) -> JEPIDCH_R { JEPIDCH_R :: new ((self . bits & 7) as u8) } # [doc = "Bit 3 - JEP-106 Identity Code is used"]
# [inline (always)]
pub fn jepu (& self) -> JEPU_R { JEPU_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:7 - Revision Number"]
# [inline (always)]
pub fn revision (& self) -> REVISION_R { REVISION_R :: new (((self . bits >> 4) & 0x0f) as u8) } } # [doc = "Peripheral Identification 2\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pid2](index.html) module"]
pub struct PID2_SPEC ; impl crate :: RegisterSpec for PID2_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [pid2::R](R) reader structure"]
impl crate :: Readable for PID2_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PID2 to value 0x09"]
impl crate :: Resettable for PID2_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x09 } } } # [doc = "PID3 register accessor: an alias for `Reg<PID3_SPEC>`"]
pub type PID3 = crate :: Reg < pid3 :: PID3_SPEC > ; # [doc = "Peripheral Identification 3"]
pub mod pid3 { # [doc = "Register `PID3` reader"]
pub struct R (crate :: R < PID3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PID3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PID3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PID3_SPEC >) -> Self { R (reader) } } # [doc = "Field `CUSMOD` reader - ARM CUSMOD"]
pub type CUSMOD_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `REVAND` reader - Revision Number"]
pub type REVAND_R = crate :: FieldReader < u8 , u8 > ; impl R { # [doc = "Bits 0:3 - ARM CUSMOD"]
# [inline (always)]
pub fn cusmod (& self) -> CUSMOD_R { CUSMOD_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bits 4:7 - Revision Number"]
# [inline (always)]
pub fn revand (& self) -> REVAND_R { REVAND_R :: new (((self . bits >> 4) & 0x0f) as u8) } } # [doc = "Peripheral Identification 3\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pid3](index.html) module"]
pub struct PID3_SPEC ; impl crate :: RegisterSpec for PID3_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [pid3::R](R) reader structure"]
impl crate :: Readable for PID3_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PID3 to value 0"]
impl crate :: Resettable for PID3_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CID0 register accessor: an alias for `Reg<CID0_SPEC>`"]
pub type CID0 = crate :: Reg < cid0 :: CID0_SPEC > ; # [doc = "Component Identification 0"]
pub mod cid0 { # [doc = "Register `CID0` reader"]
pub struct R (crate :: R < CID0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CID0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CID0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CID0_SPEC >) -> Self { R (reader) } } # [doc = "Field `PREAMBLEB0` reader - Preamble Byte 0"]
pub type PREAMBLEB0_R = crate :: FieldReader < u8 , u8 > ; impl R { # [doc = "Bits 0:7 - Preamble Byte 0"]
# [inline (always)]
pub fn preambleb0 (& self) -> PREAMBLEB0_R { PREAMBLEB0_R :: new ((self . bits & 0xff) as u8) } } # [doc = "Component Identification 0\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cid0](index.html) module"]
pub struct CID0_SPEC ; impl crate :: RegisterSpec for CID0_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [cid0::R](R) reader structure"]
impl crate :: Readable for CID0_SPEC { type Reader = R ; } # [doc = "`reset()` method sets CID0 to value 0x0d"]
impl crate :: Resettable for CID0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x0d } } } # [doc = "CID1 register accessor: an alias for `Reg<CID1_SPEC>`"]
pub type CID1 = crate :: Reg < cid1 :: CID1_SPEC > ; # [doc = "Component Identification 1"]
pub mod cid1 { # [doc = "Register `CID1` reader"]
pub struct R (crate :: R < CID1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CID1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CID1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CID1_SPEC >) -> Self { R (reader) } } # [doc = "Field `PREAMBLE` reader - Preamble"]
pub type PREAMBLE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CCLASS` reader - Component Class"]
pub type CCLASS_R = crate :: FieldReader < u8 , u8 > ; impl R { # [doc = "Bits 0:3 - Preamble"]
# [inline (always)]
pub fn preamble (& self) -> PREAMBLE_R { PREAMBLE_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bits 4:7 - Component Class"]
# [inline (always)]
pub fn cclass (& self) -> CCLASS_R { CCLASS_R :: new (((self . bits >> 4) & 0x0f) as u8) } } # [doc = "Component Identification 1\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cid1](index.html) module"]
pub struct CID1_SPEC ; impl crate :: RegisterSpec for CID1_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [cid1::R](R) reader structure"]
impl crate :: Readable for CID1_SPEC { type Reader = R ; } # [doc = "`reset()` method sets CID1 to value 0x10"]
impl crate :: Resettable for CID1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x10 } } } # [doc = "CID2 register accessor: an alias for `Reg<CID2_SPEC>`"]
pub type CID2 = crate :: Reg < cid2 :: CID2_SPEC > ; # [doc = "Component Identification 2"]
pub mod cid2 { # [doc = "Register `CID2` reader"]
pub struct R (crate :: R < CID2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CID2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CID2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CID2_SPEC >) -> Self { R (reader) } } # [doc = "Field `PREAMBLEB2` reader - Preamble Byte 2"]
pub type PREAMBLEB2_R = crate :: FieldReader < u8 , u8 > ; impl R { # [doc = "Bits 0:7 - Preamble Byte 2"]
# [inline (always)]
pub fn preambleb2 (& self) -> PREAMBLEB2_R { PREAMBLEB2_R :: new ((self . bits & 0xff) as u8) } } # [doc = "Component Identification 2\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cid2](index.html) module"]
pub struct CID2_SPEC ; impl crate :: RegisterSpec for CID2_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [cid2::R](R) reader structure"]
impl crate :: Readable for CID2_SPEC { type Reader = R ; } # [doc = "`reset()` method sets CID2 to value 0x05"]
impl crate :: Resettable for CID2_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x05 } } } # [doc = "CID3 register accessor: an alias for `Reg<CID3_SPEC>`"]
pub type CID3 = crate :: Reg < cid3 :: CID3_SPEC > ; # [doc = "Component Identification 3"]
pub mod cid3 { # [doc = "Register `CID3` reader"]
pub struct R (crate :: R < CID3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CID3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CID3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CID3_SPEC >) -> Self { R (reader) } } # [doc = "Field `PREAMBLEB3` reader - Preamble Byte 3"]
pub type PREAMBLEB3_R = crate :: FieldReader < u8 , u8 > ; impl R { # [doc = "Bits 0:7 - Preamble Byte 3"]
# [inline (always)]
pub fn preambleb3 (& self) -> PREAMBLEB3_R { PREAMBLEB3_R :: new ((self . bits & 0xff) as u8) } } # [doc = "Component Identification 3\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cid3](index.html) module"]
pub struct CID3_SPEC ; impl crate :: RegisterSpec for CID3_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [cid3::R](R) reader structure"]
impl crate :: Readable for CID3_SPEC { type Reader = R ; } # [doc = "`reset()` method sets CID3 to value 0xb1"]
impl crate :: Resettable for CID3_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0xb1 } } } } # [doc = "External Interrupt Controller"]
pub struct EIC { _marker : PhantomData < * const () > } unsafe impl Send for EIC { } impl EIC { # [doc = r"Pointer to the register block"]
pub const PTR : * const eic :: RegisterBlock = 0x4000_1800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const eic :: RegisterBlock { Self :: PTR } } impl Deref for EIC { type Target = eic :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for EIC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("EIC") . finish () } } # [doc = "External Interrupt Controller"]
pub mod eic { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control"]
pub ctrl : crate :: Reg < ctrl :: CTRL_SPEC > , # [doc = "0x01 - Status"]
pub status : crate :: Reg < status :: STATUS_SPEC > , # [doc = "0x02 - Non-Maskable Interrupt Control"]
pub nmictrl : crate :: Reg < nmictrl :: NMICTRL_SPEC > , # [doc = "0x03 - Non-Maskable Interrupt Flag Status and Clear"]
pub nmiflag : crate :: Reg < nmiflag :: NMIFLAG_SPEC > , # [doc = "0x04 - Event Control"]
pub evctrl : crate :: Reg < evctrl :: EVCTRL_SPEC > , # [doc = "0x08 - Interrupt Enable Clear"]
pub intenclr : crate :: Reg < intenclr :: INTENCLR_SPEC > , # [doc = "0x0c - Interrupt Enable Set"]
pub intenset : crate :: Reg < intenset :: INTENSET_SPEC > , # [doc = "0x10 - Interrupt Flag Status and Clear"]
pub intflag : crate :: Reg < intflag :: INTFLAG_SPEC > , # [doc = "0x14 - Wake-Up Enable"]
pub wakeup : crate :: Reg < wakeup :: WAKEUP_SPEC > , # [doc = "0x18..0x20 - Configuration n"]
pub config : [crate :: Reg < config :: CONFIG_SPEC > ; 2]
, } # [doc = "CTRL register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWRST` reader - Software Reset"]
pub type SWRST_R = crate :: BitReader < bool > ; # [doc = "Field `SWRST` writer - Software Reset"]
pub type SWRST_W < 'a > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , 0 > ; # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , 1 > ; impl R { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& self) -> SWRST_R { SWRST_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& mut self) -> SWRST_W { SWRST_W :: new (self) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATUS register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `SYNCBUSY` reader - Synchronization Busy"]
pub type SYNCBUSY_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 7 - Synchronization Busy"]
# [inline (always)]
pub fn syncbusy (& self) -> SYNCBUSY_R { SYNCBUSY_R :: new (((self . bits >> 7) & 1) != 0) } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "NMICTRL register accessor: an alias for `Reg<NMICTRL_SPEC>`"]
pub type NMICTRL = crate :: Reg < nmictrl :: NMICTRL_SPEC > ; # [doc = "Non-Maskable Interrupt Control"]
pub mod nmictrl { # [doc = "Register `NMICTRL` reader"]
pub struct R (crate :: R < NMICTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < NMICTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < NMICTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < NMICTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `NMICTRL` writer"]
pub struct W (crate :: W < NMICTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < NMICTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < NMICTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < NMICTRL_SPEC >) -> Self { W (writer) } } # [doc = "Non-Maskable Interrupt Sense\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum NMISENSE_A { # [doc = "0: No detection"]
NONE = 0 , # [doc = "1: Rising-edge detection"]
RISE = 1 , # [doc = "2: Falling-edge detection"]
FALL = 2 , # [doc = "3: Both-edges detection"]
BOTH = 3 , # [doc = "4: High-level detection"]
HIGH = 4 , # [doc = "5: Low-level detection"]
LOW = 5 , } impl From < NMISENSE_A > for u8 { # [inline (always)]
fn from (variant : NMISENSE_A) -> Self { variant as _ } } # [doc = "Field `NMISENSE` reader - Non-Maskable Interrupt Sense"]
pub type NMISENSE_R = crate :: FieldReader < u8 , NMISENSE_A > ; impl NMISENSE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < NMISENSE_A > { match self . bits { 0 => Some (NMISENSE_A :: NONE) , 1 => Some (NMISENSE_A :: RISE) , 2 => Some (NMISENSE_A :: FALL) , 3 => Some (NMISENSE_A :: BOTH) , 4 => Some (NMISENSE_A :: HIGH) , 5 => Some (NMISENSE_A :: LOW) , _ => None , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == NMISENSE_A :: NONE } # [doc = "Checks if the value of the field is `RISE`"]
# [inline (always)]
pub fn is_rise (& self) -> bool { * self == NMISENSE_A :: RISE } # [doc = "Checks if the value of the field is `FALL`"]
# [inline (always)]
pub fn is_fall (& self) -> bool { * self == NMISENSE_A :: FALL } # [doc = "Checks if the value of the field is `BOTH`"]
# [inline (always)]
pub fn is_both (& self) -> bool { * self == NMISENSE_A :: BOTH } # [doc = "Checks if the value of the field is `HIGH`"]
# [inline (always)]
pub fn is_high (& self) -> bool { * self == NMISENSE_A :: HIGH } # [doc = "Checks if the value of the field is `LOW`"]
# [inline (always)]
pub fn is_low (& self) -> bool { * self == NMISENSE_A :: LOW } } # [doc = "Field `NMISENSE` writer - Non-Maskable Interrupt Sense"]
pub type NMISENSE_W < 'a > = crate :: FieldWriter < 'a , u8 , NMICTRL_SPEC , u8 , NMISENSE_A , 3 , 0 > ; impl < 'a > NMISENSE_W < 'a > { # [doc = "No detection"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (NMISENSE_A :: NONE) } # [doc = "Rising-edge detection"]
# [inline (always)]
pub fn rise (self) -> & 'a mut W { self . variant (NMISENSE_A :: RISE) } # [doc = "Falling-edge detection"]
# [inline (always)]
pub fn fall (self) -> & 'a mut W { self . variant (NMISENSE_A :: FALL) } # [doc = "Both-edges detection"]
# [inline (always)]
pub fn both (self) -> & 'a mut W { self . variant (NMISENSE_A :: BOTH) } # [doc = "High-level detection"]
# [inline (always)]
pub fn high (self) -> & 'a mut W { self . variant (NMISENSE_A :: HIGH) } # [doc = "Low-level detection"]
# [inline (always)]
pub fn low (self) -> & 'a mut W { self . variant (NMISENSE_A :: LOW) } } # [doc = "Field `NMIFILTEN` reader - Non-Maskable Interrupt Filter Enable"]
pub type NMIFILTEN_R = crate :: BitReader < bool > ; # [doc = "Field `NMIFILTEN` writer - Non-Maskable Interrupt Filter Enable"]
pub type NMIFILTEN_W < 'a > = crate :: BitWriter < 'a , u8 , NMICTRL_SPEC , bool , 3 > ; impl R { # [doc = "Bits 0:2 - Non-Maskable Interrupt Sense"]
# [inline (always)]
pub fn nmisense (& self) -> NMISENSE_R { NMISENSE_R :: new ((self . bits & 7) as u8) } # [doc = "Bit 3 - Non-Maskable Interrupt Filter Enable"]
# [inline (always)]
pub fn nmifilten (& self) -> NMIFILTEN_R { NMIFILTEN_R :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Non-Maskable Interrupt Sense"]
# [inline (always)]
pub fn nmisense (& mut self) -> NMISENSE_W { NMISENSE_W :: new (self) } # [doc = "Bit 3 - Non-Maskable Interrupt Filter Enable"]
# [inline (always)]
pub fn nmifilten (& mut self) -> NMIFILTEN_W { NMIFILTEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Non-Maskable Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [nmictrl](index.html) module"]
pub struct NMICTRL_SPEC ; impl crate :: RegisterSpec for NMICTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [nmictrl::R](R) reader structure"]
impl crate :: Readable for NMICTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [nmictrl::W](W) writer structure"]
impl crate :: Writable for NMICTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets NMICTRL to value 0"]
impl crate :: Resettable for NMICTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "NMIFLAG register accessor: an alias for `Reg<NMIFLAG_SPEC>`"]
pub type NMIFLAG = crate :: Reg < nmiflag :: NMIFLAG_SPEC > ; # [doc = "Non-Maskable Interrupt Flag Status and Clear"]
pub mod nmiflag { # [doc = "Register `NMIFLAG` reader"]
pub struct R (crate :: R < NMIFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < NMIFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < NMIFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < NMIFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `NMIFLAG` writer"]
pub struct W (crate :: W < NMIFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < NMIFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < NMIFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < NMIFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `NMI` reader - Non-Maskable Interrupt"]
pub type NMI_R = crate :: BitReader < bool > ; # [doc = "Field `NMI` writer - Non-Maskable Interrupt"]
pub type NMI_W < 'a > = crate :: BitWriter < 'a , u8 , NMIFLAG_SPEC , bool , 0 > ; impl R { # [doc = "Bit 0 - Non-Maskable Interrupt"]
# [inline (always)]
pub fn nmi (& self) -> NMI_R { NMI_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Non-Maskable Interrupt"]
# [inline (always)]
pub fn nmi (& mut self) -> NMI_W { NMI_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Non-Maskable Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [nmiflag](index.html) module"]
pub struct NMIFLAG_SPEC ; impl crate :: RegisterSpec for NMIFLAG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [nmiflag::R](R) reader structure"]
impl crate :: Readable for NMIFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [nmiflag::W](W) writer structure"]
impl crate :: Writable for NMIFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets NMIFLAG to value 0"]
impl crate :: Resettable for NMIFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "EVCTRL register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "Event Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `EXTINTEO0` reader - External Interrupt 0 Event Output Enable"]
pub type EXTINTEO0_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINTEO0` writer - External Interrupt 0 Event Output Enable"]
pub type EXTINTEO0_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 0 > ; # [doc = "Field `EXTINTEO1` reader - External Interrupt 1 Event Output Enable"]
pub type EXTINTEO1_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINTEO1` writer - External Interrupt 1 Event Output Enable"]
pub type EXTINTEO1_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 1 > ; # [doc = "Field `EXTINTEO2` reader - External Interrupt 2 Event Output Enable"]
pub type EXTINTEO2_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINTEO2` writer - External Interrupt 2 Event Output Enable"]
pub type EXTINTEO2_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 2 > ; # [doc = "Field `EXTINTEO3` reader - External Interrupt 3 Event Output Enable"]
pub type EXTINTEO3_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINTEO3` writer - External Interrupt 3 Event Output Enable"]
pub type EXTINTEO3_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 3 > ; # [doc = "Field `EXTINTEO4` reader - External Interrupt 4 Event Output Enable"]
pub type EXTINTEO4_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINTEO4` writer - External Interrupt 4 Event Output Enable"]
pub type EXTINTEO4_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 4 > ; # [doc = "Field `EXTINTEO5` reader - External Interrupt 5 Event Output Enable"]
pub type EXTINTEO5_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINTEO5` writer - External Interrupt 5 Event Output Enable"]
pub type EXTINTEO5_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 5 > ; # [doc = "Field `EXTINTEO6` reader - External Interrupt 6 Event Output Enable"]
pub type EXTINTEO6_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINTEO6` writer - External Interrupt 6 Event Output Enable"]
pub type EXTINTEO6_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 6 > ; # [doc = "Field `EXTINTEO7` reader - External Interrupt 7 Event Output Enable"]
pub type EXTINTEO7_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINTEO7` writer - External Interrupt 7 Event Output Enable"]
pub type EXTINTEO7_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 7 > ; # [doc = "Field `EXTINTEO8` reader - External Interrupt 8 Event Output Enable"]
pub type EXTINTEO8_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINTEO8` writer - External Interrupt 8 Event Output Enable"]
pub type EXTINTEO8_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 8 > ; # [doc = "Field `EXTINTEO9` reader - External Interrupt 9 Event Output Enable"]
pub type EXTINTEO9_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINTEO9` writer - External Interrupt 9 Event Output Enable"]
pub type EXTINTEO9_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 9 > ; # [doc = "Field `EXTINTEO10` reader - External Interrupt 10 Event Output Enable"]
pub type EXTINTEO10_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINTEO10` writer - External Interrupt 10 Event Output Enable"]
pub type EXTINTEO10_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 10 > ; # [doc = "Field `EXTINTEO11` reader - External Interrupt 11 Event Output Enable"]
pub type EXTINTEO11_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINTEO11` writer - External Interrupt 11 Event Output Enable"]
pub type EXTINTEO11_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 11 > ; # [doc = "Field `EXTINTEO12` reader - External Interrupt 12 Event Output Enable"]
pub type EXTINTEO12_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINTEO12` writer - External Interrupt 12 Event Output Enable"]
pub type EXTINTEO12_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 12 > ; # [doc = "Field `EXTINTEO13` reader - External Interrupt 13 Event Output Enable"]
pub type EXTINTEO13_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINTEO13` writer - External Interrupt 13 Event Output Enable"]
pub type EXTINTEO13_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 13 > ; # [doc = "Field `EXTINTEO14` reader - External Interrupt 14 Event Output Enable"]
pub type EXTINTEO14_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINTEO14` writer - External Interrupt 14 Event Output Enable"]
pub type EXTINTEO14_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 14 > ; # [doc = "Field `EXTINTEO15` reader - External Interrupt 15 Event Output Enable"]
pub type EXTINTEO15_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINTEO15` writer - External Interrupt 15 Event Output Enable"]
pub type EXTINTEO15_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 15 > ; impl R { # [doc = "Bit 0 - External Interrupt 0 Event Output Enable"]
# [inline (always)]
pub fn extinteo0 (& self) -> EXTINTEO0_R { EXTINTEO0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - External Interrupt 1 Event Output Enable"]
# [inline (always)]
pub fn extinteo1 (& self) -> EXTINTEO1_R { EXTINTEO1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - External Interrupt 2 Event Output Enable"]
# [inline (always)]
pub fn extinteo2 (& self) -> EXTINTEO2_R { EXTINTEO2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - External Interrupt 3 Event Output Enable"]
# [inline (always)]
pub fn extinteo3 (& self) -> EXTINTEO3_R { EXTINTEO3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - External Interrupt 4 Event Output Enable"]
# [inline (always)]
pub fn extinteo4 (& self) -> EXTINTEO4_R { EXTINTEO4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - External Interrupt 5 Event Output Enable"]
# [inline (always)]
pub fn extinteo5 (& self) -> EXTINTEO5_R { EXTINTEO5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - External Interrupt 6 Event Output Enable"]
# [inline (always)]
pub fn extinteo6 (& self) -> EXTINTEO6_R { EXTINTEO6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - External Interrupt 7 Event Output Enable"]
# [inline (always)]
pub fn extinteo7 (& self) -> EXTINTEO7_R { EXTINTEO7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - External Interrupt 8 Event Output Enable"]
# [inline (always)]
pub fn extinteo8 (& self) -> EXTINTEO8_R { EXTINTEO8_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - External Interrupt 9 Event Output Enable"]
# [inline (always)]
pub fn extinteo9 (& self) -> EXTINTEO9_R { EXTINTEO9_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - External Interrupt 10 Event Output Enable"]
# [inline (always)]
pub fn extinteo10 (& self) -> EXTINTEO10_R { EXTINTEO10_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - External Interrupt 11 Event Output Enable"]
# [inline (always)]
pub fn extinteo11 (& self) -> EXTINTEO11_R { EXTINTEO11_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - External Interrupt 12 Event Output Enable"]
# [inline (always)]
pub fn extinteo12 (& self) -> EXTINTEO12_R { EXTINTEO12_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - External Interrupt 13 Event Output Enable"]
# [inline (always)]
pub fn extinteo13 (& self) -> EXTINTEO13_R { EXTINTEO13_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - External Interrupt 14 Event Output Enable"]
# [inline (always)]
pub fn extinteo14 (& self) -> EXTINTEO14_R { EXTINTEO14_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - External Interrupt 15 Event Output Enable"]
# [inline (always)]
pub fn extinteo15 (& self) -> EXTINTEO15_R { EXTINTEO15_R :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bit 0 - External Interrupt 0 Event Output Enable"]
# [inline (always)]
pub fn extinteo0 (& mut self) -> EXTINTEO0_W { EXTINTEO0_W :: new (self) } # [doc = "Bit 1 - External Interrupt 1 Event Output Enable"]
# [inline (always)]
pub fn extinteo1 (& mut self) -> EXTINTEO1_W { EXTINTEO1_W :: new (self) } # [doc = "Bit 2 - External Interrupt 2 Event Output Enable"]
# [inline (always)]
pub fn extinteo2 (& mut self) -> EXTINTEO2_W { EXTINTEO2_W :: new (self) } # [doc = "Bit 3 - External Interrupt 3 Event Output Enable"]
# [inline (always)]
pub fn extinteo3 (& mut self) -> EXTINTEO3_W { EXTINTEO3_W :: new (self) } # [doc = "Bit 4 - External Interrupt 4 Event Output Enable"]
# [inline (always)]
pub fn extinteo4 (& mut self) -> EXTINTEO4_W { EXTINTEO4_W :: new (self) } # [doc = "Bit 5 - External Interrupt 5 Event Output Enable"]
# [inline (always)]
pub fn extinteo5 (& mut self) -> EXTINTEO5_W { EXTINTEO5_W :: new (self) } # [doc = "Bit 6 - External Interrupt 6 Event Output Enable"]
# [inline (always)]
pub fn extinteo6 (& mut self) -> EXTINTEO6_W { EXTINTEO6_W :: new (self) } # [doc = "Bit 7 - External Interrupt 7 Event Output Enable"]
# [inline (always)]
pub fn extinteo7 (& mut self) -> EXTINTEO7_W { EXTINTEO7_W :: new (self) } # [doc = "Bit 8 - External Interrupt 8 Event Output Enable"]
# [inline (always)]
pub fn extinteo8 (& mut self) -> EXTINTEO8_W { EXTINTEO8_W :: new (self) } # [doc = "Bit 9 - External Interrupt 9 Event Output Enable"]
# [inline (always)]
pub fn extinteo9 (& mut self) -> EXTINTEO9_W { EXTINTEO9_W :: new (self) } # [doc = "Bit 10 - External Interrupt 10 Event Output Enable"]
# [inline (always)]
pub fn extinteo10 (& mut self) -> EXTINTEO10_W { EXTINTEO10_W :: new (self) } # [doc = "Bit 11 - External Interrupt 11 Event Output Enable"]
# [inline (always)]
pub fn extinteo11 (& mut self) -> EXTINTEO11_W { EXTINTEO11_W :: new (self) } # [doc = "Bit 12 - External Interrupt 12 Event Output Enable"]
# [inline (always)]
pub fn extinteo12 (& mut self) -> EXTINTEO12_W { EXTINTEO12_W :: new (self) } # [doc = "Bit 13 - External Interrupt 13 Event Output Enable"]
# [inline (always)]
pub fn extinteo13 (& mut self) -> EXTINTEO13_W { EXTINTEO13_W :: new (self) } # [doc = "Bit 14 - External Interrupt 14 Event Output Enable"]
# [inline (always)]
pub fn extinteo14 (& mut self) -> EXTINTEO14_W { EXTINTEO14_W :: new (self) } # [doc = "Bit 15 - External Interrupt 15 Event Output Enable"]
# [inline (always)]
pub fn extinteo15 (& mut self) -> EXTINTEO15_W { EXTINTEO15_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENCLR register accessor: an alias for `Reg<INTENCLR_SPEC>`"]
pub type INTENCLR = crate :: Reg < intenclr :: INTENCLR_SPEC > ; # [doc = "Interrupt Enable Clear"]
pub mod intenclr { # [doc = "Register `INTENCLR` reader"]
pub struct R (crate :: R < INTENCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENCLR` writer"]
pub struct W (crate :: W < INTENCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `EXTINT0` reader - External Interrupt 0 Enable"]
pub type EXTINT0_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT0` writer - External Interrupt 0 Enable"]
pub type EXTINT0_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 0 > ; # [doc = "Field `EXTINT1` reader - External Interrupt 1 Enable"]
pub type EXTINT1_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT1` writer - External Interrupt 1 Enable"]
pub type EXTINT1_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 1 > ; # [doc = "Field `EXTINT2` reader - External Interrupt 2 Enable"]
pub type EXTINT2_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT2` writer - External Interrupt 2 Enable"]
pub type EXTINT2_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 2 > ; # [doc = "Field `EXTINT3` reader - External Interrupt 3 Enable"]
pub type EXTINT3_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT3` writer - External Interrupt 3 Enable"]
pub type EXTINT3_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 3 > ; # [doc = "Field `EXTINT4` reader - External Interrupt 4 Enable"]
pub type EXTINT4_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT4` writer - External Interrupt 4 Enable"]
pub type EXTINT4_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 4 > ; # [doc = "Field `EXTINT5` reader - External Interrupt 5 Enable"]
pub type EXTINT5_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT5` writer - External Interrupt 5 Enable"]
pub type EXTINT5_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 5 > ; # [doc = "Field `EXTINT6` reader - External Interrupt 6 Enable"]
pub type EXTINT6_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT6` writer - External Interrupt 6 Enable"]
pub type EXTINT6_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 6 > ; # [doc = "Field `EXTINT7` reader - External Interrupt 7 Enable"]
pub type EXTINT7_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT7` writer - External Interrupt 7 Enable"]
pub type EXTINT7_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 7 > ; # [doc = "Field `EXTINT8` reader - External Interrupt 8 Enable"]
pub type EXTINT8_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT8` writer - External Interrupt 8 Enable"]
pub type EXTINT8_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 8 > ; # [doc = "Field `EXTINT9` reader - External Interrupt 9 Enable"]
pub type EXTINT9_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT9` writer - External Interrupt 9 Enable"]
pub type EXTINT9_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 9 > ; # [doc = "Field `EXTINT10` reader - External Interrupt 10 Enable"]
pub type EXTINT10_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT10` writer - External Interrupt 10 Enable"]
pub type EXTINT10_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 10 > ; # [doc = "Field `EXTINT11` reader - External Interrupt 11 Enable"]
pub type EXTINT11_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT11` writer - External Interrupt 11 Enable"]
pub type EXTINT11_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 11 > ; # [doc = "Field `EXTINT12` reader - External Interrupt 12 Enable"]
pub type EXTINT12_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT12` writer - External Interrupt 12 Enable"]
pub type EXTINT12_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 12 > ; # [doc = "Field `EXTINT13` reader - External Interrupt 13 Enable"]
pub type EXTINT13_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT13` writer - External Interrupt 13 Enable"]
pub type EXTINT13_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 13 > ; # [doc = "Field `EXTINT14` reader - External Interrupt 14 Enable"]
pub type EXTINT14_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT14` writer - External Interrupt 14 Enable"]
pub type EXTINT14_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 14 > ; # [doc = "Field `EXTINT15` reader - External Interrupt 15 Enable"]
pub type EXTINT15_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT15` writer - External Interrupt 15 Enable"]
pub type EXTINT15_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 15 > ; impl R { # [doc = "Bit 0 - External Interrupt 0 Enable"]
# [inline (always)]
pub fn extint0 (& self) -> EXTINT0_R { EXTINT0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - External Interrupt 1 Enable"]
# [inline (always)]
pub fn extint1 (& self) -> EXTINT1_R { EXTINT1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - External Interrupt 2 Enable"]
# [inline (always)]
pub fn extint2 (& self) -> EXTINT2_R { EXTINT2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - External Interrupt 3 Enable"]
# [inline (always)]
pub fn extint3 (& self) -> EXTINT3_R { EXTINT3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - External Interrupt 4 Enable"]
# [inline (always)]
pub fn extint4 (& self) -> EXTINT4_R { EXTINT4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - External Interrupt 5 Enable"]
# [inline (always)]
pub fn extint5 (& self) -> EXTINT5_R { EXTINT5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - External Interrupt 6 Enable"]
# [inline (always)]
pub fn extint6 (& self) -> EXTINT6_R { EXTINT6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - External Interrupt 7 Enable"]
# [inline (always)]
pub fn extint7 (& self) -> EXTINT7_R { EXTINT7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - External Interrupt 8 Enable"]
# [inline (always)]
pub fn extint8 (& self) -> EXTINT8_R { EXTINT8_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - External Interrupt 9 Enable"]
# [inline (always)]
pub fn extint9 (& self) -> EXTINT9_R { EXTINT9_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - External Interrupt 10 Enable"]
# [inline (always)]
pub fn extint10 (& self) -> EXTINT10_R { EXTINT10_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - External Interrupt 11 Enable"]
# [inline (always)]
pub fn extint11 (& self) -> EXTINT11_R { EXTINT11_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - External Interrupt 12 Enable"]
# [inline (always)]
pub fn extint12 (& self) -> EXTINT12_R { EXTINT12_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - External Interrupt 13 Enable"]
# [inline (always)]
pub fn extint13 (& self) -> EXTINT13_R { EXTINT13_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - External Interrupt 14 Enable"]
# [inline (always)]
pub fn extint14 (& self) -> EXTINT14_R { EXTINT14_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - External Interrupt 15 Enable"]
# [inline (always)]
pub fn extint15 (& self) -> EXTINT15_R { EXTINT15_R :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bit 0 - External Interrupt 0 Enable"]
# [inline (always)]
pub fn extint0 (& mut self) -> EXTINT0_W { EXTINT0_W :: new (self) } # [doc = "Bit 1 - External Interrupt 1 Enable"]
# [inline (always)]
pub fn extint1 (& mut self) -> EXTINT1_W { EXTINT1_W :: new (self) } # [doc = "Bit 2 - External Interrupt 2 Enable"]
# [inline (always)]
pub fn extint2 (& mut self) -> EXTINT2_W { EXTINT2_W :: new (self) } # [doc = "Bit 3 - External Interrupt 3 Enable"]
# [inline (always)]
pub fn extint3 (& mut self) -> EXTINT3_W { EXTINT3_W :: new (self) } # [doc = "Bit 4 - External Interrupt 4 Enable"]
# [inline (always)]
pub fn extint4 (& mut self) -> EXTINT4_W { EXTINT4_W :: new (self) } # [doc = "Bit 5 - External Interrupt 5 Enable"]
# [inline (always)]
pub fn extint5 (& mut self) -> EXTINT5_W { EXTINT5_W :: new (self) } # [doc = "Bit 6 - External Interrupt 6 Enable"]
# [inline (always)]
pub fn extint6 (& mut self) -> EXTINT6_W { EXTINT6_W :: new (self) } # [doc = "Bit 7 - External Interrupt 7 Enable"]
# [inline (always)]
pub fn extint7 (& mut self) -> EXTINT7_W { EXTINT7_W :: new (self) } # [doc = "Bit 8 - External Interrupt 8 Enable"]
# [inline (always)]
pub fn extint8 (& mut self) -> EXTINT8_W { EXTINT8_W :: new (self) } # [doc = "Bit 9 - External Interrupt 9 Enable"]
# [inline (always)]
pub fn extint9 (& mut self) -> EXTINT9_W { EXTINT9_W :: new (self) } # [doc = "Bit 10 - External Interrupt 10 Enable"]
# [inline (always)]
pub fn extint10 (& mut self) -> EXTINT10_W { EXTINT10_W :: new (self) } # [doc = "Bit 11 - External Interrupt 11 Enable"]
# [inline (always)]
pub fn extint11 (& mut self) -> EXTINT11_W { EXTINT11_W :: new (self) } # [doc = "Bit 12 - External Interrupt 12 Enable"]
# [inline (always)]
pub fn extint12 (& mut self) -> EXTINT12_W { EXTINT12_W :: new (self) } # [doc = "Bit 13 - External Interrupt 13 Enable"]
# [inline (always)]
pub fn extint13 (& mut self) -> EXTINT13_W { EXTINT13_W :: new (self) } # [doc = "Bit 14 - External Interrupt 14 Enable"]
# [inline (always)]
pub fn extint14 (& mut self) -> EXTINT14_W { EXTINT14_W :: new (self) } # [doc = "Bit 15 - External Interrupt 15 Enable"]
# [inline (always)]
pub fn extint15 (& mut self) -> EXTINT15_W { EXTINT15_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenclr](index.html) module"]
pub struct INTENCLR_SPEC ; impl crate :: RegisterSpec for INTENCLR_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [intenclr::R](R) reader structure"]
impl crate :: Readable for INTENCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenclr::W](W) writer structure"]
impl crate :: Writable for INTENCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENCLR to value 0"]
impl crate :: Resettable for INTENCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENSET register accessor: an alias for `Reg<INTENSET_SPEC>`"]
pub type INTENSET = crate :: Reg < intenset :: INTENSET_SPEC > ; # [doc = "Interrupt Enable Set"]
pub mod intenset { # [doc = "Register `INTENSET` reader"]
pub struct R (crate :: R < INTENSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENSET` writer"]
pub struct W (crate :: W < INTENSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `EXTINT0` reader - External Interrupt 0 Enable"]
pub type EXTINT0_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT0` writer - External Interrupt 0 Enable"]
pub type EXTINT0_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 0 > ; # [doc = "Field `EXTINT1` reader - External Interrupt 1 Enable"]
pub type EXTINT1_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT1` writer - External Interrupt 1 Enable"]
pub type EXTINT1_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 1 > ; # [doc = "Field `EXTINT2` reader - External Interrupt 2 Enable"]
pub type EXTINT2_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT2` writer - External Interrupt 2 Enable"]
pub type EXTINT2_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 2 > ; # [doc = "Field `EXTINT3` reader - External Interrupt 3 Enable"]
pub type EXTINT3_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT3` writer - External Interrupt 3 Enable"]
pub type EXTINT3_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 3 > ; # [doc = "Field `EXTINT4` reader - External Interrupt 4 Enable"]
pub type EXTINT4_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT4` writer - External Interrupt 4 Enable"]
pub type EXTINT4_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 4 > ; # [doc = "Field `EXTINT5` reader - External Interrupt 5 Enable"]
pub type EXTINT5_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT5` writer - External Interrupt 5 Enable"]
pub type EXTINT5_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 5 > ; # [doc = "Field `EXTINT6` reader - External Interrupt 6 Enable"]
pub type EXTINT6_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT6` writer - External Interrupt 6 Enable"]
pub type EXTINT6_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 6 > ; # [doc = "Field `EXTINT7` reader - External Interrupt 7 Enable"]
pub type EXTINT7_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT7` writer - External Interrupt 7 Enable"]
pub type EXTINT7_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 7 > ; # [doc = "Field `EXTINT8` reader - External Interrupt 8 Enable"]
pub type EXTINT8_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT8` writer - External Interrupt 8 Enable"]
pub type EXTINT8_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 8 > ; # [doc = "Field `EXTINT9` reader - External Interrupt 9 Enable"]
pub type EXTINT9_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT9` writer - External Interrupt 9 Enable"]
pub type EXTINT9_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 9 > ; # [doc = "Field `EXTINT10` reader - External Interrupt 10 Enable"]
pub type EXTINT10_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT10` writer - External Interrupt 10 Enable"]
pub type EXTINT10_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 10 > ; # [doc = "Field `EXTINT11` reader - External Interrupt 11 Enable"]
pub type EXTINT11_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT11` writer - External Interrupt 11 Enable"]
pub type EXTINT11_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 11 > ; # [doc = "Field `EXTINT12` reader - External Interrupt 12 Enable"]
pub type EXTINT12_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT12` writer - External Interrupt 12 Enable"]
pub type EXTINT12_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 12 > ; # [doc = "Field `EXTINT13` reader - External Interrupt 13 Enable"]
pub type EXTINT13_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT13` writer - External Interrupt 13 Enable"]
pub type EXTINT13_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 13 > ; # [doc = "Field `EXTINT14` reader - External Interrupt 14 Enable"]
pub type EXTINT14_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT14` writer - External Interrupt 14 Enable"]
pub type EXTINT14_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 14 > ; # [doc = "Field `EXTINT15` reader - External Interrupt 15 Enable"]
pub type EXTINT15_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT15` writer - External Interrupt 15 Enable"]
pub type EXTINT15_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 15 > ; impl R { # [doc = "Bit 0 - External Interrupt 0 Enable"]
# [inline (always)]
pub fn extint0 (& self) -> EXTINT0_R { EXTINT0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - External Interrupt 1 Enable"]
# [inline (always)]
pub fn extint1 (& self) -> EXTINT1_R { EXTINT1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - External Interrupt 2 Enable"]
# [inline (always)]
pub fn extint2 (& self) -> EXTINT2_R { EXTINT2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - External Interrupt 3 Enable"]
# [inline (always)]
pub fn extint3 (& self) -> EXTINT3_R { EXTINT3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - External Interrupt 4 Enable"]
# [inline (always)]
pub fn extint4 (& self) -> EXTINT4_R { EXTINT4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - External Interrupt 5 Enable"]
# [inline (always)]
pub fn extint5 (& self) -> EXTINT5_R { EXTINT5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - External Interrupt 6 Enable"]
# [inline (always)]
pub fn extint6 (& self) -> EXTINT6_R { EXTINT6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - External Interrupt 7 Enable"]
# [inline (always)]
pub fn extint7 (& self) -> EXTINT7_R { EXTINT7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - External Interrupt 8 Enable"]
# [inline (always)]
pub fn extint8 (& self) -> EXTINT8_R { EXTINT8_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - External Interrupt 9 Enable"]
# [inline (always)]
pub fn extint9 (& self) -> EXTINT9_R { EXTINT9_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - External Interrupt 10 Enable"]
# [inline (always)]
pub fn extint10 (& self) -> EXTINT10_R { EXTINT10_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - External Interrupt 11 Enable"]
# [inline (always)]
pub fn extint11 (& self) -> EXTINT11_R { EXTINT11_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - External Interrupt 12 Enable"]
# [inline (always)]
pub fn extint12 (& self) -> EXTINT12_R { EXTINT12_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - External Interrupt 13 Enable"]
# [inline (always)]
pub fn extint13 (& self) -> EXTINT13_R { EXTINT13_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - External Interrupt 14 Enable"]
# [inline (always)]
pub fn extint14 (& self) -> EXTINT14_R { EXTINT14_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - External Interrupt 15 Enable"]
# [inline (always)]
pub fn extint15 (& self) -> EXTINT15_R { EXTINT15_R :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bit 0 - External Interrupt 0 Enable"]
# [inline (always)]
pub fn extint0 (& mut self) -> EXTINT0_W { EXTINT0_W :: new (self) } # [doc = "Bit 1 - External Interrupt 1 Enable"]
# [inline (always)]
pub fn extint1 (& mut self) -> EXTINT1_W { EXTINT1_W :: new (self) } # [doc = "Bit 2 - External Interrupt 2 Enable"]
# [inline (always)]
pub fn extint2 (& mut self) -> EXTINT2_W { EXTINT2_W :: new (self) } # [doc = "Bit 3 - External Interrupt 3 Enable"]
# [inline (always)]
pub fn extint3 (& mut self) -> EXTINT3_W { EXTINT3_W :: new (self) } # [doc = "Bit 4 - External Interrupt 4 Enable"]
# [inline (always)]
pub fn extint4 (& mut self) -> EXTINT4_W { EXTINT4_W :: new (self) } # [doc = "Bit 5 - External Interrupt 5 Enable"]
# [inline (always)]
pub fn extint5 (& mut self) -> EXTINT5_W { EXTINT5_W :: new (self) } # [doc = "Bit 6 - External Interrupt 6 Enable"]
# [inline (always)]
pub fn extint6 (& mut self) -> EXTINT6_W { EXTINT6_W :: new (self) } # [doc = "Bit 7 - External Interrupt 7 Enable"]
# [inline (always)]
pub fn extint7 (& mut self) -> EXTINT7_W { EXTINT7_W :: new (self) } # [doc = "Bit 8 - External Interrupt 8 Enable"]
# [inline (always)]
pub fn extint8 (& mut self) -> EXTINT8_W { EXTINT8_W :: new (self) } # [doc = "Bit 9 - External Interrupt 9 Enable"]
# [inline (always)]
pub fn extint9 (& mut self) -> EXTINT9_W { EXTINT9_W :: new (self) } # [doc = "Bit 10 - External Interrupt 10 Enable"]
# [inline (always)]
pub fn extint10 (& mut self) -> EXTINT10_W { EXTINT10_W :: new (self) } # [doc = "Bit 11 - External Interrupt 11 Enable"]
# [inline (always)]
pub fn extint11 (& mut self) -> EXTINT11_W { EXTINT11_W :: new (self) } # [doc = "Bit 12 - External Interrupt 12 Enable"]
# [inline (always)]
pub fn extint12 (& mut self) -> EXTINT12_W { EXTINT12_W :: new (self) } # [doc = "Bit 13 - External Interrupt 13 Enable"]
# [inline (always)]
pub fn extint13 (& mut self) -> EXTINT13_W { EXTINT13_W :: new (self) } # [doc = "Bit 14 - External Interrupt 14 Enable"]
# [inline (always)]
pub fn extint14 (& mut self) -> EXTINT14_W { EXTINT14_W :: new (self) } # [doc = "Bit 15 - External Interrupt 15 Enable"]
# [inline (always)]
pub fn extint15 (& mut self) -> EXTINT15_W { EXTINT15_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenset](index.html) module"]
pub struct INTENSET_SPEC ; impl crate :: RegisterSpec for INTENSET_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [intenset::R](R) reader structure"]
impl crate :: Readable for INTENSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenset::W](W) writer structure"]
impl crate :: Writable for INTENSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENSET to value 0"]
impl crate :: Resettable for INTENSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTFLAG register accessor: an alias for `Reg<INTFLAG_SPEC>`"]
pub type INTFLAG = crate :: Reg < intflag :: INTFLAG_SPEC > ; # [doc = "Interrupt Flag Status and Clear"]
pub mod intflag { # [doc = "Register `INTFLAG` reader"]
pub struct R (crate :: R < INTFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAG` writer"]
pub struct W (crate :: W < INTFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `EXTINT0` reader - External Interrupt 0"]
pub type EXTINT0_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT0` writer - External Interrupt 0"]
pub type EXTINT0_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 0 > ; # [doc = "Field `EXTINT1` reader - External Interrupt 1"]
pub type EXTINT1_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT1` writer - External Interrupt 1"]
pub type EXTINT1_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 1 > ; # [doc = "Field `EXTINT2` reader - External Interrupt 2"]
pub type EXTINT2_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT2` writer - External Interrupt 2"]
pub type EXTINT2_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 2 > ; # [doc = "Field `EXTINT3` reader - External Interrupt 3"]
pub type EXTINT3_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT3` writer - External Interrupt 3"]
pub type EXTINT3_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 3 > ; # [doc = "Field `EXTINT4` reader - External Interrupt 4"]
pub type EXTINT4_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT4` writer - External Interrupt 4"]
pub type EXTINT4_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 4 > ; # [doc = "Field `EXTINT5` reader - External Interrupt 5"]
pub type EXTINT5_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT5` writer - External Interrupt 5"]
pub type EXTINT5_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 5 > ; # [doc = "Field `EXTINT6` reader - External Interrupt 6"]
pub type EXTINT6_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT6` writer - External Interrupt 6"]
pub type EXTINT6_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 6 > ; # [doc = "Field `EXTINT7` reader - External Interrupt 7"]
pub type EXTINT7_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT7` writer - External Interrupt 7"]
pub type EXTINT7_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 7 > ; # [doc = "Field `EXTINT8` reader - External Interrupt 8"]
pub type EXTINT8_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT8` writer - External Interrupt 8"]
pub type EXTINT8_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 8 > ; # [doc = "Field `EXTINT9` reader - External Interrupt 9"]
pub type EXTINT9_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT9` writer - External Interrupt 9"]
pub type EXTINT9_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 9 > ; # [doc = "Field `EXTINT10` reader - External Interrupt 10"]
pub type EXTINT10_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT10` writer - External Interrupt 10"]
pub type EXTINT10_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 10 > ; # [doc = "Field `EXTINT11` reader - External Interrupt 11"]
pub type EXTINT11_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT11` writer - External Interrupt 11"]
pub type EXTINT11_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 11 > ; # [doc = "Field `EXTINT12` reader - External Interrupt 12"]
pub type EXTINT12_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT12` writer - External Interrupt 12"]
pub type EXTINT12_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 12 > ; # [doc = "Field `EXTINT13` reader - External Interrupt 13"]
pub type EXTINT13_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT13` writer - External Interrupt 13"]
pub type EXTINT13_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 13 > ; # [doc = "Field `EXTINT14` reader - External Interrupt 14"]
pub type EXTINT14_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT14` writer - External Interrupt 14"]
pub type EXTINT14_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 14 > ; # [doc = "Field `EXTINT15` reader - External Interrupt 15"]
pub type EXTINT15_R = crate :: BitReader < bool > ; # [doc = "Field `EXTINT15` writer - External Interrupt 15"]
pub type EXTINT15_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 15 > ; impl R { # [doc = "Bit 0 - External Interrupt 0"]
# [inline (always)]
pub fn extint0 (& self) -> EXTINT0_R { EXTINT0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - External Interrupt 1"]
# [inline (always)]
pub fn extint1 (& self) -> EXTINT1_R { EXTINT1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - External Interrupt 2"]
# [inline (always)]
pub fn extint2 (& self) -> EXTINT2_R { EXTINT2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - External Interrupt 3"]
# [inline (always)]
pub fn extint3 (& self) -> EXTINT3_R { EXTINT3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - External Interrupt 4"]
# [inline (always)]
pub fn extint4 (& self) -> EXTINT4_R { EXTINT4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - External Interrupt 5"]
# [inline (always)]
pub fn extint5 (& self) -> EXTINT5_R { EXTINT5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - External Interrupt 6"]
# [inline (always)]
pub fn extint6 (& self) -> EXTINT6_R { EXTINT6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - External Interrupt 7"]
# [inline (always)]
pub fn extint7 (& self) -> EXTINT7_R { EXTINT7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - External Interrupt 8"]
# [inline (always)]
pub fn extint8 (& self) -> EXTINT8_R { EXTINT8_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - External Interrupt 9"]
# [inline (always)]
pub fn extint9 (& self) -> EXTINT9_R { EXTINT9_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - External Interrupt 10"]
# [inline (always)]
pub fn extint10 (& self) -> EXTINT10_R { EXTINT10_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - External Interrupt 11"]
# [inline (always)]
pub fn extint11 (& self) -> EXTINT11_R { EXTINT11_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - External Interrupt 12"]
# [inline (always)]
pub fn extint12 (& self) -> EXTINT12_R { EXTINT12_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - External Interrupt 13"]
# [inline (always)]
pub fn extint13 (& self) -> EXTINT13_R { EXTINT13_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - External Interrupt 14"]
# [inline (always)]
pub fn extint14 (& self) -> EXTINT14_R { EXTINT14_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - External Interrupt 15"]
# [inline (always)]
pub fn extint15 (& self) -> EXTINT15_R { EXTINT15_R :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bit 0 - External Interrupt 0"]
# [inline (always)]
pub fn extint0 (& mut self) -> EXTINT0_W { EXTINT0_W :: new (self) } # [doc = "Bit 1 - External Interrupt 1"]
# [inline (always)]
pub fn extint1 (& mut self) -> EXTINT1_W { EXTINT1_W :: new (self) } # [doc = "Bit 2 - External Interrupt 2"]
# [inline (always)]
pub fn extint2 (& mut self) -> EXTINT2_W { EXTINT2_W :: new (self) } # [doc = "Bit 3 - External Interrupt 3"]
# [inline (always)]
pub fn extint3 (& mut self) -> EXTINT3_W { EXTINT3_W :: new (self) } # [doc = "Bit 4 - External Interrupt 4"]
# [inline (always)]
pub fn extint4 (& mut self) -> EXTINT4_W { EXTINT4_W :: new (self) } # [doc = "Bit 5 - External Interrupt 5"]
# [inline (always)]
pub fn extint5 (& mut self) -> EXTINT5_W { EXTINT5_W :: new (self) } # [doc = "Bit 6 - External Interrupt 6"]
# [inline (always)]
pub fn extint6 (& mut self) -> EXTINT6_W { EXTINT6_W :: new (self) } # [doc = "Bit 7 - External Interrupt 7"]
# [inline (always)]
pub fn extint7 (& mut self) -> EXTINT7_W { EXTINT7_W :: new (self) } # [doc = "Bit 8 - External Interrupt 8"]
# [inline (always)]
pub fn extint8 (& mut self) -> EXTINT8_W { EXTINT8_W :: new (self) } # [doc = "Bit 9 - External Interrupt 9"]
# [inline (always)]
pub fn extint9 (& mut self) -> EXTINT9_W { EXTINT9_W :: new (self) } # [doc = "Bit 10 - External Interrupt 10"]
# [inline (always)]
pub fn extint10 (& mut self) -> EXTINT10_W { EXTINT10_W :: new (self) } # [doc = "Bit 11 - External Interrupt 11"]
# [inline (always)]
pub fn extint11 (& mut self) -> EXTINT11_W { EXTINT11_W :: new (self) } # [doc = "Bit 12 - External Interrupt 12"]
# [inline (always)]
pub fn extint12 (& mut self) -> EXTINT12_W { EXTINT12_W :: new (self) } # [doc = "Bit 13 - External Interrupt 13"]
# [inline (always)]
pub fn extint13 (& mut self) -> EXTINT13_W { EXTINT13_W :: new (self) } # [doc = "Bit 14 - External Interrupt 14"]
# [inline (always)]
pub fn extint14 (& mut self) -> EXTINT14_W { EXTINT14_W :: new (self) } # [doc = "Bit 15 - External Interrupt 15"]
# [inline (always)]
pub fn extint15 (& mut self) -> EXTINT15_W { EXTINT15_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflag](index.html) module"]
pub struct INTFLAG_SPEC ; impl crate :: RegisterSpec for INTFLAG_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [intflag::R](R) reader structure"]
impl crate :: Readable for INTFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflag::W](W) writer structure"]
impl crate :: Writable for INTFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTFLAG to value 0"]
impl crate :: Resettable for INTFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "WAKEUP register accessor: an alias for `Reg<WAKEUP_SPEC>`"]
pub type WAKEUP = crate :: Reg < wakeup :: WAKEUP_SPEC > ; # [doc = "Wake-Up Enable"]
pub mod wakeup { # [doc = "Register `WAKEUP` reader"]
pub struct R (crate :: R < WAKEUP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < WAKEUP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < WAKEUP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < WAKEUP_SPEC >) -> Self { R (reader) } } # [doc = "Register `WAKEUP` writer"]
pub struct W (crate :: W < WAKEUP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < WAKEUP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < WAKEUP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < WAKEUP_SPEC >) -> Self { W (writer) } } # [doc = "Field `WAKEUPEN0` reader - External Interrupt 0 Wake-up Enable"]
pub type WAKEUPEN0_R = crate :: BitReader < bool > ; # [doc = "Field `WAKEUPEN0` writer - External Interrupt 0 Wake-up Enable"]
pub type WAKEUPEN0_W < 'a > = crate :: BitWriter < 'a , u32 , WAKEUP_SPEC , bool , 0 > ; # [doc = "Field `WAKEUPEN1` reader - External Interrupt 1 Wake-up Enable"]
pub type WAKEUPEN1_R = crate :: BitReader < bool > ; # [doc = "Field `WAKEUPEN1` writer - External Interrupt 1 Wake-up Enable"]
pub type WAKEUPEN1_W < 'a > = crate :: BitWriter < 'a , u32 , WAKEUP_SPEC , bool , 1 > ; # [doc = "Field `WAKEUPEN2` reader - External Interrupt 2 Wake-up Enable"]
pub type WAKEUPEN2_R = crate :: BitReader < bool > ; # [doc = "Field `WAKEUPEN2` writer - External Interrupt 2 Wake-up Enable"]
pub type WAKEUPEN2_W < 'a > = crate :: BitWriter < 'a , u32 , WAKEUP_SPEC , bool , 2 > ; # [doc = "Field `WAKEUPEN3` reader - External Interrupt 3 Wake-up Enable"]
pub type WAKEUPEN3_R = crate :: BitReader < bool > ; # [doc = "Field `WAKEUPEN3` writer - External Interrupt 3 Wake-up Enable"]
pub type WAKEUPEN3_W < 'a > = crate :: BitWriter < 'a , u32 , WAKEUP_SPEC , bool , 3 > ; # [doc = "Field `WAKEUPEN4` reader - External Interrupt 4 Wake-up Enable"]
pub type WAKEUPEN4_R = crate :: BitReader < bool > ; # [doc = "Field `WAKEUPEN4` writer - External Interrupt 4 Wake-up Enable"]
pub type WAKEUPEN4_W < 'a > = crate :: BitWriter < 'a , u32 , WAKEUP_SPEC , bool , 4 > ; # [doc = "Field `WAKEUPEN5` reader - External Interrupt 5 Wake-up Enable"]
pub type WAKEUPEN5_R = crate :: BitReader < bool > ; # [doc = "Field `WAKEUPEN5` writer - External Interrupt 5 Wake-up Enable"]
pub type WAKEUPEN5_W < 'a > = crate :: BitWriter < 'a , u32 , WAKEUP_SPEC , bool , 5 > ; # [doc = "Field `WAKEUPEN6` reader - External Interrupt 6 Wake-up Enable"]
pub type WAKEUPEN6_R = crate :: BitReader < bool > ; # [doc = "Field `WAKEUPEN6` writer - External Interrupt 6 Wake-up Enable"]
pub type WAKEUPEN6_W < 'a > = crate :: BitWriter < 'a , u32 , WAKEUP_SPEC , bool , 6 > ; # [doc = "Field `WAKEUPEN7` reader - External Interrupt 7 Wake-up Enable"]
pub type WAKEUPEN7_R = crate :: BitReader < bool > ; # [doc = "Field `WAKEUPEN7` writer - External Interrupt 7 Wake-up Enable"]
pub type WAKEUPEN7_W < 'a > = crate :: BitWriter < 'a , u32 , WAKEUP_SPEC , bool , 7 > ; # [doc = "Field `WAKEUPEN8` reader - External Interrupt 8 Wake-up Enable"]
pub type WAKEUPEN8_R = crate :: BitReader < bool > ; # [doc = "Field `WAKEUPEN8` writer - External Interrupt 8 Wake-up Enable"]
pub type WAKEUPEN8_W < 'a > = crate :: BitWriter < 'a , u32 , WAKEUP_SPEC , bool , 8 > ; # [doc = "Field `WAKEUPEN9` reader - External Interrupt 9 Wake-up Enable"]
pub type WAKEUPEN9_R = crate :: BitReader < bool > ; # [doc = "Field `WAKEUPEN9` writer - External Interrupt 9 Wake-up Enable"]
pub type WAKEUPEN9_W < 'a > = crate :: BitWriter < 'a , u32 , WAKEUP_SPEC , bool , 9 > ; # [doc = "Field `WAKEUPEN10` reader - External Interrupt 10 Wake-up Enable"]
pub type WAKEUPEN10_R = crate :: BitReader < bool > ; # [doc = "Field `WAKEUPEN10` writer - External Interrupt 10 Wake-up Enable"]
pub type WAKEUPEN10_W < 'a > = crate :: BitWriter < 'a , u32 , WAKEUP_SPEC , bool , 10 > ; # [doc = "Field `WAKEUPEN11` reader - External Interrupt 11 Wake-up Enable"]
pub type WAKEUPEN11_R = crate :: BitReader < bool > ; # [doc = "Field `WAKEUPEN11` writer - External Interrupt 11 Wake-up Enable"]
pub type WAKEUPEN11_W < 'a > = crate :: BitWriter < 'a , u32 , WAKEUP_SPEC , bool , 11 > ; # [doc = "Field `WAKEUPEN12` reader - External Interrupt 12 Wake-up Enable"]
pub type WAKEUPEN12_R = crate :: BitReader < bool > ; # [doc = "Field `WAKEUPEN12` writer - External Interrupt 12 Wake-up Enable"]
pub type WAKEUPEN12_W < 'a > = crate :: BitWriter < 'a , u32 , WAKEUP_SPEC , bool , 12 > ; # [doc = "Field `WAKEUPEN13` reader - External Interrupt 13 Wake-up Enable"]
pub type WAKEUPEN13_R = crate :: BitReader < bool > ; # [doc = "Field `WAKEUPEN13` writer - External Interrupt 13 Wake-up Enable"]
pub type WAKEUPEN13_W < 'a > = crate :: BitWriter < 'a , u32 , WAKEUP_SPEC , bool , 13 > ; # [doc = "Field `WAKEUPEN14` reader - External Interrupt 14 Wake-up Enable"]
pub type WAKEUPEN14_R = crate :: BitReader < bool > ; # [doc = "Field `WAKEUPEN14` writer - External Interrupt 14 Wake-up Enable"]
pub type WAKEUPEN14_W < 'a > = crate :: BitWriter < 'a , u32 , WAKEUP_SPEC , bool , 14 > ; # [doc = "Field `WAKEUPEN15` reader - External Interrupt 15 Wake-up Enable"]
pub type WAKEUPEN15_R = crate :: BitReader < bool > ; # [doc = "Field `WAKEUPEN15` writer - External Interrupt 15 Wake-up Enable"]
pub type WAKEUPEN15_W < 'a > = crate :: BitWriter < 'a , u32 , WAKEUP_SPEC , bool , 15 > ; impl R { # [doc = "Bit 0 - External Interrupt 0 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen0 (& self) -> WAKEUPEN0_R { WAKEUPEN0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - External Interrupt 1 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen1 (& self) -> WAKEUPEN1_R { WAKEUPEN1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - External Interrupt 2 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen2 (& self) -> WAKEUPEN2_R { WAKEUPEN2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - External Interrupt 3 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen3 (& self) -> WAKEUPEN3_R { WAKEUPEN3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - External Interrupt 4 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen4 (& self) -> WAKEUPEN4_R { WAKEUPEN4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - External Interrupt 5 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen5 (& self) -> WAKEUPEN5_R { WAKEUPEN5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - External Interrupt 6 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen6 (& self) -> WAKEUPEN6_R { WAKEUPEN6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - External Interrupt 7 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen7 (& self) -> WAKEUPEN7_R { WAKEUPEN7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - External Interrupt 8 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen8 (& self) -> WAKEUPEN8_R { WAKEUPEN8_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - External Interrupt 9 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen9 (& self) -> WAKEUPEN9_R { WAKEUPEN9_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - External Interrupt 10 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen10 (& self) -> WAKEUPEN10_R { WAKEUPEN10_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - External Interrupt 11 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen11 (& self) -> WAKEUPEN11_R { WAKEUPEN11_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - External Interrupt 12 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen12 (& self) -> WAKEUPEN12_R { WAKEUPEN12_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - External Interrupt 13 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen13 (& self) -> WAKEUPEN13_R { WAKEUPEN13_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - External Interrupt 14 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen14 (& self) -> WAKEUPEN14_R { WAKEUPEN14_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - External Interrupt 15 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen15 (& self) -> WAKEUPEN15_R { WAKEUPEN15_R :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bit 0 - External Interrupt 0 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen0 (& mut self) -> WAKEUPEN0_W { WAKEUPEN0_W :: new (self) } # [doc = "Bit 1 - External Interrupt 1 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen1 (& mut self) -> WAKEUPEN1_W { WAKEUPEN1_W :: new (self) } # [doc = "Bit 2 - External Interrupt 2 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen2 (& mut self) -> WAKEUPEN2_W { WAKEUPEN2_W :: new (self) } # [doc = "Bit 3 - External Interrupt 3 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen3 (& mut self) -> WAKEUPEN3_W { WAKEUPEN3_W :: new (self) } # [doc = "Bit 4 - External Interrupt 4 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen4 (& mut self) -> WAKEUPEN4_W { WAKEUPEN4_W :: new (self) } # [doc = "Bit 5 - External Interrupt 5 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen5 (& mut self) -> WAKEUPEN5_W { WAKEUPEN5_W :: new (self) } # [doc = "Bit 6 - External Interrupt 6 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen6 (& mut self) -> WAKEUPEN6_W { WAKEUPEN6_W :: new (self) } # [doc = "Bit 7 - External Interrupt 7 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen7 (& mut self) -> WAKEUPEN7_W { WAKEUPEN7_W :: new (self) } # [doc = "Bit 8 - External Interrupt 8 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen8 (& mut self) -> WAKEUPEN8_W { WAKEUPEN8_W :: new (self) } # [doc = "Bit 9 - External Interrupt 9 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen9 (& mut self) -> WAKEUPEN9_W { WAKEUPEN9_W :: new (self) } # [doc = "Bit 10 - External Interrupt 10 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen10 (& mut self) -> WAKEUPEN10_W { WAKEUPEN10_W :: new (self) } # [doc = "Bit 11 - External Interrupt 11 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen11 (& mut self) -> WAKEUPEN11_W { WAKEUPEN11_W :: new (self) } # [doc = "Bit 12 - External Interrupt 12 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen12 (& mut self) -> WAKEUPEN12_W { WAKEUPEN12_W :: new (self) } # [doc = "Bit 13 - External Interrupt 13 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen13 (& mut self) -> WAKEUPEN13_W { WAKEUPEN13_W :: new (self) } # [doc = "Bit 14 - External Interrupt 14 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen14 (& mut self) -> WAKEUPEN14_W { WAKEUPEN14_W :: new (self) } # [doc = "Bit 15 - External Interrupt 15 Wake-up Enable"]
# [inline (always)]
pub fn wakeupen15 (& mut self) -> WAKEUPEN15_W { WAKEUPEN15_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Wake-Up Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [wakeup](index.html) module"]
pub struct WAKEUP_SPEC ; impl crate :: RegisterSpec for WAKEUP_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [wakeup::R](R) reader structure"]
impl crate :: Readable for WAKEUP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [wakeup::W](W) writer structure"]
impl crate :: Writable for WAKEUP_SPEC { type Writer = W ; } # [doc = "`reset()` method sets WAKEUP to value 0"]
impl crate :: Resettable for WAKEUP_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CONFIG register accessor: an alias for `Reg<CONFIG_SPEC>`"]
pub type CONFIG = crate :: Reg < config :: CONFIG_SPEC > ; # [doc = "Configuration n"]
pub mod config { # [doc = "Register `CONFIG%s` reader"]
pub struct R (crate :: R < CONFIG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CONFIG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CONFIG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CONFIG_SPEC >) -> Self { R (reader) } } # [doc = "Register `CONFIG%s` writer"]
pub struct W (crate :: W < CONFIG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CONFIG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CONFIG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CONFIG_SPEC >) -> Self { W (writer) } } # [doc = "Input Sense 0 Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum SENSE0_A { # [doc = "0: No detection"]
NONE = 0 , # [doc = "1: Rising-edge detection"]
RISE = 1 , # [doc = "2: Falling-edge detection"]
FALL = 2 , # [doc = "3: Both-edges detection"]
BOTH = 3 , # [doc = "4: High-level detection"]
HIGH = 4 , # [doc = "5: Low-level detection"]
LOW = 5 , } impl From < SENSE0_A > for u8 { # [inline (always)]
fn from (variant : SENSE0_A) -> Self { variant as _ } } # [doc = "Field `SENSE0` reader - Input Sense 0 Configuration"]
pub type SENSE0_R = crate :: FieldReader < u8 , SENSE0_A > ; impl SENSE0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SENSE0_A > { match self . bits { 0 => Some (SENSE0_A :: NONE) , 1 => Some (SENSE0_A :: RISE) , 2 => Some (SENSE0_A :: FALL) , 3 => Some (SENSE0_A :: BOTH) , 4 => Some (SENSE0_A :: HIGH) , 5 => Some (SENSE0_A :: LOW) , _ => None , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == SENSE0_A :: NONE } # [doc = "Checks if the value of the field is `RISE`"]
# [inline (always)]
pub fn is_rise (& self) -> bool { * self == SENSE0_A :: RISE } # [doc = "Checks if the value of the field is `FALL`"]
# [inline (always)]
pub fn is_fall (& self) -> bool { * self == SENSE0_A :: FALL } # [doc = "Checks if the value of the field is `BOTH`"]
# [inline (always)]
pub fn is_both (& self) -> bool { * self == SENSE0_A :: BOTH } # [doc = "Checks if the value of the field is `HIGH`"]
# [inline (always)]
pub fn is_high (& self) -> bool { * self == SENSE0_A :: HIGH } # [doc = "Checks if the value of the field is `LOW`"]
# [inline (always)]
pub fn is_low (& self) -> bool { * self == SENSE0_A :: LOW } } # [doc = "Field `SENSE0` writer - Input Sense 0 Configuration"]
pub type SENSE0_W < 'a > = crate :: FieldWriter < 'a , u32 , CONFIG_SPEC , u8 , SENSE0_A , 3 , 0 > ; impl < 'a > SENSE0_W < 'a > { # [doc = "No detection"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (SENSE0_A :: NONE) } # [doc = "Rising-edge detection"]
# [inline (always)]
pub fn rise (self) -> & 'a mut W { self . variant (SENSE0_A :: RISE) } # [doc = "Falling-edge detection"]
# [inline (always)]
pub fn fall (self) -> & 'a mut W { self . variant (SENSE0_A :: FALL) } # [doc = "Both-edges detection"]
# [inline (always)]
pub fn both (self) -> & 'a mut W { self . variant (SENSE0_A :: BOTH) } # [doc = "High-level detection"]
# [inline (always)]
pub fn high (self) -> & 'a mut W { self . variant (SENSE0_A :: HIGH) } # [doc = "Low-level detection"]
# [inline (always)]
pub fn low (self) -> & 'a mut W { self . variant (SENSE0_A :: LOW) } } # [doc = "Field `FILTEN0` reader - Filter 0 Enable"]
pub type FILTEN0_R = crate :: BitReader < bool > ; # [doc = "Field `FILTEN0` writer - Filter 0 Enable"]
pub type FILTEN0_W < 'a > = crate :: BitWriter < 'a , u32 , CONFIG_SPEC , bool , 3 > ; # [doc = "Input Sense 1 Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum SENSE1_A { # [doc = "0: No detection"]
NONE = 0 , # [doc = "1: Rising edge detection"]
RISE = 1 , # [doc = "2: Falling edge detection"]
FALL = 2 , # [doc = "3: Both edges detection"]
BOTH = 3 , # [doc = "4: High level detection"]
HIGH = 4 , # [doc = "5: Low level detection"]
LOW = 5 , } impl From < SENSE1_A > for u8 { # [inline (always)]
fn from (variant : SENSE1_A) -> Self { variant as _ } } # [doc = "Field `SENSE1` reader - Input Sense 1 Configuration"]
pub type SENSE1_R = crate :: FieldReader < u8 , SENSE1_A > ; impl SENSE1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SENSE1_A > { match self . bits { 0 => Some (SENSE1_A :: NONE) , 1 => Some (SENSE1_A :: RISE) , 2 => Some (SENSE1_A :: FALL) , 3 => Some (SENSE1_A :: BOTH) , 4 => Some (SENSE1_A :: HIGH) , 5 => Some (SENSE1_A :: LOW) , _ => None , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == SENSE1_A :: NONE } # [doc = "Checks if the value of the field is `RISE`"]
# [inline (always)]
pub fn is_rise (& self) -> bool { * self == SENSE1_A :: RISE } # [doc = "Checks if the value of the field is `FALL`"]
# [inline (always)]
pub fn is_fall (& self) -> bool { * self == SENSE1_A :: FALL } # [doc = "Checks if the value of the field is `BOTH`"]
# [inline (always)]
pub fn is_both (& self) -> bool { * self == SENSE1_A :: BOTH } # [doc = "Checks if the value of the field is `HIGH`"]
# [inline (always)]
pub fn is_high (& self) -> bool { * self == SENSE1_A :: HIGH } # [doc = "Checks if the value of the field is `LOW`"]
# [inline (always)]
pub fn is_low (& self) -> bool { * self == SENSE1_A :: LOW } } # [doc = "Field `SENSE1` writer - Input Sense 1 Configuration"]
pub type SENSE1_W < 'a > = crate :: FieldWriter < 'a , u32 , CONFIG_SPEC , u8 , SENSE1_A , 3 , 4 > ; impl < 'a > SENSE1_W < 'a > { # [doc = "No detection"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (SENSE1_A :: NONE) } # [doc = "Rising edge detection"]
# [inline (always)]
pub fn rise (self) -> & 'a mut W { self . variant (SENSE1_A :: RISE) } # [doc = "Falling edge detection"]
# [inline (always)]
pub fn fall (self) -> & 'a mut W { self . variant (SENSE1_A :: FALL) } # [doc = "Both edges detection"]
# [inline (always)]
pub fn both (self) -> & 'a mut W { self . variant (SENSE1_A :: BOTH) } # [doc = "High level detection"]
# [inline (always)]
pub fn high (self) -> & 'a mut W { self . variant (SENSE1_A :: HIGH) } # [doc = "Low level detection"]
# [inline (always)]
pub fn low (self) -> & 'a mut W { self . variant (SENSE1_A :: LOW) } } # [doc = "Field `FILTEN1` reader - Filter 1 Enable"]
pub type FILTEN1_R = crate :: BitReader < bool > ; # [doc = "Field `FILTEN1` writer - Filter 1 Enable"]
pub type FILTEN1_W < 'a > = crate :: BitWriter < 'a , u32 , CONFIG_SPEC , bool , 7 > ; # [doc = "Input Sense 2 Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum SENSE2_A { # [doc = "0: No detection"]
NONE = 0 , # [doc = "1: Rising edge detection"]
RISE = 1 , # [doc = "2: Falling edge detection"]
FALL = 2 , # [doc = "3: Both edges detection"]
BOTH = 3 , # [doc = "4: High level detection"]
HIGH = 4 , # [doc = "5: Low level detection"]
LOW = 5 , } impl From < SENSE2_A > for u8 { # [inline (always)]
fn from (variant : SENSE2_A) -> Self { variant as _ } } # [doc = "Field `SENSE2` reader - Input Sense 2 Configuration"]
pub type SENSE2_R = crate :: FieldReader < u8 , SENSE2_A > ; impl SENSE2_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SENSE2_A > { match self . bits { 0 => Some (SENSE2_A :: NONE) , 1 => Some (SENSE2_A :: RISE) , 2 => Some (SENSE2_A :: FALL) , 3 => Some (SENSE2_A :: BOTH) , 4 => Some (SENSE2_A :: HIGH) , 5 => Some (SENSE2_A :: LOW) , _ => None , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == SENSE2_A :: NONE } # [doc = "Checks if the value of the field is `RISE`"]
# [inline (always)]
pub fn is_rise (& self) -> bool { * self == SENSE2_A :: RISE } # [doc = "Checks if the value of the field is `FALL`"]
# [inline (always)]
pub fn is_fall (& self) -> bool { * self == SENSE2_A :: FALL } # [doc = "Checks if the value of the field is `BOTH`"]
# [inline (always)]
pub fn is_both (& self) -> bool { * self == SENSE2_A :: BOTH } # [doc = "Checks if the value of the field is `HIGH`"]
# [inline (always)]
pub fn is_high (& self) -> bool { * self == SENSE2_A :: HIGH } # [doc = "Checks if the value of the field is `LOW`"]
# [inline (always)]
pub fn is_low (& self) -> bool { * self == SENSE2_A :: LOW } } # [doc = "Field `SENSE2` writer - Input Sense 2 Configuration"]
pub type SENSE2_W < 'a > = crate :: FieldWriter < 'a , u32 , CONFIG_SPEC , u8 , SENSE2_A , 3 , 8 > ; impl < 'a > SENSE2_W < 'a > { # [doc = "No detection"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (SENSE2_A :: NONE) } # [doc = "Rising edge detection"]
# [inline (always)]
pub fn rise (self) -> & 'a mut W { self . variant (SENSE2_A :: RISE) } # [doc = "Falling edge detection"]
# [inline (always)]
pub fn fall (self) -> & 'a mut W { self . variant (SENSE2_A :: FALL) } # [doc = "Both edges detection"]
# [inline (always)]
pub fn both (self) -> & 'a mut W { self . variant (SENSE2_A :: BOTH) } # [doc = "High level detection"]
# [inline (always)]
pub fn high (self) -> & 'a mut W { self . variant (SENSE2_A :: HIGH) } # [doc = "Low level detection"]
# [inline (always)]
pub fn low (self) -> & 'a mut W { self . variant (SENSE2_A :: LOW) } } # [doc = "Field `FILTEN2` reader - Filter 2 Enable"]
pub type FILTEN2_R = crate :: BitReader < bool > ; # [doc = "Field `FILTEN2` writer - Filter 2 Enable"]
pub type FILTEN2_W < 'a > = crate :: BitWriter < 'a , u32 , CONFIG_SPEC , bool , 11 > ; # [doc = "Input Sense 3 Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum SENSE3_A { # [doc = "0: No detection"]
NONE = 0 , # [doc = "1: Rising edge detection"]
RISE = 1 , # [doc = "2: Falling edge detection"]
FALL = 2 , # [doc = "3: Both edges detection"]
BOTH = 3 , # [doc = "4: High level detection"]
HIGH = 4 , # [doc = "5: Low level detection"]
LOW = 5 , } impl From < SENSE3_A > for u8 { # [inline (always)]
fn from (variant : SENSE3_A) -> Self { variant as _ } } # [doc = "Field `SENSE3` reader - Input Sense 3 Configuration"]
pub type SENSE3_R = crate :: FieldReader < u8 , SENSE3_A > ; impl SENSE3_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SENSE3_A > { match self . bits { 0 => Some (SENSE3_A :: NONE) , 1 => Some (SENSE3_A :: RISE) , 2 => Some (SENSE3_A :: FALL) , 3 => Some (SENSE3_A :: BOTH) , 4 => Some (SENSE3_A :: HIGH) , 5 => Some (SENSE3_A :: LOW) , _ => None , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == SENSE3_A :: NONE } # [doc = "Checks if the value of the field is `RISE`"]
# [inline (always)]
pub fn is_rise (& self) -> bool { * self == SENSE3_A :: RISE } # [doc = "Checks if the value of the field is `FALL`"]
# [inline (always)]
pub fn is_fall (& self) -> bool { * self == SENSE3_A :: FALL } # [doc = "Checks if the value of the field is `BOTH`"]
# [inline (always)]
pub fn is_both (& self) -> bool { * self == SENSE3_A :: BOTH } # [doc = "Checks if the value of the field is `HIGH`"]
# [inline (always)]
pub fn is_high (& self) -> bool { * self == SENSE3_A :: HIGH } # [doc = "Checks if the value of the field is `LOW`"]
# [inline (always)]
pub fn is_low (& self) -> bool { * self == SENSE3_A :: LOW } } # [doc = "Field `SENSE3` writer - Input Sense 3 Configuration"]
pub type SENSE3_W < 'a > = crate :: FieldWriter < 'a , u32 , CONFIG_SPEC , u8 , SENSE3_A , 3 , 12 > ; impl < 'a > SENSE3_W < 'a > { # [doc = "No detection"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (SENSE3_A :: NONE) } # [doc = "Rising edge detection"]
# [inline (always)]
pub fn rise (self) -> & 'a mut W { self . variant (SENSE3_A :: RISE) } # [doc = "Falling edge detection"]
# [inline (always)]
pub fn fall (self) -> & 'a mut W { self . variant (SENSE3_A :: FALL) } # [doc = "Both edges detection"]
# [inline (always)]
pub fn both (self) -> & 'a mut W { self . variant (SENSE3_A :: BOTH) } # [doc = "High level detection"]
# [inline (always)]
pub fn high (self) -> & 'a mut W { self . variant (SENSE3_A :: HIGH) } # [doc = "Low level detection"]
# [inline (always)]
pub fn low (self) -> & 'a mut W { self . variant (SENSE3_A :: LOW) } } # [doc = "Field `FILTEN3` reader - Filter 3 Enable"]
pub type FILTEN3_R = crate :: BitReader < bool > ; # [doc = "Field `FILTEN3` writer - Filter 3 Enable"]
pub type FILTEN3_W < 'a > = crate :: BitWriter < 'a , u32 , CONFIG_SPEC , bool , 15 > ; # [doc = "Input Sense 4 Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum SENSE4_A { # [doc = "0: No detection"]
NONE = 0 , # [doc = "1: Rising edge detection"]
RISE = 1 , # [doc = "2: Falling edge detection"]
FALL = 2 , # [doc = "3: Both edges detection"]
BOTH = 3 , # [doc = "4: High level detection"]
HIGH = 4 , # [doc = "5: Low level detection"]
LOW = 5 , } impl From < SENSE4_A > for u8 { # [inline (always)]
fn from (variant : SENSE4_A) -> Self { variant as _ } } # [doc = "Field `SENSE4` reader - Input Sense 4 Configuration"]
pub type SENSE4_R = crate :: FieldReader < u8 , SENSE4_A > ; impl SENSE4_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SENSE4_A > { match self . bits { 0 => Some (SENSE4_A :: NONE) , 1 => Some (SENSE4_A :: RISE) , 2 => Some (SENSE4_A :: FALL) , 3 => Some (SENSE4_A :: BOTH) , 4 => Some (SENSE4_A :: HIGH) , 5 => Some (SENSE4_A :: LOW) , _ => None , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == SENSE4_A :: NONE } # [doc = "Checks if the value of the field is `RISE`"]
# [inline (always)]
pub fn is_rise (& self) -> bool { * self == SENSE4_A :: RISE } # [doc = "Checks if the value of the field is `FALL`"]
# [inline (always)]
pub fn is_fall (& self) -> bool { * self == SENSE4_A :: FALL } # [doc = "Checks if the value of the field is `BOTH`"]
# [inline (always)]
pub fn is_both (& self) -> bool { * self == SENSE4_A :: BOTH } # [doc = "Checks if the value of the field is `HIGH`"]
# [inline (always)]
pub fn is_high (& self) -> bool { * self == SENSE4_A :: HIGH } # [doc = "Checks if the value of the field is `LOW`"]
# [inline (always)]
pub fn is_low (& self) -> bool { * self == SENSE4_A :: LOW } } # [doc = "Field `SENSE4` writer - Input Sense 4 Configuration"]
pub type SENSE4_W < 'a > = crate :: FieldWriter < 'a , u32 , CONFIG_SPEC , u8 , SENSE4_A , 3 , 16 > ; impl < 'a > SENSE4_W < 'a > { # [doc = "No detection"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (SENSE4_A :: NONE) } # [doc = "Rising edge detection"]
# [inline (always)]
pub fn rise (self) -> & 'a mut W { self . variant (SENSE4_A :: RISE) } # [doc = "Falling edge detection"]
# [inline (always)]
pub fn fall (self) -> & 'a mut W { self . variant (SENSE4_A :: FALL) } # [doc = "Both edges detection"]
# [inline (always)]
pub fn both (self) -> & 'a mut W { self . variant (SENSE4_A :: BOTH) } # [doc = "High level detection"]
# [inline (always)]
pub fn high (self) -> & 'a mut W { self . variant (SENSE4_A :: HIGH) } # [doc = "Low level detection"]
# [inline (always)]
pub fn low (self) -> & 'a mut W { self . variant (SENSE4_A :: LOW) } } # [doc = "Field `FILTEN4` reader - Filter 4 Enable"]
pub type FILTEN4_R = crate :: BitReader < bool > ; # [doc = "Field `FILTEN4` writer - Filter 4 Enable"]
pub type FILTEN4_W < 'a > = crate :: BitWriter < 'a , u32 , CONFIG_SPEC , bool , 19 > ; # [doc = "Input Sense 5 Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum SENSE5_A { # [doc = "0: No detection"]
NONE = 0 , # [doc = "1: Rising edge detection"]
RISE = 1 , # [doc = "2: Falling edge detection"]
FALL = 2 , # [doc = "3: Both edges detection"]
BOTH = 3 , # [doc = "4: High level detection"]
HIGH = 4 , # [doc = "5: Low level detection"]
LOW = 5 , } impl From < SENSE5_A > for u8 { # [inline (always)]
fn from (variant : SENSE5_A) -> Self { variant as _ } } # [doc = "Field `SENSE5` reader - Input Sense 5 Configuration"]
pub type SENSE5_R = crate :: FieldReader < u8 , SENSE5_A > ; impl SENSE5_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SENSE5_A > { match self . bits { 0 => Some (SENSE5_A :: NONE) , 1 => Some (SENSE5_A :: RISE) , 2 => Some (SENSE5_A :: FALL) , 3 => Some (SENSE5_A :: BOTH) , 4 => Some (SENSE5_A :: HIGH) , 5 => Some (SENSE5_A :: LOW) , _ => None , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == SENSE5_A :: NONE } # [doc = "Checks if the value of the field is `RISE`"]
# [inline (always)]
pub fn is_rise (& self) -> bool { * self == SENSE5_A :: RISE } # [doc = "Checks if the value of the field is `FALL`"]
# [inline (always)]
pub fn is_fall (& self) -> bool { * self == SENSE5_A :: FALL } # [doc = "Checks if the value of the field is `BOTH`"]
# [inline (always)]
pub fn is_both (& self) -> bool { * self == SENSE5_A :: BOTH } # [doc = "Checks if the value of the field is `HIGH`"]
# [inline (always)]
pub fn is_high (& self) -> bool { * self == SENSE5_A :: HIGH } # [doc = "Checks if the value of the field is `LOW`"]
# [inline (always)]
pub fn is_low (& self) -> bool { * self == SENSE5_A :: LOW } } # [doc = "Field `SENSE5` writer - Input Sense 5 Configuration"]
pub type SENSE5_W < 'a > = crate :: FieldWriter < 'a , u32 , CONFIG_SPEC , u8 , SENSE5_A , 3 , 20 > ; impl < 'a > SENSE5_W < 'a > { # [doc = "No detection"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (SENSE5_A :: NONE) } # [doc = "Rising edge detection"]
# [inline (always)]
pub fn rise (self) -> & 'a mut W { self . variant (SENSE5_A :: RISE) } # [doc = "Falling edge detection"]
# [inline (always)]
pub fn fall (self) -> & 'a mut W { self . variant (SENSE5_A :: FALL) } # [doc = "Both edges detection"]
# [inline (always)]
pub fn both (self) -> & 'a mut W { self . variant (SENSE5_A :: BOTH) } # [doc = "High level detection"]
# [inline (always)]
pub fn high (self) -> & 'a mut W { self . variant (SENSE5_A :: HIGH) } # [doc = "Low level detection"]
# [inline (always)]
pub fn low (self) -> & 'a mut W { self . variant (SENSE5_A :: LOW) } } # [doc = "Field `FILTEN5` reader - Filter 5 Enable"]
pub type FILTEN5_R = crate :: BitReader < bool > ; # [doc = "Field `FILTEN5` writer - Filter 5 Enable"]
pub type FILTEN5_W < 'a > = crate :: BitWriter < 'a , u32 , CONFIG_SPEC , bool , 23 > ; # [doc = "Input Sense 6 Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum SENSE6_A { # [doc = "0: No detection"]
NONE = 0 , # [doc = "1: Rising edge detection"]
RISE = 1 , # [doc = "2: Falling edge detection"]
FALL = 2 , # [doc = "3: Both edges detection"]
BOTH = 3 , # [doc = "4: High level detection"]
HIGH = 4 , # [doc = "5: Low level detection"]
LOW = 5 , } impl From < SENSE6_A > for u8 { # [inline (always)]
fn from (variant : SENSE6_A) -> Self { variant as _ } } # [doc = "Field `SENSE6` reader - Input Sense 6 Configuration"]
pub type SENSE6_R = crate :: FieldReader < u8 , SENSE6_A > ; impl SENSE6_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SENSE6_A > { match self . bits { 0 => Some (SENSE6_A :: NONE) , 1 => Some (SENSE6_A :: RISE) , 2 => Some (SENSE6_A :: FALL) , 3 => Some (SENSE6_A :: BOTH) , 4 => Some (SENSE6_A :: HIGH) , 5 => Some (SENSE6_A :: LOW) , _ => None , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == SENSE6_A :: NONE } # [doc = "Checks if the value of the field is `RISE`"]
# [inline (always)]
pub fn is_rise (& self) -> bool { * self == SENSE6_A :: RISE } # [doc = "Checks if the value of the field is `FALL`"]
# [inline (always)]
pub fn is_fall (& self) -> bool { * self == SENSE6_A :: FALL } # [doc = "Checks if the value of the field is `BOTH`"]
# [inline (always)]
pub fn is_both (& self) -> bool { * self == SENSE6_A :: BOTH } # [doc = "Checks if the value of the field is `HIGH`"]
# [inline (always)]
pub fn is_high (& self) -> bool { * self == SENSE6_A :: HIGH } # [doc = "Checks if the value of the field is `LOW`"]
# [inline (always)]
pub fn is_low (& self) -> bool { * self == SENSE6_A :: LOW } } # [doc = "Field `SENSE6` writer - Input Sense 6 Configuration"]
pub type SENSE6_W < 'a > = crate :: FieldWriter < 'a , u32 , CONFIG_SPEC , u8 , SENSE6_A , 3 , 24 > ; impl < 'a > SENSE6_W < 'a > { # [doc = "No detection"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (SENSE6_A :: NONE) } # [doc = "Rising edge detection"]
# [inline (always)]
pub fn rise (self) -> & 'a mut W { self . variant (SENSE6_A :: RISE) } # [doc = "Falling edge detection"]
# [inline (always)]
pub fn fall (self) -> & 'a mut W { self . variant (SENSE6_A :: FALL) } # [doc = "Both edges detection"]
# [inline (always)]
pub fn both (self) -> & 'a mut W { self . variant (SENSE6_A :: BOTH) } # [doc = "High level detection"]
# [inline (always)]
pub fn high (self) -> & 'a mut W { self . variant (SENSE6_A :: HIGH) } # [doc = "Low level detection"]
# [inline (always)]
pub fn low (self) -> & 'a mut W { self . variant (SENSE6_A :: LOW) } } # [doc = "Field `FILTEN6` reader - Filter 6 Enable"]
pub type FILTEN6_R = crate :: BitReader < bool > ; # [doc = "Field `FILTEN6` writer - Filter 6 Enable"]
pub type FILTEN6_W < 'a > = crate :: BitWriter < 'a , u32 , CONFIG_SPEC , bool , 27 > ; # [doc = "Input Sense 7 Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum SENSE7_A { # [doc = "0: No detection"]
NONE = 0 , # [doc = "1: Rising edge detection"]
RISE = 1 , # [doc = "2: Falling edge detection"]
FALL = 2 , # [doc = "3: Both edges detection"]
BOTH = 3 , # [doc = "4: High level detection"]
HIGH = 4 , # [doc = "5: Low level detection"]
LOW = 5 , } impl From < SENSE7_A > for u8 { # [inline (always)]
fn from (variant : SENSE7_A) -> Self { variant as _ } } # [doc = "Field `SENSE7` reader - Input Sense 7 Configuration"]
pub type SENSE7_R = crate :: FieldReader < u8 , SENSE7_A > ; impl SENSE7_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SENSE7_A > { match self . bits { 0 => Some (SENSE7_A :: NONE) , 1 => Some (SENSE7_A :: RISE) , 2 => Some (SENSE7_A :: FALL) , 3 => Some (SENSE7_A :: BOTH) , 4 => Some (SENSE7_A :: HIGH) , 5 => Some (SENSE7_A :: LOW) , _ => None , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == SENSE7_A :: NONE } # [doc = "Checks if the value of the field is `RISE`"]
# [inline (always)]
pub fn is_rise (& self) -> bool { * self == SENSE7_A :: RISE } # [doc = "Checks if the value of the field is `FALL`"]
# [inline (always)]
pub fn is_fall (& self) -> bool { * self == SENSE7_A :: FALL } # [doc = "Checks if the value of the field is `BOTH`"]
# [inline (always)]
pub fn is_both (& self) -> bool { * self == SENSE7_A :: BOTH } # [doc = "Checks if the value of the field is `HIGH`"]
# [inline (always)]
pub fn is_high (& self) -> bool { * self == SENSE7_A :: HIGH } # [doc = "Checks if the value of the field is `LOW`"]
# [inline (always)]
pub fn is_low (& self) -> bool { * self == SENSE7_A :: LOW } } # [doc = "Field `SENSE7` writer - Input Sense 7 Configuration"]
pub type SENSE7_W < 'a > = crate :: FieldWriter < 'a , u32 , CONFIG_SPEC , u8 , SENSE7_A , 3 , 28 > ; impl < 'a > SENSE7_W < 'a > { # [doc = "No detection"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (SENSE7_A :: NONE) } # [doc = "Rising edge detection"]
# [inline (always)]
pub fn rise (self) -> & 'a mut W { self . variant (SENSE7_A :: RISE) } # [doc = "Falling edge detection"]
# [inline (always)]
pub fn fall (self) -> & 'a mut W { self . variant (SENSE7_A :: FALL) } # [doc = "Both edges detection"]
# [inline (always)]
pub fn both (self) -> & 'a mut W { self . variant (SENSE7_A :: BOTH) } # [doc = "High level detection"]
# [inline (always)]
pub fn high (self) -> & 'a mut W { self . variant (SENSE7_A :: HIGH) } # [doc = "Low level detection"]
# [inline (always)]
pub fn low (self) -> & 'a mut W { self . variant (SENSE7_A :: LOW) } } # [doc = "Field `FILTEN7` reader - Filter 7 Enable"]
pub type FILTEN7_R = crate :: BitReader < bool > ; # [doc = "Field `FILTEN7` writer - Filter 7 Enable"]
pub type FILTEN7_W < 'a > = crate :: BitWriter < 'a , u32 , CONFIG_SPEC , bool , 31 > ; impl R { # [doc = "Bits 0:2 - Input Sense 0 Configuration"]
# [inline (always)]
pub fn sense0 (& self) -> SENSE0_R { SENSE0_R :: new ((self . bits & 7) as u8) } # [doc = "Bit 3 - Filter 0 Enable"]
# [inline (always)]
pub fn filten0 (& self) -> FILTEN0_R { FILTEN0_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:6 - Input Sense 1 Configuration"]
# [inline (always)]
pub fn sense1 (& self) -> SENSE1_R { SENSE1_R :: new (((self . bits >> 4) & 7) as u8) } # [doc = "Bit 7 - Filter 1 Enable"]
# [inline (always)]
pub fn filten1 (& self) -> FILTEN1_R { FILTEN1_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bits 8:10 - Input Sense 2 Configuration"]
# [inline (always)]
pub fn sense2 (& self) -> SENSE2_R { SENSE2_R :: new (((self . bits >> 8) & 7) as u8) } # [doc = "Bit 11 - Filter 2 Enable"]
# [inline (always)]
pub fn filten2 (& self) -> FILTEN2_R { FILTEN2_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bits 12:14 - Input Sense 3 Configuration"]
# [inline (always)]
pub fn sense3 (& self) -> SENSE3_R { SENSE3_R :: new (((self . bits >> 12) & 7) as u8) } # [doc = "Bit 15 - Filter 3 Enable"]
# [inline (always)]
pub fn filten3 (& self) -> FILTEN3_R { FILTEN3_R :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bits 16:18 - Input Sense 4 Configuration"]
# [inline (always)]
pub fn sense4 (& self) -> SENSE4_R { SENSE4_R :: new (((self . bits >> 16) & 7) as u8) } # [doc = "Bit 19 - Filter 4 Enable"]
# [inline (always)]
pub fn filten4 (& self) -> FILTEN4_R { FILTEN4_R :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bits 20:22 - Input Sense 5 Configuration"]
# [inline (always)]
pub fn sense5 (& self) -> SENSE5_R { SENSE5_R :: new (((self . bits >> 20) & 7) as u8) } # [doc = "Bit 23 - Filter 5 Enable"]
# [inline (always)]
pub fn filten5 (& self) -> FILTEN5_R { FILTEN5_R :: new (((self . bits >> 23) & 1) != 0) } # [doc = "Bits 24:26 - Input Sense 6 Configuration"]
# [inline (always)]
pub fn sense6 (& self) -> SENSE6_R { SENSE6_R :: new (((self . bits >> 24) & 7) as u8) } # [doc = "Bit 27 - Filter 6 Enable"]
# [inline (always)]
pub fn filten6 (& self) -> FILTEN6_R { FILTEN6_R :: new (((self . bits >> 27) & 1) != 0) } # [doc = "Bits 28:30 - Input Sense 7 Configuration"]
# [inline (always)]
pub fn sense7 (& self) -> SENSE7_R { SENSE7_R :: new (((self . bits >> 28) & 7) as u8) } # [doc = "Bit 31 - Filter 7 Enable"]
# [inline (always)]
pub fn filten7 (& self) -> FILTEN7_R { FILTEN7_R :: new (((self . bits >> 31) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Input Sense 0 Configuration"]
# [inline (always)]
pub fn sense0 (& mut self) -> SENSE0_W { SENSE0_W :: new (self) } # [doc = "Bit 3 - Filter 0 Enable"]
# [inline (always)]
pub fn filten0 (& mut self) -> FILTEN0_W { FILTEN0_W :: new (self) } # [doc = "Bits 4:6 - Input Sense 1 Configuration"]
# [inline (always)]
pub fn sense1 (& mut self) -> SENSE1_W { SENSE1_W :: new (self) } # [doc = "Bit 7 - Filter 1 Enable"]
# [inline (always)]
pub fn filten1 (& mut self) -> FILTEN1_W { FILTEN1_W :: new (self) } # [doc = "Bits 8:10 - Input Sense 2 Configuration"]
# [inline (always)]
pub fn sense2 (& mut self) -> SENSE2_W { SENSE2_W :: new (self) } # [doc = "Bit 11 - Filter 2 Enable"]
# [inline (always)]
pub fn filten2 (& mut self) -> FILTEN2_W { FILTEN2_W :: new (self) } # [doc = "Bits 12:14 - Input Sense 3 Configuration"]
# [inline (always)]
pub fn sense3 (& mut self) -> SENSE3_W { SENSE3_W :: new (self) } # [doc = "Bit 15 - Filter 3 Enable"]
# [inline (always)]
pub fn filten3 (& mut self) -> FILTEN3_W { FILTEN3_W :: new (self) } # [doc = "Bits 16:18 - Input Sense 4 Configuration"]
# [inline (always)]
pub fn sense4 (& mut self) -> SENSE4_W { SENSE4_W :: new (self) } # [doc = "Bit 19 - Filter 4 Enable"]
# [inline (always)]
pub fn filten4 (& mut self) -> FILTEN4_W { FILTEN4_W :: new (self) } # [doc = "Bits 20:22 - Input Sense 5 Configuration"]
# [inline (always)]
pub fn sense5 (& mut self) -> SENSE5_W { SENSE5_W :: new (self) } # [doc = "Bit 23 - Filter 5 Enable"]
# [inline (always)]
pub fn filten5 (& mut self) -> FILTEN5_W { FILTEN5_W :: new (self) } # [doc = "Bits 24:26 - Input Sense 6 Configuration"]
# [inline (always)]
pub fn sense6 (& mut self) -> SENSE6_W { SENSE6_W :: new (self) } # [doc = "Bit 27 - Filter 6 Enable"]
# [inline (always)]
pub fn filten6 (& mut self) -> FILTEN6_W { FILTEN6_W :: new (self) } # [doc = "Bits 28:30 - Input Sense 7 Configuration"]
# [inline (always)]
pub fn sense7 (& mut self) -> SENSE7_W { SENSE7_W :: new (self) } # [doc = "Bit 31 - Filter 7 Enable"]
# [inline (always)]
pub fn filten7 (& mut self) -> FILTEN7_W { FILTEN7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Configuration n\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [config](index.html) module"]
pub struct CONFIG_SPEC ; impl crate :: RegisterSpec for CONFIG_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [config::R](R) reader structure"]
impl crate :: Readable for CONFIG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [config::W](W) writer structure"]
impl crate :: Writable for CONFIG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CONFIG%s to value 0"]
impl crate :: Resettable for CONFIG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "Event System Interface"]
pub struct EVSYS { _marker : PhantomData < * const () > } unsafe impl Send for EVSYS { } impl EVSYS { # [doc = r"Pointer to the register block"]
pub const PTR : * const evsys :: RegisterBlock = 0x4200_0400 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const evsys :: RegisterBlock { Self :: PTR } } impl Deref for EVSYS { type Target = evsys :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for EVSYS { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("EVSYS") . finish () } } # [doc = "Event System Interface"]
pub mod evsys { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control"]
pub ctrl : crate :: Reg < ctrl :: CTRL_SPEC > , _reserved1 : [u8 ; 0x03]
, # [doc = "0x04 - Channel"]
pub channel : crate :: Reg < channel :: CHANNEL_SPEC > , # [doc = "0x08 - User Multiplexer"]
pub user : crate :: Reg < user :: USER_SPEC > , _reserved3 : [u8 ; 0x02]
, # [doc = "0x0c - Channel Status"]
pub chstatus : crate :: Reg < chstatus :: CHSTATUS_SPEC > , # [doc = "0x10 - Interrupt Enable Clear"]
pub intenclr : crate :: Reg < intenclr :: INTENCLR_SPEC > , # [doc = "0x14 - Interrupt Enable Set"]
pub intenset : crate :: Reg < intenset :: INTENSET_SPEC > , # [doc = "0x18 - Interrupt Flag Status and Clear"]
pub intflag : crate :: Reg < intflag :: INTFLAG_SPEC > , } # [doc = "CTRL register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control"]
pub mod ctrl { # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWRST` writer - Software Reset"]
pub type SWRST_W < 'a > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , 0 > ; # [doc = "Field `GCLKREQ` writer - Generic Clock Requests"]
pub type GCLKREQ_W < 'a > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , 4 > ; impl W { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& mut self) -> SWRST_W { SWRST_W :: new (self) } # [doc = "Bit 4 - Generic Clock Requests"]
# [inline (always)]
pub fn gclkreq (& mut self) -> GCLKREQ_W { GCLKREQ_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CHANNEL register accessor: an alias for `Reg<CHANNEL_SPEC>`"]
pub type CHANNEL = crate :: Reg < channel :: CHANNEL_SPEC > ; # [doc = "Channel"]
pub mod channel { # [doc = "Register `CHANNEL` reader"]
pub struct R (crate :: R < CHANNEL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CHANNEL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CHANNEL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CHANNEL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CHANNEL` writer"]
pub struct W (crate :: W < CHANNEL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CHANNEL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CHANNEL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CHANNEL_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHANNEL` reader - Channel Selection"]
pub type CHANNEL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CHANNEL` writer - Channel Selection"]
pub type CHANNEL_W < 'a > = crate :: FieldWriter < 'a , u32 , CHANNEL_SPEC , u8 , u8 , 4 , 0 > ; # [doc = "Field `SWEVT` reader - Software Event"]
pub type SWEVT_R = crate :: BitReader < bool > ; # [doc = "Field `SWEVT` writer - Software Event"]
pub type SWEVT_W < 'a > = crate :: BitWriter < 'a , u32 , CHANNEL_SPEC , bool , 8 > ; # [doc = "Field `EVGEN` reader - Event Generator Selection"]
pub type EVGEN_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `EVGEN` writer - Event Generator Selection"]
pub type EVGEN_W < 'a > = crate :: FieldWriter < 'a , u32 , CHANNEL_SPEC , u8 , u8 , 7 , 16 > ; # [doc = "Path Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum PATH_A { # [doc = "0: Synchronous path"]
SYNCHRONOUS = 0 , # [doc = "1: Resynchronized path"]
RESYNCHRONIZED = 1 , # [doc = "2: Asynchronous path"]
ASYNCHRONOUS = 2 , } impl From < PATH_A > for u8 { # [inline (always)]
fn from (variant : PATH_A) -> Self { variant as _ } } # [doc = "Field `PATH` reader - Path Selection"]
pub type PATH_R = crate :: FieldReader < u8 , PATH_A > ; impl PATH_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PATH_A > { match self . bits { 0 => Some (PATH_A :: SYNCHRONOUS) , 1 => Some (PATH_A :: RESYNCHRONIZED) , 2 => Some (PATH_A :: ASYNCHRONOUS) , _ => None , } } # [doc = "Checks if the value of the field is `SYNCHRONOUS`"]
# [inline (always)]
pub fn is_synchronous (& self) -> bool { * self == PATH_A :: SYNCHRONOUS } # [doc = "Checks if the value of the field is `RESYNCHRONIZED`"]
# [inline (always)]
pub fn is_resynchronized (& self) -> bool { * self == PATH_A :: RESYNCHRONIZED } # [doc = "Checks if the value of the field is `ASYNCHRONOUS`"]
# [inline (always)]
pub fn is_asynchronous (& self) -> bool { * self == PATH_A :: ASYNCHRONOUS } } # [doc = "Field `PATH` writer - Path Selection"]
pub type PATH_W < 'a > = crate :: FieldWriter < 'a , u32 , CHANNEL_SPEC , u8 , PATH_A , 2 , 24 > ; impl < 'a > PATH_W < 'a > { # [doc = "Synchronous path"]
# [inline (always)]
pub fn synchronous (self) -> & 'a mut W { self . variant (PATH_A :: SYNCHRONOUS) } # [doc = "Resynchronized path"]
# [inline (always)]
pub fn resynchronized (self) -> & 'a mut W { self . variant (PATH_A :: RESYNCHRONIZED) } # [doc = "Asynchronous path"]
# [inline (always)]
pub fn asynchronous (self) -> & 'a mut W { self . variant (PATH_A :: ASYNCHRONOUS) } } # [doc = "Edge Detection Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum EDGSEL_A { # [doc = "0: No event output when using the resynchronized or synchronous path"]
NO_EVT_OUTPUT = 0 , # [doc = "1: Event detection only on the rising edge of the signal from the event generator when using the resynchronized or synchronous path"]
RISING_EDGE = 1 , # [doc = "2: Event detection only on the falling edge of the signal from the event generator when using the resynchronized or synchronous path"]
FALLING_EDGE = 2 , # [doc = "3: Event detection on rising and falling edges of the signal from the event generator when using the resynchronized or synchronous path"]
BOTH_EDGES = 3 , } impl From < EDGSEL_A > for u8 { # [inline (always)]
fn from (variant : EDGSEL_A) -> Self { variant as _ } } # [doc = "Field `EDGSEL` reader - Edge Detection Selection"]
pub type EDGSEL_R = crate :: FieldReader < u8 , EDGSEL_A > ; impl EDGSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> EDGSEL_A { match self . bits { 0 => EDGSEL_A :: NO_EVT_OUTPUT , 1 => EDGSEL_A :: RISING_EDGE , 2 => EDGSEL_A :: FALLING_EDGE , 3 => EDGSEL_A :: BOTH_EDGES , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NO_EVT_OUTPUT`"]
# [inline (always)]
pub fn is_no_evt_output (& self) -> bool { * self == EDGSEL_A :: NO_EVT_OUTPUT } # [doc = "Checks if the value of the field is `RISING_EDGE`"]
# [inline (always)]
pub fn is_rising_edge (& self) -> bool { * self == EDGSEL_A :: RISING_EDGE } # [doc = "Checks if the value of the field is `FALLING_EDGE`"]
# [inline (always)]
pub fn is_falling_edge (& self) -> bool { * self == EDGSEL_A :: FALLING_EDGE } # [doc = "Checks if the value of the field is `BOTH_EDGES`"]
# [inline (always)]
pub fn is_both_edges (& self) -> bool { * self == EDGSEL_A :: BOTH_EDGES } } # [doc = "Field `EDGSEL` writer - Edge Detection Selection"]
pub type EDGSEL_W < 'a > = crate :: FieldWriterSafe < 'a , u32 , CHANNEL_SPEC , u8 , EDGSEL_A , 2 , 26 > ; impl < 'a > EDGSEL_W < 'a > { # [doc = "No event output when using the resynchronized or synchronous path"]
# [inline (always)]
pub fn no_evt_output (self) -> & 'a mut W { self . variant (EDGSEL_A :: NO_EVT_OUTPUT) } # [doc = "Event detection only on the rising edge of the signal from the event generator when using the resynchronized or synchronous path"]
# [inline (always)]
pub fn rising_edge (self) -> & 'a mut W { self . variant (EDGSEL_A :: RISING_EDGE) } # [doc = "Event detection only on the falling edge of the signal from the event generator when using the resynchronized or synchronous path"]
# [inline (always)]
pub fn falling_edge (self) -> & 'a mut W { self . variant (EDGSEL_A :: FALLING_EDGE) } # [doc = "Event detection on rising and falling edges of the signal from the event generator when using the resynchronized or synchronous path"]
# [inline (always)]
pub fn both_edges (self) -> & 'a mut W { self . variant (EDGSEL_A :: BOTH_EDGES) } } impl R { # [doc = "Bits 0:3 - Channel Selection"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bit 8 - Software Event"]
# [inline (always)]
pub fn swevt (& self) -> SWEVT_R { SWEVT_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bits 16:22 - Event Generator Selection"]
# [inline (always)]
pub fn evgen (& self) -> EVGEN_R { EVGEN_R :: new (((self . bits >> 16) & 0x7f) as u8) } # [doc = "Bits 24:25 - Path Selection"]
# [inline (always)]
pub fn path (& self) -> PATH_R { PATH_R :: new (((self . bits >> 24) & 3) as u8) } # [doc = "Bits 26:27 - Edge Detection Selection"]
# [inline (always)]
pub fn edgsel (& self) -> EDGSEL_R { EDGSEL_R :: new (((self . bits >> 26) & 3) as u8) } } impl W { # [doc = "Bits 0:3 - Channel Selection"]
# [inline (always)]
pub fn channel (& mut self) -> CHANNEL_W { CHANNEL_W :: new (self) } # [doc = "Bit 8 - Software Event"]
# [inline (always)]
pub fn swevt (& mut self) -> SWEVT_W { SWEVT_W :: new (self) } # [doc = "Bits 16:22 - Event Generator Selection"]
# [inline (always)]
pub fn evgen (& mut self) -> EVGEN_W { EVGEN_W :: new (self) } # [doc = "Bits 24:25 - Path Selection"]
# [inline (always)]
pub fn path (& mut self) -> PATH_W { PATH_W :: new (self) } # [doc = "Bits 26:27 - Edge Detection Selection"]
# [inline (always)]
pub fn edgsel (& mut self) -> EDGSEL_W { EDGSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Channel\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [channel](index.html) module"]
pub struct CHANNEL_SPEC ; impl crate :: RegisterSpec for CHANNEL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [channel::R](R) reader structure"]
impl crate :: Readable for CHANNEL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [channel::W](W) writer structure"]
impl crate :: Writable for CHANNEL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CHANNEL to value 0"]
impl crate :: Resettable for CHANNEL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "USER register accessor: an alias for `Reg<USER_SPEC>`"]
pub type USER = crate :: Reg < user :: USER_SPEC > ; # [doc = "User Multiplexer"]
pub mod user { # [doc = "Register `USER` reader"]
pub struct R (crate :: R < USER_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < USER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < USER_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < USER_SPEC >) -> Self { R (reader) } } # [doc = "Register `USER` writer"]
pub struct W (crate :: W < USER_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < USER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < USER_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < USER_SPEC >) -> Self { W (writer) } } # [doc = "Field `USER` reader - User Multiplexer Selection"]
pub type USER_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `USER` writer - User Multiplexer Selection"]
pub type USER_W < 'a > = crate :: FieldWriter < 'a , u16 , USER_SPEC , u8 , u8 , 5 , 0 > ; # [doc = "Channel Event Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CHANNEL_A { # [doc = "0: No Channel Output Selected"]
_0 = 0 , } impl From < CHANNEL_A > for u8 { # [inline (always)]
fn from (variant : CHANNEL_A) -> Self { variant as _ } } # [doc = "Field `CHANNEL` reader - Channel Event Selection"]
pub type CHANNEL_R = crate :: FieldReader < u8 , CHANNEL_A > ; impl CHANNEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CHANNEL_A > { match self . bits { 0 => Some (CHANNEL_A :: _0) , _ => None , } } # [doc = "Checks if the value of the field is `_0`"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == CHANNEL_A :: _0 } } # [doc = "Field `CHANNEL` writer - Channel Event Selection"]
pub type CHANNEL_W < 'a > = crate :: FieldWriter < 'a , u16 , USER_SPEC , u8 , CHANNEL_A , 5 , 8 > ; impl < 'a > CHANNEL_W < 'a > { # [doc = "No Channel Output Selected"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut W { self . variant (CHANNEL_A :: _0) } } impl R { # [doc = "Bits 0:4 - User Multiplexer Selection"]
# [inline (always)]
pub fn user (& self) -> USER_R { USER_R :: new ((self . bits & 0x1f) as u8) } # [doc = "Bits 8:12 - Channel Event Selection"]
# [inline (always)]
pub fn channel (& self) -> CHANNEL_R { CHANNEL_R :: new (((self . bits >> 8) & 0x1f) as u8) } } impl W { # [doc = "Bits 0:4 - User Multiplexer Selection"]
# [inline (always)]
pub fn user (& mut self) -> USER_W { USER_W :: new (self) } # [doc = "Bits 8:12 - Channel Event Selection"]
# [inline (always)]
pub fn channel (& mut self) -> CHANNEL_W { CHANNEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "User Multiplexer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [user](index.html) module"]
pub struct USER_SPEC ; impl crate :: RegisterSpec for USER_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [user::R](R) reader structure"]
impl crate :: Readable for USER_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [user::W](W) writer structure"]
impl crate :: Writable for USER_SPEC { type Writer = W ; } # [doc = "`reset()` method sets USER to value 0"]
impl crate :: Resettable for USER_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CHSTATUS register accessor: an alias for `Reg<CHSTATUS_SPEC>`"]
pub type CHSTATUS = crate :: Reg < chstatus :: CHSTATUS_SPEC > ; # [doc = "Channel Status"]
pub mod chstatus { # [doc = "Register `CHSTATUS` reader"]
pub struct R (crate :: R < CHSTATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CHSTATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CHSTATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CHSTATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `USRRDY0` reader - Channel 0 User Ready"]
pub type USRRDY0_R = crate :: BitReader < bool > ; # [doc = "Field `USRRDY1` reader - Channel 1 User Ready"]
pub type USRRDY1_R = crate :: BitReader < bool > ; # [doc = "Field `USRRDY2` reader - Channel 2 User Ready"]
pub type USRRDY2_R = crate :: BitReader < bool > ; # [doc = "Field `USRRDY3` reader - Channel 3 User Ready"]
pub type USRRDY3_R = crate :: BitReader < bool > ; # [doc = "Field `USRRDY4` reader - Channel 4 User Ready"]
pub type USRRDY4_R = crate :: BitReader < bool > ; # [doc = "Field `USRRDY5` reader - Channel 5 User Ready"]
pub type USRRDY5_R = crate :: BitReader < bool > ; # [doc = "Field `USRRDY6` reader - Channel 6 User Ready"]
pub type USRRDY6_R = crate :: BitReader < bool > ; # [doc = "Field `USRRDY7` reader - Channel 7 User Ready"]
pub type USRRDY7_R = crate :: BitReader < bool > ; # [doc = "Field `CHBUSY0` reader - Channel 0 Busy"]
pub type CHBUSY0_R = crate :: BitReader < bool > ; # [doc = "Field `CHBUSY1` reader - Channel 1 Busy"]
pub type CHBUSY1_R = crate :: BitReader < bool > ; # [doc = "Field `CHBUSY2` reader - Channel 2 Busy"]
pub type CHBUSY2_R = crate :: BitReader < bool > ; # [doc = "Field `CHBUSY3` reader - Channel 3 Busy"]
pub type CHBUSY3_R = crate :: BitReader < bool > ; # [doc = "Field `CHBUSY4` reader - Channel 4 Busy"]
pub type CHBUSY4_R = crate :: BitReader < bool > ; # [doc = "Field `CHBUSY5` reader - Channel 5 Busy"]
pub type CHBUSY5_R = crate :: BitReader < bool > ; # [doc = "Field `CHBUSY6` reader - Channel 6 Busy"]
pub type CHBUSY6_R = crate :: BitReader < bool > ; # [doc = "Field `CHBUSY7` reader - Channel 7 Busy"]
pub type CHBUSY7_R = crate :: BitReader < bool > ; # [doc = "Field `USRRDY8` reader - Channel 8 User Ready"]
pub type USRRDY8_R = crate :: BitReader < bool > ; # [doc = "Field `USRRDY9` reader - Channel 9 User Ready"]
pub type USRRDY9_R = crate :: BitReader < bool > ; # [doc = "Field `USRRDY10` reader - Channel 10 User Ready"]
pub type USRRDY10_R = crate :: BitReader < bool > ; # [doc = "Field `USRRDY11` reader - Channel 11 User Ready"]
pub type USRRDY11_R = crate :: BitReader < bool > ; # [doc = "Field `CHBUSY8` reader - Channel 8 Busy"]
pub type CHBUSY8_R = crate :: BitReader < bool > ; # [doc = "Field `CHBUSY9` reader - Channel 9 Busy"]
pub type CHBUSY9_R = crate :: BitReader < bool > ; # [doc = "Field `CHBUSY10` reader - Channel 10 Busy"]
pub type CHBUSY10_R = crate :: BitReader < bool > ; # [doc = "Field `CHBUSY11` reader - Channel 11 Busy"]
pub type CHBUSY11_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Channel 0 User Ready"]
# [inline (always)]
pub fn usrrdy0 (& self) -> USRRDY0_R { USRRDY0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Channel 1 User Ready"]
# [inline (always)]
pub fn usrrdy1 (& self) -> USRRDY1_R { USRRDY1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Channel 2 User Ready"]
# [inline (always)]
pub fn usrrdy2 (& self) -> USRRDY2_R { USRRDY2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Channel 3 User Ready"]
# [inline (always)]
pub fn usrrdy3 (& self) -> USRRDY3_R { USRRDY3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Channel 4 User Ready"]
# [inline (always)]
pub fn usrrdy4 (& self) -> USRRDY4_R { USRRDY4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Channel 5 User Ready"]
# [inline (always)]
pub fn usrrdy5 (& self) -> USRRDY5_R { USRRDY5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Channel 6 User Ready"]
# [inline (always)]
pub fn usrrdy6 (& self) -> USRRDY6_R { USRRDY6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Channel 7 User Ready"]
# [inline (always)]
pub fn usrrdy7 (& self) -> USRRDY7_R { USRRDY7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Channel 0 Busy"]
# [inline (always)]
pub fn chbusy0 (& self) -> CHBUSY0_R { CHBUSY0_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Channel 1 Busy"]
# [inline (always)]
pub fn chbusy1 (& self) -> CHBUSY1_R { CHBUSY1_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Channel 2 Busy"]
# [inline (always)]
pub fn chbusy2 (& self) -> CHBUSY2_R { CHBUSY2_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Channel 3 Busy"]
# [inline (always)]
pub fn chbusy3 (& self) -> CHBUSY3_R { CHBUSY3_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Channel 4 Busy"]
# [inline (always)]
pub fn chbusy4 (& self) -> CHBUSY4_R { CHBUSY4_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Channel 5 Busy"]
# [inline (always)]
pub fn chbusy5 (& self) -> CHBUSY5_R { CHBUSY5_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Channel 6 Busy"]
# [inline (always)]
pub fn chbusy6 (& self) -> CHBUSY6_R { CHBUSY6_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Channel 7 Busy"]
# [inline (always)]
pub fn chbusy7 (& self) -> CHBUSY7_R { CHBUSY7_R :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - Channel 8 User Ready"]
# [inline (always)]
pub fn usrrdy8 (& self) -> USRRDY8_R { USRRDY8_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Channel 9 User Ready"]
# [inline (always)]
pub fn usrrdy9 (& self) -> USRRDY9_R { USRRDY9_R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Channel 10 User Ready"]
# [inline (always)]
pub fn usrrdy10 (& self) -> USRRDY10_R { USRRDY10_R :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Channel 11 User Ready"]
# [inline (always)]
pub fn usrrdy11 (& self) -> USRRDY11_R { USRRDY11_R :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 24 - Channel 8 Busy"]
# [inline (always)]
pub fn chbusy8 (& self) -> CHBUSY8_R { CHBUSY8_R :: new (((self . bits >> 24) & 1) != 0) } # [doc = "Bit 25 - Channel 9 Busy"]
# [inline (always)]
pub fn chbusy9 (& self) -> CHBUSY9_R { CHBUSY9_R :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - Channel 10 Busy"]
# [inline (always)]
pub fn chbusy10 (& self) -> CHBUSY10_R { CHBUSY10_R :: new (((self . bits >> 26) & 1) != 0) } # [doc = "Bit 27 - Channel 11 Busy"]
# [inline (always)]
pub fn chbusy11 (& self) -> CHBUSY11_R { CHBUSY11_R :: new (((self . bits >> 27) & 1) != 0) } } # [doc = "Channel Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [chstatus](index.html) module"]
pub struct CHSTATUS_SPEC ; impl crate :: RegisterSpec for CHSTATUS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [chstatus::R](R) reader structure"]
impl crate :: Readable for CHSTATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets CHSTATUS to value 0x000f_00ff"]
impl crate :: Resettable for CHSTATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x000f_00ff } } } # [doc = "INTENCLR register accessor: an alias for `Reg<INTENCLR_SPEC>`"]
pub type INTENCLR = crate :: Reg < intenclr :: INTENCLR_SPEC > ; # [doc = "Interrupt Enable Clear"]
pub mod intenclr { # [doc = "Register `INTENCLR` reader"]
pub struct R (crate :: R < INTENCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENCLR` writer"]
pub struct W (crate :: W < INTENCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVR0` reader - Channel 0 Overrun Interrupt Enable"]
pub type OVR0_R = crate :: BitReader < bool > ; # [doc = "Field `OVR0` writer - Channel 0 Overrun Interrupt Enable"]
pub type OVR0_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 0 > ; # [doc = "Field `OVR1` reader - Channel 1 Overrun Interrupt Enable"]
pub type OVR1_R = crate :: BitReader < bool > ; # [doc = "Field `OVR1` writer - Channel 1 Overrun Interrupt Enable"]
pub type OVR1_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 1 > ; # [doc = "Field `OVR2` reader - Channel 2 Overrun Interrupt Enable"]
pub type OVR2_R = crate :: BitReader < bool > ; # [doc = "Field `OVR2` writer - Channel 2 Overrun Interrupt Enable"]
pub type OVR2_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 2 > ; # [doc = "Field `OVR3` reader - Channel 3 Overrun Interrupt Enable"]
pub type OVR3_R = crate :: BitReader < bool > ; # [doc = "Field `OVR3` writer - Channel 3 Overrun Interrupt Enable"]
pub type OVR3_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 3 > ; # [doc = "Field `OVR4` reader - Channel 4 Overrun Interrupt Enable"]
pub type OVR4_R = crate :: BitReader < bool > ; # [doc = "Field `OVR4` writer - Channel 4 Overrun Interrupt Enable"]
pub type OVR4_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 4 > ; # [doc = "Field `OVR5` reader - Channel 5 Overrun Interrupt Enable"]
pub type OVR5_R = crate :: BitReader < bool > ; # [doc = "Field `OVR5` writer - Channel 5 Overrun Interrupt Enable"]
pub type OVR5_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 5 > ; # [doc = "Field `OVR6` reader - Channel 6 Overrun Interrupt Enable"]
pub type OVR6_R = crate :: BitReader < bool > ; # [doc = "Field `OVR6` writer - Channel 6 Overrun Interrupt Enable"]
pub type OVR6_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 6 > ; # [doc = "Field `OVR7` reader - Channel 7 Overrun Interrupt Enable"]
pub type OVR7_R = crate :: BitReader < bool > ; # [doc = "Field `OVR7` writer - Channel 7 Overrun Interrupt Enable"]
pub type OVR7_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 7 > ; # [doc = "Field `EVD0` reader - Channel 0 Event Detection Interrupt Enable"]
pub type EVD0_R = crate :: BitReader < bool > ; # [doc = "Field `EVD0` writer - Channel 0 Event Detection Interrupt Enable"]
pub type EVD0_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 8 > ; # [doc = "Field `EVD1` reader - Channel 1 Event Detection Interrupt Enable"]
pub type EVD1_R = crate :: BitReader < bool > ; # [doc = "Field `EVD1` writer - Channel 1 Event Detection Interrupt Enable"]
pub type EVD1_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 9 > ; # [doc = "Field `EVD2` reader - Channel 2 Event Detection Interrupt Enable"]
pub type EVD2_R = crate :: BitReader < bool > ; # [doc = "Field `EVD2` writer - Channel 2 Event Detection Interrupt Enable"]
pub type EVD2_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 10 > ; # [doc = "Field `EVD3` reader - Channel 3 Event Detection Interrupt Enable"]
pub type EVD3_R = crate :: BitReader < bool > ; # [doc = "Field `EVD3` writer - Channel 3 Event Detection Interrupt Enable"]
pub type EVD3_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 11 > ; # [doc = "Field `EVD4` reader - Channel 4 Event Detection Interrupt Enable"]
pub type EVD4_R = crate :: BitReader < bool > ; # [doc = "Field `EVD4` writer - Channel 4 Event Detection Interrupt Enable"]
pub type EVD4_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 12 > ; # [doc = "Field `EVD5` reader - Channel 5 Event Detection Interrupt Enable"]
pub type EVD5_R = crate :: BitReader < bool > ; # [doc = "Field `EVD5` writer - Channel 5 Event Detection Interrupt Enable"]
pub type EVD5_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 13 > ; # [doc = "Field `EVD6` reader - Channel 6 Event Detection Interrupt Enable"]
pub type EVD6_R = crate :: BitReader < bool > ; # [doc = "Field `EVD6` writer - Channel 6 Event Detection Interrupt Enable"]
pub type EVD6_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 14 > ; # [doc = "Field `EVD7` reader - Channel 7 Event Detection Interrupt Enable"]
pub type EVD7_R = crate :: BitReader < bool > ; # [doc = "Field `EVD7` writer - Channel 7 Event Detection Interrupt Enable"]
pub type EVD7_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 15 > ; # [doc = "Field `OVR8` reader - Channel 8 Overrun Interrupt Enable"]
pub type OVR8_R = crate :: BitReader < bool > ; # [doc = "Field `OVR8` writer - Channel 8 Overrun Interrupt Enable"]
pub type OVR8_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 16 > ; # [doc = "Field `OVR9` reader - Channel 9 Overrun Interrupt Enable"]
pub type OVR9_R = crate :: BitReader < bool > ; # [doc = "Field `OVR9` writer - Channel 9 Overrun Interrupt Enable"]
pub type OVR9_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 17 > ; # [doc = "Field `OVR10` reader - Channel 10 Overrun Interrupt Enable"]
pub type OVR10_R = crate :: BitReader < bool > ; # [doc = "Field `OVR10` writer - Channel 10 Overrun Interrupt Enable"]
pub type OVR10_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 18 > ; # [doc = "Field `OVR11` reader - Channel 11 Overrun Interrupt Enable"]
pub type OVR11_R = crate :: BitReader < bool > ; # [doc = "Field `OVR11` writer - Channel 11 Overrun Interrupt Enable"]
pub type OVR11_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 19 > ; # [doc = "Field `EVD8` reader - Channel 8 Event Detection Interrupt Enable"]
pub type EVD8_R = crate :: BitReader < bool > ; # [doc = "Field `EVD8` writer - Channel 8 Event Detection Interrupt Enable"]
pub type EVD8_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 24 > ; # [doc = "Field `EVD9` reader - Channel 9 Event Detection Interrupt Enable"]
pub type EVD9_R = crate :: BitReader < bool > ; # [doc = "Field `EVD9` writer - Channel 9 Event Detection Interrupt Enable"]
pub type EVD9_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 25 > ; # [doc = "Field `EVD10` reader - Channel 10 Event Detection Interrupt Enable"]
pub type EVD10_R = crate :: BitReader < bool > ; # [doc = "Field `EVD10` writer - Channel 10 Event Detection Interrupt Enable"]
pub type EVD10_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 26 > ; # [doc = "Field `EVD11` reader - Channel 11 Event Detection Interrupt Enable"]
pub type EVD11_R = crate :: BitReader < bool > ; # [doc = "Field `EVD11` writer - Channel 11 Event Detection Interrupt Enable"]
pub type EVD11_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 27 > ; impl R { # [doc = "Bit 0 - Channel 0 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr0 (& self) -> OVR0_R { OVR0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Channel 1 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr1 (& self) -> OVR1_R { OVR1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Channel 2 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr2 (& self) -> OVR2_R { OVR2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Channel 3 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr3 (& self) -> OVR3_R { OVR3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Channel 4 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr4 (& self) -> OVR4_R { OVR4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Channel 5 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr5 (& self) -> OVR5_R { OVR5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Channel 6 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr6 (& self) -> OVR6_R { OVR6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Channel 7 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr7 (& self) -> OVR7_R { OVR7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Channel 0 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd0 (& self) -> EVD0_R { EVD0_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Channel 1 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd1 (& self) -> EVD1_R { EVD1_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Channel 2 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd2 (& self) -> EVD2_R { EVD2_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Channel 3 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd3 (& self) -> EVD3_R { EVD3_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Channel 4 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd4 (& self) -> EVD4_R { EVD4_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Channel 5 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd5 (& self) -> EVD5_R { EVD5_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Channel 6 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd6 (& self) -> EVD6_R { EVD6_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Channel 7 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd7 (& self) -> EVD7_R { EVD7_R :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - Channel 8 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr8 (& self) -> OVR8_R { OVR8_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Channel 9 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr9 (& self) -> OVR9_R { OVR9_R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Channel 10 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr10 (& self) -> OVR10_R { OVR10_R :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Channel 11 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr11 (& self) -> OVR11_R { OVR11_R :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 24 - Channel 8 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd8 (& self) -> EVD8_R { EVD8_R :: new (((self . bits >> 24) & 1) != 0) } # [doc = "Bit 25 - Channel 9 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd9 (& self) -> EVD9_R { EVD9_R :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - Channel 10 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd10 (& self) -> EVD10_R { EVD10_R :: new (((self . bits >> 26) & 1) != 0) } # [doc = "Bit 27 - Channel 11 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd11 (& self) -> EVD11_R { EVD11_R :: new (((self . bits >> 27) & 1) != 0) } } impl W { # [doc = "Bit 0 - Channel 0 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr0 (& mut self) -> OVR0_W { OVR0_W :: new (self) } # [doc = "Bit 1 - Channel 1 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr1 (& mut self) -> OVR1_W { OVR1_W :: new (self) } # [doc = "Bit 2 - Channel 2 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr2 (& mut self) -> OVR2_W { OVR2_W :: new (self) } # [doc = "Bit 3 - Channel 3 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr3 (& mut self) -> OVR3_W { OVR3_W :: new (self) } # [doc = "Bit 4 - Channel 4 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr4 (& mut self) -> OVR4_W { OVR4_W :: new (self) } # [doc = "Bit 5 - Channel 5 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr5 (& mut self) -> OVR5_W { OVR5_W :: new (self) } # [doc = "Bit 6 - Channel 6 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr6 (& mut self) -> OVR6_W { OVR6_W :: new (self) } # [doc = "Bit 7 - Channel 7 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr7 (& mut self) -> OVR7_W { OVR7_W :: new (self) } # [doc = "Bit 8 - Channel 0 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd0 (& mut self) -> EVD0_W { EVD0_W :: new (self) } # [doc = "Bit 9 - Channel 1 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd1 (& mut self) -> EVD1_W { EVD1_W :: new (self) } # [doc = "Bit 10 - Channel 2 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd2 (& mut self) -> EVD2_W { EVD2_W :: new (self) } # [doc = "Bit 11 - Channel 3 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd3 (& mut self) -> EVD3_W { EVD3_W :: new (self) } # [doc = "Bit 12 - Channel 4 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd4 (& mut self) -> EVD4_W { EVD4_W :: new (self) } # [doc = "Bit 13 - Channel 5 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd5 (& mut self) -> EVD5_W { EVD5_W :: new (self) } # [doc = "Bit 14 - Channel 6 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd6 (& mut self) -> EVD6_W { EVD6_W :: new (self) } # [doc = "Bit 15 - Channel 7 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd7 (& mut self) -> EVD7_W { EVD7_W :: new (self) } # [doc = "Bit 16 - Channel 8 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr8 (& mut self) -> OVR8_W { OVR8_W :: new (self) } # [doc = "Bit 17 - Channel 9 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr9 (& mut self) -> OVR9_W { OVR9_W :: new (self) } # [doc = "Bit 18 - Channel 10 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr10 (& mut self) -> OVR10_W { OVR10_W :: new (self) } # [doc = "Bit 19 - Channel 11 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr11 (& mut self) -> OVR11_W { OVR11_W :: new (self) } # [doc = "Bit 24 - Channel 8 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd8 (& mut self) -> EVD8_W { EVD8_W :: new (self) } # [doc = "Bit 25 - Channel 9 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd9 (& mut self) -> EVD9_W { EVD9_W :: new (self) } # [doc = "Bit 26 - Channel 10 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd10 (& mut self) -> EVD10_W { EVD10_W :: new (self) } # [doc = "Bit 27 - Channel 11 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd11 (& mut self) -> EVD11_W { EVD11_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenclr](index.html) module"]
pub struct INTENCLR_SPEC ; impl crate :: RegisterSpec for INTENCLR_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [intenclr::R](R) reader structure"]
impl crate :: Readable for INTENCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenclr::W](W) writer structure"]
impl crate :: Writable for INTENCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENCLR to value 0"]
impl crate :: Resettable for INTENCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENSET register accessor: an alias for `Reg<INTENSET_SPEC>`"]
pub type INTENSET = crate :: Reg < intenset :: INTENSET_SPEC > ; # [doc = "Interrupt Enable Set"]
pub mod intenset { # [doc = "Register `INTENSET` reader"]
pub struct R (crate :: R < INTENSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENSET` writer"]
pub struct W (crate :: W < INTENSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVR0` reader - Channel 0 Overrun Interrupt Enable"]
pub type OVR0_R = crate :: BitReader < bool > ; # [doc = "Field `OVR0` writer - Channel 0 Overrun Interrupt Enable"]
pub type OVR0_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 0 > ; # [doc = "Field `OVR1` reader - Channel 1 Overrun Interrupt Enable"]
pub type OVR1_R = crate :: BitReader < bool > ; # [doc = "Field `OVR1` writer - Channel 1 Overrun Interrupt Enable"]
pub type OVR1_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 1 > ; # [doc = "Field `OVR2` reader - Channel 2 Overrun Interrupt Enable"]
pub type OVR2_R = crate :: BitReader < bool > ; # [doc = "Field `OVR2` writer - Channel 2 Overrun Interrupt Enable"]
pub type OVR2_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 2 > ; # [doc = "Field `OVR3` reader - Channel 3 Overrun Interrupt Enable"]
pub type OVR3_R = crate :: BitReader < bool > ; # [doc = "Field `OVR3` writer - Channel 3 Overrun Interrupt Enable"]
pub type OVR3_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 3 > ; # [doc = "Field `OVR4` reader - Channel 4 Overrun Interrupt Enable"]
pub type OVR4_R = crate :: BitReader < bool > ; # [doc = "Field `OVR4` writer - Channel 4 Overrun Interrupt Enable"]
pub type OVR4_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 4 > ; # [doc = "Field `OVR5` reader - Channel 5 Overrun Interrupt Enable"]
pub type OVR5_R = crate :: BitReader < bool > ; # [doc = "Field `OVR5` writer - Channel 5 Overrun Interrupt Enable"]
pub type OVR5_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 5 > ; # [doc = "Field `OVR6` reader - Channel 6 Overrun Interrupt Enable"]
pub type OVR6_R = crate :: BitReader < bool > ; # [doc = "Field `OVR6` writer - Channel 6 Overrun Interrupt Enable"]
pub type OVR6_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 6 > ; # [doc = "Field `OVR7` reader - Channel 7 Overrun Interrupt Enable"]
pub type OVR7_R = crate :: BitReader < bool > ; # [doc = "Field `OVR7` writer - Channel 7 Overrun Interrupt Enable"]
pub type OVR7_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 7 > ; # [doc = "Field `EVD0` reader - Channel 0 Event Detection Interrupt Enable"]
pub type EVD0_R = crate :: BitReader < bool > ; # [doc = "Field `EVD0` writer - Channel 0 Event Detection Interrupt Enable"]
pub type EVD0_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 8 > ; # [doc = "Field `EVD1` reader - Channel 1 Event Detection Interrupt Enable"]
pub type EVD1_R = crate :: BitReader < bool > ; # [doc = "Field `EVD1` writer - Channel 1 Event Detection Interrupt Enable"]
pub type EVD1_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 9 > ; # [doc = "Field `EVD2` reader - Channel 2 Event Detection Interrupt Enable"]
pub type EVD2_R = crate :: BitReader < bool > ; # [doc = "Field `EVD2` writer - Channel 2 Event Detection Interrupt Enable"]
pub type EVD2_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 10 > ; # [doc = "Field `EVD3` reader - Channel 3 Event Detection Interrupt Enable"]
pub type EVD3_R = crate :: BitReader < bool > ; # [doc = "Field `EVD3` writer - Channel 3 Event Detection Interrupt Enable"]
pub type EVD3_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 11 > ; # [doc = "Field `EVD4` reader - Channel 4 Event Detection Interrupt Enable"]
pub type EVD4_R = crate :: BitReader < bool > ; # [doc = "Field `EVD4` writer - Channel 4 Event Detection Interrupt Enable"]
pub type EVD4_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 12 > ; # [doc = "Field `EVD5` reader - Channel 5 Event Detection Interrupt Enable"]
pub type EVD5_R = crate :: BitReader < bool > ; # [doc = "Field `EVD5` writer - Channel 5 Event Detection Interrupt Enable"]
pub type EVD5_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 13 > ; # [doc = "Field `EVD6` reader - Channel 6 Event Detection Interrupt Enable"]
pub type EVD6_R = crate :: BitReader < bool > ; # [doc = "Field `EVD6` writer - Channel 6 Event Detection Interrupt Enable"]
pub type EVD6_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 14 > ; # [doc = "Field `EVD7` reader - Channel 7 Event Detection Interrupt Enable"]
pub type EVD7_R = crate :: BitReader < bool > ; # [doc = "Field `EVD7` writer - Channel 7 Event Detection Interrupt Enable"]
pub type EVD7_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 15 > ; # [doc = "Field `OVR8` reader - Channel 8 Overrun Interrupt Enable"]
pub type OVR8_R = crate :: BitReader < bool > ; # [doc = "Field `OVR8` writer - Channel 8 Overrun Interrupt Enable"]
pub type OVR8_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 16 > ; # [doc = "Field `OVR9` reader - Channel 9 Overrun Interrupt Enable"]
pub type OVR9_R = crate :: BitReader < bool > ; # [doc = "Field `OVR9` writer - Channel 9 Overrun Interrupt Enable"]
pub type OVR9_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 17 > ; # [doc = "Field `OVR10` reader - Channel 10 Overrun Interrupt Enable"]
pub type OVR10_R = crate :: BitReader < bool > ; # [doc = "Field `OVR10` writer - Channel 10 Overrun Interrupt Enable"]
pub type OVR10_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 18 > ; # [doc = "Field `OVR11` reader - Channel 11 Overrun Interrupt Enable"]
pub type OVR11_R = crate :: BitReader < bool > ; # [doc = "Field `OVR11` writer - Channel 11 Overrun Interrupt Enable"]
pub type OVR11_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 19 > ; # [doc = "Field `EVD8` reader - Channel 8 Event Detection Interrupt Enable"]
pub type EVD8_R = crate :: BitReader < bool > ; # [doc = "Field `EVD8` writer - Channel 8 Event Detection Interrupt Enable"]
pub type EVD8_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 24 > ; # [doc = "Field `EVD9` reader - Channel 9 Event Detection Interrupt Enable"]
pub type EVD9_R = crate :: BitReader < bool > ; # [doc = "Field `EVD9` writer - Channel 9 Event Detection Interrupt Enable"]
pub type EVD9_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 25 > ; # [doc = "Field `EVD10` reader - Channel 10 Event Detection Interrupt Enable"]
pub type EVD10_R = crate :: BitReader < bool > ; # [doc = "Field `EVD10` writer - Channel 10 Event Detection Interrupt Enable"]
pub type EVD10_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 26 > ; # [doc = "Field `EVD11` reader - Channel 11 Event Detection Interrupt Enable"]
pub type EVD11_R = crate :: BitReader < bool > ; # [doc = "Field `EVD11` writer - Channel 11 Event Detection Interrupt Enable"]
pub type EVD11_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 27 > ; impl R { # [doc = "Bit 0 - Channel 0 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr0 (& self) -> OVR0_R { OVR0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Channel 1 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr1 (& self) -> OVR1_R { OVR1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Channel 2 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr2 (& self) -> OVR2_R { OVR2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Channel 3 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr3 (& self) -> OVR3_R { OVR3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Channel 4 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr4 (& self) -> OVR4_R { OVR4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Channel 5 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr5 (& self) -> OVR5_R { OVR5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Channel 6 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr6 (& self) -> OVR6_R { OVR6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Channel 7 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr7 (& self) -> OVR7_R { OVR7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Channel 0 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd0 (& self) -> EVD0_R { EVD0_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Channel 1 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd1 (& self) -> EVD1_R { EVD1_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Channel 2 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd2 (& self) -> EVD2_R { EVD2_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Channel 3 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd3 (& self) -> EVD3_R { EVD3_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Channel 4 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd4 (& self) -> EVD4_R { EVD4_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Channel 5 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd5 (& self) -> EVD5_R { EVD5_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Channel 6 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd6 (& self) -> EVD6_R { EVD6_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Channel 7 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd7 (& self) -> EVD7_R { EVD7_R :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - Channel 8 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr8 (& self) -> OVR8_R { OVR8_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Channel 9 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr9 (& self) -> OVR9_R { OVR9_R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Channel 10 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr10 (& self) -> OVR10_R { OVR10_R :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Channel 11 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr11 (& self) -> OVR11_R { OVR11_R :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 24 - Channel 8 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd8 (& self) -> EVD8_R { EVD8_R :: new (((self . bits >> 24) & 1) != 0) } # [doc = "Bit 25 - Channel 9 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd9 (& self) -> EVD9_R { EVD9_R :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - Channel 10 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd10 (& self) -> EVD10_R { EVD10_R :: new (((self . bits >> 26) & 1) != 0) } # [doc = "Bit 27 - Channel 11 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd11 (& self) -> EVD11_R { EVD11_R :: new (((self . bits >> 27) & 1) != 0) } } impl W { # [doc = "Bit 0 - Channel 0 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr0 (& mut self) -> OVR0_W { OVR0_W :: new (self) } # [doc = "Bit 1 - Channel 1 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr1 (& mut self) -> OVR1_W { OVR1_W :: new (self) } # [doc = "Bit 2 - Channel 2 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr2 (& mut self) -> OVR2_W { OVR2_W :: new (self) } # [doc = "Bit 3 - Channel 3 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr3 (& mut self) -> OVR3_W { OVR3_W :: new (self) } # [doc = "Bit 4 - Channel 4 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr4 (& mut self) -> OVR4_W { OVR4_W :: new (self) } # [doc = "Bit 5 - Channel 5 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr5 (& mut self) -> OVR5_W { OVR5_W :: new (self) } # [doc = "Bit 6 - Channel 6 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr6 (& mut self) -> OVR6_W { OVR6_W :: new (self) } # [doc = "Bit 7 - Channel 7 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr7 (& mut self) -> OVR7_W { OVR7_W :: new (self) } # [doc = "Bit 8 - Channel 0 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd0 (& mut self) -> EVD0_W { EVD0_W :: new (self) } # [doc = "Bit 9 - Channel 1 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd1 (& mut self) -> EVD1_W { EVD1_W :: new (self) } # [doc = "Bit 10 - Channel 2 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd2 (& mut self) -> EVD2_W { EVD2_W :: new (self) } # [doc = "Bit 11 - Channel 3 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd3 (& mut self) -> EVD3_W { EVD3_W :: new (self) } # [doc = "Bit 12 - Channel 4 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd4 (& mut self) -> EVD4_W { EVD4_W :: new (self) } # [doc = "Bit 13 - Channel 5 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd5 (& mut self) -> EVD5_W { EVD5_W :: new (self) } # [doc = "Bit 14 - Channel 6 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd6 (& mut self) -> EVD6_W { EVD6_W :: new (self) } # [doc = "Bit 15 - Channel 7 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd7 (& mut self) -> EVD7_W { EVD7_W :: new (self) } # [doc = "Bit 16 - Channel 8 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr8 (& mut self) -> OVR8_W { OVR8_W :: new (self) } # [doc = "Bit 17 - Channel 9 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr9 (& mut self) -> OVR9_W { OVR9_W :: new (self) } # [doc = "Bit 18 - Channel 10 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr10 (& mut self) -> OVR10_W { OVR10_W :: new (self) } # [doc = "Bit 19 - Channel 11 Overrun Interrupt Enable"]
# [inline (always)]
pub fn ovr11 (& mut self) -> OVR11_W { OVR11_W :: new (self) } # [doc = "Bit 24 - Channel 8 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd8 (& mut self) -> EVD8_W { EVD8_W :: new (self) } # [doc = "Bit 25 - Channel 9 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd9 (& mut self) -> EVD9_W { EVD9_W :: new (self) } # [doc = "Bit 26 - Channel 10 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd10 (& mut self) -> EVD10_W { EVD10_W :: new (self) } # [doc = "Bit 27 - Channel 11 Event Detection Interrupt Enable"]
# [inline (always)]
pub fn evd11 (& mut self) -> EVD11_W { EVD11_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenset](index.html) module"]
pub struct INTENSET_SPEC ; impl crate :: RegisterSpec for INTENSET_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [intenset::R](R) reader structure"]
impl crate :: Readable for INTENSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenset::W](W) writer structure"]
impl crate :: Writable for INTENSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENSET to value 0"]
impl crate :: Resettable for INTENSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTFLAG register accessor: an alias for `Reg<INTFLAG_SPEC>`"]
pub type INTFLAG = crate :: Reg < intflag :: INTFLAG_SPEC > ; # [doc = "Interrupt Flag Status and Clear"]
pub mod intflag { # [doc = "Register `INTFLAG` reader"]
pub struct R (crate :: R < INTFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAG` writer"]
pub struct W (crate :: W < INTFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVR0` reader - Channel 0 Overrun"]
pub type OVR0_R = crate :: BitReader < bool > ; # [doc = "Field `OVR0` writer - Channel 0 Overrun"]
pub type OVR0_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 0 > ; # [doc = "Field `OVR1` reader - Channel 1 Overrun"]
pub type OVR1_R = crate :: BitReader < bool > ; # [doc = "Field `OVR1` writer - Channel 1 Overrun"]
pub type OVR1_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 1 > ; # [doc = "Field `OVR2` reader - Channel 2 Overrun"]
pub type OVR2_R = crate :: BitReader < bool > ; # [doc = "Field `OVR2` writer - Channel 2 Overrun"]
pub type OVR2_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 2 > ; # [doc = "Field `OVR3` reader - Channel 3 Overrun"]
pub type OVR3_R = crate :: BitReader < bool > ; # [doc = "Field `OVR3` writer - Channel 3 Overrun"]
pub type OVR3_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 3 > ; # [doc = "Field `OVR4` reader - Channel 4 Overrun"]
pub type OVR4_R = crate :: BitReader < bool > ; # [doc = "Field `OVR4` writer - Channel 4 Overrun"]
pub type OVR4_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 4 > ; # [doc = "Field `OVR5` reader - Channel 5 Overrun"]
pub type OVR5_R = crate :: BitReader < bool > ; # [doc = "Field `OVR5` writer - Channel 5 Overrun"]
pub type OVR5_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 5 > ; # [doc = "Field `OVR6` reader - Channel 6 Overrun"]
pub type OVR6_R = crate :: BitReader < bool > ; # [doc = "Field `OVR6` writer - Channel 6 Overrun"]
pub type OVR6_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 6 > ; # [doc = "Field `OVR7` reader - Channel 7 Overrun"]
pub type OVR7_R = crate :: BitReader < bool > ; # [doc = "Field `OVR7` writer - Channel 7 Overrun"]
pub type OVR7_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 7 > ; # [doc = "Field `EVD0` reader - Channel 0 Event Detection"]
pub type EVD0_R = crate :: BitReader < bool > ; # [doc = "Field `EVD0` writer - Channel 0 Event Detection"]
pub type EVD0_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 8 > ; # [doc = "Field `EVD1` reader - Channel 1 Event Detection"]
pub type EVD1_R = crate :: BitReader < bool > ; # [doc = "Field `EVD1` writer - Channel 1 Event Detection"]
pub type EVD1_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 9 > ; # [doc = "Field `EVD2` reader - Channel 2 Event Detection"]
pub type EVD2_R = crate :: BitReader < bool > ; # [doc = "Field `EVD2` writer - Channel 2 Event Detection"]
pub type EVD2_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 10 > ; # [doc = "Field `EVD3` reader - Channel 3 Event Detection"]
pub type EVD3_R = crate :: BitReader < bool > ; # [doc = "Field `EVD3` writer - Channel 3 Event Detection"]
pub type EVD3_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 11 > ; # [doc = "Field `EVD4` reader - Channel 4 Event Detection"]
pub type EVD4_R = crate :: BitReader < bool > ; # [doc = "Field `EVD4` writer - Channel 4 Event Detection"]
pub type EVD4_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 12 > ; # [doc = "Field `EVD5` reader - Channel 5 Event Detection"]
pub type EVD5_R = crate :: BitReader < bool > ; # [doc = "Field `EVD5` writer - Channel 5 Event Detection"]
pub type EVD5_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 13 > ; # [doc = "Field `EVD6` reader - Channel 6 Event Detection"]
pub type EVD6_R = crate :: BitReader < bool > ; # [doc = "Field `EVD6` writer - Channel 6 Event Detection"]
pub type EVD6_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 14 > ; # [doc = "Field `EVD7` reader - Channel 7 Event Detection"]
pub type EVD7_R = crate :: BitReader < bool > ; # [doc = "Field `EVD7` writer - Channel 7 Event Detection"]
pub type EVD7_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 15 > ; # [doc = "Field `OVR8` reader - Channel 8 Overrun"]
pub type OVR8_R = crate :: BitReader < bool > ; # [doc = "Field `OVR8` writer - Channel 8 Overrun"]
pub type OVR8_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 16 > ; # [doc = "Field `OVR9` reader - Channel 9 Overrun"]
pub type OVR9_R = crate :: BitReader < bool > ; # [doc = "Field `OVR9` writer - Channel 9 Overrun"]
pub type OVR9_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 17 > ; # [doc = "Field `OVR10` reader - Channel 10 Overrun"]
pub type OVR10_R = crate :: BitReader < bool > ; # [doc = "Field `OVR10` writer - Channel 10 Overrun"]
pub type OVR10_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 18 > ; # [doc = "Field `OVR11` reader - Channel 11 Overrun"]
pub type OVR11_R = crate :: BitReader < bool > ; # [doc = "Field `OVR11` writer - Channel 11 Overrun"]
pub type OVR11_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 19 > ; # [doc = "Field `EVD8` reader - Channel 8 Event Detection"]
pub type EVD8_R = crate :: BitReader < bool > ; # [doc = "Field `EVD8` writer - Channel 8 Event Detection"]
pub type EVD8_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 24 > ; # [doc = "Field `EVD9` reader - Channel 9 Event Detection"]
pub type EVD9_R = crate :: BitReader < bool > ; # [doc = "Field `EVD9` writer - Channel 9 Event Detection"]
pub type EVD9_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 25 > ; # [doc = "Field `EVD10` reader - Channel 10 Event Detection"]
pub type EVD10_R = crate :: BitReader < bool > ; # [doc = "Field `EVD10` writer - Channel 10 Event Detection"]
pub type EVD10_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 26 > ; # [doc = "Field `EVD11` reader - Channel 11 Event Detection"]
pub type EVD11_R = crate :: BitReader < bool > ; # [doc = "Field `EVD11` writer - Channel 11 Event Detection"]
pub type EVD11_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 27 > ; impl R { # [doc = "Bit 0 - Channel 0 Overrun"]
# [inline (always)]
pub fn ovr0 (& self) -> OVR0_R { OVR0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Channel 1 Overrun"]
# [inline (always)]
pub fn ovr1 (& self) -> OVR1_R { OVR1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Channel 2 Overrun"]
# [inline (always)]
pub fn ovr2 (& self) -> OVR2_R { OVR2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Channel 3 Overrun"]
# [inline (always)]
pub fn ovr3 (& self) -> OVR3_R { OVR3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Channel 4 Overrun"]
# [inline (always)]
pub fn ovr4 (& self) -> OVR4_R { OVR4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Channel 5 Overrun"]
# [inline (always)]
pub fn ovr5 (& self) -> OVR5_R { OVR5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Channel 6 Overrun"]
# [inline (always)]
pub fn ovr6 (& self) -> OVR6_R { OVR6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Channel 7 Overrun"]
# [inline (always)]
pub fn ovr7 (& self) -> OVR7_R { OVR7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Channel 0 Event Detection"]
# [inline (always)]
pub fn evd0 (& self) -> EVD0_R { EVD0_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Channel 1 Event Detection"]
# [inline (always)]
pub fn evd1 (& self) -> EVD1_R { EVD1_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Channel 2 Event Detection"]
# [inline (always)]
pub fn evd2 (& self) -> EVD2_R { EVD2_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Channel 3 Event Detection"]
# [inline (always)]
pub fn evd3 (& self) -> EVD3_R { EVD3_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Channel 4 Event Detection"]
# [inline (always)]
pub fn evd4 (& self) -> EVD4_R { EVD4_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Channel 5 Event Detection"]
# [inline (always)]
pub fn evd5 (& self) -> EVD5_R { EVD5_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Channel 6 Event Detection"]
# [inline (always)]
pub fn evd6 (& self) -> EVD6_R { EVD6_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Channel 7 Event Detection"]
# [inline (always)]
pub fn evd7 (& self) -> EVD7_R { EVD7_R :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - Channel 8 Overrun"]
# [inline (always)]
pub fn ovr8 (& self) -> OVR8_R { OVR8_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Channel 9 Overrun"]
# [inline (always)]
pub fn ovr9 (& self) -> OVR9_R { OVR9_R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Channel 10 Overrun"]
# [inline (always)]
pub fn ovr10 (& self) -> OVR10_R { OVR10_R :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Channel 11 Overrun"]
# [inline (always)]
pub fn ovr11 (& self) -> OVR11_R { OVR11_R :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 24 - Channel 8 Event Detection"]
# [inline (always)]
pub fn evd8 (& self) -> EVD8_R { EVD8_R :: new (((self . bits >> 24) & 1) != 0) } # [doc = "Bit 25 - Channel 9 Event Detection"]
# [inline (always)]
pub fn evd9 (& self) -> EVD9_R { EVD9_R :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - Channel 10 Event Detection"]
# [inline (always)]
pub fn evd10 (& self) -> EVD10_R { EVD10_R :: new (((self . bits >> 26) & 1) != 0) } # [doc = "Bit 27 - Channel 11 Event Detection"]
# [inline (always)]
pub fn evd11 (& self) -> EVD11_R { EVD11_R :: new (((self . bits >> 27) & 1) != 0) } } impl W { # [doc = "Bit 0 - Channel 0 Overrun"]
# [inline (always)]
pub fn ovr0 (& mut self) -> OVR0_W { OVR0_W :: new (self) } # [doc = "Bit 1 - Channel 1 Overrun"]
# [inline (always)]
pub fn ovr1 (& mut self) -> OVR1_W { OVR1_W :: new (self) } # [doc = "Bit 2 - Channel 2 Overrun"]
# [inline (always)]
pub fn ovr2 (& mut self) -> OVR2_W { OVR2_W :: new (self) } # [doc = "Bit 3 - Channel 3 Overrun"]
# [inline (always)]
pub fn ovr3 (& mut self) -> OVR3_W { OVR3_W :: new (self) } # [doc = "Bit 4 - Channel 4 Overrun"]
# [inline (always)]
pub fn ovr4 (& mut self) -> OVR4_W { OVR4_W :: new (self) } # [doc = "Bit 5 - Channel 5 Overrun"]
# [inline (always)]
pub fn ovr5 (& mut self) -> OVR5_W { OVR5_W :: new (self) } # [doc = "Bit 6 - Channel 6 Overrun"]
# [inline (always)]
pub fn ovr6 (& mut self) -> OVR6_W { OVR6_W :: new (self) } # [doc = "Bit 7 - Channel 7 Overrun"]
# [inline (always)]
pub fn ovr7 (& mut self) -> OVR7_W { OVR7_W :: new (self) } # [doc = "Bit 8 - Channel 0 Event Detection"]
# [inline (always)]
pub fn evd0 (& mut self) -> EVD0_W { EVD0_W :: new (self) } # [doc = "Bit 9 - Channel 1 Event Detection"]
# [inline (always)]
pub fn evd1 (& mut self) -> EVD1_W { EVD1_W :: new (self) } # [doc = "Bit 10 - Channel 2 Event Detection"]
# [inline (always)]
pub fn evd2 (& mut self) -> EVD2_W { EVD2_W :: new (self) } # [doc = "Bit 11 - Channel 3 Event Detection"]
# [inline (always)]
pub fn evd3 (& mut self) -> EVD3_W { EVD3_W :: new (self) } # [doc = "Bit 12 - Channel 4 Event Detection"]
# [inline (always)]
pub fn evd4 (& mut self) -> EVD4_W { EVD4_W :: new (self) } # [doc = "Bit 13 - Channel 5 Event Detection"]
# [inline (always)]
pub fn evd5 (& mut self) -> EVD5_W { EVD5_W :: new (self) } # [doc = "Bit 14 - Channel 6 Event Detection"]
# [inline (always)]
pub fn evd6 (& mut self) -> EVD6_W { EVD6_W :: new (self) } # [doc = "Bit 15 - Channel 7 Event Detection"]
# [inline (always)]
pub fn evd7 (& mut self) -> EVD7_W { EVD7_W :: new (self) } # [doc = "Bit 16 - Channel 8 Overrun"]
# [inline (always)]
pub fn ovr8 (& mut self) -> OVR8_W { OVR8_W :: new (self) } # [doc = "Bit 17 - Channel 9 Overrun"]
# [inline (always)]
pub fn ovr9 (& mut self) -> OVR9_W { OVR9_W :: new (self) } # [doc = "Bit 18 - Channel 10 Overrun"]
# [inline (always)]
pub fn ovr10 (& mut self) -> OVR10_W { OVR10_W :: new (self) } # [doc = "Bit 19 - Channel 11 Overrun"]
# [inline (always)]
pub fn ovr11 (& mut self) -> OVR11_W { OVR11_W :: new (self) } # [doc = "Bit 24 - Channel 8 Event Detection"]
# [inline (always)]
pub fn evd8 (& mut self) -> EVD8_W { EVD8_W :: new (self) } # [doc = "Bit 25 - Channel 9 Event Detection"]
# [inline (always)]
pub fn evd9 (& mut self) -> EVD9_W { EVD9_W :: new (self) } # [doc = "Bit 26 - Channel 10 Event Detection"]
# [inline (always)]
pub fn evd10 (& mut self) -> EVD10_W { EVD10_W :: new (self) } # [doc = "Bit 27 - Channel 11 Event Detection"]
# [inline (always)]
pub fn evd11 (& mut self) -> EVD11_W { EVD11_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflag](index.html) module"]
pub struct INTFLAG_SPEC ; impl crate :: RegisterSpec for INTFLAG_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [intflag::R](R) reader structure"]
impl crate :: Readable for INTFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflag::W](W) writer structure"]
impl crate :: Writable for INTFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTFLAG to value 0"]
impl crate :: Resettable for INTFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "Generic Clock Generator"]
pub struct GCLK { _marker : PhantomData < * const () > } unsafe impl Send for GCLK { } impl GCLK { # [doc = r"Pointer to the register block"]
pub const PTR : * const gclk :: RegisterBlock = 0x4000_0c00 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const gclk :: RegisterBlock { Self :: PTR } } impl Deref for GCLK { type Target = gclk :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for GCLK { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("GCLK") . finish () } } # [doc = "Generic Clock Generator"]
pub mod gclk { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control"]
pub ctrl : crate :: Reg < ctrl :: CTRL_SPEC > , # [doc = "0x01 - Status"]
pub status : crate :: Reg < status :: STATUS_SPEC > , # [doc = "0x02 - Generic Clock Control"]
pub clkctrl : crate :: Reg < clkctrl :: CLKCTRL_SPEC > , # [doc = "0x04 - Generic Clock Generator Control"]
pub genctrl : crate :: Reg < genctrl :: GENCTRL_SPEC > , # [doc = "0x08 - Generic Clock Generator Division"]
pub gendiv : crate :: Reg < gendiv :: GENDIV_SPEC > , } # [doc = "CTRL register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWRST` reader - Software Reset"]
pub type SWRST_R = crate :: BitReader < bool > ; # [doc = "Field `SWRST` writer - Software Reset"]
pub type SWRST_W < 'a > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , 0 > ; impl R { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& self) -> SWRST_R { SWRST_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& mut self) -> SWRST_W { SWRST_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATUS register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `SYNCBUSY` reader - Synchronization Busy Status"]
pub type SYNCBUSY_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 7 - Synchronization Busy Status"]
# [inline (always)]
pub fn syncbusy (& self) -> SYNCBUSY_R { SYNCBUSY_R :: new (((self . bits >> 7) & 1) != 0) } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CLKCTRL register accessor: an alias for `Reg<CLKCTRL_SPEC>`"]
pub type CLKCTRL = crate :: Reg < clkctrl :: CLKCTRL_SPEC > ; # [doc = "Generic Clock Control"]
pub mod clkctrl { # [doc = "Register `CLKCTRL` reader"]
pub struct R (crate :: R < CLKCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CLKCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CLKCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CLKCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CLKCTRL` writer"]
pub struct W (crate :: W < CLKCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CLKCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CLKCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CLKCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Generic Clock Selection ID\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum ID_A { # [doc = "0: DFLL48"]
DFLL48 = 0 , # [doc = "1: FDPLL"]
FDPLL = 1 , # [doc = "2: FDPLL32K"]
FDPLL32K = 2 , # [doc = "3: WDT"]
WDT = 3 , # [doc = "4: RTC"]
RTC = 4 , # [doc = "5: EIC"]
EIC = 5 , # [doc = "6: USB"]
USB = 6 , # [doc = "7: EVSYS_0"]
EVSYS_0 = 7 , # [doc = "8: EVSYS_1"]
EVSYS_1 = 8 , # [doc = "9: EVSYS_2"]
EVSYS_2 = 9 , # [doc = "10: EVSYS_3"]
EVSYS_3 = 10 , # [doc = "11: EVSYS_4"]
EVSYS_4 = 11 , # [doc = "12: EVSYS_5"]
EVSYS_5 = 12 , # [doc = "13: EVSYS_6"]
EVSYS_6 = 13 , # [doc = "14: EVSYS_7"]
EVSYS_7 = 14 , # [doc = "15: EVSYS_8"]
EVSYS_8 = 15 , # [doc = "16: EVSYS_9"]
EVSYS_9 = 16 , # [doc = "17: EVSYS_10"]
EVSYS_10 = 17 , # [doc = "18: EVSYS_11"]
EVSYS_11 = 18 , # [doc = "19: SERCOMX_SLOW"]
SERCOMX_SLOW = 19 , # [doc = "20: SERCOM0_CORE"]
SERCOM0_CORE = 20 , # [doc = "21: SERCOM1_CORE"]
SERCOM1_CORE = 21 , # [doc = "22: SERCOM2_CORE"]
SERCOM2_CORE = 22 , # [doc = "23: SERCOM3_CORE"]
SERCOM3_CORE = 23 , # [doc = "24: SERCOM4_CORE"]
SERCOM4_CORE = 24 , # [doc = "25: SERCOM5_CORE"]
SERCOM5_CORE = 25 , # [doc = "26: TCC0_TCC1"]
TCC0_TCC1 = 26 , # [doc = "27: TCC2_TC3"]
TCC2_TC3 = 27 , # [doc = "28: TC4_TC5"]
TC4_TC5 = 28 , # [doc = "29: TC6_TC7"]
TC6_TC7 = 29 , # [doc = "30: ADC"]
ADC = 30 , # [doc = "31: AC_DIG"]
AC_DIG = 31 , # [doc = "32: AC_ANA"]
AC_ANA = 32 , # [doc = "33: DAC"]
DAC = 33 , # [doc = "35: I2S_0"]
I2S_0 = 35 , # [doc = "36: I2S_1"]
I2S_1 = 36 , } impl From < ID_A > for u8 { # [inline (always)]
fn from (variant : ID_A) -> Self { variant as _ } } # [doc = "Field `ID` reader - Generic Clock Selection ID"]
pub type ID_R = crate :: FieldReader < u8 , ID_A > ; impl ID_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ID_A > { match self . bits { 0 => Some (ID_A :: DFLL48) , 1 => Some (ID_A :: FDPLL) , 2 => Some (ID_A :: FDPLL32K) , 3 => Some (ID_A :: WDT) , 4 => Some (ID_A :: RTC) , 5 => Some (ID_A :: EIC) , 6 => Some (ID_A :: USB) , 7 => Some (ID_A :: EVSYS_0) , 8 => Some (ID_A :: EVSYS_1) , 9 => Some (ID_A :: EVSYS_2) , 10 => Some (ID_A :: EVSYS_3) , 11 => Some (ID_A :: EVSYS_4) , 12 => Some (ID_A :: EVSYS_5) , 13 => Some (ID_A :: EVSYS_6) , 14 => Some (ID_A :: EVSYS_7) , 15 => Some (ID_A :: EVSYS_8) , 16 => Some (ID_A :: EVSYS_9) , 17 => Some (ID_A :: EVSYS_10) , 18 => Some (ID_A :: EVSYS_11) , 19 => Some (ID_A :: SERCOMX_SLOW) , 20 => Some (ID_A :: SERCOM0_CORE) , 21 => Some (ID_A :: SERCOM1_CORE) , 22 => Some (ID_A :: SERCOM2_CORE) , 23 => Some (ID_A :: SERCOM3_CORE) , 24 => Some (ID_A :: SERCOM4_CORE) , 25 => Some (ID_A :: SERCOM5_CORE) , 26 => Some (ID_A :: TCC0_TCC1) , 27 => Some (ID_A :: TCC2_TC3) , 28 => Some (ID_A :: TC4_TC5) , 29 => Some (ID_A :: TC6_TC7) , 30 => Some (ID_A :: ADC) , 31 => Some (ID_A :: AC_DIG) , 32 => Some (ID_A :: AC_ANA) , 33 => Some (ID_A :: DAC) , 35 => Some (ID_A :: I2S_0) , 36 => Some (ID_A :: I2S_1) , _ => None , } } # [doc = "Checks if the value of the field is `DFLL48`"]
# [inline (always)]
pub fn is_dfll48 (& self) -> bool { * self == ID_A :: DFLL48 } # [doc = "Checks if the value of the field is `FDPLL`"]
# [inline (always)]
pub fn is_fdpll (& self) -> bool { * self == ID_A :: FDPLL } # [doc = "Checks if the value of the field is `FDPLL32K`"]
# [inline (always)]
pub fn is_fdpll32k (& self) -> bool { * self == ID_A :: FDPLL32K } # [doc = "Checks if the value of the field is `WDT`"]
# [inline (always)]
pub fn is_wdt (& self) -> bool { * self == ID_A :: WDT } # [doc = "Checks if the value of the field is `RTC`"]
# [inline (always)]
pub fn is_rtc (& self) -> bool { * self == ID_A :: RTC } # [doc = "Checks if the value of the field is `EIC`"]
# [inline (always)]
pub fn is_eic (& self) -> bool { * self == ID_A :: EIC } # [doc = "Checks if the value of the field is `USB`"]
# [inline (always)]
pub fn is_usb (& self) -> bool { * self == ID_A :: USB } # [doc = "Checks if the value of the field is `EVSYS_0`"]
# [inline (always)]
pub fn is_evsys_0 (& self) -> bool { * self == ID_A :: EVSYS_0 } # [doc = "Checks if the value of the field is `EVSYS_1`"]
# [inline (always)]
pub fn is_evsys_1 (& self) -> bool { * self == ID_A :: EVSYS_1 } # [doc = "Checks if the value of the field is `EVSYS_2`"]
# [inline (always)]
pub fn is_evsys_2 (& self) -> bool { * self == ID_A :: EVSYS_2 } # [doc = "Checks if the value of the field is `EVSYS_3`"]
# [inline (always)]
pub fn is_evsys_3 (& self) -> bool { * self == ID_A :: EVSYS_3 } # [doc = "Checks if the value of the field is `EVSYS_4`"]
# [inline (always)]
pub fn is_evsys_4 (& self) -> bool { * self == ID_A :: EVSYS_4 } # [doc = "Checks if the value of the field is `EVSYS_5`"]
# [inline (always)]
pub fn is_evsys_5 (& self) -> bool { * self == ID_A :: EVSYS_5 } # [doc = "Checks if the value of the field is `EVSYS_6`"]
# [inline (always)]
pub fn is_evsys_6 (& self) -> bool { * self == ID_A :: EVSYS_6 } # [doc = "Checks if the value of the field is `EVSYS_7`"]
# [inline (always)]
pub fn is_evsys_7 (& self) -> bool { * self == ID_A :: EVSYS_7 } # [doc = "Checks if the value of the field is `EVSYS_8`"]
# [inline (always)]
pub fn is_evsys_8 (& self) -> bool { * self == ID_A :: EVSYS_8 } # [doc = "Checks if the value of the field is `EVSYS_9`"]
# [inline (always)]
pub fn is_evsys_9 (& self) -> bool { * self == ID_A :: EVSYS_9 } # [doc = "Checks if the value of the field is `EVSYS_10`"]
# [inline (always)]
pub fn is_evsys_10 (& self) -> bool { * self == ID_A :: EVSYS_10 } # [doc = "Checks if the value of the field is `EVSYS_11`"]
# [inline (always)]
pub fn is_evsys_11 (& self) -> bool { * self == ID_A :: EVSYS_11 } # [doc = "Checks if the value of the field is `SERCOMX_SLOW`"]
# [inline (always)]
pub fn is_sercomx_slow (& self) -> bool { * self == ID_A :: SERCOMX_SLOW } # [doc = "Checks if the value of the field is `SERCOM0_CORE`"]
# [inline (always)]
pub fn is_sercom0_core (& self) -> bool { * self == ID_A :: SERCOM0_CORE } # [doc = "Checks if the value of the field is `SERCOM1_CORE`"]
# [inline (always)]
pub fn is_sercom1_core (& self) -> bool { * self == ID_A :: SERCOM1_CORE } # [doc = "Checks if the value of the field is `SERCOM2_CORE`"]
# [inline (always)]
pub fn is_sercom2_core (& self) -> bool { * self == ID_A :: SERCOM2_CORE } # [doc = "Checks if the value of the field is `SERCOM3_CORE`"]
# [inline (always)]
pub fn is_sercom3_core (& self) -> bool { * self == ID_A :: SERCOM3_CORE } # [doc = "Checks if the value of the field is `SERCOM4_CORE`"]
# [inline (always)]
pub fn is_sercom4_core (& self) -> bool { * self == ID_A :: SERCOM4_CORE } # [doc = "Checks if the value of the field is `SERCOM5_CORE`"]
# [inline (always)]
pub fn is_sercom5_core (& self) -> bool { * self == ID_A :: SERCOM5_CORE } # [doc = "Checks if the value of the field is `TCC0_TCC1`"]
# [inline (always)]
pub fn is_tcc0_tcc1 (& self) -> bool { * self == ID_A :: TCC0_TCC1 } # [doc = "Checks if the value of the field is `TCC2_TC3`"]
# [inline (always)]
pub fn is_tcc2_tc3 (& self) -> bool { * self == ID_A :: TCC2_TC3 } # [doc = "Checks if the value of the field is `TC4_TC5`"]
# [inline (always)]
pub fn is_tc4_tc5 (& self) -> bool { * self == ID_A :: TC4_TC5 } # [doc = "Checks if the value of the field is `TC6_TC7`"]
# [inline (always)]
pub fn is_tc6_tc7 (& self) -> bool { * self == ID_A :: TC6_TC7 } # [doc = "Checks if the value of the field is `ADC`"]
# [inline (always)]
pub fn is_adc (& self) -> bool { * self == ID_A :: ADC } # [doc = "Checks if the value of the field is `AC_DIG`"]
# [inline (always)]
pub fn is_ac_dig (& self) -> bool { * self == ID_A :: AC_DIG } # [doc = "Checks if the value of the field is `AC_ANA`"]
# [inline (always)]
pub fn is_ac_ana (& self) -> bool { * self == ID_A :: AC_ANA } # [doc = "Checks if the value of the field is `DAC`"]
# [inline (always)]
pub fn is_dac (& self) -> bool { * self == ID_A :: DAC } # [doc = "Checks if the value of the field is `I2S_0`"]
# [inline (always)]
pub fn is_i2s_0 (& self) -> bool { * self == ID_A :: I2S_0 } # [doc = "Checks if the value of the field is `I2S_1`"]
# [inline (always)]
pub fn is_i2s_1 (& self) -> bool { * self == ID_A :: I2S_1 } } # [doc = "Field `ID` writer - Generic Clock Selection ID"]
pub type ID_W < 'a > = crate :: FieldWriter < 'a , u16 , CLKCTRL_SPEC , u8 , ID_A , 6 , 0 > ; impl < 'a > ID_W < 'a > { # [doc = "DFLL48"]
# [inline (always)]
pub fn dfll48 (self) -> & 'a mut W { self . variant (ID_A :: DFLL48) } # [doc = "FDPLL"]
# [inline (always)]
pub fn fdpll (self) -> & 'a mut W { self . variant (ID_A :: FDPLL) } # [doc = "FDPLL32K"]
# [inline (always)]
pub fn fdpll32k (self) -> & 'a mut W { self . variant (ID_A :: FDPLL32K) } # [doc = "WDT"]
# [inline (always)]
pub fn wdt (self) -> & 'a mut W { self . variant (ID_A :: WDT) } # [doc = "RTC"]
# [inline (always)]
pub fn rtc (self) -> & 'a mut W { self . variant (ID_A :: RTC) } # [doc = "EIC"]
# [inline (always)]
pub fn eic (self) -> & 'a mut W { self . variant (ID_A :: EIC) } # [doc = "USB"]
# [inline (always)]
pub fn usb (self) -> & 'a mut W { self . variant (ID_A :: USB) } # [doc = "EVSYS_0"]
# [inline (always)]
pub fn evsys_0 (self) -> & 'a mut W { self . variant (ID_A :: EVSYS_0) } # [doc = "EVSYS_1"]
# [inline (always)]
pub fn evsys_1 (self) -> & 'a mut W { self . variant (ID_A :: EVSYS_1) } # [doc = "EVSYS_2"]
# [inline (always)]
pub fn evsys_2 (self) -> & 'a mut W { self . variant (ID_A :: EVSYS_2) } # [doc = "EVSYS_3"]
# [inline (always)]
pub fn evsys_3 (self) -> & 'a mut W { self . variant (ID_A :: EVSYS_3) } # [doc = "EVSYS_4"]
# [inline (always)]
pub fn evsys_4 (self) -> & 'a mut W { self . variant (ID_A :: EVSYS_4) } # [doc = "EVSYS_5"]
# [inline (always)]
pub fn evsys_5 (self) -> & 'a mut W { self . variant (ID_A :: EVSYS_5) } # [doc = "EVSYS_6"]
# [inline (always)]
pub fn evsys_6 (self) -> & 'a mut W { self . variant (ID_A :: EVSYS_6) } # [doc = "EVSYS_7"]
# [inline (always)]
pub fn evsys_7 (self) -> & 'a mut W { self . variant (ID_A :: EVSYS_7) } # [doc = "EVSYS_8"]
# [inline (always)]
pub fn evsys_8 (self) -> & 'a mut W { self . variant (ID_A :: EVSYS_8) } # [doc = "EVSYS_9"]
# [inline (always)]
pub fn evsys_9 (self) -> & 'a mut W { self . variant (ID_A :: EVSYS_9) } # [doc = "EVSYS_10"]
# [inline (always)]
pub fn evsys_10 (self) -> & 'a mut W { self . variant (ID_A :: EVSYS_10) } # [doc = "EVSYS_11"]
# [inline (always)]
pub fn evsys_11 (self) -> & 'a mut W { self . variant (ID_A :: EVSYS_11) } # [doc = "SERCOMX_SLOW"]
# [inline (always)]
pub fn sercomx_slow (self) -> & 'a mut W { self . variant (ID_A :: SERCOMX_SLOW) } # [doc = "SERCOM0_CORE"]
# [inline (always)]
pub fn sercom0_core (self) -> & 'a mut W { self . variant (ID_A :: SERCOM0_CORE) } # [doc = "SERCOM1_CORE"]
# [inline (always)]
pub fn sercom1_core (self) -> & 'a mut W { self . variant (ID_A :: SERCOM1_CORE) } # [doc = "SERCOM2_CORE"]
# [inline (always)]
pub fn sercom2_core (self) -> & 'a mut W { self . variant (ID_A :: SERCOM2_CORE) } # [doc = "SERCOM3_CORE"]
# [inline (always)]
pub fn sercom3_core (self) -> & 'a mut W { self . variant (ID_A :: SERCOM3_CORE) } # [doc = "SERCOM4_CORE"]
# [inline (always)]
pub fn sercom4_core (self) -> & 'a mut W { self . variant (ID_A :: SERCOM4_CORE) } # [doc = "SERCOM5_CORE"]
# [inline (always)]
pub fn sercom5_core (self) -> & 'a mut W { self . variant (ID_A :: SERCOM5_CORE) } # [doc = "TCC0_TCC1"]
# [inline (always)]
pub fn tcc0_tcc1 (self) -> & 'a mut W { self . variant (ID_A :: TCC0_TCC1) } # [doc = "TCC2_TC3"]
# [inline (always)]
pub fn tcc2_tc3 (self) -> & 'a mut W { self . variant (ID_A :: TCC2_TC3) } # [doc = "TC4_TC5"]
# [inline (always)]
pub fn tc4_tc5 (self) -> & 'a mut W { self . variant (ID_A :: TC4_TC5) } # [doc = "TC6_TC7"]
# [inline (always)]
pub fn tc6_tc7 (self) -> & 'a mut W { self . variant (ID_A :: TC6_TC7) } # [doc = "ADC"]
# [inline (always)]
pub fn adc (self) -> & 'a mut W { self . variant (ID_A :: ADC) } # [doc = "AC_DIG"]
# [inline (always)]
pub fn ac_dig (self) -> & 'a mut W { self . variant (ID_A :: AC_DIG) } # [doc = "AC_ANA"]
# [inline (always)]
pub fn ac_ana (self) -> & 'a mut W { self . variant (ID_A :: AC_ANA) } # [doc = "DAC"]
# [inline (always)]
pub fn dac (self) -> & 'a mut W { self . variant (ID_A :: DAC) } # [doc = "I2S_0"]
# [inline (always)]
pub fn i2s_0 (self) -> & 'a mut W { self . variant (ID_A :: I2S_0) } # [doc = "I2S_1"]
# [inline (always)]
pub fn i2s_1 (self) -> & 'a mut W { self . variant (ID_A :: I2S_1) } } # [doc = "Generic Clock Generator\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum GEN_A { # [doc = "0: Generic clock generator 0"]
GCLK0 = 0 , # [doc = "1: Generic clock generator 1"]
GCLK1 = 1 , # [doc = "2: Generic clock generator 2"]
GCLK2 = 2 , # [doc = "3: Generic clock generator 3"]
GCLK3 = 3 , # [doc = "4: Generic clock generator 4"]
GCLK4 = 4 , # [doc = "5: Generic clock generator 5"]
GCLK5 = 5 , # [doc = "6: Generic clock generator 6"]
GCLK6 = 6 , # [doc = "7: Generic clock generator 7"]
GCLK7 = 7 , } impl From < GEN_A > for u8 { # [inline (always)]
fn from (variant : GEN_A) -> Self { variant as _ } } # [doc = "Field `GEN` reader - Generic Clock Generator"]
pub type GEN_R = crate :: FieldReader < u8 , GEN_A > ; impl GEN_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < GEN_A > { match self . bits { 0 => Some (GEN_A :: GCLK0) , 1 => Some (GEN_A :: GCLK1) , 2 => Some (GEN_A :: GCLK2) , 3 => Some (GEN_A :: GCLK3) , 4 => Some (GEN_A :: GCLK4) , 5 => Some (GEN_A :: GCLK5) , 6 => Some (GEN_A :: GCLK6) , 7 => Some (GEN_A :: GCLK7) , _ => None , } } # [doc = "Checks if the value of the field is `GCLK0`"]
# [inline (always)]
pub fn is_gclk0 (& self) -> bool { * self == GEN_A :: GCLK0 } # [doc = "Checks if the value of the field is `GCLK1`"]
# [inline (always)]
pub fn is_gclk1 (& self) -> bool { * self == GEN_A :: GCLK1 } # [doc = "Checks if the value of the field is `GCLK2`"]
# [inline (always)]
pub fn is_gclk2 (& self) -> bool { * self == GEN_A :: GCLK2 } # [doc = "Checks if the value of the field is `GCLK3`"]
# [inline (always)]
pub fn is_gclk3 (& self) -> bool { * self == GEN_A :: GCLK3 } # [doc = "Checks if the value of the field is `GCLK4`"]
# [inline (always)]
pub fn is_gclk4 (& self) -> bool { * self == GEN_A :: GCLK4 } # [doc = "Checks if the value of the field is `GCLK5`"]
# [inline (always)]
pub fn is_gclk5 (& self) -> bool { * self == GEN_A :: GCLK5 } # [doc = "Checks if the value of the field is `GCLK6`"]
# [inline (always)]
pub fn is_gclk6 (& self) -> bool { * self == GEN_A :: GCLK6 } # [doc = "Checks if the value of the field is `GCLK7`"]
# [inline (always)]
pub fn is_gclk7 (& self) -> bool { * self == GEN_A :: GCLK7 } } # [doc = "Field `GEN` writer - Generic Clock Generator"]
pub type GEN_W < 'a > = crate :: FieldWriter < 'a , u16 , CLKCTRL_SPEC , u8 , GEN_A , 4 , 8 > ; impl < 'a > GEN_W < 'a > { # [doc = "Generic clock generator 0"]
# [inline (always)]
pub fn gclk0 (self) -> & 'a mut W { self . variant (GEN_A :: GCLK0) } # [doc = "Generic clock generator 1"]
# [inline (always)]
pub fn gclk1 (self) -> & 'a mut W { self . variant (GEN_A :: GCLK1) } # [doc = "Generic clock generator 2"]
# [inline (always)]
pub fn gclk2 (self) -> & 'a mut W { self . variant (GEN_A :: GCLK2) } # [doc = "Generic clock generator 3"]
# [inline (always)]
pub fn gclk3 (self) -> & 'a mut W { self . variant (GEN_A :: GCLK3) } # [doc = "Generic clock generator 4"]
# [inline (always)]
pub fn gclk4 (self) -> & 'a mut W { self . variant (GEN_A :: GCLK4) } # [doc = "Generic clock generator 5"]
# [inline (always)]
pub fn gclk5 (self) -> & 'a mut W { self . variant (GEN_A :: GCLK5) } # [doc = "Generic clock generator 6"]
# [inline (always)]
pub fn gclk6 (self) -> & 'a mut W { self . variant (GEN_A :: GCLK6) } # [doc = "Generic clock generator 7"]
# [inline (always)]
pub fn gclk7 (self) -> & 'a mut W { self . variant (GEN_A :: GCLK7) } } # [doc = "Field `CLKEN` reader - Clock Enable"]
pub type CLKEN_R = crate :: BitReader < bool > ; # [doc = "Field `CLKEN` writer - Clock Enable"]
pub type CLKEN_W < 'a > = crate :: BitWriter < 'a , u16 , CLKCTRL_SPEC , bool , 14 > ; # [doc = "Field `WRTLOCK` reader - Write Lock"]
pub type WRTLOCK_R = crate :: BitReader < bool > ; # [doc = "Field `WRTLOCK` writer - Write Lock"]
pub type WRTLOCK_W < 'a > = crate :: BitWriter < 'a , u16 , CLKCTRL_SPEC , bool , 15 > ; impl R { # [doc = "Bits 0:5 - Generic Clock Selection ID"]
# [inline (always)]
pub fn id (& self) -> ID_R { ID_R :: new ((self . bits & 0x3f) as u8) } # [doc = "Bits 8:11 - Generic Clock Generator"]
# [inline (always)]
pub fn gen (& self) -> GEN_R { GEN_R :: new (((self . bits >> 8) & 0x0f) as u8) } # [doc = "Bit 14 - Clock Enable"]
# [inline (always)]
pub fn clken (& self) -> CLKEN_R { CLKEN_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Write Lock"]
# [inline (always)]
pub fn wrtlock (& self) -> WRTLOCK_R { WRTLOCK_R :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bits 0:5 - Generic Clock Selection ID"]
# [inline (always)]
pub fn id (& mut self) -> ID_W { ID_W :: new (self) } # [doc = "Bits 8:11 - Generic Clock Generator"]
# [inline (always)]
pub fn gen (& mut self) -> GEN_W { GEN_W :: new (self) } # [doc = "Bit 14 - Clock Enable"]
# [inline (always)]
pub fn clken (& mut self) -> CLKEN_W { CLKEN_W :: new (self) } # [doc = "Bit 15 - Write Lock"]
# [inline (always)]
pub fn wrtlock (& mut self) -> WRTLOCK_W { WRTLOCK_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Generic Clock Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clkctrl](index.html) module"]
pub struct CLKCTRL_SPEC ; impl crate :: RegisterSpec for CLKCTRL_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [clkctrl::R](R) reader structure"]
impl crate :: Readable for CLKCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [clkctrl::W](W) writer structure"]
impl crate :: Writable for CLKCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CLKCTRL to value 0"]
impl crate :: Resettable for CLKCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "GENCTRL register accessor: an alias for `Reg<GENCTRL_SPEC>`"]
pub type GENCTRL = crate :: Reg < genctrl :: GENCTRL_SPEC > ; # [doc = "Generic Clock Generator Control"]
pub mod genctrl { # [doc = "Register `GENCTRL` reader"]
pub struct R (crate :: R < GENCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GENCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GENCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GENCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `GENCTRL` writer"]
pub struct W (crate :: W < GENCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GENCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GENCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GENCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ID` reader - Generic Clock Generator Selection"]
pub type ID_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `ID` writer - Generic Clock Generator Selection"]
pub type ID_W < 'a > = crate :: FieldWriter < 'a , u32 , GENCTRL_SPEC , u8 , u8 , 4 , 0 > ; # [doc = "Source Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum SRC_A { # [doc = "0: XOSC oscillator output"]
XOSC = 0 , # [doc = "1: Generator input pad"]
GCLKIN = 1 , # [doc = "2: Generic clock generator 1 output"]
GCLKGEN1 = 2 , # [doc = "3: OSCULP32K oscillator output"]
OSCULP32K = 3 , # [doc = "4: OSC32K oscillator output"]
OSC32K = 4 , # [doc = "5: XOSC32K oscillator output"]
XOSC32K = 5 , # [doc = "6: OSC8M oscillator output"]
OSC8M = 6 , # [doc = "7: DFLL48M output"]
DFLL48M = 7 , # [doc = "8: FDPLL output"]
FDPLL = 8 , } impl From < SRC_A > for u8 { # [inline (always)]
fn from (variant : SRC_A) -> Self { variant as _ } } # [doc = "Field `SRC` reader - Source Select"]
pub type SRC_R = crate :: FieldReader < u8 , SRC_A > ; impl SRC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SRC_A > { match self . bits { 0 => Some (SRC_A :: XOSC) , 1 => Some (SRC_A :: GCLKIN) , 2 => Some (SRC_A :: GCLKGEN1) , 3 => Some (SRC_A :: OSCULP32K) , 4 => Some (SRC_A :: OSC32K) , 5 => Some (SRC_A :: XOSC32K) , 6 => Some (SRC_A :: OSC8M) , 7 => Some (SRC_A :: DFLL48M) , 8 => Some (SRC_A :: FDPLL) , _ => None , } } # [doc = "Checks if the value of the field is `XOSC`"]
# [inline (always)]
pub fn is_xosc (& self) -> bool { * self == SRC_A :: XOSC } # [doc = "Checks if the value of the field is `GCLKIN`"]
# [inline (always)]
pub fn is_gclkin (& self) -> bool { * self == SRC_A :: GCLKIN } # [doc = "Checks if the value of the field is `GCLKGEN1`"]
# [inline (always)]
pub fn is_gclkgen1 (& self) -> bool { * self == SRC_A :: GCLKGEN1 } # [doc = "Checks if the value of the field is `OSCULP32K`"]
# [inline (always)]
pub fn is_osculp32k (& self) -> bool { * self == SRC_A :: OSCULP32K } # [doc = "Checks if the value of the field is `OSC32K`"]
# [inline (always)]
pub fn is_osc32k (& self) -> bool { * self == SRC_A :: OSC32K } # [doc = "Checks if the value of the field is `XOSC32K`"]
# [inline (always)]
pub fn is_xosc32k (& self) -> bool { * self == SRC_A :: XOSC32K } # [doc = "Checks if the value of the field is `OSC8M`"]
# [inline (always)]
pub fn is_osc8m (& self) -> bool { * self == SRC_A :: OSC8M } # [doc = "Checks if the value of the field is `DFLL48M`"]
# [inline (always)]
pub fn is_dfll48m (& self) -> bool { * self == SRC_A :: DFLL48M } # [doc = "Checks if the value of the field is `FDPLL`"]
# [inline (always)]
pub fn is_fdpll (& self) -> bool { * self == SRC_A :: FDPLL } } # [doc = "Field `SRC` writer - Source Select"]
pub type SRC_W < 'a > = crate :: FieldWriter < 'a , u32 , GENCTRL_SPEC , u8 , SRC_A , 5 , 8 > ; impl < 'a > SRC_W < 'a > { # [doc = "XOSC oscillator output"]
# [inline (always)]
pub fn xosc (self) -> & 'a mut W { self . variant (SRC_A :: XOSC) } # [doc = "Generator input pad"]
# [inline (always)]
pub fn gclkin (self) -> & 'a mut W { self . variant (SRC_A :: GCLKIN) } # [doc = "Generic clock generator 1 output"]
# [inline (always)]
pub fn gclkgen1 (self) -> & 'a mut W { self . variant (SRC_A :: GCLKGEN1) } # [doc = "OSCULP32K oscillator output"]
# [inline (always)]
pub fn osculp32k (self) -> & 'a mut W { self . variant (SRC_A :: OSCULP32K) } # [doc = "OSC32K oscillator output"]
# [inline (always)]
pub fn osc32k (self) -> & 'a mut W { self . variant (SRC_A :: OSC32K) } # [doc = "XOSC32K oscillator output"]
# [inline (always)]
pub fn xosc32k (self) -> & 'a mut W { self . variant (SRC_A :: XOSC32K) } # [doc = "OSC8M oscillator output"]
# [inline (always)]
pub fn osc8m (self) -> & 'a mut W { self . variant (SRC_A :: OSC8M) } # [doc = "DFLL48M output"]
# [inline (always)]
pub fn dfll48m (self) -> & 'a mut W { self . variant (SRC_A :: DFLL48M) } # [doc = "FDPLL output"]
# [inline (always)]
pub fn fdpll (self) -> & 'a mut W { self . variant (SRC_A :: FDPLL) } } # [doc = "Field `GENEN` reader - Generic Clock Generator Enable"]
pub type GENEN_R = crate :: BitReader < bool > ; # [doc = "Field `GENEN` writer - Generic Clock Generator Enable"]
pub type GENEN_W < 'a > = crate :: BitWriter < 'a , u32 , GENCTRL_SPEC , bool , 16 > ; # [doc = "Field `IDC` reader - Improve Duty Cycle"]
pub type IDC_R = crate :: BitReader < bool > ; # [doc = "Field `IDC` writer - Improve Duty Cycle"]
pub type IDC_W < 'a > = crate :: BitWriter < 'a , u32 , GENCTRL_SPEC , bool , 17 > ; # [doc = "Field `OOV` reader - Output Off Value"]
pub type OOV_R = crate :: BitReader < bool > ; # [doc = "Field `OOV` writer - Output Off Value"]
pub type OOV_W < 'a > = crate :: BitWriter < 'a , u32 , GENCTRL_SPEC , bool , 18 > ; # [doc = "Field `OE` reader - Output Enable"]
pub type OE_R = crate :: BitReader < bool > ; # [doc = "Field `OE` writer - Output Enable"]
pub type OE_W < 'a > = crate :: BitWriter < 'a , u32 , GENCTRL_SPEC , bool , 19 > ; # [doc = "Field `DIVSEL` reader - Divide Selection"]
pub type DIVSEL_R = crate :: BitReader < bool > ; # [doc = "Field `DIVSEL` writer - Divide Selection"]
pub type DIVSEL_W < 'a > = crate :: BitWriter < 'a , u32 , GENCTRL_SPEC , bool , 20 > ; # [doc = "Field `RUNSTDBY` reader - Run in Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run in Standby"]
pub type RUNSTDBY_W < 'a > = crate :: BitWriter < 'a , u32 , GENCTRL_SPEC , bool , 21 > ; impl R { # [doc = "Bits 0:3 - Generic Clock Generator Selection"]
# [inline (always)]
pub fn id (& self) -> ID_R { ID_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bits 8:12 - Source Select"]
# [inline (always)]
pub fn src (& self) -> SRC_R { SRC_R :: new (((self . bits >> 8) & 0x1f) as u8) } # [doc = "Bit 16 - Generic Clock Generator Enable"]
# [inline (always)]
pub fn genen (& self) -> GENEN_R { GENEN_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Improve Duty Cycle"]
# [inline (always)]
pub fn idc (& self) -> IDC_R { IDC_R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Output Off Value"]
# [inline (always)]
pub fn oov (& self) -> OOV_R { OOV_R :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Output Enable"]
# [inline (always)]
pub fn oe (& self) -> OE_R { OE_R :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 20 - Divide Selection"]
# [inline (always)]
pub fn divsel (& self) -> DIVSEL_R { DIVSEL_R :: new (((self . bits >> 20) & 1) != 0) } # [doc = "Bit 21 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 21) & 1) != 0) } } impl W { # [doc = "Bits 0:3 - Generic Clock Generator Selection"]
# [inline (always)]
pub fn id (& mut self) -> ID_W { ID_W :: new (self) } # [doc = "Bits 8:12 - Source Select"]
# [inline (always)]
pub fn src (& mut self) -> SRC_W { SRC_W :: new (self) } # [doc = "Bit 16 - Generic Clock Generator Enable"]
# [inline (always)]
pub fn genen (& mut self) -> GENEN_W { GENEN_W :: new (self) } # [doc = "Bit 17 - Improve Duty Cycle"]
# [inline (always)]
pub fn idc (& mut self) -> IDC_W { IDC_W :: new (self) } # [doc = "Bit 18 - Output Off Value"]
# [inline (always)]
pub fn oov (& mut self) -> OOV_W { OOV_W :: new (self) } # [doc = "Bit 19 - Output Enable"]
# [inline (always)]
pub fn oe (& mut self) -> OE_W { OE_W :: new (self) } # [doc = "Bit 20 - Divide Selection"]
# [inline (always)]
pub fn divsel (& mut self) -> DIVSEL_W { DIVSEL_W :: new (self) } # [doc = "Bit 21 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& mut self) -> RUNSTDBY_W { RUNSTDBY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Generic Clock Generator Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [genctrl](index.html) module"]
pub struct GENCTRL_SPEC ; impl crate :: RegisterSpec for GENCTRL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [genctrl::R](R) reader structure"]
impl crate :: Readable for GENCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [genctrl::W](W) writer structure"]
impl crate :: Writable for GENCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets GENCTRL to value 0"]
impl crate :: Resettable for GENCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "GENDIV register accessor: an alias for `Reg<GENDIV_SPEC>`"]
pub type GENDIV = crate :: Reg < gendiv :: GENDIV_SPEC > ; # [doc = "Generic Clock Generator Division"]
pub mod gendiv { # [doc = "Register `GENDIV` reader"]
pub struct R (crate :: R < GENDIV_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < GENDIV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < GENDIV_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < GENDIV_SPEC >) -> Self { R (reader) } } # [doc = "Register `GENDIV` writer"]
pub struct W (crate :: W < GENDIV_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < GENDIV_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < GENDIV_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < GENDIV_SPEC >) -> Self { W (writer) } } # [doc = "Field `ID` reader - Generic Clock Generator Selection"]
pub type ID_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `ID` writer - Generic Clock Generator Selection"]
pub type ID_W < 'a > = crate :: FieldWriter < 'a , u32 , GENDIV_SPEC , u8 , u8 , 4 , 0 > ; # [doc = "Field `DIV` reader - Division Factor"]
pub type DIV_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `DIV` writer - Division Factor"]
pub type DIV_W < 'a > = crate :: FieldWriter < 'a , u32 , GENDIV_SPEC , u16 , u16 , 16 , 8 > ; impl R { # [doc = "Bits 0:3 - Generic Clock Generator Selection"]
# [inline (always)]
pub fn id (& self) -> ID_R { ID_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bits 8:23 - Division Factor"]
# [inline (always)]
pub fn div (& self) -> DIV_R { DIV_R :: new (((self . bits >> 8) & 0xffff) as u16) } } impl W { # [doc = "Bits 0:3 - Generic Clock Generator Selection"]
# [inline (always)]
pub fn id (& mut self) -> ID_W { ID_W :: new (self) } # [doc = "Bits 8:23 - Division Factor"]
# [inline (always)]
pub fn div (& mut self) -> DIV_W { DIV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Generic Clock Generator Division\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gendiv](index.html) module"]
pub struct GENDIV_SPEC ; impl crate :: RegisterSpec for GENDIV_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [gendiv::R](R) reader structure"]
impl crate :: Readable for GENDIV_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [gendiv::W](W) writer structure"]
impl crate :: Writable for GENDIV_SPEC { type Writer = W ; } # [doc = "`reset()` method sets GENDIV to value 0"]
impl crate :: Resettable for GENDIV_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "HSB Matrix"]
pub struct HMATRIX { _marker : PhantomData < * const () > } unsafe impl Send for HMATRIX { } impl HMATRIX { # [doc = r"Pointer to the register block"]
pub const PTR : * const hmatrix :: RegisterBlock = 0x4100_7000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const hmatrix :: RegisterBlock { Self :: PTR } } impl Deref for HMATRIX { type Target = hmatrix :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for HMATRIX { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("HMATRIX") . finish () } } # [doc = "HSB Matrix"]
pub mod hmatrix { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { _reserved0 : [u8 ; 0x80]
, # [doc = "0x80 - Priority A for Slave"]
pub pras0 : crate :: Reg < pras :: PRAS_SPEC > , # [doc = "0x84 - Priority B for Slave"]
pub prbs0 : crate :: Reg < prbs :: PRBS_SPEC > , # [doc = "0x88 - Priority A for Slave"]
pub pras1 : crate :: Reg < pras :: PRAS_SPEC > , # [doc = "0x8c - Priority B for Slave"]
pub prbs1 : crate :: Reg < prbs :: PRBS_SPEC > , # [doc = "0x90 - Priority A for Slave"]
pub pras2 : crate :: Reg < pras :: PRAS_SPEC > , # [doc = "0x94 - Priority B for Slave"]
pub prbs2 : crate :: Reg < prbs :: PRBS_SPEC > , # [doc = "0x98 - Priority A for Slave"]
pub pras3 : crate :: Reg < pras :: PRAS_SPEC > , # [doc = "0x9c - Priority B for Slave"]
pub prbs3 : crate :: Reg < prbs :: PRBS_SPEC > , # [doc = "0xa0 - Priority A for Slave"]
pub pras4 : crate :: Reg < pras :: PRAS_SPEC > , # [doc = "0xa4 - Priority B for Slave"]
pub prbs4 : crate :: Reg < prbs :: PRBS_SPEC > , # [doc = "0xa8 - Priority A for Slave"]
pub pras5 : crate :: Reg < pras :: PRAS_SPEC > , # [doc = "0xac - Priority B for Slave"]
pub prbs5 : crate :: Reg < prbs :: PRBS_SPEC > , # [doc = "0xb0 - Priority A for Slave"]
pub pras6 : crate :: Reg < pras :: PRAS_SPEC > , # [doc = "0xb4 - Priority B for Slave"]
pub prbs6 : crate :: Reg < prbs :: PRBS_SPEC > , # [doc = "0xb8 - Priority A for Slave"]
pub pras7 : crate :: Reg < pras :: PRAS_SPEC > , # [doc = "0xbc - Priority B for Slave"]
pub prbs7 : crate :: Reg < prbs :: PRBS_SPEC > , # [doc = "0xc0 - Priority A for Slave"]
pub pras8 : crate :: Reg < pras :: PRAS_SPEC > , # [doc = "0xc4 - Priority B for Slave"]
pub prbs8 : crate :: Reg < prbs :: PRBS_SPEC > , # [doc = "0xc8 - Priority A for Slave"]
pub pras9 : crate :: Reg < pras :: PRAS_SPEC > , # [doc = "0xcc - Priority B for Slave"]
pub prbs9 : crate :: Reg < prbs :: PRBS_SPEC > , # [doc = "0xd0 - Priority A for Slave"]
pub pras10 : crate :: Reg < pras :: PRAS_SPEC > , # [doc = "0xd4 - Priority B for Slave"]
pub prbs10 : crate :: Reg < prbs :: PRBS_SPEC > , # [doc = "0xd8 - Priority A for Slave"]
pub pras11 : crate :: Reg < pras :: PRAS_SPEC > , # [doc = "0xdc - Priority B for Slave"]
pub prbs11 : crate :: Reg < prbs :: PRBS_SPEC > , # [doc = "0xe0 - Priority A for Slave"]
pub pras12 : crate :: Reg < pras :: PRAS_SPEC > , # [doc = "0xe4 - Priority B for Slave"]
pub prbs12 : crate :: Reg < prbs :: PRBS_SPEC > , # [doc = "0xe8 - Priority A for Slave"]
pub pras13 : crate :: Reg < pras :: PRAS_SPEC > , # [doc = "0xec - Priority B for Slave"]
pub prbs13 : crate :: Reg < prbs :: PRBS_SPEC > , # [doc = "0xf0 - Priority A for Slave"]
pub pras14 : crate :: Reg < pras :: PRAS_SPEC > , # [doc = "0xf4 - Priority B for Slave"]
pub prbs14 : crate :: Reg < prbs :: PRBS_SPEC > , # [doc = "0xf8 - Priority A for Slave"]
pub pras15 : crate :: Reg < pras :: PRAS_SPEC > , # [doc = "0xfc - Priority B for Slave"]
pub prbs15 : crate :: Reg < prbs :: PRBS_SPEC > , _reserved32 : [u8 ; 0x10]
, # [doc = "0x110..0x150 - Special Function"]
pub sfr : [crate :: Reg < sfr :: SFR_SPEC > ; 16]
, } # [doc = "PRAS register accessor: an alias for `Reg<PRAS_SPEC>`"]
pub type PRAS = crate :: Reg < pras :: PRAS_SPEC > ; # [doc = "Priority A for Slave"]
pub mod pras { # [doc = "Register `PRAS%s` reader"]
pub struct R (crate :: R < PRAS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PRAS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PRAS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PRAS_SPEC >) -> Self { R (reader) } } # [doc = "Register `PRAS%s` writer"]
pub struct W (crate :: W < PRAS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PRAS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PRAS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PRAS_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Priority A for Slave\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pras](index.html) module"]
pub struct PRAS_SPEC ; impl crate :: RegisterSpec for PRAS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [pras::R](R) reader structure"]
impl crate :: Readable for PRAS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pras::W](W) writer structure"]
impl crate :: Writable for PRAS_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PRAS%s to value 0"]
impl crate :: Resettable for PRAS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PRBS register accessor: an alias for `Reg<PRBS_SPEC>`"]
pub type PRBS = crate :: Reg < prbs :: PRBS_SPEC > ; # [doc = "Priority B for Slave"]
pub mod prbs { # [doc = "Register `PRBS%s` reader"]
pub struct R (crate :: R < PRBS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PRBS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PRBS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PRBS_SPEC >) -> Self { R (reader) } } # [doc = "Register `PRBS%s` writer"]
pub struct W (crate :: W < PRBS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PRBS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PRBS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PRBS_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Priority B for Slave\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prbs](index.html) module"]
pub struct PRBS_SPEC ; impl crate :: RegisterSpec for PRBS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [prbs::R](R) reader structure"]
impl crate :: Readable for PRBS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [prbs::W](W) writer structure"]
impl crate :: Writable for PRBS_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PRBS%s to value 0"]
impl crate :: Resettable for PRBS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SFR register accessor: an alias for `Reg<SFR_SPEC>`"]
pub type SFR = crate :: Reg < sfr :: SFR_SPEC > ; # [doc = "Special Function"]
pub mod sfr { # [doc = "Register `SFR%s` reader"]
pub struct R (crate :: R < SFR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SFR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SFR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SFR_SPEC >) -> Self { R (reader) } } # [doc = "Register `SFR%s` writer"]
pub struct W (crate :: W < SFR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SFR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SFR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SFR_SPEC >) -> Self { W (writer) } } # [doc = "Field `SFR` reader - Special Function Register"]
pub type SFR_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `SFR` writer - Special Function Register"]
pub type SFR_W < 'a > = crate :: FieldWriter < 'a , u32 , SFR_SPEC , u32 , u32 , 32 , 0 > ; impl R { # [doc = "Bits 0:31 - Special Function Register"]
# [inline (always)]
pub fn sfr (& self) -> SFR_R { SFR_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Special Function Register"]
# [inline (always)]
pub fn sfr (& mut self) -> SFR_W { SFR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Special Function\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sfr](index.html) module"]
pub struct SFR_SPEC ; impl crate :: RegisterSpec for SFR_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [sfr::R](R) reader structure"]
impl crate :: Readable for SFR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sfr::W](W) writer structure"]
impl crate :: Writable for SFR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SFR%s to value 0"]
impl crate :: Resettable for SFR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "Inter-IC Sound Interface"]
pub struct I2S { _marker : PhantomData < * const () > } unsafe impl Send for I2S { } impl I2S { # [doc = r"Pointer to the register block"]
pub const PTR : * const i2s :: RegisterBlock = 0x4200_5000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const i2s :: RegisterBlock { Self :: PTR } } impl Deref for I2S { type Target = i2s :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for I2S { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("I2S") . finish () } } # [doc = "Inter-IC Sound Interface"]
pub mod i2s { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : crate :: Reg < ctrla :: CTRLA_SPEC > , _reserved1 : [u8 ; 0x03]
, # [doc = "0x04..0x0c - Clock Unit n Control"]
pub clkctrl : [crate :: Reg < clkctrl :: CLKCTRL_SPEC > ; 2]
, # [doc = "0x0c - Interrupt Enable Clear"]
pub intenclr : crate :: Reg < intenclr :: INTENCLR_SPEC > , _reserved3 : [u8 ; 0x02]
, # [doc = "0x10 - Interrupt Enable Set"]
pub intenset : crate :: Reg < intenset :: INTENSET_SPEC > , _reserved4 : [u8 ; 0x02]
, # [doc = "0x14 - Interrupt Flag Status and Clear"]
pub intflag : crate :: Reg < intflag :: INTFLAG_SPEC > , _reserved5 : [u8 ; 0x02]
, # [doc = "0x18 - Synchronization Status"]
pub syncbusy : crate :: Reg < syncbusy :: SYNCBUSY_SPEC > , _reserved6 : [u8 ; 0x06]
, # [doc = "0x20..0x28 - Serializer n Control"]
pub serctrl : [crate :: Reg < serctrl :: SERCTRL_SPEC > ; 2]
, _reserved7 : [u8 ; 0x08]
, # [doc = "0x30..0x38 - Data n"]
pub data : [crate :: Reg < data :: DATA_SPEC > ; 2]
, } # [doc = "CTRLA register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWRST` reader - Software Reset"]
pub type SWRST_R = crate :: BitReader < bool > ; # [doc = "Field `SWRST` writer - Software Reset"]
pub type SWRST_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , 0 > ; # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , 1 > ; # [doc = "Field `CKEN0` reader - Clock Unit 0 Enable"]
pub type CKEN0_R = crate :: BitReader < bool > ; # [doc = "Field `CKEN0` writer - Clock Unit 0 Enable"]
pub type CKEN0_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , 2 > ; # [doc = "Field `CKEN1` reader - Clock Unit 1 Enable"]
pub type CKEN1_R = crate :: BitReader < bool > ; # [doc = "Field `CKEN1` writer - Clock Unit 1 Enable"]
pub type CKEN1_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , 3 > ; # [doc = "Field `SEREN0` reader - Serializer 0 Enable"]
pub type SEREN0_R = crate :: BitReader < bool > ; # [doc = "Field `SEREN0` writer - Serializer 0 Enable"]
pub type SEREN0_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , 4 > ; # [doc = "Field `SEREN1` reader - Serializer 1 Enable"]
pub type SEREN1_R = crate :: BitReader < bool > ; # [doc = "Field `SEREN1` writer - Serializer 1 Enable"]
pub type SEREN1_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , 5 > ; impl R { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& self) -> SWRST_R { SWRST_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Clock Unit 0 Enable"]
# [inline (always)]
pub fn cken0 (& self) -> CKEN0_R { CKEN0_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Clock Unit 1 Enable"]
# [inline (always)]
pub fn cken1 (& self) -> CKEN1_R { CKEN1_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Serializer 0 Enable"]
# [inline (always)]
pub fn seren0 (& self) -> SEREN0_R { SEREN0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Serializer 1 Enable"]
# [inline (always)]
pub fn seren1 (& self) -> SEREN1_R { SEREN1_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& mut self) -> SWRST_W { SWRST_W :: new (self) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Bit 2 - Clock Unit 0 Enable"]
# [inline (always)]
pub fn cken0 (& mut self) -> CKEN0_W { CKEN0_W :: new (self) } # [doc = "Bit 3 - Clock Unit 1 Enable"]
# [inline (always)]
pub fn cken1 (& mut self) -> CKEN1_W { CKEN1_W :: new (self) } # [doc = "Bit 4 - Serializer 0 Enable"]
# [inline (always)]
pub fn seren0 (& mut self) -> SEREN0_W { SEREN0_W :: new (self) } # [doc = "Bit 5 - Serializer 1 Enable"]
# [inline (always)]
pub fn seren1 (& mut self) -> SEREN1_W { SEREN1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CLKCTRL register accessor: an alias for `Reg<CLKCTRL_SPEC>`"]
pub type CLKCTRL = crate :: Reg < clkctrl :: CLKCTRL_SPEC > ; # [doc = "Clock Unit n Control"]
pub mod clkctrl { # [doc = "Register `CLKCTRL%s` reader"]
pub struct R (crate :: R < CLKCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CLKCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CLKCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CLKCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CLKCTRL%s` writer"]
pub struct W (crate :: W < CLKCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CLKCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CLKCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CLKCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Slot Size\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum SLOTSIZE_A { # [doc = "0: 8-bit Slot for Clock Unit n"]
_8 = 0 , # [doc = "1: 16-bit Slot for Clock Unit n"]
_16 = 1 , # [doc = "2: 24-bit Slot for Clock Unit n"]
_24 = 2 , # [doc = "3: 32-bit Slot for Clock Unit n"]
_32 = 3 , } impl From < SLOTSIZE_A > for u8 { # [inline (always)]
fn from (variant : SLOTSIZE_A) -> Self { variant as _ } } # [doc = "Field `SLOTSIZE` reader - Slot Size"]
pub type SLOTSIZE_R = crate :: FieldReader < u8 , SLOTSIZE_A > ; impl SLOTSIZE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SLOTSIZE_A { match self . bits { 0 => SLOTSIZE_A :: _8 , 1 => SLOTSIZE_A :: _16 , 2 => SLOTSIZE_A :: _24 , 3 => SLOTSIZE_A :: _32 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_8`"]
# [inline (always)]
pub fn is_8 (& self) -> bool { * self == SLOTSIZE_A :: _8 } # [doc = "Checks if the value of the field is `_16`"]
# [inline (always)]
pub fn is_16 (& self) -> bool { * self == SLOTSIZE_A :: _16 } # [doc = "Checks if the value of the field is `_24`"]
# [inline (always)]
pub fn is_24 (& self) -> bool { * self == SLOTSIZE_A :: _24 } # [doc = "Checks if the value of the field is `_32`"]
# [inline (always)]
pub fn is_32 (& self) -> bool { * self == SLOTSIZE_A :: _32 } } # [doc = "Field `SLOTSIZE` writer - Slot Size"]
pub type SLOTSIZE_W < 'a > = crate :: FieldWriterSafe < 'a , u32 , CLKCTRL_SPEC , u8 , SLOTSIZE_A , 2 , 0 > ; impl < 'a > SLOTSIZE_W < 'a > { # [doc = "8-bit Slot for Clock Unit n"]
# [inline (always)]
pub fn _8 (self) -> & 'a mut W { self . variant (SLOTSIZE_A :: _8) } # [doc = "16-bit Slot for Clock Unit n"]
# [inline (always)]
pub fn _16 (self) -> & 'a mut W { self . variant (SLOTSIZE_A :: _16) } # [doc = "24-bit Slot for Clock Unit n"]
# [inline (always)]
pub fn _24 (self) -> & 'a mut W { self . variant (SLOTSIZE_A :: _24) } # [doc = "32-bit Slot for Clock Unit n"]
# [inline (always)]
pub fn _32 (self) -> & 'a mut W { self . variant (SLOTSIZE_A :: _32) } } # [doc = "Field `NBSLOTS` reader - Number of Slots in Frame"]
pub type NBSLOTS_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `NBSLOTS` writer - Number of Slots in Frame"]
pub type NBSLOTS_W < 'a > = crate :: FieldWriter < 'a , u32 , CLKCTRL_SPEC , u8 , u8 , 3 , 2 > ; # [doc = "Frame Sync Width\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum FSWIDTH_A { # [doc = "0: Frame Sync Pulse is 1 Slot wide (default for I2S protocol)"]
SLOT = 0 , # [doc = "1: Frame Sync Pulse is half a Frame wide"]
HALF = 1 , # [doc = "2: Frame Sync Pulse is 1 Bit wide"]
BIT = 2 , # [doc = "3: Clock Unit n operates in Burst mode, with a 1-bit wide Frame Sync pulse per Data sample, only when Data transfer is requested"]
BURST = 3 , } impl From < FSWIDTH_A > for u8 { # [inline (always)]
fn from (variant : FSWIDTH_A) -> Self { variant as _ } } # [doc = "Field `FSWIDTH` reader - Frame Sync Width"]
pub type FSWIDTH_R = crate :: FieldReader < u8 , FSWIDTH_A > ; impl FSWIDTH_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> FSWIDTH_A { match self . bits { 0 => FSWIDTH_A :: SLOT , 1 => FSWIDTH_A :: HALF , 2 => FSWIDTH_A :: BIT , 3 => FSWIDTH_A :: BURST , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `SLOT`"]
# [inline (always)]
pub fn is_slot (& self) -> bool { * self == FSWIDTH_A :: SLOT } # [doc = "Checks if the value of the field is `HALF`"]
# [inline (always)]
pub fn is_half (& self) -> bool { * self == FSWIDTH_A :: HALF } # [doc = "Checks if the value of the field is `BIT`"]
# [inline (always)]
pub fn is_bit_ (& self) -> bool { * self == FSWIDTH_A :: BIT } # [doc = "Checks if the value of the field is `BURST`"]
# [inline (always)]
pub fn is_burst (& self) -> bool { * self == FSWIDTH_A :: BURST } } # [doc = "Field `FSWIDTH` writer - Frame Sync Width"]
pub type FSWIDTH_W < 'a > = crate :: FieldWriterSafe < 'a , u32 , CLKCTRL_SPEC , u8 , FSWIDTH_A , 2 , 5 > ; impl < 'a > FSWIDTH_W < 'a > { # [doc = "Frame Sync Pulse is 1 Slot wide (default for I2S protocol)"]
# [inline (always)]
pub fn slot (self) -> & 'a mut W { self . variant (FSWIDTH_A :: SLOT) } # [doc = "Frame Sync Pulse is half a Frame wide"]
# [inline (always)]
pub fn half (self) -> & 'a mut W { self . variant (FSWIDTH_A :: HALF) } # [doc = "Frame Sync Pulse is 1 Bit wide"]
# [inline (always)]
pub fn bit_ (self) -> & 'a mut W { self . variant (FSWIDTH_A :: BIT) } # [doc = "Clock Unit n operates in Burst mode, with a 1-bit wide Frame Sync pulse per Data sample, only when Data transfer is requested"]
# [inline (always)]
pub fn burst (self) -> & 'a mut W { self . variant (FSWIDTH_A :: BURST) } } # [doc = "Data Delay from Frame Sync\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
pub enum BITDELAY_A { # [doc = "0: Left Justified (0 Bit Delay)"]
LJ = 0 , # [doc = "1: I2S (1 Bit Delay)"]
I2S = 1 , } impl From < BITDELAY_A > for bool { # [inline (always)]
fn from (variant : BITDELAY_A) -> Self { variant as u8 != 0 } } # [doc = "Field `BITDELAY` reader - Data Delay from Frame Sync"]
pub type BITDELAY_R = crate :: BitReader < BITDELAY_A > ; impl BITDELAY_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> BITDELAY_A { match self . bits { false => BITDELAY_A :: LJ , true => BITDELAY_A :: I2S , } } # [doc = "Checks if the value of the field is `LJ`"]
# [inline (always)]
pub fn is_lj (& self) -> bool { * self == BITDELAY_A :: LJ } # [doc = "Checks if the value of the field is `I2S`"]
# [inline (always)]
pub fn is_i2s (& self) -> bool { * self == BITDELAY_A :: I2S } } # [doc = "Field `BITDELAY` writer - Data Delay from Frame Sync"]
pub type BITDELAY_W < 'a > = crate :: BitWriter < 'a , u32 , CLKCTRL_SPEC , BITDELAY_A , 7 > ; impl < 'a > BITDELAY_W < 'a > { # [doc = "Left Justified (0 Bit Delay)"]
# [inline (always)]
pub fn lj (self) -> & 'a mut W { self . variant (BITDELAY_A :: LJ) } # [doc = "I2S (1 Bit Delay)"]
# [inline (always)]
pub fn i2s (self) -> & 'a mut W { self . variant (BITDELAY_A :: I2S) } } # [doc = "Frame Sync Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
pub enum FSSEL_A { # [doc = "0: Divided Serial Clock n is used as Frame Sync n source"]
SCKDIV = 0 , # [doc = "1: FSn input pin is used as Frame Sync n source"]
FSPIN = 1 , } impl From < FSSEL_A > for bool { # [inline (always)]
fn from (variant : FSSEL_A) -> Self { variant as u8 != 0 } } # [doc = "Field `FSSEL` reader - Frame Sync Select"]
pub type FSSEL_R = crate :: BitReader < FSSEL_A > ; impl FSSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> FSSEL_A { match self . bits { false => FSSEL_A :: SCKDIV , true => FSSEL_A :: FSPIN , } } # [doc = "Checks if the value of the field is `SCKDIV`"]
# [inline (always)]
pub fn is_sckdiv (& self) -> bool { * self == FSSEL_A :: SCKDIV } # [doc = "Checks if the value of the field is `FSPIN`"]
# [inline (always)]
pub fn is_fspin (& self) -> bool { * self == FSSEL_A :: FSPIN } } # [doc = "Field `FSSEL` writer - Frame Sync Select"]
pub type FSSEL_W < 'a > = crate :: BitWriter < 'a , u32 , CLKCTRL_SPEC , FSSEL_A , 8 > ; impl < 'a > FSSEL_W < 'a > { # [doc = "Divided Serial Clock n is used as Frame Sync n source"]
# [inline (always)]
pub fn sckdiv (self) -> & 'a mut W { self . variant (FSSEL_A :: SCKDIV) } # [doc = "FSn input pin is used as Frame Sync n source"]
# [inline (always)]
pub fn fspin (self) -> & 'a mut W { self . variant (FSSEL_A :: FSPIN) } } # [doc = "Field `FSINV` reader - Frame Sync Invert"]
pub type FSINV_R = crate :: BitReader < bool > ; # [doc = "Field `FSINV` writer - Frame Sync Invert"]
pub type FSINV_W < 'a > = crate :: BitWriter < 'a , u32 , CLKCTRL_SPEC , bool , 11 > ; # [doc = "Serial Clock Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
pub enum SCKSEL_A { # [doc = "0: Divided Master Clock n is used as Serial Clock n source"]
MCKDIV = 0 , # [doc = "1: SCKn input pin is used as Serial Clock n source"]
SCKPIN = 1 , } impl From < SCKSEL_A > for bool { # [inline (always)]
fn from (variant : SCKSEL_A) -> Self { variant as u8 != 0 } } # [doc = "Field `SCKSEL` reader - Serial Clock Select"]
pub type SCKSEL_R = crate :: BitReader < SCKSEL_A > ; impl SCKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SCKSEL_A { match self . bits { false => SCKSEL_A :: MCKDIV , true => SCKSEL_A :: SCKPIN , } } # [doc = "Checks if the value of the field is `MCKDIV`"]
# [inline (always)]
pub fn is_mckdiv (& self) -> bool { * self == SCKSEL_A :: MCKDIV } # [doc = "Checks if the value of the field is `SCKPIN`"]
# [inline (always)]
pub fn is_sckpin (& self) -> bool { * self == SCKSEL_A :: SCKPIN } } # [doc = "Field `SCKSEL` writer - Serial Clock Select"]
pub type SCKSEL_W < 'a > = crate :: BitWriter < 'a , u32 , CLKCTRL_SPEC , SCKSEL_A , 12 > ; impl < 'a > SCKSEL_W < 'a > { # [doc = "Divided Master Clock n is used as Serial Clock n source"]
# [inline (always)]
pub fn mckdiv (self) -> & 'a mut W { self . variant (SCKSEL_A :: MCKDIV) } # [doc = "SCKn input pin is used as Serial Clock n source"]
# [inline (always)]
pub fn sckpin (self) -> & 'a mut W { self . variant (SCKSEL_A :: SCKPIN) } } # [doc = "Master Clock Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
pub enum MCKSEL_A { # [doc = "0: GCLK_I2S_n is used as Master Clock n source"]
GCLK = 0 , # [doc = "1: MCKn input pin is used as Master Clock n source"]
MCKPIN = 1 , } impl From < MCKSEL_A > for bool { # [inline (always)]
fn from (variant : MCKSEL_A) -> Self { variant as u8 != 0 } } # [doc = "Field `MCKSEL` reader - Master Clock Select"]
pub type MCKSEL_R = crate :: BitReader < MCKSEL_A > ; impl MCKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MCKSEL_A { match self . bits { false => MCKSEL_A :: GCLK , true => MCKSEL_A :: MCKPIN , } } # [doc = "Checks if the value of the field is `GCLK`"]
# [inline (always)]
pub fn is_gclk (& self) -> bool { * self == MCKSEL_A :: GCLK } # [doc = "Checks if the value of the field is `MCKPIN`"]
# [inline (always)]
pub fn is_mckpin (& self) -> bool { * self == MCKSEL_A :: MCKPIN } } # [doc = "Field `MCKSEL` writer - Master Clock Select"]
pub type MCKSEL_W < 'a > = crate :: BitWriter < 'a , u32 , CLKCTRL_SPEC , MCKSEL_A , 16 > ; impl < 'a > MCKSEL_W < 'a > { # [doc = "GCLK_I2S_n is used as Master Clock n source"]
# [inline (always)]
pub fn gclk (self) -> & 'a mut W { self . variant (MCKSEL_A :: GCLK) } # [doc = "MCKn input pin is used as Master Clock n source"]
# [inline (always)]
pub fn mckpin (self) -> & 'a mut W { self . variant (MCKSEL_A :: MCKPIN) } } # [doc = "Field `MCKEN` reader - Master Clock Enable"]
pub type MCKEN_R = crate :: BitReader < bool > ; # [doc = "Field `MCKEN` writer - Master Clock Enable"]
pub type MCKEN_W < 'a > = crate :: BitWriter < 'a , u32 , CLKCTRL_SPEC , bool , 18 > ; # [doc = "Field `MCKDIV` reader - Master Clock Division Factor"]
pub type MCKDIV_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `MCKDIV` writer - Master Clock Division Factor"]
pub type MCKDIV_W < 'a > = crate :: FieldWriter < 'a , u32 , CLKCTRL_SPEC , u8 , u8 , 5 , 19 > ; # [doc = "Field `MCKOUTDIV` reader - Master Clock Output Division Factor"]
pub type MCKOUTDIV_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `MCKOUTDIV` writer - Master Clock Output Division Factor"]
pub type MCKOUTDIV_W < 'a > = crate :: FieldWriter < 'a , u32 , CLKCTRL_SPEC , u8 , u8 , 5 , 24 > ; # [doc = "Field `FSOUTINV` reader - Frame Sync Output Invert"]
pub type FSOUTINV_R = crate :: BitReader < bool > ; # [doc = "Field `FSOUTINV` writer - Frame Sync Output Invert"]
pub type FSOUTINV_W < 'a > = crate :: BitWriter < 'a , u32 , CLKCTRL_SPEC , bool , 29 > ; # [doc = "Field `SCKOUTINV` reader - Serial Clock Output Invert"]
pub type SCKOUTINV_R = crate :: BitReader < bool > ; # [doc = "Field `SCKOUTINV` writer - Serial Clock Output Invert"]
pub type SCKOUTINV_W < 'a > = crate :: BitWriter < 'a , u32 , CLKCTRL_SPEC , bool , 30 > ; # [doc = "Field `MCKOUTINV` reader - Master Clock Output Invert"]
pub type MCKOUTINV_R = crate :: BitReader < bool > ; # [doc = "Field `MCKOUTINV` writer - Master Clock Output Invert"]
pub type MCKOUTINV_W < 'a > = crate :: BitWriter < 'a , u32 , CLKCTRL_SPEC , bool , 31 > ; impl R { # [doc = "Bits 0:1 - Slot Size"]
# [inline (always)]
pub fn slotsize (& self) -> SLOTSIZE_R { SLOTSIZE_R :: new ((self . bits & 3) as u8) } # [doc = "Bits 2:4 - Number of Slots in Frame"]
# [inline (always)]
pub fn nbslots (& self) -> NBSLOTS_R { NBSLOTS_R :: new (((self . bits >> 2) & 7) as u8) } # [doc = "Bits 5:6 - Frame Sync Width"]
# [inline (always)]
pub fn fswidth (& self) -> FSWIDTH_R { FSWIDTH_R :: new (((self . bits >> 5) & 3) as u8) } # [doc = "Bit 7 - Data Delay from Frame Sync"]
# [inline (always)]
pub fn bitdelay (& self) -> BITDELAY_R { BITDELAY_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Frame Sync Select"]
# [inline (always)]
pub fn fssel (& self) -> FSSEL_R { FSSEL_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 11 - Frame Sync Invert"]
# [inline (always)]
pub fn fsinv (& self) -> FSINV_R { FSINV_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Serial Clock Select"]
# [inline (always)]
pub fn scksel (& self) -> SCKSEL_R { SCKSEL_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 16 - Master Clock Select"]
# [inline (always)]
pub fn mcksel (& self) -> MCKSEL_R { MCKSEL_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 18 - Master Clock Enable"]
# [inline (always)]
pub fn mcken (& self) -> MCKEN_R { MCKEN_R :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bits 19:23 - Master Clock Division Factor"]
# [inline (always)]
pub fn mckdiv (& self) -> MCKDIV_R { MCKDIV_R :: new (((self . bits >> 19) & 0x1f) as u8) } # [doc = "Bits 24:28 - Master Clock Output Division Factor"]
# [inline (always)]
pub fn mckoutdiv (& self) -> MCKOUTDIV_R { MCKOUTDIV_R :: new (((self . bits >> 24) & 0x1f) as u8) } # [doc = "Bit 29 - Frame Sync Output Invert"]
# [inline (always)]
pub fn fsoutinv (& self) -> FSOUTINV_R { FSOUTINV_R :: new (((self . bits >> 29) & 1) != 0) } # [doc = "Bit 30 - Serial Clock Output Invert"]
# [inline (always)]
pub fn sckoutinv (& self) -> SCKOUTINV_R { SCKOUTINV_R :: new (((self . bits >> 30) & 1) != 0) } # [doc = "Bit 31 - Master Clock Output Invert"]
# [inline (always)]
pub fn mckoutinv (& self) -> MCKOUTINV_R { MCKOUTINV_R :: new (((self . bits >> 31) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Slot Size"]
# [inline (always)]
pub fn slotsize (& mut self) -> SLOTSIZE_W { SLOTSIZE_W :: new (self) } # [doc = "Bits 2:4 - Number of Slots in Frame"]
# [inline (always)]
pub fn nbslots (& mut self) -> NBSLOTS_W { NBSLOTS_W :: new (self) } # [doc = "Bits 5:6 - Frame Sync Width"]
# [inline (always)]
pub fn fswidth (& mut self) -> FSWIDTH_W { FSWIDTH_W :: new (self) } # [doc = "Bit 7 - Data Delay from Frame Sync"]
# [inline (always)]
pub fn bitdelay (& mut self) -> BITDELAY_W { BITDELAY_W :: new (self) } # [doc = "Bit 8 - Frame Sync Select"]
# [inline (always)]
pub fn fssel (& mut self) -> FSSEL_W { FSSEL_W :: new (self) } # [doc = "Bit 11 - Frame Sync Invert"]
# [inline (always)]
pub fn fsinv (& mut self) -> FSINV_W { FSINV_W :: new (self) } # [doc = "Bit 12 - Serial Clock Select"]
# [inline (always)]
pub fn scksel (& mut self) -> SCKSEL_W { SCKSEL_W :: new (self) } # [doc = "Bit 16 - Master Clock Select"]
# [inline (always)]
pub fn mcksel (& mut self) -> MCKSEL_W { MCKSEL_W :: new (self) } # [doc = "Bit 18 - Master Clock Enable"]
# [inline (always)]
pub fn mcken (& mut self) -> MCKEN_W { MCKEN_W :: new (self) } # [doc = "Bits 19:23 - Master Clock Division Factor"]
# [inline (always)]
pub fn mckdiv (& mut self) -> MCKDIV_W { MCKDIV_W :: new (self) } # [doc = "Bits 24:28 - Master Clock Output Division Factor"]
# [inline (always)]
pub fn mckoutdiv (& mut self) -> MCKOUTDIV_W { MCKOUTDIV_W :: new (self) } # [doc = "Bit 29 - Frame Sync Output Invert"]
# [inline (always)]
pub fn fsoutinv (& mut self) -> FSOUTINV_W { FSOUTINV_W :: new (self) } # [doc = "Bit 30 - Serial Clock Output Invert"]
# [inline (always)]
pub fn sckoutinv (& mut self) -> SCKOUTINV_W { SCKOUTINV_W :: new (self) } # [doc = "Bit 31 - Master Clock Output Invert"]
# [inline (always)]
pub fn mckoutinv (& mut self) -> MCKOUTINV_W { MCKOUTINV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Clock Unit n Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clkctrl](index.html) module"]
pub struct CLKCTRL_SPEC ; impl crate :: RegisterSpec for CLKCTRL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [clkctrl::R](R) reader structure"]
impl crate :: Readable for CLKCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [clkctrl::W](W) writer structure"]
impl crate :: Writable for CLKCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CLKCTRL%s to value 0"]
impl crate :: Resettable for CLKCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENCLR register accessor: an alias for `Reg<INTENCLR_SPEC>`"]
pub type INTENCLR = crate :: Reg < intenclr :: INTENCLR_SPEC > ; # [doc = "Interrupt Enable Clear"]
pub mod intenclr { # [doc = "Register `INTENCLR` reader"]
pub struct R (crate :: R < INTENCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENCLR` writer"]
pub struct W (crate :: W < INTENCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `RXRDY0` reader - Receive Ready 0 Interrupt Enable"]
pub type RXRDY0_R = crate :: BitReader < bool > ; # [doc = "Field `RXRDY0` writer - Receive Ready 0 Interrupt Enable"]
pub type RXRDY0_W < 'a > = crate :: BitWriter < 'a , u16 , INTENCLR_SPEC , bool , 0 > ; # [doc = "Field `RXRDY1` reader - Receive Ready 1 Interrupt Enable"]
pub type RXRDY1_R = crate :: BitReader < bool > ; # [doc = "Field `RXRDY1` writer - Receive Ready 1 Interrupt Enable"]
pub type RXRDY1_W < 'a > = crate :: BitWriter < 'a , u16 , INTENCLR_SPEC , bool , 1 > ; # [doc = "Field `RXOR0` reader - Receive Overrun 0 Interrupt Enable"]
pub type RXOR0_R = crate :: BitReader < bool > ; # [doc = "Field `RXOR0` writer - Receive Overrun 0 Interrupt Enable"]
pub type RXOR0_W < 'a > = crate :: BitWriter < 'a , u16 , INTENCLR_SPEC , bool , 4 > ; # [doc = "Field `RXOR1` reader - Receive Overrun 1 Interrupt Enable"]
pub type RXOR1_R = crate :: BitReader < bool > ; # [doc = "Field `RXOR1` writer - Receive Overrun 1 Interrupt Enable"]
pub type RXOR1_W < 'a > = crate :: BitWriter < 'a , u16 , INTENCLR_SPEC , bool , 5 > ; # [doc = "Field `TXRDY0` reader - Transmit Ready 0 Interrupt Enable"]
pub type TXRDY0_R = crate :: BitReader < bool > ; # [doc = "Field `TXRDY0` writer - Transmit Ready 0 Interrupt Enable"]
pub type TXRDY0_W < 'a > = crate :: BitWriter < 'a , u16 , INTENCLR_SPEC , bool , 8 > ; # [doc = "Field `TXRDY1` reader - Transmit Ready 1 Interrupt Enable"]
pub type TXRDY1_R = crate :: BitReader < bool > ; # [doc = "Field `TXRDY1` writer - Transmit Ready 1 Interrupt Enable"]
pub type TXRDY1_W < 'a > = crate :: BitWriter < 'a , u16 , INTENCLR_SPEC , bool , 9 > ; # [doc = "Field `TXUR0` reader - Transmit Underrun 0 Interrupt Enable"]
pub type TXUR0_R = crate :: BitReader < bool > ; # [doc = "Field `TXUR0` writer - Transmit Underrun 0 Interrupt Enable"]
pub type TXUR0_W < 'a > = crate :: BitWriter < 'a , u16 , INTENCLR_SPEC , bool , 12 > ; # [doc = "Field `TXUR1` reader - Transmit Underrun 1 Interrupt Enable"]
pub type TXUR1_R = crate :: BitReader < bool > ; # [doc = "Field `TXUR1` writer - Transmit Underrun 1 Interrupt Enable"]
pub type TXUR1_W < 'a > = crate :: BitWriter < 'a , u16 , INTENCLR_SPEC , bool , 13 > ; impl R { # [doc = "Bit 0 - Receive Ready 0 Interrupt Enable"]
# [inline (always)]
pub fn rxrdy0 (& self) -> RXRDY0_R { RXRDY0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Receive Ready 1 Interrupt Enable"]
# [inline (always)]
pub fn rxrdy1 (& self) -> RXRDY1_R { RXRDY1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - Receive Overrun 0 Interrupt Enable"]
# [inline (always)]
pub fn rxor0 (& self) -> RXOR0_R { RXOR0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Receive Overrun 1 Interrupt Enable"]
# [inline (always)]
pub fn rxor1 (& self) -> RXOR1_R { RXOR1_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 8 - Transmit Ready 0 Interrupt Enable"]
# [inline (always)]
pub fn txrdy0 (& self) -> TXRDY0_R { TXRDY0_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Transmit Ready 1 Interrupt Enable"]
# [inline (always)]
pub fn txrdy1 (& self) -> TXRDY1_R { TXRDY1_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 12 - Transmit Underrun 0 Interrupt Enable"]
# [inline (always)]
pub fn txur0 (& self) -> TXUR0_R { TXUR0_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Transmit Underrun 1 Interrupt Enable"]
# [inline (always)]
pub fn txur1 (& self) -> TXUR1_R { TXUR1_R :: new (((self . bits >> 13) & 1) != 0) } } impl W { # [doc = "Bit 0 - Receive Ready 0 Interrupt Enable"]
# [inline (always)]
pub fn rxrdy0 (& mut self) -> RXRDY0_W { RXRDY0_W :: new (self) } # [doc = "Bit 1 - Receive Ready 1 Interrupt Enable"]
# [inline (always)]
pub fn rxrdy1 (& mut self) -> RXRDY1_W { RXRDY1_W :: new (self) } # [doc = "Bit 4 - Receive Overrun 0 Interrupt Enable"]
# [inline (always)]
pub fn rxor0 (& mut self) -> RXOR0_W { RXOR0_W :: new (self) } # [doc = "Bit 5 - Receive Overrun 1 Interrupt Enable"]
# [inline (always)]
pub fn rxor1 (& mut self) -> RXOR1_W { RXOR1_W :: new (self) } # [doc = "Bit 8 - Transmit Ready 0 Interrupt Enable"]
# [inline (always)]
pub fn txrdy0 (& mut self) -> TXRDY0_W { TXRDY0_W :: new (self) } # [doc = "Bit 9 - Transmit Ready 1 Interrupt Enable"]
# [inline (always)]
pub fn txrdy1 (& mut self) -> TXRDY1_W { TXRDY1_W :: new (self) } # [doc = "Bit 12 - Transmit Underrun 0 Interrupt Enable"]
# [inline (always)]
pub fn txur0 (& mut self) -> TXUR0_W { TXUR0_W :: new (self) } # [doc = "Bit 13 - Transmit Underrun 1 Interrupt Enable"]
# [inline (always)]
pub fn txur1 (& mut self) -> TXUR1_W { TXUR1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenclr](index.html) module"]
pub struct INTENCLR_SPEC ; impl crate :: RegisterSpec for INTENCLR_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [intenclr::R](R) reader structure"]
impl crate :: Readable for INTENCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenclr::W](W) writer structure"]
impl crate :: Writable for INTENCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENCLR to value 0"]
impl crate :: Resettable for INTENCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENSET register accessor: an alias for `Reg<INTENSET_SPEC>`"]
pub type INTENSET = crate :: Reg < intenset :: INTENSET_SPEC > ; # [doc = "Interrupt Enable Set"]
pub mod intenset { # [doc = "Register `INTENSET` reader"]
pub struct R (crate :: R < INTENSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENSET` writer"]
pub struct W (crate :: W < INTENSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `RXRDY0` reader - Receive Ready 0 Interrupt Enable"]
pub type RXRDY0_R = crate :: BitReader < bool > ; # [doc = "Field `RXRDY0` writer - Receive Ready 0 Interrupt Enable"]
pub type RXRDY0_W < 'a > = crate :: BitWriter < 'a , u16 , INTENSET_SPEC , bool , 0 > ; # [doc = "Field `RXRDY1` reader - Receive Ready 1 Interrupt Enable"]
pub type RXRDY1_R = crate :: BitReader < bool > ; # [doc = "Field `RXRDY1` writer - Receive Ready 1 Interrupt Enable"]
pub type RXRDY1_W < 'a > = crate :: BitWriter < 'a , u16 , INTENSET_SPEC , bool , 1 > ; # [doc = "Field `RXOR0` reader - Receive Overrun 0 Interrupt Enable"]
pub type RXOR0_R = crate :: BitReader < bool > ; # [doc = "Field `RXOR0` writer - Receive Overrun 0 Interrupt Enable"]
pub type RXOR0_W < 'a > = crate :: BitWriter < 'a , u16 , INTENSET_SPEC , bool , 4 > ; # [doc = "Field `RXOR1` reader - Receive Overrun 1 Interrupt Enable"]
pub type RXOR1_R = crate :: BitReader < bool > ; # [doc = "Field `RXOR1` writer - Receive Overrun 1 Interrupt Enable"]
pub type RXOR1_W < 'a > = crate :: BitWriter < 'a , u16 , INTENSET_SPEC , bool , 5 > ; # [doc = "Field `TXRDY0` reader - Transmit Ready 0 Interrupt Enable"]
pub type TXRDY0_R = crate :: BitReader < bool > ; # [doc = "Field `TXRDY0` writer - Transmit Ready 0 Interrupt Enable"]
pub type TXRDY0_W < 'a > = crate :: BitWriter < 'a , u16 , INTENSET_SPEC , bool , 8 > ; # [doc = "Field `TXRDY1` reader - Transmit Ready 1 Interrupt Enable"]
pub type TXRDY1_R = crate :: BitReader < bool > ; # [doc = "Field `TXRDY1` writer - Transmit Ready 1 Interrupt Enable"]
pub type TXRDY1_W < 'a > = crate :: BitWriter < 'a , u16 , INTENSET_SPEC , bool , 9 > ; # [doc = "Field `TXUR0` reader - Transmit Underrun 0 Interrupt Enable"]
pub type TXUR0_R = crate :: BitReader < bool > ; # [doc = "Field `TXUR0` writer - Transmit Underrun 0 Interrupt Enable"]
pub type TXUR0_W < 'a > = crate :: BitWriter < 'a , u16 , INTENSET_SPEC , bool , 12 > ; # [doc = "Field `TXUR1` reader - Transmit Underrun 1 Interrupt Enable"]
pub type TXUR1_R = crate :: BitReader < bool > ; # [doc = "Field `TXUR1` writer - Transmit Underrun 1 Interrupt Enable"]
pub type TXUR1_W < 'a > = crate :: BitWriter < 'a , u16 , INTENSET_SPEC , bool , 13 > ; impl R { # [doc = "Bit 0 - Receive Ready 0 Interrupt Enable"]
# [inline (always)]
pub fn rxrdy0 (& self) -> RXRDY0_R { RXRDY0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Receive Ready 1 Interrupt Enable"]
# [inline (always)]
pub fn rxrdy1 (& self) -> RXRDY1_R { RXRDY1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - Receive Overrun 0 Interrupt Enable"]
# [inline (always)]
pub fn rxor0 (& self) -> RXOR0_R { RXOR0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Receive Overrun 1 Interrupt Enable"]
# [inline (always)]
pub fn rxor1 (& self) -> RXOR1_R { RXOR1_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 8 - Transmit Ready 0 Interrupt Enable"]
# [inline (always)]
pub fn txrdy0 (& self) -> TXRDY0_R { TXRDY0_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Transmit Ready 1 Interrupt Enable"]
# [inline (always)]
pub fn txrdy1 (& self) -> TXRDY1_R { TXRDY1_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 12 - Transmit Underrun 0 Interrupt Enable"]
# [inline (always)]
pub fn txur0 (& self) -> TXUR0_R { TXUR0_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Transmit Underrun 1 Interrupt Enable"]
# [inline (always)]
pub fn txur1 (& self) -> TXUR1_R { TXUR1_R :: new (((self . bits >> 13) & 1) != 0) } } impl W { # [doc = "Bit 0 - Receive Ready 0 Interrupt Enable"]
# [inline (always)]
pub fn rxrdy0 (& mut self) -> RXRDY0_W { RXRDY0_W :: new (self) } # [doc = "Bit 1 - Receive Ready 1 Interrupt Enable"]
# [inline (always)]
pub fn rxrdy1 (& mut self) -> RXRDY1_W { RXRDY1_W :: new (self) } # [doc = "Bit 4 - Receive Overrun 0 Interrupt Enable"]
# [inline (always)]
pub fn rxor0 (& mut self) -> RXOR0_W { RXOR0_W :: new (self) } # [doc = "Bit 5 - Receive Overrun 1 Interrupt Enable"]
# [inline (always)]
pub fn rxor1 (& mut self) -> RXOR1_W { RXOR1_W :: new (self) } # [doc = "Bit 8 - Transmit Ready 0 Interrupt Enable"]
# [inline (always)]
pub fn txrdy0 (& mut self) -> TXRDY0_W { TXRDY0_W :: new (self) } # [doc = "Bit 9 - Transmit Ready 1 Interrupt Enable"]
# [inline (always)]
pub fn txrdy1 (& mut self) -> TXRDY1_W { TXRDY1_W :: new (self) } # [doc = "Bit 12 - Transmit Underrun 0 Interrupt Enable"]
# [inline (always)]
pub fn txur0 (& mut self) -> TXUR0_W { TXUR0_W :: new (self) } # [doc = "Bit 13 - Transmit Underrun 1 Interrupt Enable"]
# [inline (always)]
pub fn txur1 (& mut self) -> TXUR1_W { TXUR1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenset](index.html) module"]
pub struct INTENSET_SPEC ; impl crate :: RegisterSpec for INTENSET_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [intenset::R](R) reader structure"]
impl crate :: Readable for INTENSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenset::W](W) writer structure"]
impl crate :: Writable for INTENSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENSET to value 0"]
impl crate :: Resettable for INTENSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTFLAG register accessor: an alias for `Reg<INTFLAG_SPEC>`"]
pub type INTFLAG = crate :: Reg < intflag :: INTFLAG_SPEC > ; # [doc = "Interrupt Flag Status and Clear"]
pub mod intflag { # [doc = "Register `INTFLAG` reader"]
pub struct R (crate :: R < INTFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAG` writer"]
pub struct W (crate :: W < INTFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `RXRDY0` reader - Receive Ready 0"]
pub type RXRDY0_R = crate :: BitReader < bool > ; # [doc = "Field `RXRDY0` writer - Receive Ready 0"]
pub type RXRDY0_W < 'a > = crate :: BitWriter < 'a , u16 , INTFLAG_SPEC , bool , 0 > ; # [doc = "Field `RXRDY1` reader - Receive Ready 1"]
pub type RXRDY1_R = crate :: BitReader < bool > ; # [doc = "Field `RXRDY1` writer - Receive Ready 1"]
pub type RXRDY1_W < 'a > = crate :: BitWriter < 'a , u16 , INTFLAG_SPEC , bool , 1 > ; # [doc = "Field `RXOR0` reader - Receive Overrun 0"]
pub type RXOR0_R = crate :: BitReader < bool > ; # [doc = "Field `RXOR0` writer - Receive Overrun 0"]
pub type RXOR0_W < 'a > = crate :: BitWriter < 'a , u16 , INTFLAG_SPEC , bool , 4 > ; # [doc = "Field `RXOR1` reader - Receive Overrun 1"]
pub type RXOR1_R = crate :: BitReader < bool > ; # [doc = "Field `RXOR1` writer - Receive Overrun 1"]
pub type RXOR1_W < 'a > = crate :: BitWriter < 'a , u16 , INTFLAG_SPEC , bool , 5 > ; # [doc = "Field `TXRDY0` reader - Transmit Ready 0"]
pub type TXRDY0_R = crate :: BitReader < bool > ; # [doc = "Field `TXRDY0` writer - Transmit Ready 0"]
pub type TXRDY0_W < 'a > = crate :: BitWriter < 'a , u16 , INTFLAG_SPEC , bool , 8 > ; # [doc = "Field `TXRDY1` reader - Transmit Ready 1"]
pub type TXRDY1_R = crate :: BitReader < bool > ; # [doc = "Field `TXRDY1` writer - Transmit Ready 1"]
pub type TXRDY1_W < 'a > = crate :: BitWriter < 'a , u16 , INTFLAG_SPEC , bool , 9 > ; # [doc = "Field `TXUR0` reader - Transmit Underrun 0"]
pub type TXUR0_R = crate :: BitReader < bool > ; # [doc = "Field `TXUR0` writer - Transmit Underrun 0"]
pub type TXUR0_W < 'a > = crate :: BitWriter < 'a , u16 , INTFLAG_SPEC , bool , 12 > ; # [doc = "Field `TXUR1` reader - Transmit Underrun 1"]
pub type TXUR1_R = crate :: BitReader < bool > ; # [doc = "Field `TXUR1` writer - Transmit Underrun 1"]
pub type TXUR1_W < 'a > = crate :: BitWriter < 'a , u16 , INTFLAG_SPEC , bool , 13 > ; impl R { # [doc = "Bit 0 - Receive Ready 0"]
# [inline (always)]
pub fn rxrdy0 (& self) -> RXRDY0_R { RXRDY0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Receive Ready 1"]
# [inline (always)]
pub fn rxrdy1 (& self) -> RXRDY1_R { RXRDY1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - Receive Overrun 0"]
# [inline (always)]
pub fn rxor0 (& self) -> RXOR0_R { RXOR0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Receive Overrun 1"]
# [inline (always)]
pub fn rxor1 (& self) -> RXOR1_R { RXOR1_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 8 - Transmit Ready 0"]
# [inline (always)]
pub fn txrdy0 (& self) -> TXRDY0_R { TXRDY0_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Transmit Ready 1"]
# [inline (always)]
pub fn txrdy1 (& self) -> TXRDY1_R { TXRDY1_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 12 - Transmit Underrun 0"]
# [inline (always)]
pub fn txur0 (& self) -> TXUR0_R { TXUR0_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Transmit Underrun 1"]
# [inline (always)]
pub fn txur1 (& self) -> TXUR1_R { TXUR1_R :: new (((self . bits >> 13) & 1) != 0) } } impl W { # [doc = "Bit 0 - Receive Ready 0"]
# [inline (always)]
pub fn rxrdy0 (& mut self) -> RXRDY0_W { RXRDY0_W :: new (self) } # [doc = "Bit 1 - Receive Ready 1"]
# [inline (always)]
pub fn rxrdy1 (& mut self) -> RXRDY1_W { RXRDY1_W :: new (self) } # [doc = "Bit 4 - Receive Overrun 0"]
# [inline (always)]
pub fn rxor0 (& mut self) -> RXOR0_W { RXOR0_W :: new (self) } # [doc = "Bit 5 - Receive Overrun 1"]
# [inline (always)]
pub fn rxor1 (& mut self) -> RXOR1_W { RXOR1_W :: new (self) } # [doc = "Bit 8 - Transmit Ready 0"]
# [inline (always)]
pub fn txrdy0 (& mut self) -> TXRDY0_W { TXRDY0_W :: new (self) } # [doc = "Bit 9 - Transmit Ready 1"]
# [inline (always)]
pub fn txrdy1 (& mut self) -> TXRDY1_W { TXRDY1_W :: new (self) } # [doc = "Bit 12 - Transmit Underrun 0"]
# [inline (always)]
pub fn txur0 (& mut self) -> TXUR0_W { TXUR0_W :: new (self) } # [doc = "Bit 13 - Transmit Underrun 1"]
# [inline (always)]
pub fn txur1 (& mut self) -> TXUR1_W { TXUR1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflag](index.html) module"]
pub struct INTFLAG_SPEC ; impl crate :: RegisterSpec for INTFLAG_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [intflag::R](R) reader structure"]
impl crate :: Readable for INTFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflag::W](W) writer structure"]
impl crate :: Writable for INTFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTFLAG to value 0"]
impl crate :: Resettable for INTFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYNCBUSY register accessor: an alias for `Reg<SYNCBUSY_SPEC>`"]
pub type SYNCBUSY = crate :: Reg < syncbusy :: SYNCBUSY_SPEC > ; # [doc = "Synchronization Status"]
pub mod syncbusy { # [doc = "Register `SYNCBUSY` reader"]
pub struct R (crate :: R < SYNCBUSY_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYNCBUSY_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYNCBUSY_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYNCBUSY_SPEC >) -> Self { R (reader) } } # [doc = "Field `SWRST` reader - Software Reset Synchronization Status"]
pub type SWRST_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` reader - Enable Synchronization Status"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `CKEN0` reader - Clock Unit 0 Enable Synchronization Status"]
pub type CKEN0_R = crate :: BitReader < bool > ; # [doc = "Field `CKEN1` reader - Clock Unit 1 Enable Synchronization Status"]
pub type CKEN1_R = crate :: BitReader < bool > ; # [doc = "Field `SEREN0` reader - Serializer 0 Enable Synchronization Status"]
pub type SEREN0_R = crate :: BitReader < bool > ; # [doc = "Field `SEREN1` reader - Serializer 1 Enable Synchronization Status"]
pub type SEREN1_R = crate :: BitReader < bool > ; # [doc = "Field `DATA0` reader - Data 0 Synchronization Status"]
pub type DATA0_R = crate :: BitReader < bool > ; # [doc = "Field `DATA1` reader - Data 1 Synchronization Status"]
pub type DATA1_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Software Reset Synchronization Status"]
# [inline (always)]
pub fn swrst (& self) -> SWRST_R { SWRST_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Enable Synchronization Status"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Clock Unit 0 Enable Synchronization Status"]
# [inline (always)]
pub fn cken0 (& self) -> CKEN0_R { CKEN0_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Clock Unit 1 Enable Synchronization Status"]
# [inline (always)]
pub fn cken1 (& self) -> CKEN1_R { CKEN1_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Serializer 0 Enable Synchronization Status"]
# [inline (always)]
pub fn seren0 (& self) -> SEREN0_R { SEREN0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Serializer 1 Enable Synchronization Status"]
# [inline (always)]
pub fn seren1 (& self) -> SEREN1_R { SEREN1_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 8 - Data 0 Synchronization Status"]
# [inline (always)]
pub fn data0 (& self) -> DATA0_R { DATA0_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Data 1 Synchronization Status"]
# [inline (always)]
pub fn data1 (& self) -> DATA1_R { DATA1_R :: new (((self . bits >> 9) & 1) != 0) } } # [doc = "Synchronization Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [syncbusy](index.html) module"]
pub struct SYNCBUSY_SPEC ; impl crate :: RegisterSpec for SYNCBUSY_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [syncbusy::R](R) reader structure"]
impl crate :: Readable for SYNCBUSY_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SYNCBUSY to value 0"]
impl crate :: Resettable for SYNCBUSY_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SERCTRL register accessor: an alias for `Reg<SERCTRL_SPEC>`"]
pub type SERCTRL = crate :: Reg < serctrl :: SERCTRL_SPEC > ; # [doc = "Serializer n Control"]
pub mod serctrl { # [doc = "Register `SERCTRL%s` reader"]
pub struct R (crate :: R < SERCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SERCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SERCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SERCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `SERCTRL%s` writer"]
pub struct W (crate :: W < SERCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SERCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SERCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SERCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Serializer Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum SERMODE_A { # [doc = "0: Receive"]
RX = 0 , # [doc = "1: Transmit"]
TX = 1 , # [doc = "2: Receive one PDM data on each serial clock edge"]
PDM2 = 2 , } impl From < SERMODE_A > for u8 { # [inline (always)]
fn from (variant : SERMODE_A) -> Self { variant as _ } } # [doc = "Field `SERMODE` reader - Serializer Mode"]
pub type SERMODE_R = crate :: FieldReader < u8 , SERMODE_A > ; impl SERMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SERMODE_A > { match self . bits { 0 => Some (SERMODE_A :: RX) , 1 => Some (SERMODE_A :: TX) , 2 => Some (SERMODE_A :: PDM2) , _ => None , } } # [doc = "Checks if the value of the field is `RX`"]
# [inline (always)]
pub fn is_rx (& self) -> bool { * self == SERMODE_A :: RX } # [doc = "Checks if the value of the field is `TX`"]
# [inline (always)]
pub fn is_tx (& self) -> bool { * self == SERMODE_A :: TX } # [doc = "Checks if the value of the field is `PDM2`"]
# [inline (always)]
pub fn is_pdm2 (& self) -> bool { * self == SERMODE_A :: PDM2 } } # [doc = "Field `SERMODE` writer - Serializer Mode"]
pub type SERMODE_W < 'a > = crate :: FieldWriter < 'a , u32 , SERCTRL_SPEC , u8 , SERMODE_A , 2 , 0 > ; impl < 'a > SERMODE_W < 'a > { # [doc = "Receive"]
# [inline (always)]
pub fn rx (self) -> & 'a mut W { self . variant (SERMODE_A :: RX) } # [doc = "Transmit"]
# [inline (always)]
pub fn tx (self) -> & 'a mut W { self . variant (SERMODE_A :: TX) } # [doc = "Receive one PDM data on each serial clock edge"]
# [inline (always)]
pub fn pdm2 (self) -> & 'a mut W { self . variant (SERMODE_A :: PDM2) } } # [doc = "Line Default Line when Slot Disabled\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum TXDEFAULT_A { # [doc = "0: Output Default Value is 0"]
ZERO = 0 , # [doc = "1: Output Default Value is 1"]
ONE = 1 , # [doc = "3: Output Default Value is high impedance"]
HIZ = 3 , } impl From < TXDEFAULT_A > for u8 { # [inline (always)]
fn from (variant : TXDEFAULT_A) -> Self { variant as _ } } # [doc = "Field `TXDEFAULT` reader - Line Default Line when Slot Disabled"]
pub type TXDEFAULT_R = crate :: FieldReader < u8 , TXDEFAULT_A > ; impl TXDEFAULT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < TXDEFAULT_A > { match self . bits { 0 => Some (TXDEFAULT_A :: ZERO) , 1 => Some (TXDEFAULT_A :: ONE) , 3 => Some (TXDEFAULT_A :: HIZ) , _ => None , } } # [doc = "Checks if the value of the field is `ZERO`"]
# [inline (always)]
pub fn is_zero (& self) -> bool { * self == TXDEFAULT_A :: ZERO } # [doc = "Checks if the value of the field is `ONE`"]
# [inline (always)]
pub fn is_one (& self) -> bool { * self == TXDEFAULT_A :: ONE } # [doc = "Checks if the value of the field is `HIZ`"]
# [inline (always)]
pub fn is_hiz (& self) -> bool { * self == TXDEFAULT_A :: HIZ } } # [doc = "Field `TXDEFAULT` writer - Line Default Line when Slot Disabled"]
pub type TXDEFAULT_W < 'a > = crate :: FieldWriter < 'a , u32 , SERCTRL_SPEC , u8 , TXDEFAULT_A , 2 , 2 > ; impl < 'a > TXDEFAULT_W < 'a > { # [doc = "Output Default Value is 0"]
# [inline (always)]
pub fn zero (self) -> & 'a mut W { self . variant (TXDEFAULT_A :: ZERO) } # [doc = "Output Default Value is 1"]
# [inline (always)]
pub fn one (self) -> & 'a mut W { self . variant (TXDEFAULT_A :: ONE) } # [doc = "Output Default Value is high impedance"]
# [inline (always)]
pub fn hiz (self) -> & 'a mut W { self . variant (TXDEFAULT_A :: HIZ) } } # [doc = "Transmit Data when Underrun\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
pub enum TXSAME_A { # [doc = "0: Zero data transmitted in case of underrun"]
ZERO = 0 , # [doc = "1: Last data transmitted in case of underrun"]
SAME = 1 , } impl From < TXSAME_A > for bool { # [inline (always)]
fn from (variant : TXSAME_A) -> Self { variant as u8 != 0 } } # [doc = "Field `TXSAME` reader - Transmit Data when Underrun"]
pub type TXSAME_R = crate :: BitReader < TXSAME_A > ; impl TXSAME_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> TXSAME_A { match self . bits { false => TXSAME_A :: ZERO , true => TXSAME_A :: SAME , } } # [doc = "Checks if the value of the field is `ZERO`"]
# [inline (always)]
pub fn is_zero (& self) -> bool { * self == TXSAME_A :: ZERO } # [doc = "Checks if the value of the field is `SAME`"]
# [inline (always)]
pub fn is_same (& self) -> bool { * self == TXSAME_A :: SAME } } # [doc = "Field `TXSAME` writer - Transmit Data when Underrun"]
pub type TXSAME_W < 'a > = crate :: BitWriter < 'a , u32 , SERCTRL_SPEC , TXSAME_A , 4 > ; impl < 'a > TXSAME_W < 'a > { # [doc = "Zero data transmitted in case of underrun"]
# [inline (always)]
pub fn zero (self) -> & 'a mut W { self . variant (TXSAME_A :: ZERO) } # [doc = "Last data transmitted in case of underrun"]
# [inline (always)]
pub fn same (self) -> & 'a mut W { self . variant (TXSAME_A :: SAME) } } # [doc = "Clock Unit Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
pub enum CLKSEL_A { # [doc = "0: Use Clock Unit 0"]
CLK0 = 0 , # [doc = "1: Use Clock Unit 1"]
CLK1 = 1 , } impl From < CLKSEL_A > for bool { # [inline (always)]
fn from (variant : CLKSEL_A) -> Self { variant as u8 != 0 } } # [doc = "Field `CLKSEL` reader - Clock Unit Selection"]
pub type CLKSEL_R = crate :: BitReader < CLKSEL_A > ; impl CLKSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CLKSEL_A { match self . bits { false => CLKSEL_A :: CLK0 , true => CLKSEL_A :: CLK1 , } } # [doc = "Checks if the value of the field is `CLK0`"]
# [inline (always)]
pub fn is_clk0 (& self) -> bool { * self == CLKSEL_A :: CLK0 } # [doc = "Checks if the value of the field is `CLK1`"]
# [inline (always)]
pub fn is_clk1 (& self) -> bool { * self == CLKSEL_A :: CLK1 } } # [doc = "Field `CLKSEL` writer - Clock Unit Selection"]
pub type CLKSEL_W < 'a > = crate :: BitWriter < 'a , u32 , SERCTRL_SPEC , CLKSEL_A , 5 > ; impl < 'a > CLKSEL_W < 'a > { # [doc = "Use Clock Unit 0"]
# [inline (always)]
pub fn clk0 (self) -> & 'a mut W { self . variant (CLKSEL_A :: CLK0) } # [doc = "Use Clock Unit 1"]
# [inline (always)]
pub fn clk1 (self) -> & 'a mut W { self . variant (CLKSEL_A :: CLK1) } } # [doc = "Data Slot Formatting Adjust\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
pub enum SLOTADJ_A { # [doc = "0: Data is right adjusted in slot"]
RIGHT = 0 , # [doc = "1: Data is left adjusted in slot"]
LEFT = 1 , } impl From < SLOTADJ_A > for bool { # [inline (always)]
fn from (variant : SLOTADJ_A) -> Self { variant as u8 != 0 } } # [doc = "Field `SLOTADJ` reader - Data Slot Formatting Adjust"]
pub type SLOTADJ_R = crate :: BitReader < SLOTADJ_A > ; impl SLOTADJ_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SLOTADJ_A { match self . bits { false => SLOTADJ_A :: RIGHT , true => SLOTADJ_A :: LEFT , } } # [doc = "Checks if the value of the field is `RIGHT`"]
# [inline (always)]
pub fn is_right (& self) -> bool { * self == SLOTADJ_A :: RIGHT } # [doc = "Checks if the value of the field is `LEFT`"]
# [inline (always)]
pub fn is_left (& self) -> bool { * self == SLOTADJ_A :: LEFT } } # [doc = "Field `SLOTADJ` writer - Data Slot Formatting Adjust"]
pub type SLOTADJ_W < 'a > = crate :: BitWriter < 'a , u32 , SERCTRL_SPEC , SLOTADJ_A , 7 > ; impl < 'a > SLOTADJ_W < 'a > { # [doc = "Data is right adjusted in slot"]
# [inline (always)]
pub fn right (self) -> & 'a mut W { self . variant (SLOTADJ_A :: RIGHT) } # [doc = "Data is left adjusted in slot"]
# [inline (always)]
pub fn left (self) -> & 'a mut W { self . variant (SLOTADJ_A :: LEFT) } } # [doc = "Data Word Size\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum DATASIZE_A { # [doc = "0: 32 bits"]
_32 = 0 , # [doc = "1: 24 bits"]
_24 = 1 , # [doc = "2: 20 bits"]
_20 = 2 , # [doc = "3: 18 bits"]
_18 = 3 , # [doc = "4: 16 bits"]
_16 = 4 , # [doc = "5: 16 bits compact stereo"]
_16C = 5 , # [doc = "6: 8 bits"]
_8 = 6 , # [doc = "7: 8 bits compact stereo"]
_8C = 7 , } impl From < DATASIZE_A > for u8 { # [inline (always)]
fn from (variant : DATASIZE_A) -> Self { variant as _ } } # [doc = "Field `DATASIZE` reader - Data Word Size"]
pub type DATASIZE_R = crate :: FieldReader < u8 , DATASIZE_A > ; impl DATASIZE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DATASIZE_A { match self . bits { 0 => DATASIZE_A :: _32 , 1 => DATASIZE_A :: _24 , 2 => DATASIZE_A :: _20 , 3 => DATASIZE_A :: _18 , 4 => DATASIZE_A :: _16 , 5 => DATASIZE_A :: _16C , 6 => DATASIZE_A :: _8 , 7 => DATASIZE_A :: _8C , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_32`"]
# [inline (always)]
pub fn is_32 (& self) -> bool { * self == DATASIZE_A :: _32 } # [doc = "Checks if the value of the field is `_24`"]
# [inline (always)]
pub fn is_24 (& self) -> bool { * self == DATASIZE_A :: _24 } # [doc = "Checks if the value of the field is `_20`"]
# [inline (always)]
pub fn is_20 (& self) -> bool { * self == DATASIZE_A :: _20 } # [doc = "Checks if the value of the field is `_18`"]
# [inline (always)]
pub fn is_18 (& self) -> bool { * self == DATASIZE_A :: _18 } # [doc = "Checks if the value of the field is `_16`"]
# [inline (always)]
pub fn is_16 (& self) -> bool { * self == DATASIZE_A :: _16 } # [doc = "Checks if the value of the field is `_16C`"]
# [inline (always)]
pub fn is_16c (& self) -> bool { * self == DATASIZE_A :: _16C } # [doc = "Checks if the value of the field is `_8`"]
# [inline (always)]
pub fn is_8 (& self) -> bool { * self == DATASIZE_A :: _8 } # [doc = "Checks if the value of the field is `_8C`"]
# [inline (always)]
pub fn is_8c (& self) -> bool { * self == DATASIZE_A :: _8C } } # [doc = "Field `DATASIZE` writer - Data Word Size"]
pub type DATASIZE_W < 'a > = crate :: FieldWriterSafe < 'a , u32 , SERCTRL_SPEC , u8 , DATASIZE_A , 3 , 8 > ; impl < 'a > DATASIZE_W < 'a > { # [doc = "32 bits"]
# [inline (always)]
pub fn _32 (self) -> & 'a mut W { self . variant (DATASIZE_A :: _32) } # [doc = "24 bits"]
# [inline (always)]
pub fn _24 (self) -> & 'a mut W { self . variant (DATASIZE_A :: _24) } # [doc = "20 bits"]
# [inline (always)]
pub fn _20 (self) -> & 'a mut W { self . variant (DATASIZE_A :: _20) } # [doc = "18 bits"]
# [inline (always)]
pub fn _18 (self) -> & 'a mut W { self . variant (DATASIZE_A :: _18) } # [doc = "16 bits"]
# [inline (always)]
pub fn _16 (self) -> & 'a mut W { self . variant (DATASIZE_A :: _16) } # [doc = "16 bits compact stereo"]
# [inline (always)]
pub fn _16c (self) -> & 'a mut W { self . variant (DATASIZE_A :: _16C) } # [doc = "8 bits"]
# [inline (always)]
pub fn _8 (self) -> & 'a mut W { self . variant (DATASIZE_A :: _8) } # [doc = "8 bits compact stereo"]
# [inline (always)]
pub fn _8c (self) -> & 'a mut W { self . variant (DATASIZE_A :: _8C) } } # [doc = "Data Word Formatting Adjust\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
pub enum WORDADJ_A { # [doc = "0: Data is right adjusted in word"]
RIGHT = 0 , # [doc = "1: Data is left adjusted in word"]
LEFT = 1 , } impl From < WORDADJ_A > for bool { # [inline (always)]
fn from (variant : WORDADJ_A) -> Self { variant as u8 != 0 } } # [doc = "Field `WORDADJ` reader - Data Word Formatting Adjust"]
pub type WORDADJ_R = crate :: BitReader < WORDADJ_A > ; impl WORDADJ_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> WORDADJ_A { match self . bits { false => WORDADJ_A :: RIGHT , true => WORDADJ_A :: LEFT , } } # [doc = "Checks if the value of the field is `RIGHT`"]
# [inline (always)]
pub fn is_right (& self) -> bool { * self == WORDADJ_A :: RIGHT } # [doc = "Checks if the value of the field is `LEFT`"]
# [inline (always)]
pub fn is_left (& self) -> bool { * self == WORDADJ_A :: LEFT } } # [doc = "Field `WORDADJ` writer - Data Word Formatting Adjust"]
pub type WORDADJ_W < 'a > = crate :: BitWriter < 'a , u32 , SERCTRL_SPEC , WORDADJ_A , 12 > ; impl < 'a > WORDADJ_W < 'a > { # [doc = "Data is right adjusted in word"]
# [inline (always)]
pub fn right (self) -> & 'a mut W { self . variant (WORDADJ_A :: RIGHT) } # [doc = "Data is left adjusted in word"]
# [inline (always)]
pub fn left (self) -> & 'a mut W { self . variant (WORDADJ_A :: LEFT) } } # [doc = "Data Formatting Bit Extension\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum EXTEND_A { # [doc = "0: Extend with zeroes"]
ZERO = 0 , # [doc = "1: Extend with ones"]
ONE = 1 , # [doc = "2: Extend with Most Significant Bit"]
MSBIT = 2 , # [doc = "3: Extend with Least Significant Bit"]
LSBIT = 3 , } impl From < EXTEND_A > for u8 { # [inline (always)]
fn from (variant : EXTEND_A) -> Self { variant as _ } } # [doc = "Field `EXTEND` reader - Data Formatting Bit Extension"]
pub type EXTEND_R = crate :: FieldReader < u8 , EXTEND_A > ; impl EXTEND_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> EXTEND_A { match self . bits { 0 => EXTEND_A :: ZERO , 1 => EXTEND_A :: ONE , 2 => EXTEND_A :: MSBIT , 3 => EXTEND_A :: LSBIT , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `ZERO`"]
# [inline (always)]
pub fn is_zero (& self) -> bool { * self == EXTEND_A :: ZERO } # [doc = "Checks if the value of the field is `ONE`"]
# [inline (always)]
pub fn is_one (& self) -> bool { * self == EXTEND_A :: ONE } # [doc = "Checks if the value of the field is `MSBIT`"]
# [inline (always)]
pub fn is_msbit (& self) -> bool { * self == EXTEND_A :: MSBIT } # [doc = "Checks if the value of the field is `LSBIT`"]
# [inline (always)]
pub fn is_lsbit (& self) -> bool { * self == EXTEND_A :: LSBIT } } # [doc = "Field `EXTEND` writer - Data Formatting Bit Extension"]
pub type EXTEND_W < 'a > = crate :: FieldWriterSafe < 'a , u32 , SERCTRL_SPEC , u8 , EXTEND_A , 2 , 13 > ; impl < 'a > EXTEND_W < 'a > { # [doc = "Extend with zeroes"]
# [inline (always)]
pub fn zero (self) -> & 'a mut W { self . variant (EXTEND_A :: ZERO) } # [doc = "Extend with ones"]
# [inline (always)]
pub fn one (self) -> & 'a mut W { self . variant (EXTEND_A :: ONE) } # [doc = "Extend with Most Significant Bit"]
# [inline (always)]
pub fn msbit (self) -> & 'a mut W { self . variant (EXTEND_A :: MSBIT) } # [doc = "Extend with Least Significant Bit"]
# [inline (always)]
pub fn lsbit (self) -> & 'a mut W { self . variant (EXTEND_A :: LSBIT) } } # [doc = "Data Formatting Bit Reverse\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
pub enum BITREV_A { # [doc = "0: Transfer Data Most Significant Bit (MSB) first (default for I2S protocol)"]
MSBIT = 0 , # [doc = "1: Transfer Data Least Significant Bit (LSB) first"]
LSBIT = 1 , } impl From < BITREV_A > for bool { # [inline (always)]
fn from (variant : BITREV_A) -> Self { variant as u8 != 0 } } # [doc = "Field `BITREV` reader - Data Formatting Bit Reverse"]
pub type BITREV_R = crate :: BitReader < BITREV_A > ; impl BITREV_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> BITREV_A { match self . bits { false => BITREV_A :: MSBIT , true => BITREV_A :: LSBIT , } } # [doc = "Checks if the value of the field is `MSBIT`"]
# [inline (always)]
pub fn is_msbit (& self) -> bool { * self == BITREV_A :: MSBIT } # [doc = "Checks if the value of the field is `LSBIT`"]
# [inline (always)]
pub fn is_lsbit (& self) -> bool { * self == BITREV_A :: LSBIT } } # [doc = "Field `BITREV` writer - Data Formatting Bit Reverse"]
pub type BITREV_W < 'a > = crate :: BitWriter < 'a , u32 , SERCTRL_SPEC , BITREV_A , 15 > ; impl < 'a > BITREV_W < 'a > { # [doc = "Transfer Data Most Significant Bit (MSB) first (default for I2S protocol)"]
# [inline (always)]
pub fn msbit (self) -> & 'a mut W { self . variant (BITREV_A :: MSBIT) } # [doc = "Transfer Data Least Significant Bit (LSB) first"]
# [inline (always)]
pub fn lsbit (self) -> & 'a mut W { self . variant (BITREV_A :: LSBIT) } } # [doc = "Field `SLOTDIS0` reader - Slot 0 Disabled for this Serializer"]
pub type SLOTDIS0_R = crate :: BitReader < bool > ; # [doc = "Field `SLOTDIS0` writer - Slot 0 Disabled for this Serializer"]
pub type SLOTDIS0_W < 'a > = crate :: BitWriter < 'a , u32 , SERCTRL_SPEC , bool , 16 > ; # [doc = "Field `SLOTDIS1` reader - Slot 1 Disabled for this Serializer"]
pub type SLOTDIS1_R = crate :: BitReader < bool > ; # [doc = "Field `SLOTDIS1` writer - Slot 1 Disabled for this Serializer"]
pub type SLOTDIS1_W < 'a > = crate :: BitWriter < 'a , u32 , SERCTRL_SPEC , bool , 17 > ; # [doc = "Field `SLOTDIS2` reader - Slot 2 Disabled for this Serializer"]
pub type SLOTDIS2_R = crate :: BitReader < bool > ; # [doc = "Field `SLOTDIS2` writer - Slot 2 Disabled for this Serializer"]
pub type SLOTDIS2_W < 'a > = crate :: BitWriter < 'a , u32 , SERCTRL_SPEC , bool , 18 > ; # [doc = "Field `SLOTDIS3` reader - Slot 3 Disabled for this Serializer"]
pub type SLOTDIS3_R = crate :: BitReader < bool > ; # [doc = "Field `SLOTDIS3` writer - Slot 3 Disabled for this Serializer"]
pub type SLOTDIS3_W < 'a > = crate :: BitWriter < 'a , u32 , SERCTRL_SPEC , bool , 19 > ; # [doc = "Field `SLOTDIS4` reader - Slot 4 Disabled for this Serializer"]
pub type SLOTDIS4_R = crate :: BitReader < bool > ; # [doc = "Field `SLOTDIS4` writer - Slot 4 Disabled for this Serializer"]
pub type SLOTDIS4_W < 'a > = crate :: BitWriter < 'a , u32 , SERCTRL_SPEC , bool , 20 > ; # [doc = "Field `SLOTDIS5` reader - Slot 5 Disabled for this Serializer"]
pub type SLOTDIS5_R = crate :: BitReader < bool > ; # [doc = "Field `SLOTDIS5` writer - Slot 5 Disabled for this Serializer"]
pub type SLOTDIS5_W < 'a > = crate :: BitWriter < 'a , u32 , SERCTRL_SPEC , bool , 21 > ; # [doc = "Field `SLOTDIS6` reader - Slot 6 Disabled for this Serializer"]
pub type SLOTDIS6_R = crate :: BitReader < bool > ; # [doc = "Field `SLOTDIS6` writer - Slot 6 Disabled for this Serializer"]
pub type SLOTDIS6_W < 'a > = crate :: BitWriter < 'a , u32 , SERCTRL_SPEC , bool , 22 > ; # [doc = "Field `SLOTDIS7` reader - Slot 7 Disabled for this Serializer"]
pub type SLOTDIS7_R = crate :: BitReader < bool > ; # [doc = "Field `SLOTDIS7` writer - Slot 7 Disabled for this Serializer"]
pub type SLOTDIS7_W < 'a > = crate :: BitWriter < 'a , u32 , SERCTRL_SPEC , bool , 23 > ; # [doc = "Mono Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
pub enum MONO_A { # [doc = "0: Normal mode"]
STEREO = 0 , # [doc = "1: Left channel data is duplicated to right channel"]
MONO = 1 , } impl From < MONO_A > for bool { # [inline (always)]
fn from (variant : MONO_A) -> Self { variant as u8 != 0 } } # [doc = "Field `MONO` reader - Mono Mode"]
pub type MONO_R = crate :: BitReader < MONO_A > ; impl MONO_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MONO_A { match self . bits { false => MONO_A :: STEREO , true => MONO_A :: MONO , } } # [doc = "Checks if the value of the field is `STEREO`"]
# [inline (always)]
pub fn is_stereo (& self) -> bool { * self == MONO_A :: STEREO } # [doc = "Checks if the value of the field is `MONO`"]
# [inline (always)]
pub fn is_mono (& self) -> bool { * self == MONO_A :: MONO } } # [doc = "Field `MONO` writer - Mono Mode"]
pub type MONO_W < 'a > = crate :: BitWriter < 'a , u32 , SERCTRL_SPEC , MONO_A , 24 > ; impl < 'a > MONO_W < 'a > { # [doc = "Normal mode"]
# [inline (always)]
pub fn stereo (self) -> & 'a mut W { self . variant (MONO_A :: STEREO) } # [doc = "Left channel data is duplicated to right channel"]
# [inline (always)]
pub fn mono (self) -> & 'a mut W { self . variant (MONO_A :: MONO) } } # [doc = "Single or Multiple DMA Channels\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
pub enum DMA_A { # [doc = "0: Single DMA channel"]
SINGLE = 0 , # [doc = "1: One DMA channel per data channel"]
MULTIPLE = 1 , } impl From < DMA_A > for bool { # [inline (always)]
fn from (variant : DMA_A) -> Self { variant as u8 != 0 } } # [doc = "Field `DMA` reader - Single or Multiple DMA Channels"]
pub type DMA_R = crate :: BitReader < DMA_A > ; impl DMA_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DMA_A { match self . bits { false => DMA_A :: SINGLE , true => DMA_A :: MULTIPLE , } } # [doc = "Checks if the value of the field is `SINGLE`"]
# [inline (always)]
pub fn is_single (& self) -> bool { * self == DMA_A :: SINGLE } # [doc = "Checks if the value of the field is `MULTIPLE`"]
# [inline (always)]
pub fn is_multiple (& self) -> bool { * self == DMA_A :: MULTIPLE } } # [doc = "Field `DMA` writer - Single or Multiple DMA Channels"]
pub type DMA_W < 'a > = crate :: BitWriter < 'a , u32 , SERCTRL_SPEC , DMA_A , 25 > ; impl < 'a > DMA_W < 'a > { # [doc = "Single DMA channel"]
# [inline (always)]
pub fn single (self) -> & 'a mut W { self . variant (DMA_A :: SINGLE) } # [doc = "One DMA channel per data channel"]
# [inline (always)]
pub fn multiple (self) -> & 'a mut W { self . variant (DMA_A :: MULTIPLE) } } # [doc = "Field `RXLOOP` reader - Loop-back Test Mode"]
pub type RXLOOP_R = crate :: BitReader < bool > ; # [doc = "Field `RXLOOP` writer - Loop-back Test Mode"]
pub type RXLOOP_W < 'a > = crate :: BitWriter < 'a , u32 , SERCTRL_SPEC , bool , 26 > ; impl R { # [doc = "Bits 0:1 - Serializer Mode"]
# [inline (always)]
pub fn sermode (& self) -> SERMODE_R { SERMODE_R :: new ((self . bits & 3) as u8) } # [doc = "Bits 2:3 - Line Default Line when Slot Disabled"]
# [inline (always)]
pub fn txdefault (& self) -> TXDEFAULT_R { TXDEFAULT_R :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bit 4 - Transmit Data when Underrun"]
# [inline (always)]
pub fn txsame (& self) -> TXSAME_R { TXSAME_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Clock Unit Selection"]
# [inline (always)]
pub fn clksel (& self) -> CLKSEL_R { CLKSEL_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 7 - Data Slot Formatting Adjust"]
# [inline (always)]
pub fn slotadj (& self) -> SLOTADJ_R { SLOTADJ_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bits 8:10 - Data Word Size"]
# [inline (always)]
pub fn datasize (& self) -> DATASIZE_R { DATASIZE_R :: new (((self . bits >> 8) & 7) as u8) } # [doc = "Bit 12 - Data Word Formatting Adjust"]
# [inline (always)]
pub fn wordadj (& self) -> WORDADJ_R { WORDADJ_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bits 13:14 - Data Formatting Bit Extension"]
# [inline (always)]
pub fn extend (& self) -> EXTEND_R { EXTEND_R :: new (((self . bits >> 13) & 3) as u8) } # [doc = "Bit 15 - Data Formatting Bit Reverse"]
# [inline (always)]
pub fn bitrev (& self) -> BITREV_R { BITREV_R :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - Slot 0 Disabled for this Serializer"]
# [inline (always)]
pub fn slotdis0 (& self) -> SLOTDIS0_R { SLOTDIS0_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Slot 1 Disabled for this Serializer"]
# [inline (always)]
pub fn slotdis1 (& self) -> SLOTDIS1_R { SLOTDIS1_R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Slot 2 Disabled for this Serializer"]
# [inline (always)]
pub fn slotdis2 (& self) -> SLOTDIS2_R { SLOTDIS2_R :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Slot 3 Disabled for this Serializer"]
# [inline (always)]
pub fn slotdis3 (& self) -> SLOTDIS3_R { SLOTDIS3_R :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 20 - Slot 4 Disabled for this Serializer"]
# [inline (always)]
pub fn slotdis4 (& self) -> SLOTDIS4_R { SLOTDIS4_R :: new (((self . bits >> 20) & 1) != 0) } # [doc = "Bit 21 - Slot 5 Disabled for this Serializer"]
# [inline (always)]
pub fn slotdis5 (& self) -> SLOTDIS5_R { SLOTDIS5_R :: new (((self . bits >> 21) & 1) != 0) } # [doc = "Bit 22 - Slot 6 Disabled for this Serializer"]
# [inline (always)]
pub fn slotdis6 (& self) -> SLOTDIS6_R { SLOTDIS6_R :: new (((self . bits >> 22) & 1) != 0) } # [doc = "Bit 23 - Slot 7 Disabled for this Serializer"]
# [inline (always)]
pub fn slotdis7 (& self) -> SLOTDIS7_R { SLOTDIS7_R :: new (((self . bits >> 23) & 1) != 0) } # [doc = "Bit 24 - Mono Mode"]
# [inline (always)]
pub fn mono (& self) -> MONO_R { MONO_R :: new (((self . bits >> 24) & 1) != 0) } # [doc = "Bit 25 - Single or Multiple DMA Channels"]
# [inline (always)]
pub fn dma (& self) -> DMA_R { DMA_R :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - Loop-back Test Mode"]
# [inline (always)]
pub fn rxloop (& self) -> RXLOOP_R { RXLOOP_R :: new (((self . bits >> 26) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Serializer Mode"]
# [inline (always)]
pub fn sermode (& mut self) -> SERMODE_W { SERMODE_W :: new (self) } # [doc = "Bits 2:3 - Line Default Line when Slot Disabled"]
# [inline (always)]
pub fn txdefault (& mut self) -> TXDEFAULT_W { TXDEFAULT_W :: new (self) } # [doc = "Bit 4 - Transmit Data when Underrun"]
# [inline (always)]
pub fn txsame (& mut self) -> TXSAME_W { TXSAME_W :: new (self) } # [doc = "Bit 5 - Clock Unit Selection"]
# [inline (always)]
pub fn clksel (& mut self) -> CLKSEL_W { CLKSEL_W :: new (self) } # [doc = "Bit 7 - Data Slot Formatting Adjust"]
# [inline (always)]
pub fn slotadj (& mut self) -> SLOTADJ_W { SLOTADJ_W :: new (self) } # [doc = "Bits 8:10 - Data Word Size"]
# [inline (always)]
pub fn datasize (& mut self) -> DATASIZE_W { DATASIZE_W :: new (self) } # [doc = "Bit 12 - Data Word Formatting Adjust"]
# [inline (always)]
pub fn wordadj (& mut self) -> WORDADJ_W { WORDADJ_W :: new (self) } # [doc = "Bits 13:14 - Data Formatting Bit Extension"]
# [inline (always)]
pub fn extend (& mut self) -> EXTEND_W { EXTEND_W :: new (self) } # [doc = "Bit 15 - Data Formatting Bit Reverse"]
# [inline (always)]
pub fn bitrev (& mut self) -> BITREV_W { BITREV_W :: new (self) } # [doc = "Bit 16 - Slot 0 Disabled for this Serializer"]
# [inline (always)]
pub fn slotdis0 (& mut self) -> SLOTDIS0_W { SLOTDIS0_W :: new (self) } # [doc = "Bit 17 - Slot 1 Disabled for this Serializer"]
# [inline (always)]
pub fn slotdis1 (& mut self) -> SLOTDIS1_W { SLOTDIS1_W :: new (self) } # [doc = "Bit 18 - Slot 2 Disabled for this Serializer"]
# [inline (always)]
pub fn slotdis2 (& mut self) -> SLOTDIS2_W { SLOTDIS2_W :: new (self) } # [doc = "Bit 19 - Slot 3 Disabled for this Serializer"]
# [inline (always)]
pub fn slotdis3 (& mut self) -> SLOTDIS3_W { SLOTDIS3_W :: new (self) } # [doc = "Bit 20 - Slot 4 Disabled for this Serializer"]
# [inline (always)]
pub fn slotdis4 (& mut self) -> SLOTDIS4_W { SLOTDIS4_W :: new (self) } # [doc = "Bit 21 - Slot 5 Disabled for this Serializer"]
# [inline (always)]
pub fn slotdis5 (& mut self) -> SLOTDIS5_W { SLOTDIS5_W :: new (self) } # [doc = "Bit 22 - Slot 6 Disabled for this Serializer"]
# [inline (always)]
pub fn slotdis6 (& mut self) -> SLOTDIS6_W { SLOTDIS6_W :: new (self) } # [doc = "Bit 23 - Slot 7 Disabled for this Serializer"]
# [inline (always)]
pub fn slotdis7 (& mut self) -> SLOTDIS7_W { SLOTDIS7_W :: new (self) } # [doc = "Bit 24 - Mono Mode"]
# [inline (always)]
pub fn mono (& mut self) -> MONO_W { MONO_W :: new (self) } # [doc = "Bit 25 - Single or Multiple DMA Channels"]
# [inline (always)]
pub fn dma (& mut self) -> DMA_W { DMA_W :: new (self) } # [doc = "Bit 26 - Loop-back Test Mode"]
# [inline (always)]
pub fn rxloop (& mut self) -> RXLOOP_W { RXLOOP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Serializer n Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [serctrl](index.html) module"]
pub struct SERCTRL_SPEC ; impl crate :: RegisterSpec for SERCTRL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [serctrl::R](R) reader structure"]
impl crate :: Readable for SERCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [serctrl::W](W) writer structure"]
impl crate :: Writable for SERCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SERCTRL%s to value 0"]
impl crate :: Resettable for SERCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DATA register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "Data n"]
pub mod data { # [doc = "Register `DATA%s` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA%s` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } # [doc = "Field `DATA` reader - Sample Data"]
pub type DATA_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `DATA` writer - Sample Data"]
pub type DATA_W < 'a > = crate :: FieldWriter < 'a , u32 , DATA_SPEC , u32 , u32 , 32 , 0 > ; impl R { # [doc = "Bits 0:31 - Sample Data"]
# [inline (always)]
pub fn data (& self) -> DATA_R { DATA_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Sample Data"]
# [inline (always)]
pub fn data (& mut self) -> DATA_W { DATA_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data n\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DATA%s to value 0"]
impl crate :: Resettable for DATA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "Cortex-M0+ Micro-Trace Buffer"]
pub struct MTB { _marker : PhantomData < * const () > } unsafe impl Send for MTB { } impl MTB { # [doc = r"Pointer to the register block"]
pub const PTR : * const mtb :: RegisterBlock = 0x4100_6000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const mtb :: RegisterBlock { Self :: PTR } } impl Deref for MTB { type Target = mtb :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for MTB { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("MTB") . finish () } } # [doc = "Cortex-M0+ Micro-Trace Buffer"]
pub mod mtb { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - MTB Position"]
pub position : crate :: Reg < position :: POSITION_SPEC > , # [doc = "0x04 - MTB Master"]
pub master : crate :: Reg < master :: MASTER_SPEC > , # [doc = "0x08 - MTB Flow"]
pub flow : crate :: Reg < flow :: FLOW_SPEC > , # [doc = "0x0c - MTB Base"]
pub base : crate :: Reg < base :: BASE_SPEC > , _reserved4 : [u8 ; 0x0ef0]
, # [doc = "0xf00 - MTB Integration Mode Control"]
pub itctrl : crate :: Reg < itctrl :: ITCTRL_SPEC > , _reserved5 : [u8 ; 0x9c]
, # [doc = "0xfa0 - MTB Claim Set"]
pub claimset : crate :: Reg < claimset :: CLAIMSET_SPEC > , # [doc = "0xfa4 - MTB Claim Clear"]
pub claimclr : crate :: Reg < claimclr :: CLAIMCLR_SPEC > , _reserved7 : [u8 ; 0x08]
, # [doc = "0xfb0 - MTB Lock Access"]
pub lockaccess : crate :: Reg < lockaccess :: LOCKACCESS_SPEC > , # [doc = "0xfb4 - MTB Lock Status"]
pub lockstatus : crate :: Reg < lockstatus :: LOCKSTATUS_SPEC > , # [doc = "0xfb8 - MTB Authentication Status"]
pub authstatus : crate :: Reg < authstatus :: AUTHSTATUS_SPEC > , # [doc = "0xfbc - MTB Device Architecture"]
pub devarch : crate :: Reg < devarch :: DEVARCH_SPEC > , _reserved11 : [u8 ; 0x08]
, # [doc = "0xfc8 - MTB Device Configuration"]
pub devid : crate :: Reg < devid :: DEVID_SPEC > , # [doc = "0xfcc - MTB Device Type"]
pub devtype : crate :: Reg < devtype :: DEVTYPE_SPEC > , # [doc = "0xfd0 - CoreSight"]
pub pid4 : crate :: Reg < pid4 :: PID4_SPEC > , # [doc = "0xfd4 - CoreSight"]
pub pid5 : crate :: Reg < pid5 :: PID5_SPEC > , # [doc = "0xfd8 - CoreSight"]
pub pid6 : crate :: Reg < pid6 :: PID6_SPEC > , # [doc = "0xfdc - CoreSight"]
pub pid7 : crate :: Reg < pid7 :: PID7_SPEC > , # [doc = "0xfe0 - CoreSight"]
pub pid0 : crate :: Reg < pid0 :: PID0_SPEC > , # [doc = "0xfe4 - CoreSight"]
pub pid1 : crate :: Reg < pid1 :: PID1_SPEC > , # [doc = "0xfe8 - CoreSight"]
pub pid2 : crate :: Reg < pid2 :: PID2_SPEC > , # [doc = "0xfec - CoreSight"]
pub pid3 : crate :: Reg < pid3 :: PID3_SPEC > , # [doc = "0xff0 - CoreSight"]
pub cid0 : crate :: Reg < cid0 :: CID0_SPEC > , # [doc = "0xff4 - CoreSight"]
pub cid1 : crate :: Reg < cid1 :: CID1_SPEC > , # [doc = "0xff8 - CoreSight"]
pub cid2 : crate :: Reg < cid2 :: CID2_SPEC > , # [doc = "0xffc - CoreSight"]
pub cid3 : crate :: Reg < cid3 :: CID3_SPEC > , } # [doc = "POSITION register accessor: an alias for `Reg<POSITION_SPEC>`"]
pub type POSITION = crate :: Reg < position :: POSITION_SPEC > ; # [doc = "MTB Position"]
pub mod position { # [doc = "Register `POSITION` reader"]
pub struct R (crate :: R < POSITION_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < POSITION_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < POSITION_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < POSITION_SPEC >) -> Self { R (reader) } } # [doc = "Register `POSITION` writer"]
pub struct W (crate :: W < POSITION_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < POSITION_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < POSITION_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < POSITION_SPEC >) -> Self { W (writer) } } # [doc = "Field `WRAP` reader - Pointer Value Wraps"]
pub type WRAP_R = crate :: BitReader < bool > ; # [doc = "Field `WRAP` writer - Pointer Value Wraps"]
pub type WRAP_W < 'a > = crate :: BitWriter < 'a , u32 , POSITION_SPEC , bool , 2 > ; # [doc = "Field `POINTER` reader - Trace Packet Location Pointer"]
pub type POINTER_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `POINTER` writer - Trace Packet Location Pointer"]
pub type POINTER_W < 'a > = crate :: FieldWriter < 'a , u32 , POSITION_SPEC , u32 , u32 , 29 , 3 > ; impl R { # [doc = "Bit 2 - Pointer Value Wraps"]
# [inline (always)]
pub fn wrap (& self) -> WRAP_R { WRAP_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 3:31 - Trace Packet Location Pointer"]
# [inline (always)]
pub fn pointer (& self) -> POINTER_R { POINTER_R :: new (((self . bits >> 3) & 0x1fff_ffff) as u32) } } impl W { # [doc = "Bit 2 - Pointer Value Wraps"]
# [inline (always)]
pub fn wrap (& mut self) -> WRAP_W { WRAP_W :: new (self) } # [doc = "Bits 3:31 - Trace Packet Location Pointer"]
# [inline (always)]
pub fn pointer (& mut self) -> POINTER_W { POINTER_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MTB Position\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [position](index.html) module"]
pub struct POSITION_SPEC ; impl crate :: RegisterSpec for POSITION_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [position::R](R) reader structure"]
impl crate :: Readable for POSITION_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [position::W](W) writer structure"]
impl crate :: Writable for POSITION_SPEC { type Writer = W ; } # [doc = "`reset()` method sets POSITION to value 0"]
impl crate :: Resettable for POSITION_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "MASTER register accessor: an alias for `Reg<MASTER_SPEC>`"]
pub type MASTER = crate :: Reg < master :: MASTER_SPEC > ; # [doc = "MTB Master"]
pub mod master { # [doc = "Register `MASTER` reader"]
pub struct R (crate :: R < MASTER_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MASTER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MASTER_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MASTER_SPEC >) -> Self { R (reader) } } # [doc = "Register `MASTER` writer"]
pub struct W (crate :: W < MASTER_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MASTER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MASTER_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MASTER_SPEC >) -> Self { W (writer) } } # [doc = "Field `MASK` reader - Maximum Value of the Trace Buffer in SRAM"]
pub type MASK_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `MASK` writer - Maximum Value of the Trace Buffer in SRAM"]
pub type MASK_W < 'a > = crate :: FieldWriter < 'a , u32 , MASTER_SPEC , u8 , u8 , 5 , 0 > ; # [doc = "Field `TSTARTEN` reader - Trace Start Input Enable"]
pub type TSTARTEN_R = crate :: BitReader < bool > ; # [doc = "Field `TSTARTEN` writer - Trace Start Input Enable"]
pub type TSTARTEN_W < 'a > = crate :: BitWriter < 'a , u32 , MASTER_SPEC , bool , 5 > ; # [doc = "Field `TSTOPEN` reader - Trace Stop Input Enable"]
pub type TSTOPEN_R = crate :: BitReader < bool > ; # [doc = "Field `TSTOPEN` writer - Trace Stop Input Enable"]
pub type TSTOPEN_W < 'a > = crate :: BitWriter < 'a , u32 , MASTER_SPEC , bool , 6 > ; # [doc = "Field `SFRWPRIV` reader - Special Function Register Write Privilege"]
pub type SFRWPRIV_R = crate :: BitReader < bool > ; # [doc = "Field `SFRWPRIV` writer - Special Function Register Write Privilege"]
pub type SFRWPRIV_W < 'a > = crate :: BitWriter < 'a , u32 , MASTER_SPEC , bool , 7 > ; # [doc = "Field `RAMPRIV` reader - SRAM Privilege"]
pub type RAMPRIV_R = crate :: BitReader < bool > ; # [doc = "Field `RAMPRIV` writer - SRAM Privilege"]
pub type RAMPRIV_W < 'a > = crate :: BitWriter < 'a , u32 , MASTER_SPEC , bool , 8 > ; # [doc = "Field `HALTREQ` reader - Halt Request"]
pub type HALTREQ_R = crate :: BitReader < bool > ; # [doc = "Field `HALTREQ` writer - Halt Request"]
pub type HALTREQ_W < 'a > = crate :: BitWriter < 'a , u32 , MASTER_SPEC , bool , 9 > ; # [doc = "Field `EN` reader - Main Trace Enable"]
pub type EN_R = crate :: BitReader < bool > ; # [doc = "Field `EN` writer - Main Trace Enable"]
pub type EN_W < 'a > = crate :: BitWriter < 'a , u32 , MASTER_SPEC , bool , 31 > ; impl R { # [doc = "Bits 0:4 - Maximum Value of the Trace Buffer in SRAM"]
# [inline (always)]
pub fn mask (& self) -> MASK_R { MASK_R :: new ((self . bits & 0x1f) as u8) } # [doc = "Bit 5 - Trace Start Input Enable"]
# [inline (always)]
pub fn tstarten (& self) -> TSTARTEN_R { TSTARTEN_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Trace Stop Input Enable"]
# [inline (always)]
pub fn tstopen (& self) -> TSTOPEN_R { TSTOPEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Special Function Register Write Privilege"]
# [inline (always)]
pub fn sfrwpriv (& self) -> SFRWPRIV_R { SFRWPRIV_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - SRAM Privilege"]
# [inline (always)]
pub fn rampriv (& self) -> RAMPRIV_R { RAMPRIV_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Halt Request"]
# [inline (always)]
pub fn haltreq (& self) -> HALTREQ_R { HALTREQ_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 31 - Main Trace Enable"]
# [inline (always)]
pub fn en (& self) -> EN_R { EN_R :: new (((self . bits >> 31) & 1) != 0) } } impl W { # [doc = "Bits 0:4 - Maximum Value of the Trace Buffer in SRAM"]
# [inline (always)]
pub fn mask (& mut self) -> MASK_W { MASK_W :: new (self) } # [doc = "Bit 5 - Trace Start Input Enable"]
# [inline (always)]
pub fn tstarten (& mut self) -> TSTARTEN_W { TSTARTEN_W :: new (self) } # [doc = "Bit 6 - Trace Stop Input Enable"]
# [inline (always)]
pub fn tstopen (& mut self) -> TSTOPEN_W { TSTOPEN_W :: new (self) } # [doc = "Bit 7 - Special Function Register Write Privilege"]
# [inline (always)]
pub fn sfrwpriv (& mut self) -> SFRWPRIV_W { SFRWPRIV_W :: new (self) } # [doc = "Bit 8 - SRAM Privilege"]
# [inline (always)]
pub fn rampriv (& mut self) -> RAMPRIV_W { RAMPRIV_W :: new (self) } # [doc = "Bit 9 - Halt Request"]
# [inline (always)]
pub fn haltreq (& mut self) -> HALTREQ_W { HALTREQ_W :: new (self) } # [doc = "Bit 31 - Main Trace Enable"]
# [inline (always)]
pub fn en (& mut self) -> EN_W { EN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MTB Master\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [master](index.html) module"]
pub struct MASTER_SPEC ; impl crate :: RegisterSpec for MASTER_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [master::R](R) reader structure"]
impl crate :: Readable for MASTER_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [master::W](W) writer structure"]
impl crate :: Writable for MASTER_SPEC { type Writer = W ; } # [doc = "`reset()` method sets MASTER to value 0"]
impl crate :: Resettable for MASTER_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "FLOW register accessor: an alias for `Reg<FLOW_SPEC>`"]
pub type FLOW = crate :: Reg < flow :: FLOW_SPEC > ; # [doc = "MTB Flow"]
pub mod flow { # [doc = "Register `FLOW` reader"]
pub struct R (crate :: R < FLOW_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < FLOW_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < FLOW_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < FLOW_SPEC >) -> Self { R (reader) } } # [doc = "Register `FLOW` writer"]
pub struct W (crate :: W < FLOW_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < FLOW_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < FLOW_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < FLOW_SPEC >) -> Self { W (writer) } } # [doc = "Field `AUTOSTOP` reader - Auto Stop Tracing"]
pub type AUTOSTOP_R = crate :: BitReader < bool > ; # [doc = "Field `AUTOSTOP` writer - Auto Stop Tracing"]
pub type AUTOSTOP_W < 'a > = crate :: BitWriter < 'a , u32 , FLOW_SPEC , bool , 0 > ; # [doc = "Field `AUTOHALT` reader - Auto Halt Request"]
pub type AUTOHALT_R = crate :: BitReader < bool > ; # [doc = "Field `AUTOHALT` writer - Auto Halt Request"]
pub type AUTOHALT_W < 'a > = crate :: BitWriter < 'a , u32 , FLOW_SPEC , bool , 1 > ; # [doc = "Field `WATERMARK` reader - Watermark value"]
pub type WATERMARK_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `WATERMARK` writer - Watermark value"]
pub type WATERMARK_W < 'a > = crate :: FieldWriter < 'a , u32 , FLOW_SPEC , u32 , u32 , 29 , 3 > ; impl R { # [doc = "Bit 0 - Auto Stop Tracing"]
# [inline (always)]
pub fn autostop (& self) -> AUTOSTOP_R { AUTOSTOP_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Auto Halt Request"]
# [inline (always)]
pub fn autohalt (& self) -> AUTOHALT_R { AUTOHALT_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 3:31 - Watermark value"]
# [inline (always)]
pub fn watermark (& self) -> WATERMARK_R { WATERMARK_R :: new (((self . bits >> 3) & 0x1fff_ffff) as u32) } } impl W { # [doc = "Bit 0 - Auto Stop Tracing"]
# [inline (always)]
pub fn autostop (& mut self) -> AUTOSTOP_W { AUTOSTOP_W :: new (self) } # [doc = "Bit 1 - Auto Halt Request"]
# [inline (always)]
pub fn autohalt (& mut self) -> AUTOHALT_W { AUTOHALT_W :: new (self) } # [doc = "Bits 3:31 - Watermark value"]
# [inline (always)]
pub fn watermark (& mut self) -> WATERMARK_W { WATERMARK_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MTB Flow\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [flow](index.html) module"]
pub struct FLOW_SPEC ; impl crate :: RegisterSpec for FLOW_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [flow::R](R) reader structure"]
impl crate :: Readable for FLOW_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [flow::W](W) writer structure"]
impl crate :: Writable for FLOW_SPEC { type Writer = W ; } # [doc = "`reset()` method sets FLOW to value 0"]
impl crate :: Resettable for FLOW_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "BASE register accessor: an alias for `Reg<BASE_SPEC>`"]
pub type BASE = crate :: Reg < base :: BASE_SPEC > ; # [doc = "MTB Base"]
pub mod base { # [doc = "Register `BASE` reader"]
pub struct R (crate :: R < BASE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BASE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BASE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BASE_SPEC >) -> Self { R (reader) } } # [doc = "MTB Base\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [base](index.html) module"]
pub struct BASE_SPEC ; impl crate :: RegisterSpec for BASE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [base::R](R) reader structure"]
impl crate :: Readable for BASE_SPEC { type Reader = R ; } # [doc = "`reset()` method sets BASE to value 0"]
impl crate :: Resettable for BASE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "ITCTRL register accessor: an alias for `Reg<ITCTRL_SPEC>`"]
pub type ITCTRL = crate :: Reg < itctrl :: ITCTRL_SPEC > ; # [doc = "MTB Integration Mode Control"]
pub mod itctrl { # [doc = "Register `ITCTRL` reader"]
pub struct R (crate :: R < ITCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ITCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ITCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ITCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `ITCTRL` writer"]
pub struct W (crate :: W < ITCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ITCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ITCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ITCTRL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MTB Integration Mode Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [itctrl](index.html) module"]
pub struct ITCTRL_SPEC ; impl crate :: RegisterSpec for ITCTRL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [itctrl::R](R) reader structure"]
impl crate :: Readable for ITCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [itctrl::W](W) writer structure"]
impl crate :: Writable for ITCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ITCTRL to value 0"]
impl crate :: Resettable for ITCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CLAIMSET register accessor: an alias for `Reg<CLAIMSET_SPEC>`"]
pub type CLAIMSET = crate :: Reg < claimset :: CLAIMSET_SPEC > ; # [doc = "MTB Claim Set"]
pub mod claimset { # [doc = "Register `CLAIMSET` reader"]
pub struct R (crate :: R < CLAIMSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CLAIMSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CLAIMSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CLAIMSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CLAIMSET` writer"]
pub struct W (crate :: W < CLAIMSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CLAIMSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CLAIMSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CLAIMSET_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MTB Claim Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [claimset](index.html) module"]
pub struct CLAIMSET_SPEC ; impl crate :: RegisterSpec for CLAIMSET_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [claimset::R](R) reader structure"]
impl crate :: Readable for CLAIMSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [claimset::W](W) writer structure"]
impl crate :: Writable for CLAIMSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CLAIMSET to value 0"]
impl crate :: Resettable for CLAIMSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CLAIMCLR register accessor: an alias for `Reg<CLAIMCLR_SPEC>`"]
pub type CLAIMCLR = crate :: Reg < claimclr :: CLAIMCLR_SPEC > ; # [doc = "MTB Claim Clear"]
pub mod claimclr { # [doc = "Register `CLAIMCLR` reader"]
pub struct R (crate :: R < CLAIMCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CLAIMCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CLAIMCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CLAIMCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CLAIMCLR` writer"]
pub struct W (crate :: W < CLAIMCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CLAIMCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CLAIMCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CLAIMCLR_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MTB Claim Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [claimclr](index.html) module"]
pub struct CLAIMCLR_SPEC ; impl crate :: RegisterSpec for CLAIMCLR_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [claimclr::R](R) reader structure"]
impl crate :: Readable for CLAIMCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [claimclr::W](W) writer structure"]
impl crate :: Writable for CLAIMCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CLAIMCLR to value 0"]
impl crate :: Resettable for CLAIMCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "LOCKACCESS register accessor: an alias for `Reg<LOCKACCESS_SPEC>`"]
pub type LOCKACCESS = crate :: Reg < lockaccess :: LOCKACCESS_SPEC > ; # [doc = "MTB Lock Access"]
pub mod lockaccess { # [doc = "Register `LOCKACCESS` reader"]
pub struct R (crate :: R < LOCKACCESS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LOCKACCESS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LOCKACCESS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LOCKACCESS_SPEC >) -> Self { R (reader) } } # [doc = "Register `LOCKACCESS` writer"]
pub struct W (crate :: W < LOCKACCESS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LOCKACCESS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LOCKACCESS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LOCKACCESS_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MTB Lock Access\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lockaccess](index.html) module"]
pub struct LOCKACCESS_SPEC ; impl crate :: RegisterSpec for LOCKACCESS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [lockaccess::R](R) reader structure"]
impl crate :: Readable for LOCKACCESS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lockaccess::W](W) writer structure"]
impl crate :: Writable for LOCKACCESS_SPEC { type Writer = W ; } # [doc = "`reset()` method sets LOCKACCESS to value 0"]
impl crate :: Resettable for LOCKACCESS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "LOCKSTATUS register accessor: an alias for `Reg<LOCKSTATUS_SPEC>`"]
pub type LOCKSTATUS = crate :: Reg < lockstatus :: LOCKSTATUS_SPEC > ; # [doc = "MTB Lock Status"]
pub mod lockstatus { # [doc = "Register `LOCKSTATUS` reader"]
pub struct R (crate :: R < LOCKSTATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LOCKSTATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LOCKSTATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LOCKSTATUS_SPEC >) -> Self { R (reader) } } # [doc = "MTB Lock Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lockstatus](index.html) module"]
pub struct LOCKSTATUS_SPEC ; impl crate :: RegisterSpec for LOCKSTATUS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [lockstatus::R](R) reader structure"]
impl crate :: Readable for LOCKSTATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets LOCKSTATUS to value 0"]
impl crate :: Resettable for LOCKSTATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "AUTHSTATUS register accessor: an alias for `Reg<AUTHSTATUS_SPEC>`"]
pub type AUTHSTATUS = crate :: Reg < authstatus :: AUTHSTATUS_SPEC > ; # [doc = "MTB Authentication Status"]
pub mod authstatus { # [doc = "Register `AUTHSTATUS` reader"]
pub struct R (crate :: R < AUTHSTATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < AUTHSTATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < AUTHSTATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < AUTHSTATUS_SPEC >) -> Self { R (reader) } } # [doc = "MTB Authentication Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [authstatus](index.html) module"]
pub struct AUTHSTATUS_SPEC ; impl crate :: RegisterSpec for AUTHSTATUS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [authstatus::R](R) reader structure"]
impl crate :: Readable for AUTHSTATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets AUTHSTATUS to value 0"]
impl crate :: Resettable for AUTHSTATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DEVARCH register accessor: an alias for `Reg<DEVARCH_SPEC>`"]
pub type DEVARCH = crate :: Reg < devarch :: DEVARCH_SPEC > ; # [doc = "MTB Device Architecture"]
pub mod devarch { # [doc = "Register `DEVARCH` reader"]
pub struct R (crate :: R < DEVARCH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DEVARCH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DEVARCH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DEVARCH_SPEC >) -> Self { R (reader) } } # [doc = "MTB Device Architecture\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [devarch](index.html) module"]
pub struct DEVARCH_SPEC ; impl crate :: RegisterSpec for DEVARCH_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [devarch::R](R) reader structure"]
impl crate :: Readable for DEVARCH_SPEC { type Reader = R ; } # [doc = "`reset()` method sets DEVARCH to value 0"]
impl crate :: Resettable for DEVARCH_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DEVID register accessor: an alias for `Reg<DEVID_SPEC>`"]
pub type DEVID = crate :: Reg < devid :: DEVID_SPEC > ; # [doc = "MTB Device Configuration"]
pub mod devid { # [doc = "Register `DEVID` reader"]
pub struct R (crate :: R < DEVID_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DEVID_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DEVID_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DEVID_SPEC >) -> Self { R (reader) } } # [doc = "MTB Device Configuration\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [devid](index.html) module"]
pub struct DEVID_SPEC ; impl crate :: RegisterSpec for DEVID_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [devid::R](R) reader structure"]
impl crate :: Readable for DEVID_SPEC { type Reader = R ; } # [doc = "`reset()` method sets DEVID to value 0"]
impl crate :: Resettable for DEVID_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DEVTYPE register accessor: an alias for `Reg<DEVTYPE_SPEC>`"]
pub type DEVTYPE = crate :: Reg < devtype :: DEVTYPE_SPEC > ; # [doc = "MTB Device Type"]
pub mod devtype { # [doc = "Register `DEVTYPE` reader"]
pub struct R (crate :: R < DEVTYPE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DEVTYPE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DEVTYPE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DEVTYPE_SPEC >) -> Self { R (reader) } } # [doc = "MTB Device Type\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [devtype](index.html) module"]
pub struct DEVTYPE_SPEC ; impl crate :: RegisterSpec for DEVTYPE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [devtype::R](R) reader structure"]
impl crate :: Readable for DEVTYPE_SPEC { type Reader = R ; } # [doc = "`reset()` method sets DEVTYPE to value 0"]
impl crate :: Resettable for DEVTYPE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PID4 register accessor: an alias for `Reg<PID4_SPEC>`"]
pub type PID4 = crate :: Reg < pid4 :: PID4_SPEC > ; # [doc = "CoreSight"]
pub mod pid4 { # [doc = "Register `PID4` reader"]
pub struct R (crate :: R < PID4_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PID4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PID4_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PID4_SPEC >) -> Self { R (reader) } } # [doc = "CoreSight\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pid4](index.html) module"]
pub struct PID4_SPEC ; impl crate :: RegisterSpec for PID4_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [pid4::R](R) reader structure"]
impl crate :: Readable for PID4_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PID4 to value 0"]
impl crate :: Resettable for PID4_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PID5 register accessor: an alias for `Reg<PID5_SPEC>`"]
pub type PID5 = crate :: Reg < pid5 :: PID5_SPEC > ; # [doc = "CoreSight"]
pub mod pid5 { # [doc = "Register `PID5` reader"]
pub struct R (crate :: R < PID5_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PID5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PID5_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PID5_SPEC >) -> Self { R (reader) } } # [doc = "CoreSight\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pid5](index.html) module"]
pub struct PID5_SPEC ; impl crate :: RegisterSpec for PID5_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [pid5::R](R) reader structure"]
impl crate :: Readable for PID5_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PID5 to value 0"]
impl crate :: Resettable for PID5_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PID6 register accessor: an alias for `Reg<PID6_SPEC>`"]
pub type PID6 = crate :: Reg < pid6 :: PID6_SPEC > ; # [doc = "CoreSight"]
pub mod pid6 { # [doc = "Register `PID6` reader"]
pub struct R (crate :: R < PID6_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PID6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PID6_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PID6_SPEC >) -> Self { R (reader) } } # [doc = "CoreSight\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pid6](index.html) module"]
pub struct PID6_SPEC ; impl crate :: RegisterSpec for PID6_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [pid6::R](R) reader structure"]
impl crate :: Readable for PID6_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PID6 to value 0"]
impl crate :: Resettable for PID6_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PID7 register accessor: an alias for `Reg<PID7_SPEC>`"]
pub type PID7 = crate :: Reg < pid7 :: PID7_SPEC > ; # [doc = "CoreSight"]
pub mod pid7 { # [doc = "Register `PID7` reader"]
pub struct R (crate :: R < PID7_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PID7_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PID7_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PID7_SPEC >) -> Self { R (reader) } } # [doc = "CoreSight\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pid7](index.html) module"]
pub struct PID7_SPEC ; impl crate :: RegisterSpec for PID7_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [pid7::R](R) reader structure"]
impl crate :: Readable for PID7_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PID7 to value 0"]
impl crate :: Resettable for PID7_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PID0 register accessor: an alias for `Reg<PID0_SPEC>`"]
pub type PID0 = crate :: Reg < pid0 :: PID0_SPEC > ; # [doc = "CoreSight"]
pub mod pid0 { # [doc = "Register `PID0` reader"]
pub struct R (crate :: R < PID0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PID0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PID0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PID0_SPEC >) -> Self { R (reader) } } # [doc = "CoreSight\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pid0](index.html) module"]
pub struct PID0_SPEC ; impl crate :: RegisterSpec for PID0_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [pid0::R](R) reader structure"]
impl crate :: Readable for PID0_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PID0 to value 0"]
impl crate :: Resettable for PID0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PID1 register accessor: an alias for `Reg<PID1_SPEC>`"]
pub type PID1 = crate :: Reg < pid1 :: PID1_SPEC > ; # [doc = "CoreSight"]
pub mod pid1 { # [doc = "Register `PID1` reader"]
pub struct R (crate :: R < PID1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PID1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PID1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PID1_SPEC >) -> Self { R (reader) } } # [doc = "CoreSight\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pid1](index.html) module"]
pub struct PID1_SPEC ; impl crate :: RegisterSpec for PID1_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [pid1::R](R) reader structure"]
impl crate :: Readable for PID1_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PID1 to value 0"]
impl crate :: Resettable for PID1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PID2 register accessor: an alias for `Reg<PID2_SPEC>`"]
pub type PID2 = crate :: Reg < pid2 :: PID2_SPEC > ; # [doc = "CoreSight"]
pub mod pid2 { # [doc = "Register `PID2` reader"]
pub struct R (crate :: R < PID2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PID2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PID2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PID2_SPEC >) -> Self { R (reader) } } # [doc = "CoreSight\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pid2](index.html) module"]
pub struct PID2_SPEC ; impl crate :: RegisterSpec for PID2_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [pid2::R](R) reader structure"]
impl crate :: Readable for PID2_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PID2 to value 0"]
impl crate :: Resettable for PID2_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PID3 register accessor: an alias for `Reg<PID3_SPEC>`"]
pub type PID3 = crate :: Reg < pid3 :: PID3_SPEC > ; # [doc = "CoreSight"]
pub mod pid3 { # [doc = "Register `PID3` reader"]
pub struct R (crate :: R < PID3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PID3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PID3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PID3_SPEC >) -> Self { R (reader) } } # [doc = "CoreSight\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pid3](index.html) module"]
pub struct PID3_SPEC ; impl crate :: RegisterSpec for PID3_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [pid3::R](R) reader structure"]
impl crate :: Readable for PID3_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PID3 to value 0"]
impl crate :: Resettable for PID3_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CID0 register accessor: an alias for `Reg<CID0_SPEC>`"]
pub type CID0 = crate :: Reg < cid0 :: CID0_SPEC > ; # [doc = "CoreSight"]
pub mod cid0 { # [doc = "Register `CID0` reader"]
pub struct R (crate :: R < CID0_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CID0_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CID0_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CID0_SPEC >) -> Self { R (reader) } } # [doc = "CoreSight\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cid0](index.html) module"]
pub struct CID0_SPEC ; impl crate :: RegisterSpec for CID0_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [cid0::R](R) reader structure"]
impl crate :: Readable for CID0_SPEC { type Reader = R ; } # [doc = "`reset()` method sets CID0 to value 0"]
impl crate :: Resettable for CID0_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CID1 register accessor: an alias for `Reg<CID1_SPEC>`"]
pub type CID1 = crate :: Reg < cid1 :: CID1_SPEC > ; # [doc = "CoreSight"]
pub mod cid1 { # [doc = "Register `CID1` reader"]
pub struct R (crate :: R < CID1_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CID1_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CID1_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CID1_SPEC >) -> Self { R (reader) } } # [doc = "CoreSight\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cid1](index.html) module"]
pub struct CID1_SPEC ; impl crate :: RegisterSpec for CID1_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [cid1::R](R) reader structure"]
impl crate :: Readable for CID1_SPEC { type Reader = R ; } # [doc = "`reset()` method sets CID1 to value 0"]
impl crate :: Resettable for CID1_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CID2 register accessor: an alias for `Reg<CID2_SPEC>`"]
pub type CID2 = crate :: Reg < cid2 :: CID2_SPEC > ; # [doc = "CoreSight"]
pub mod cid2 { # [doc = "Register `CID2` reader"]
pub struct R (crate :: R < CID2_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CID2_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CID2_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CID2_SPEC >) -> Self { R (reader) } } # [doc = "CoreSight\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cid2](index.html) module"]
pub struct CID2_SPEC ; impl crate :: RegisterSpec for CID2_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [cid2::R](R) reader structure"]
impl crate :: Readable for CID2_SPEC { type Reader = R ; } # [doc = "`reset()` method sets CID2 to value 0"]
impl crate :: Resettable for CID2_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CID3 register accessor: an alias for `Reg<CID3_SPEC>`"]
pub type CID3 = crate :: Reg < cid3 :: CID3_SPEC > ; # [doc = "CoreSight"]
pub mod cid3 { # [doc = "Register `CID3` reader"]
pub struct R (crate :: R < CID3_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CID3_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CID3_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CID3_SPEC >) -> Self { R (reader) } } # [doc = "CoreSight\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cid3](index.html) module"]
pub struct CID3_SPEC ; impl crate :: RegisterSpec for CID3_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [cid3::R](R) reader structure"]
impl crate :: Readable for CID3_SPEC { type Reader = R ; } # [doc = "`reset()` method sets CID3 to value 0"]
impl crate :: Resettable for CID3_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "Non-Volatile Memory Controller"]
pub struct NVMCTRL { _marker : PhantomData < * const () > } unsafe impl Send for NVMCTRL { } impl NVMCTRL { # [doc = r"Pointer to the register block"]
pub const PTR : * const nvmctrl :: RegisterBlock = 0x4100_4000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const nvmctrl :: RegisterBlock { Self :: PTR } } impl Deref for NVMCTRL { type Target = nvmctrl :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for NVMCTRL { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("NVMCTRL") . finish () } } # [doc = "Non-Volatile Memory Controller"]
pub mod nvmctrl { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : crate :: Reg < ctrla :: CTRLA_SPEC > , _reserved1 : [u8 ; 0x02]
, # [doc = "0x04 - Control B"]
pub ctrlb : crate :: Reg < ctrlb :: CTRLB_SPEC > , # [doc = "0x08 - NVM Parameter"]
pub param : crate :: Reg < param :: PARAM_SPEC > , # [doc = "0x0c - Interrupt Enable Clear"]
pub intenclr : crate :: Reg < intenclr :: INTENCLR_SPEC > , _reserved4 : [u8 ; 0x03]
, # [doc = "0x10 - Interrupt Enable Set"]
pub intenset : crate :: Reg < intenset :: INTENSET_SPEC > , _reserved5 : [u8 ; 0x03]
, # [doc = "0x14 - Interrupt Flag Status and Clear"]
pub intflag : crate :: Reg < intflag :: INTFLAG_SPEC > , _reserved6 : [u8 ; 0x03]
, # [doc = "0x18 - Status"]
pub status : crate :: Reg < status :: STATUS_SPEC > , _reserved7 : [u8 ; 0x02]
, # [doc = "0x1c - Address"]
pub addr : crate :: Reg < addr :: ADDR_SPEC > , # [doc = "0x20 - Lock Section"]
pub lock : crate :: Reg < lock :: LOCK_SPEC > , } # [doc = "CTRLA register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "2: Erase Row - Erases the row addressed by the ADDR register."]
ER = 2 , # [doc = "4: Write Page - Writes the contents of the page buffer to the page addressed by the ADDR register."]
WP = 4 , # [doc = "5: Erase Auxiliary Row - Erases the auxiliary row addressed by the ADDR register. This command can be given only when the security bit is not set and only to the user configuration row."]
EAR = 5 , # [doc = "6: Write Auxiliary Page - Writes the contents of the page buffer to the page addressed by the ADDR register. This command can be given only when the security bit is not set and only to the user configuration row."]
WAP = 6 , # [doc = "10: Security Flow Command"]
SF = 10 , # [doc = "15: Write lockbits"]
WL = 15 , # [doc = "26: RWW EEPROM area Erase Row - Erases the row addressed by the ADDR register."]
RWWEEER = 26 , # [doc = "28: RWW EEPROM Write Page - Writes the contents of the page buffer to the page addressed by the ADDR register."]
RWWEEWP = 28 , # [doc = "64: Lock Region - Locks the region containing the address location in the ADDR register."]
LR = 64 , # [doc = "65: Unlock Region - Unlocks the region containing the address location in the ADDR register."]
UR = 65 , # [doc = "66: Sets the power reduction mode."]
SPRM = 66 , # [doc = "67: Clears the power reduction mode."]
CPRM = 67 , # [doc = "68: Page Buffer Clear - Clears the page buffer."]
PBC = 68 , # [doc = "69: Set Security Bit - Sets the security bit by writing 0x00 to the first byte in the lockbit row."]
SSB = 69 , # [doc = "70: Invalidate all cache lines."]
INVALL = 70 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CMD_A > { match self . bits { 2 => Some (CMD_A :: ER) , 4 => Some (CMD_A :: WP) , 5 => Some (CMD_A :: EAR) , 6 => Some (CMD_A :: WAP) , 10 => Some (CMD_A :: SF) , 15 => Some (CMD_A :: WL) , 26 => Some (CMD_A :: RWWEEER) , 28 => Some (CMD_A :: RWWEEWP) , 64 => Some (CMD_A :: LR) , 65 => Some (CMD_A :: UR) , 66 => Some (CMD_A :: SPRM) , 67 => Some (CMD_A :: CPRM) , 68 => Some (CMD_A :: PBC) , 69 => Some (CMD_A :: SSB) , 70 => Some (CMD_A :: INVALL) , _ => None , } } # [doc = "Checks if the value of the field is `ER`"]
# [inline (always)]
pub fn is_er (& self) -> bool { * self == CMD_A :: ER } # [doc = "Checks if the value of the field is `WP`"]
# [inline (always)]
pub fn is_wp (& self) -> bool { * self == CMD_A :: WP } # [doc = "Checks if the value of the field is `EAR`"]
# [inline (always)]
pub fn is_ear (& self) -> bool { * self == CMD_A :: EAR } # [doc = "Checks if the value of the field is `WAP`"]
# [inline (always)]
pub fn is_wap (& self) -> bool { * self == CMD_A :: WAP } # [doc = "Checks if the value of the field is `SF`"]
# [inline (always)]
pub fn is_sf (& self) -> bool { * self == CMD_A :: SF } # [doc = "Checks if the value of the field is `WL`"]
# [inline (always)]
pub fn is_wl (& self) -> bool { * self == CMD_A :: WL } # [doc = "Checks if the value of the field is `RWWEEER`"]
# [inline (always)]
pub fn is_rwweeer (& self) -> bool { * self == CMD_A :: RWWEEER } # [doc = "Checks if the value of the field is `RWWEEWP`"]
# [inline (always)]
pub fn is_rwweewp (& self) -> bool { * self == CMD_A :: RWWEEWP } # [doc = "Checks if the value of the field is `LR`"]
# [inline (always)]
pub fn is_lr (& self) -> bool { * self == CMD_A :: LR } # [doc = "Checks if the value of the field is `UR`"]
# [inline (always)]
pub fn is_ur (& self) -> bool { * self == CMD_A :: UR } # [doc = "Checks if the value of the field is `SPRM`"]
# [inline (always)]
pub fn is_sprm (& self) -> bool { * self == CMD_A :: SPRM } # [doc = "Checks if the value of the field is `CPRM`"]
# [inline (always)]
pub fn is_cprm (& self) -> bool { * self == CMD_A :: CPRM } # [doc = "Checks if the value of the field is `PBC`"]
# [inline (always)]
pub fn is_pbc (& self) -> bool { * self == CMD_A :: PBC } # [doc = "Checks if the value of the field is `SSB`"]
# [inline (always)]
pub fn is_ssb (& self) -> bool { * self == CMD_A :: SSB } # [doc = "Checks if the value of the field is `INVALL`"]
# [inline (always)]
pub fn is_invall (& self) -> bool { * self == CMD_A :: INVALL } } # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a > = crate :: FieldWriter < 'a , u16 , CTRLA_SPEC , u8 , CMD_A , 7 , 0 > ; impl < 'a > CMD_W < 'a > { # [doc = "Erase Row - Erases the row addressed by the ADDR register."]
# [inline (always)]
pub fn er (self) -> & 'a mut W { self . variant (CMD_A :: ER) } # [doc = "Write Page - Writes the contents of the page buffer to the page addressed by the ADDR register."]
# [inline (always)]
pub fn wp (self) -> & 'a mut W { self . variant (CMD_A :: WP) } # [doc = "Erase Auxiliary Row - Erases the auxiliary row addressed by the ADDR register. This command can be given only when the security bit is not set and only to the user configuration row."]
# [inline (always)]
pub fn ear (self) -> & 'a mut W { self . variant (CMD_A :: EAR) } # [doc = "Write Auxiliary Page - Writes the contents of the page buffer to the page addressed by the ADDR register. This command can be given only when the security bit is not set and only to the user configuration row."]
# [inline (always)]
pub fn wap (self) -> & 'a mut W { self . variant (CMD_A :: WAP) } # [doc = "Security Flow Command"]
# [inline (always)]
pub fn sf (self) -> & 'a mut W { self . variant (CMD_A :: SF) } # [doc = "Write lockbits"]
# [inline (always)]
pub fn wl (self) -> & 'a mut W { self . variant (CMD_A :: WL) } # [doc = "RWW EEPROM area Erase Row - Erases the row addressed by the ADDR register."]
# [inline (always)]
pub fn rwweeer (self) -> & 'a mut W { self . variant (CMD_A :: RWWEEER) } # [doc = "RWW EEPROM Write Page - Writes the contents of the page buffer to the page addressed by the ADDR register."]
# [inline (always)]
pub fn rwweewp (self) -> & 'a mut W { self . variant (CMD_A :: RWWEEWP) } # [doc = "Lock Region - Locks the region containing the address location in the ADDR register."]
# [inline (always)]
pub fn lr (self) -> & 'a mut W { self . variant (CMD_A :: LR) } # [doc = "Unlock Region - Unlocks the region containing the address location in the ADDR register."]
# [inline (always)]
pub fn ur (self) -> & 'a mut W { self . variant (CMD_A :: UR) } # [doc = "Sets the power reduction mode."]
# [inline (always)]
pub fn sprm (self) -> & 'a mut W { self . variant (CMD_A :: SPRM) } # [doc = "Clears the power reduction mode."]
# [inline (always)]
pub fn cprm (self) -> & 'a mut W { self . variant (CMD_A :: CPRM) } # [doc = "Page Buffer Clear - Clears the page buffer."]
# [inline (always)]
pub fn pbc (self) -> & 'a mut W { self . variant (CMD_A :: PBC) } # [doc = "Set Security Bit - Sets the security bit by writing 0x00 to the first byte in the lockbit row."]
# [inline (always)]
pub fn ssb (self) -> & 'a mut W { self . variant (CMD_A :: SSB) } # [doc = "Invalidate all cache lines."]
# [inline (always)]
pub fn invall (self) -> & 'a mut W { self . variant (CMD_A :: INVALL) } } # [doc = "Command Execution\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CMDEX_A { # [doc = "165: Execution Key"]
KEY = 165 , } impl From < CMDEX_A > for u8 { # [inline (always)]
fn from (variant : CMDEX_A) -> Self { variant as _ } } # [doc = "Field `CMDEX` reader - Command Execution"]
pub type CMDEX_R = crate :: FieldReader < u8 , CMDEX_A > ; impl CMDEX_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CMDEX_A > { match self . bits { 165 => Some (CMDEX_A :: KEY) , _ => None , } } # [doc = "Checks if the value of the field is `KEY`"]
# [inline (always)]
pub fn is_key (& self) -> bool { * self == CMDEX_A :: KEY } } # [doc = "Field `CMDEX` writer - Command Execution"]
pub type CMDEX_W < 'a > = crate :: FieldWriter < 'a , u16 , CTRLA_SPEC , u8 , CMDEX_A , 8 , 8 > ; impl < 'a > CMDEX_W < 'a > { # [doc = "Execution Key"]
# [inline (always)]
pub fn key (self) -> & 'a mut W { self . variant (CMDEX_A :: KEY) } } impl R { # [doc = "Bits 0:6 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new ((self . bits & 0x7f) as u8) } # [doc = "Bits 8:15 - Command Execution"]
# [inline (always)]
pub fn cmdex (& self) -> CMDEX_R { CMDEX_R :: new (((self . bits >> 8) & 0xff) as u8) } } impl W { # [doc = "Bits 0:6 - Command"]
# [inline (always)]
pub fn cmd (& mut self) -> CMD_W { CMD_W :: new (self) } # [doc = "Bits 8:15 - Command Execution"]
# [inline (always)]
pub fn cmdex (& mut self) -> CMDEX_W { CMDEX_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CTRLB register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "NVM Read Wait States\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum RWS_A { # [doc = "0: Single Auto Wait State"]
SINGLE = 0 , # [doc = "1: Half Auto Wait State"]
HALF = 1 , # [doc = "2: Dual Auto Wait State"]
DUAL = 2 , } impl From < RWS_A > for u8 { # [inline (always)]
fn from (variant : RWS_A) -> Self { variant as _ } } # [doc = "Field `RWS` reader - NVM Read Wait States"]
pub type RWS_R = crate :: FieldReader < u8 , RWS_A > ; impl RWS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < RWS_A > { match self . bits { 0 => Some (RWS_A :: SINGLE) , 1 => Some (RWS_A :: HALF) , 2 => Some (RWS_A :: DUAL) , _ => None , } } # [doc = "Checks if the value of the field is `SINGLE`"]
# [inline (always)]
pub fn is_single (& self) -> bool { * self == RWS_A :: SINGLE } # [doc = "Checks if the value of the field is `HALF`"]
# [inline (always)]
pub fn is_half (& self) -> bool { * self == RWS_A :: HALF } # [doc = "Checks if the value of the field is `DUAL`"]
# [inline (always)]
pub fn is_dual (& self) -> bool { * self == RWS_A :: DUAL } } # [doc = "Field `RWS` writer - NVM Read Wait States"]
pub type RWS_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLB_SPEC , u8 , RWS_A , 4 , 1 > ; impl < 'a > RWS_W < 'a > { # [doc = "Single Auto Wait State"]
# [inline (always)]
pub fn single (self) -> & 'a mut W { self . variant (RWS_A :: SINGLE) } # [doc = "Half Auto Wait State"]
# [inline (always)]
pub fn half (self) -> & 'a mut W { self . variant (RWS_A :: HALF) } # [doc = "Dual Auto Wait State"]
# [inline (always)]
pub fn dual (self) -> & 'a mut W { self . variant (RWS_A :: DUAL) } } # [doc = "Field `MANW` reader - Manual Write"]
pub type MANW_R = crate :: BitReader < bool > ; # [doc = "Field `MANW` writer - Manual Write"]
pub type MANW_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLB_SPEC , bool , 7 > ; # [doc = "Power Reduction Mode during Sleep\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum SLEEPPRM_A { # [doc = "0: NVM block enters low-power mode when entering sleep.NVM block exits low-power mode upon first access."]
WAKEONACCESS = 0 , # [doc = "1: NVM block enters low-power mode when entering sleep.NVM block exits low-power mode when exiting sleep."]
WAKEUPINSTANT = 1 , # [doc = "3: Auto power reduction disabled."]
DISABLED = 3 , } impl From < SLEEPPRM_A > for u8 { # [inline (always)]
fn from (variant : SLEEPPRM_A) -> Self { variant as _ } } # [doc = "Field `SLEEPPRM` reader - Power Reduction Mode during Sleep"]
pub type SLEEPPRM_R = crate :: FieldReader < u8 , SLEEPPRM_A > ; impl SLEEPPRM_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SLEEPPRM_A > { match self . bits { 0 => Some (SLEEPPRM_A :: WAKEONACCESS) , 1 => Some (SLEEPPRM_A :: WAKEUPINSTANT) , 3 => Some (SLEEPPRM_A :: DISABLED) , _ => None , } } # [doc = "Checks if the value of the field is `WAKEONACCESS`"]
# [inline (always)]
pub fn is_wakeonaccess (& self) -> bool { * self == SLEEPPRM_A :: WAKEONACCESS } # [doc = "Checks if the value of the field is `WAKEUPINSTANT`"]
# [inline (always)]
pub fn is_wakeupinstant (& self) -> bool { * self == SLEEPPRM_A :: WAKEUPINSTANT } # [doc = "Checks if the value of the field is `DISABLED`"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == SLEEPPRM_A :: DISABLED } } # [doc = "Field `SLEEPPRM` writer - Power Reduction Mode during Sleep"]
pub type SLEEPPRM_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLB_SPEC , u8 , SLEEPPRM_A , 2 , 8 > ; impl < 'a > SLEEPPRM_W < 'a > { # [doc = "NVM block enters low-power mode when entering sleep.NVM block exits low-power mode upon first access."]
# [inline (always)]
pub fn wakeonaccess (self) -> & 'a mut W { self . variant (SLEEPPRM_A :: WAKEONACCESS) } # [doc = "NVM block enters low-power mode when entering sleep.NVM block exits low-power mode when exiting sleep."]
# [inline (always)]
pub fn wakeupinstant (self) -> & 'a mut W { self . variant (SLEEPPRM_A :: WAKEUPINSTANT) } # [doc = "Auto power reduction disabled."]
# [inline (always)]
pub fn disabled (self) -> & 'a mut W { self . variant (SLEEPPRM_A :: DISABLED) } } # [doc = "NVMCTRL Read Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum READMODE_A { # [doc = "0: The NVM Controller (cache system) does not insert wait states on a cache miss. Gives the best system performance."]
NO_MISS_PENALTY = 0 , # [doc = "1: Reduces power consumption of the cache system, but inserts a wait state each time there is a cache miss. This mode may not be relevant if CPU performance is required, as the application will be stalled and may lead to increase run time."]
LOW_POWER = 1 , # [doc = "2: The cache system ensures that a cache hit or miss takes the same amount of time, determined by the number of programmed flash wait states. This mode can be used for real-time applications that require deterministic execution timings."]
DETERMINISTIC = 2 , } impl From < READMODE_A > for u8 { # [inline (always)]
fn from (variant : READMODE_A) -> Self { variant as _ } } # [doc = "Field `READMODE` reader - NVMCTRL Read Mode"]
pub type READMODE_R = crate :: FieldReader < u8 , READMODE_A > ; impl READMODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < READMODE_A > { match self . bits { 0 => Some (READMODE_A :: NO_MISS_PENALTY) , 1 => Some (READMODE_A :: LOW_POWER) , 2 => Some (READMODE_A :: DETERMINISTIC) , _ => None , } } # [doc = "Checks if the value of the field is `NO_MISS_PENALTY`"]
# [inline (always)]
pub fn is_no_miss_penalty (& self) -> bool { * self == READMODE_A :: NO_MISS_PENALTY } # [doc = "Checks if the value of the field is `LOW_POWER`"]
# [inline (always)]
pub fn is_low_power (& self) -> bool { * self == READMODE_A :: LOW_POWER } # [doc = "Checks if the value of the field is `DETERMINISTIC`"]
# [inline (always)]
pub fn is_deterministic (& self) -> bool { * self == READMODE_A :: DETERMINISTIC } } # [doc = "Field `READMODE` writer - NVMCTRL Read Mode"]
pub type READMODE_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLB_SPEC , u8 , READMODE_A , 2 , 16 > ; impl < 'a > READMODE_W < 'a > { # [doc = "The NVM Controller (cache system) does not insert wait states on a cache miss. Gives the best system performance."]
# [inline (always)]
pub fn no_miss_penalty (self) -> & 'a mut W { self . variant (READMODE_A :: NO_MISS_PENALTY) } # [doc = "Reduces power consumption of the cache system, but inserts a wait state each time there is a cache miss. This mode may not be relevant if CPU performance is required, as the application will be stalled and may lead to increase run time."]
# [inline (always)]
pub fn low_power (self) -> & 'a mut W { self . variant (READMODE_A :: LOW_POWER) } # [doc = "The cache system ensures that a cache hit or miss takes the same amount of time, determined by the number of programmed flash wait states. This mode can be used for real-time applications that require deterministic execution timings."]
# [inline (always)]
pub fn deterministic (self) -> & 'a mut W { self . variant (READMODE_A :: DETERMINISTIC) } } # [doc = "Field `CACHEDIS` reader - Cache Disable"]
pub type CACHEDIS_R = crate :: BitReader < bool > ; # [doc = "Field `CACHEDIS` writer - Cache Disable"]
pub type CACHEDIS_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLB_SPEC , bool , 18 > ; impl R { # [doc = "Bits 1:4 - NVM Read Wait States"]
# [inline (always)]
pub fn rws (& self) -> RWS_R { RWS_R :: new (((self . bits >> 1) & 0x0f) as u8) } # [doc = "Bit 7 - Manual Write"]
# [inline (always)]
pub fn manw (& self) -> MANW_R { MANW_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bits 8:9 - Power Reduction Mode during Sleep"]
# [inline (always)]
pub fn sleepprm (& self) -> SLEEPPRM_R { SLEEPPRM_R :: new (((self . bits >> 8) & 3) as u8) } # [doc = "Bits 16:17 - NVMCTRL Read Mode"]
# [inline (always)]
pub fn readmode (& self) -> READMODE_R { READMODE_R :: new (((self . bits >> 16) & 3) as u8) } # [doc = "Bit 18 - Cache Disable"]
# [inline (always)]
pub fn cachedis (& self) -> CACHEDIS_R { CACHEDIS_R :: new (((self . bits >> 18) & 1) != 0) } } impl W { # [doc = "Bits 1:4 - NVM Read Wait States"]
# [inline (always)]
pub fn rws (& mut self) -> RWS_W { RWS_W :: new (self) } # [doc = "Bit 7 - Manual Write"]
# [inline (always)]
pub fn manw (& mut self) -> MANW_W { MANW_W :: new (self) } # [doc = "Bits 8:9 - Power Reduction Mode during Sleep"]
# [inline (always)]
pub fn sleepprm (& mut self) -> SLEEPPRM_W { SLEEPPRM_W :: new (self) } # [doc = "Bits 16:17 - NVMCTRL Read Mode"]
# [inline (always)]
pub fn readmode (& mut self) -> READMODE_W { READMODE_W :: new (self) } # [doc = "Bit 18 - Cache Disable"]
# [inline (always)]
pub fn cachedis (& mut self) -> CACHEDIS_W { CACHEDIS_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PARAM register accessor: an alias for `Reg<PARAM_SPEC>`"]
pub type PARAM = crate :: Reg < param :: PARAM_SPEC > ; # [doc = "NVM Parameter"]
pub mod param { # [doc = "Register `PARAM` reader"]
pub struct R (crate :: R < PARAM_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PARAM_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PARAM_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PARAM_SPEC >) -> Self { R (reader) } } # [doc = "Register `PARAM` writer"]
pub struct W (crate :: W < PARAM_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PARAM_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PARAM_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PARAM_SPEC >) -> Self { W (writer) } } # [doc = "Field `NVMP` reader - NVM Pages"]
pub type NVMP_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Page Size\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum PSZ_A { # [doc = "0: 8 bytes"]
_8 = 0 , # [doc = "1: 16 bytes"]
_16 = 1 , # [doc = "2: 32 bytes"]
_32 = 2 , # [doc = "3: 64 bytes"]
_64 = 3 , # [doc = "4: 128 bytes"]
_128 = 4 , # [doc = "5: 256 bytes"]
_256 = 5 , # [doc = "6: 512 bytes"]
_512 = 6 , # [doc = "7: 1024 bytes"]
_1024 = 7 , } impl From < PSZ_A > for u8 { # [inline (always)]
fn from (variant : PSZ_A) -> Self { variant as _ } } # [doc = "Field `PSZ` reader - Page Size"]
pub type PSZ_R = crate :: FieldReader < u8 , PSZ_A > ; impl PSZ_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PSZ_A { match self . bits { 0 => PSZ_A :: _8 , 1 => PSZ_A :: _16 , 2 => PSZ_A :: _32 , 3 => PSZ_A :: _64 , 4 => PSZ_A :: _128 , 5 => PSZ_A :: _256 , 6 => PSZ_A :: _512 , 7 => PSZ_A :: _1024 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_8`"]
# [inline (always)]
pub fn is_8 (& self) -> bool { * self == PSZ_A :: _8 } # [doc = "Checks if the value of the field is `_16`"]
# [inline (always)]
pub fn is_16 (& self) -> bool { * self == PSZ_A :: _16 } # [doc = "Checks if the value of the field is `_32`"]
# [inline (always)]
pub fn is_32 (& self) -> bool { * self == PSZ_A :: _32 } # [doc = "Checks if the value of the field is `_64`"]
# [inline (always)]
pub fn is_64 (& self) -> bool { * self == PSZ_A :: _64 } # [doc = "Checks if the value of the field is `_128`"]
# [inline (always)]
pub fn is_128 (& self) -> bool { * self == PSZ_A :: _128 } # [doc = "Checks if the value of the field is `_256`"]
# [inline (always)]
pub fn is_256 (& self) -> bool { * self == PSZ_A :: _256 } # [doc = "Checks if the value of the field is `_512`"]
# [inline (always)]
pub fn is_512 (& self) -> bool { * self == PSZ_A :: _512 } # [doc = "Checks if the value of the field is `_1024`"]
# [inline (always)]
pub fn is_1024 (& self) -> bool { * self == PSZ_A :: _1024 } } # [doc = "Field `RWWEEP` reader - RWW EEPROM Pages"]
pub type RWWEEP_R = crate :: FieldReader < u16 , u16 > ; impl R { # [doc = "Bits 0:15 - NVM Pages"]
# [inline (always)]
pub fn nvmp (& self) -> NVMP_R { NVMP_R :: new ((self . bits & 0xffff) as u16) } # [doc = "Bits 16:18 - Page Size"]
# [inline (always)]
pub fn psz (& self) -> PSZ_R { PSZ_R :: new (((self . bits >> 16) & 7) as u8) } # [doc = "Bits 20:31 - RWW EEPROM Pages"]
# [inline (always)]
pub fn rwweep (& self) -> RWWEEP_R { RWWEEP_R :: new (((self . bits >> 20) & 0x0fff) as u16) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "NVM Parameter\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [param](index.html) module"]
pub struct PARAM_SPEC ; impl crate :: RegisterSpec for PARAM_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [param::R](R) reader structure"]
impl crate :: Readable for PARAM_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [param::W](W) writer structure"]
impl crate :: Writable for PARAM_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PARAM to value 0"]
impl crate :: Resettable for PARAM_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENCLR register accessor: an alias for `Reg<INTENCLR_SPEC>`"]
pub type INTENCLR = crate :: Reg < intenclr :: INTENCLR_SPEC > ; # [doc = "Interrupt Enable Clear"]
pub mod intenclr { # [doc = "Register `INTENCLR` reader"]
pub struct R (crate :: R < INTENCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENCLR` writer"]
pub struct W (crate :: W < INTENCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `READY` reader - NVM Ready Interrupt Enable"]
pub type READY_R = crate :: BitReader < bool > ; # [doc = "Field `READY` writer - NVM Ready Interrupt Enable"]
pub type READY_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 0 > ; # [doc = "Field `ERROR` reader - Error Interrupt Enable"]
pub type ERROR_R = crate :: BitReader < bool > ; # [doc = "Field `ERROR` writer - Error Interrupt Enable"]
pub type ERROR_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 1 > ; impl R { # [doc = "Bit 0 - NVM Ready Interrupt Enable"]
# [inline (always)]
pub fn ready (& self) -> READY_R { READY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Error Interrupt Enable"]
# [inline (always)]
pub fn error (& self) -> ERROR_R { ERROR_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - NVM Ready Interrupt Enable"]
# [inline (always)]
pub fn ready (& mut self) -> READY_W { READY_W :: new (self) } # [doc = "Bit 1 - Error Interrupt Enable"]
# [inline (always)]
pub fn error (& mut self) -> ERROR_W { ERROR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenclr](index.html) module"]
pub struct INTENCLR_SPEC ; impl crate :: RegisterSpec for INTENCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenclr::R](R) reader structure"]
impl crate :: Readable for INTENCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenclr::W](W) writer structure"]
impl crate :: Writable for INTENCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENCLR to value 0"]
impl crate :: Resettable for INTENCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENSET register accessor: an alias for `Reg<INTENSET_SPEC>`"]
pub type INTENSET = crate :: Reg < intenset :: INTENSET_SPEC > ; # [doc = "Interrupt Enable Set"]
pub mod intenset { # [doc = "Register `INTENSET` reader"]
pub struct R (crate :: R < INTENSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENSET` writer"]
pub struct W (crate :: W < INTENSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `READY` reader - NVM Ready Interrupt Enable"]
pub type READY_R = crate :: BitReader < bool > ; # [doc = "Field `READY` writer - NVM Ready Interrupt Enable"]
pub type READY_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 0 > ; # [doc = "Field `ERROR` reader - Error Interrupt Enable"]
pub type ERROR_R = crate :: BitReader < bool > ; # [doc = "Field `ERROR` writer - Error Interrupt Enable"]
pub type ERROR_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 1 > ; impl R { # [doc = "Bit 0 - NVM Ready Interrupt Enable"]
# [inline (always)]
pub fn ready (& self) -> READY_R { READY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Error Interrupt Enable"]
# [inline (always)]
pub fn error (& self) -> ERROR_R { ERROR_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - NVM Ready Interrupt Enable"]
# [inline (always)]
pub fn ready (& mut self) -> READY_W { READY_W :: new (self) } # [doc = "Bit 1 - Error Interrupt Enable"]
# [inline (always)]
pub fn error (& mut self) -> ERROR_W { ERROR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenset](index.html) module"]
pub struct INTENSET_SPEC ; impl crate :: RegisterSpec for INTENSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenset::R](R) reader structure"]
impl crate :: Readable for INTENSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenset::W](W) writer structure"]
impl crate :: Writable for INTENSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENSET to value 0"]
impl crate :: Resettable for INTENSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTFLAG register accessor: an alias for `Reg<INTFLAG_SPEC>`"]
pub type INTFLAG = crate :: Reg < intflag :: INTFLAG_SPEC > ; # [doc = "Interrupt Flag Status and Clear"]
pub mod intflag { # [doc = "Register `INTFLAG` reader"]
pub struct R (crate :: R < INTFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAG` writer"]
pub struct W (crate :: W < INTFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `READY` reader - NVM Ready"]
pub type READY_R = crate :: BitReader < bool > ; # [doc = "Field `READY` writer - NVM Ready"]
pub type READY_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 0 > ; # [doc = "Field `ERROR` reader - Error"]
pub type ERROR_R = crate :: BitReader < bool > ; # [doc = "Field `ERROR` writer - Error"]
pub type ERROR_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 1 > ; impl R { # [doc = "Bit 0 - NVM Ready"]
# [inline (always)]
pub fn ready (& self) -> READY_R { READY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Error"]
# [inline (always)]
pub fn error (& self) -> ERROR_R { ERROR_R :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - NVM Ready"]
# [inline (always)]
pub fn ready (& mut self) -> READY_W { READY_W :: new (self) } # [doc = "Bit 1 - Error"]
# [inline (always)]
pub fn error (& mut self) -> ERROR_W { ERROR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflag](index.html) module"]
pub struct INTFLAG_SPEC ; impl crate :: RegisterSpec for INTFLAG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflag::R](R) reader structure"]
impl crate :: Readable for INTFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflag::W](W) writer structure"]
impl crate :: Writable for INTFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTFLAG to value 0"]
impl crate :: Resettable for INTFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATUS register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `PRM` reader - Power Reduction Mode"]
pub type PRM_R = crate :: BitReader < bool > ; # [doc = "Field `LOAD` reader - NVM Page Buffer Active Loading"]
pub type LOAD_R = crate :: BitReader < bool > ; # [doc = "Field `LOAD` writer - NVM Page Buffer Active Loading"]
pub type LOAD_W < 'a > = crate :: BitWriter < 'a , u16 , STATUS_SPEC , bool , 1 > ; # [doc = "Field `PROGE` reader - Programming Error Status"]
pub type PROGE_R = crate :: BitReader < bool > ; # [doc = "Field `PROGE` writer - Programming Error Status"]
pub type PROGE_W < 'a > = crate :: BitWriter < 'a , u16 , STATUS_SPEC , bool , 2 > ; # [doc = "Field `LOCKE` reader - Lock Error Status"]
pub type LOCKE_R = crate :: BitReader < bool > ; # [doc = "Field `LOCKE` writer - Lock Error Status"]
pub type LOCKE_W < 'a > = crate :: BitWriter < 'a , u16 , STATUS_SPEC , bool , 3 > ; # [doc = "Field `NVME` reader - NVM Error"]
pub type NVME_R = crate :: BitReader < bool > ; # [doc = "Field `NVME` writer - NVM Error"]
pub type NVME_W < 'a > = crate :: BitWriter < 'a , u16 , STATUS_SPEC , bool , 4 > ; # [doc = "Field `SB` reader - Security Bit Status"]
pub type SB_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Power Reduction Mode"]
# [inline (always)]
pub fn prm (& self) -> PRM_R { PRM_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - NVM Page Buffer Active Loading"]
# [inline (always)]
pub fn load (& self) -> LOAD_R { LOAD_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Programming Error Status"]
# [inline (always)]
pub fn proge (& self) -> PROGE_R { PROGE_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Lock Error Status"]
# [inline (always)]
pub fn locke (& self) -> LOCKE_R { LOCKE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - NVM Error"]
# [inline (always)]
pub fn nvme (& self) -> NVME_R { NVME_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 8 - Security Bit Status"]
# [inline (always)]
pub fn sb (& self) -> SB_R { SB_R :: new (((self . bits >> 8) & 1) != 0) } } impl W { # [doc = "Bit 1 - NVM Page Buffer Active Loading"]
# [inline (always)]
pub fn load (& mut self) -> LOAD_W { LOAD_W :: new (self) } # [doc = "Bit 2 - Programming Error Status"]
# [inline (always)]
pub fn proge (& mut self) -> PROGE_W { PROGE_W :: new (self) } # [doc = "Bit 3 - Lock Error Status"]
# [inline (always)]
pub fn locke (& mut self) -> LOCKE_W { LOCKE_W :: new (self) } # [doc = "Bit 4 - NVM Error"]
# [inline (always)]
pub fn nvme (& mut self) -> NVME_W { NVME_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "ADDR register accessor: an alias for `Reg<ADDR_SPEC>`"]
pub type ADDR = crate :: Reg < addr :: ADDR_SPEC > ; # [doc = "Address"]
pub mod addr { # [doc = "Register `ADDR` reader"]
pub struct R (crate :: R < ADDR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADDR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADDR_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADDR` writer"]
pub struct W (crate :: W < ADDR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADDR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADDR_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADDR` reader - NVM Address"]
pub type ADDR_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `ADDR` writer - NVM Address"]
pub type ADDR_W < 'a > = crate :: FieldWriter < 'a , u32 , ADDR_SPEC , u32 , u32 , 22 , 0 > ; impl R { # [doc = "Bits 0:21 - NVM Address"]
# [inline (always)]
pub fn addr (& self) -> ADDR_R { ADDR_R :: new ((self . bits & 0x003f_ffff) as u32) } } impl W { # [doc = "Bits 0:21 - NVM Address"]
# [inline (always)]
pub fn addr (& mut self) -> ADDR_W { ADDR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [addr](index.html) module"]
pub struct ADDR_SPEC ; impl crate :: RegisterSpec for ADDR_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [addr::R](R) reader structure"]
impl crate :: Readable for ADDR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [addr::W](W) writer structure"]
impl crate :: Writable for ADDR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ADDR to value 0"]
impl crate :: Resettable for ADDR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "LOCK register accessor: an alias for `Reg<LOCK_SPEC>`"]
pub type LOCK = crate :: Reg < lock :: LOCK_SPEC > ; # [doc = "Lock Section"]
pub mod lock { # [doc = "Register `LOCK` reader"]
pub struct R (crate :: R < LOCK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < LOCK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < LOCK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < LOCK_SPEC >) -> Self { R (reader) } } # [doc = "Register `LOCK` writer"]
pub struct W (crate :: W < LOCK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < LOCK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < LOCK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < LOCK_SPEC >) -> Self { W (writer) } } # [doc = "Field `LOCK` reader - Region Lock Bits"]
pub type LOCK_R = crate :: FieldReader < u16 , u16 > ; impl R { # [doc = "Bits 0:15 - Region Lock Bits"]
# [inline (always)]
pub fn lock (& self) -> LOCK_R { LOCK_R :: new (self . bits) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Lock Section\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lock](index.html) module"]
pub struct LOCK_SPEC ; impl crate :: RegisterSpec for LOCK_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [lock::R](R) reader structure"]
impl crate :: Readable for LOCK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [lock::W](W) writer structure"]
impl crate :: Writable for LOCK_SPEC { type Writer = W ; } # [doc = "`reset()` method sets LOCK to value 0"]
impl crate :: Resettable for LOCK_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "Peripheral Access Controller 0"]
pub struct PAC0 { _marker : PhantomData < * const () > } unsafe impl Send for PAC0 { } impl PAC0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const pac0 :: RegisterBlock = 0x4000_0000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const pac0 :: RegisterBlock { Self :: PTR } } impl Deref for PAC0 { type Target = pac0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PAC0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PAC0") . finish () } } # [doc = "Peripheral Access Controller 0"]
pub mod pac0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Write Protection Clear"]
pub wpclr : crate :: Reg < wpclr :: WPCLR_SPEC > , # [doc = "0x04 - Write Protection Set"]
pub wpset : crate :: Reg < wpset :: WPSET_SPEC > , } # [doc = "WPCLR register accessor: an alias for `Reg<WPCLR_SPEC>`"]
pub type WPCLR = crate :: Reg < wpclr :: WPCLR_SPEC > ; # [doc = "Write Protection Clear"]
pub mod wpclr { # [doc = "Register `WPCLR` reader"]
pub struct R (crate :: R < WPCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < WPCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < WPCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < WPCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `WPCLR` writer"]
pub struct W (crate :: W < WPCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < WPCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < WPCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < WPCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `WP` reader - Write Protection Clear"]
pub type WP_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `WP` writer - Write Protection Clear"]
pub type WP_W < 'a > = crate :: FieldWriter < 'a , u32 , WPCLR_SPEC , u32 , u32 , 31 , 1 > ; impl R { # [doc = "Bits 1:31 - Write Protection Clear"]
# [inline (always)]
pub fn wp (& self) -> WP_R { WP_R :: new (((self . bits >> 1) & 0x7fff_ffff) as u32) } } impl W { # [doc = "Bits 1:31 - Write Protection Clear"]
# [inline (always)]
pub fn wp (& mut self) -> WP_W { WP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Write Protection Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [wpclr](index.html) module"]
pub struct WPCLR_SPEC ; impl crate :: RegisterSpec for WPCLR_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [wpclr::R](R) reader structure"]
impl crate :: Readable for WPCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [wpclr::W](W) writer structure"]
impl crate :: Writable for WPCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets WPCLR to value 0"]
impl crate :: Resettable for WPCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "WPSET register accessor: an alias for `Reg<WPSET_SPEC>`"]
pub type WPSET = crate :: Reg < wpset :: WPSET_SPEC > ; # [doc = "Write Protection Set"]
pub mod wpset { # [doc = "Register `WPSET` reader"]
pub struct R (crate :: R < WPSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < WPSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < WPSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < WPSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `WPSET` writer"]
pub struct W (crate :: W < WPSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < WPSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < WPSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < WPSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `WP` reader - Write Protection Set"]
pub type WP_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `WP` writer - Write Protection Set"]
pub type WP_W < 'a > = crate :: FieldWriter < 'a , u32 , WPSET_SPEC , u32 , u32 , 31 , 1 > ; impl R { # [doc = "Bits 1:31 - Write Protection Set"]
# [inline (always)]
pub fn wp (& self) -> WP_R { WP_R :: new (((self . bits >> 1) & 0x7fff_ffff) as u32) } } impl W { # [doc = "Bits 1:31 - Write Protection Set"]
# [inline (always)]
pub fn wp (& mut self) -> WP_W { WP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Write Protection Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [wpset](index.html) module"]
pub struct WPSET_SPEC ; impl crate :: RegisterSpec for WPSET_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [wpset::R](R) reader structure"]
impl crate :: Readable for WPSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [wpset::W](W) writer structure"]
impl crate :: Writable for WPSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets WPSET to value 0"]
impl crate :: Resettable for WPSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "Peripheral Access Controller 1"]
pub struct PAC1 { _marker : PhantomData < * const () > } unsafe impl Send for PAC1 { } impl PAC1 { # [doc = r"Pointer to the register block"]
pub const PTR : * const pac0 :: RegisterBlock = 0x4100_0000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const pac0 :: RegisterBlock { Self :: PTR } } impl Deref for PAC1 { type Target = pac0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PAC1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PAC1") . finish () } } # [doc = "Peripheral Access Controller 1"]
pub use pac0 as pac1 ; # [doc = "Peripheral Access Controller 2"]
pub struct PAC2 { _marker : PhantomData < * const () > } unsafe impl Send for PAC2 { } impl PAC2 { # [doc = r"Pointer to the register block"]
pub const PTR : * const pac0 :: RegisterBlock = 0x4200_0000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const pac0 :: RegisterBlock { Self :: PTR } } impl Deref for PAC2 { type Target = pac0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PAC2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PAC2") . finish () } } # [doc = "Peripheral Access Controller 2"]
pub use pac0 as pac2 ; # [doc = "Power Manager"]
pub struct PM { _marker : PhantomData < * const () > } unsafe impl Send for PM { } impl PM { # [doc = r"Pointer to the register block"]
pub const PTR : * const pm :: RegisterBlock = 0x4000_0400 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const pm :: RegisterBlock { Self :: PTR } } impl Deref for PM { type Target = pm :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PM { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PM") . finish () } } # [doc = "Power Manager"]
pub mod pm { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control"]
pub ctrl : crate :: Reg < ctrl :: CTRL_SPEC > , # [doc = "0x01 - Sleep Mode"]
pub sleep : crate :: Reg < sleep :: SLEEP_SPEC > , # [doc = "0x02 - External Reset Controller"]
pub extctrl : crate :: Reg < extctrl :: EXTCTRL_SPEC > , _reserved3 : [u8 ; 0x05]
, # [doc = "0x08 - CPU Clock Select"]
pub cpusel : crate :: Reg < cpusel :: CPUSEL_SPEC > , # [doc = "0x09 - APBA Clock Select"]
pub apbasel : crate :: Reg < apbasel :: APBASEL_SPEC > , # [doc = "0x0a - APBB Clock Select"]
pub apbbsel : crate :: Reg < apbbsel :: APBBSEL_SPEC > , # [doc = "0x0b - APBC Clock Select"]
pub apbcsel : crate :: Reg < apbcsel :: APBCSEL_SPEC > , _reserved7 : [u8 ; 0x08]
, # [doc = "0x14 - AHB Mask"]
pub ahbmask : crate :: Reg < ahbmask :: AHBMASK_SPEC > , # [doc = "0x18 - APBA Mask"]
pub apbamask : crate :: Reg < apbamask :: APBAMASK_SPEC > , # [doc = "0x1c - APBB Mask"]
pub apbbmask : crate :: Reg < apbbmask :: APBBMASK_SPEC > , # [doc = "0x20 - APBC Mask"]
pub apbcmask : crate :: Reg < apbcmask :: APBCMASK_SPEC > , _reserved11 : [u8 ; 0x10]
, # [doc = "0x34 - Interrupt Enable Clear"]
pub intenclr : crate :: Reg < intenclr :: INTENCLR_SPEC > , # [doc = "0x35 - Interrupt Enable Set"]
pub intenset : crate :: Reg < intenset :: INTENSET_SPEC > , # [doc = "0x36 - Interrupt Flag Status and Clear"]
pub intflag : crate :: Reg < intflag :: INTFLAG_SPEC > , _reserved14 : [u8 ; 0x01]
, # [doc = "0x38 - Reset Cause"]
pub rcause : crate :: Reg < rcause :: RCAUSE_SPEC > , } # [doc = "CTRL register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SLEEP register accessor: an alias for `Reg<SLEEP_SPEC>`"]
pub type SLEEP = crate :: Reg < sleep :: SLEEP_SPEC > ; # [doc = "Sleep Mode"]
pub mod sleep { # [doc = "Register `SLEEP` reader"]
pub struct R (crate :: R < SLEEP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SLEEP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SLEEP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SLEEP_SPEC >) -> Self { R (reader) } } # [doc = "Register `SLEEP` writer"]
pub struct W (crate :: W < SLEEP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < SLEEP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < SLEEP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < SLEEP_SPEC >) -> Self { W (writer) } } # [doc = "Idle Mode Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum IDLE_A { # [doc = "0: The CPU clock domain is stopped"]
CPU = 0 , # [doc = "1: The CPU and AHB clock domains are stopped"]
AHB = 1 , # [doc = "2: The CPU, AHB and APB clock domains are stopped"]
APB = 2 , } impl From < IDLE_A > for u8 { # [inline (always)]
fn from (variant : IDLE_A) -> Self { variant as _ } } # [doc = "Field `IDLE` reader - Idle Mode Configuration"]
pub type IDLE_R = crate :: FieldReader < u8 , IDLE_A > ; impl IDLE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < IDLE_A > { match self . bits { 0 => Some (IDLE_A :: CPU) , 1 => Some (IDLE_A :: AHB) , 2 => Some (IDLE_A :: APB) , _ => None , } } # [doc = "Checks if the value of the field is `CPU`"]
# [inline (always)]
pub fn is_cpu (& self) -> bool { * self == IDLE_A :: CPU } # [doc = "Checks if the value of the field is `AHB`"]
# [inline (always)]
pub fn is_ahb (& self) -> bool { * self == IDLE_A :: AHB } # [doc = "Checks if the value of the field is `APB`"]
# [inline (always)]
pub fn is_apb (& self) -> bool { * self == IDLE_A :: APB } } # [doc = "Field `IDLE` writer - Idle Mode Configuration"]
pub type IDLE_W < 'a > = crate :: FieldWriter < 'a , u8 , SLEEP_SPEC , u8 , IDLE_A , 2 , 0 > ; impl < 'a > IDLE_W < 'a > { # [doc = "The CPU clock domain is stopped"]
# [inline (always)]
pub fn cpu (self) -> & 'a mut W { self . variant (IDLE_A :: CPU) } # [doc = "The CPU and AHB clock domains are stopped"]
# [inline (always)]
pub fn ahb (self) -> & 'a mut W { self . variant (IDLE_A :: AHB) } # [doc = "The CPU, AHB and APB clock domains are stopped"]
# [inline (always)]
pub fn apb (self) -> & 'a mut W { self . variant (IDLE_A :: APB) } } impl R { # [doc = "Bits 0:1 - Idle Mode Configuration"]
# [inline (always)]
pub fn idle (& self) -> IDLE_R { IDLE_R :: new ((self . bits & 3) as u8) } } impl W { # [doc = "Bits 0:1 - Idle Mode Configuration"]
# [inline (always)]
pub fn idle (& mut self) -> IDLE_W { IDLE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Sleep Mode\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sleep](index.html) module"]
pub struct SLEEP_SPEC ; impl crate :: RegisterSpec for SLEEP_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [sleep::R](R) reader structure"]
impl crate :: Readable for SLEEP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [sleep::W](W) writer structure"]
impl crate :: Writable for SLEEP_SPEC { type Writer = W ; } # [doc = "`reset()` method sets SLEEP to value 0"]
impl crate :: Resettable for SLEEP_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "EXTCTRL register accessor: an alias for `Reg<EXTCTRL_SPEC>`"]
pub type EXTCTRL = crate :: Reg < extctrl :: EXTCTRL_SPEC > ; # [doc = "External Reset Controller"]
pub mod extctrl { # [doc = "Register `EXTCTRL` reader"]
pub struct R (crate :: R < EXTCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EXTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EXTCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EXTCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EXTCTRL` writer"]
pub struct W (crate :: W < EXTCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EXTCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EXTCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EXTCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SETDIS` reader - External Reset Disable"]
pub type SETDIS_R = crate :: BitReader < bool > ; # [doc = "Field `SETDIS` writer - External Reset Disable"]
pub type SETDIS_W < 'a > = crate :: BitWriter < 'a , u8 , EXTCTRL_SPEC , bool , 0 > ; impl R { # [doc = "Bit 0 - External Reset Disable"]
# [inline (always)]
pub fn setdis (& self) -> SETDIS_R { SETDIS_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - External Reset Disable"]
# [inline (always)]
pub fn setdis (& mut self) -> SETDIS_W { SETDIS_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "External Reset Controller\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [extctrl](index.html) module"]
pub struct EXTCTRL_SPEC ; impl crate :: RegisterSpec for EXTCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [extctrl::R](R) reader structure"]
impl crate :: Readable for EXTCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [extctrl::W](W) writer structure"]
impl crate :: Writable for EXTCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets EXTCTRL to value 0"]
impl crate :: Resettable for EXTCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CPUSEL register accessor: an alias for `Reg<CPUSEL_SPEC>`"]
pub type CPUSEL = crate :: Reg < cpusel :: CPUSEL_SPEC > ; # [doc = "CPU Clock Select"]
pub mod cpusel { # [doc = "Register `CPUSEL` reader"]
pub struct R (crate :: R < CPUSEL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CPUSEL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CPUSEL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CPUSEL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CPUSEL` writer"]
pub struct W (crate :: W < CPUSEL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CPUSEL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CPUSEL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CPUSEL_SPEC >) -> Self { W (writer) } } # [doc = "CPU Prescaler Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CPUDIV_A { # [doc = "0: Divide by 1"]
DIV1 = 0 , # [doc = "1: Divide by 2"]
DIV2 = 1 , # [doc = "2: Divide by 4"]
DIV4 = 2 , # [doc = "3: Divide by 8"]
DIV8 = 3 , # [doc = "4: Divide by 16"]
DIV16 = 4 , # [doc = "5: Divide by 32"]
DIV32 = 5 , # [doc = "6: Divide by 64"]
DIV64 = 6 , # [doc = "7: Divide by 128"]
DIV128 = 7 , } impl From < CPUDIV_A > for u8 { # [inline (always)]
fn from (variant : CPUDIV_A) -> Self { variant as _ } } # [doc = "Field `CPUDIV` reader - CPU Prescaler Selection"]
pub type CPUDIV_R = crate :: FieldReader < u8 , CPUDIV_A > ; impl CPUDIV_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CPUDIV_A { match self . bits { 0 => CPUDIV_A :: DIV1 , 1 => CPUDIV_A :: DIV2 , 2 => CPUDIV_A :: DIV4 , 3 => CPUDIV_A :: DIV8 , 4 => CPUDIV_A :: DIV16 , 5 => CPUDIV_A :: DIV32 , 6 => CPUDIV_A :: DIV64 , 7 => CPUDIV_A :: DIV128 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == CPUDIV_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == CPUDIV_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == CPUDIV_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == CPUDIV_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == CPUDIV_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV32`"]
# [inline (always)]
pub fn is_div32 (& self) -> bool { * self == CPUDIV_A :: DIV32 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == CPUDIV_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV128`"]
# [inline (always)]
pub fn is_div128 (& self) -> bool { * self == CPUDIV_A :: DIV128 } } # [doc = "Field `CPUDIV` writer - CPU Prescaler Selection"]
pub type CPUDIV_W < 'a > = crate :: FieldWriterSafe < 'a , u8 , CPUSEL_SPEC , u8 , CPUDIV_A , 3 , 0 > ; impl < 'a > CPUDIV_W < 'a > { # [doc = "Divide by 1"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (CPUDIV_A :: DIV1) } # [doc = "Divide by 2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (CPUDIV_A :: DIV2) } # [doc = "Divide by 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (CPUDIV_A :: DIV4) } # [doc = "Divide by 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (CPUDIV_A :: DIV8) } # [doc = "Divide by 16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (CPUDIV_A :: DIV16) } # [doc = "Divide by 32"]
# [inline (always)]
pub fn div32 (self) -> & 'a mut W { self . variant (CPUDIV_A :: DIV32) } # [doc = "Divide by 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (CPUDIV_A :: DIV64) } # [doc = "Divide by 128"]
# [inline (always)]
pub fn div128 (self) -> & 'a mut W { self . variant (CPUDIV_A :: DIV128) } } impl R { # [doc = "Bits 0:2 - CPU Prescaler Selection"]
# [inline (always)]
pub fn cpudiv (& self) -> CPUDIV_R { CPUDIV_R :: new ((self . bits & 7) as u8) } } impl W { # [doc = "Bits 0:2 - CPU Prescaler Selection"]
# [inline (always)]
pub fn cpudiv (& mut self) -> CPUDIV_W { CPUDIV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "CPU Clock Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cpusel](index.html) module"]
pub struct CPUSEL_SPEC ; impl crate :: RegisterSpec for CPUSEL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [cpusel::R](R) reader structure"]
impl crate :: Readable for CPUSEL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cpusel::W](W) writer structure"]
impl crate :: Writable for CPUSEL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CPUSEL to value 0"]
impl crate :: Resettable for CPUSEL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "APBASEL register accessor: an alias for `Reg<APBASEL_SPEC>`"]
pub type APBASEL = crate :: Reg < apbasel :: APBASEL_SPEC > ; # [doc = "APBA Clock Select"]
pub mod apbasel { # [doc = "Register `APBASEL` reader"]
pub struct R (crate :: R < APBASEL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < APBASEL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < APBASEL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < APBASEL_SPEC >) -> Self { R (reader) } } # [doc = "Register `APBASEL` writer"]
pub struct W (crate :: W < APBASEL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < APBASEL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < APBASEL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < APBASEL_SPEC >) -> Self { W (writer) } } # [doc = "APBA Prescaler Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum APBADIV_A { # [doc = "0: Divide by 1"]
DIV1 = 0 , # [doc = "1: Divide by 2"]
DIV2 = 1 , # [doc = "2: Divide by 4"]
DIV4 = 2 , # [doc = "3: Divide by 8"]
DIV8 = 3 , # [doc = "4: Divide by 16"]
DIV16 = 4 , # [doc = "5: Divide by 32"]
DIV32 = 5 , # [doc = "6: Divide by 64"]
DIV64 = 6 , # [doc = "7: Divide by 128"]
DIV128 = 7 , } impl From < APBADIV_A > for u8 { # [inline (always)]
fn from (variant : APBADIV_A) -> Self { variant as _ } } # [doc = "Field `APBADIV` reader - APBA Prescaler Selection"]
pub type APBADIV_R = crate :: FieldReader < u8 , APBADIV_A > ; impl APBADIV_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> APBADIV_A { match self . bits { 0 => APBADIV_A :: DIV1 , 1 => APBADIV_A :: DIV2 , 2 => APBADIV_A :: DIV4 , 3 => APBADIV_A :: DIV8 , 4 => APBADIV_A :: DIV16 , 5 => APBADIV_A :: DIV32 , 6 => APBADIV_A :: DIV64 , 7 => APBADIV_A :: DIV128 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == APBADIV_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == APBADIV_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == APBADIV_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == APBADIV_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == APBADIV_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV32`"]
# [inline (always)]
pub fn is_div32 (& self) -> bool { * self == APBADIV_A :: DIV32 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == APBADIV_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV128`"]
# [inline (always)]
pub fn is_div128 (& self) -> bool { * self == APBADIV_A :: DIV128 } } # [doc = "Field `APBADIV` writer - APBA Prescaler Selection"]
pub type APBADIV_W < 'a > = crate :: FieldWriterSafe < 'a , u8 , APBASEL_SPEC , u8 , APBADIV_A , 3 , 0 > ; impl < 'a > APBADIV_W < 'a > { # [doc = "Divide by 1"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (APBADIV_A :: DIV1) } # [doc = "Divide by 2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (APBADIV_A :: DIV2) } # [doc = "Divide by 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (APBADIV_A :: DIV4) } # [doc = "Divide by 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (APBADIV_A :: DIV8) } # [doc = "Divide by 16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (APBADIV_A :: DIV16) } # [doc = "Divide by 32"]
# [inline (always)]
pub fn div32 (self) -> & 'a mut W { self . variant (APBADIV_A :: DIV32) } # [doc = "Divide by 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (APBADIV_A :: DIV64) } # [doc = "Divide by 128"]
# [inline (always)]
pub fn div128 (self) -> & 'a mut W { self . variant (APBADIV_A :: DIV128) } } impl R { # [doc = "Bits 0:2 - APBA Prescaler Selection"]
# [inline (always)]
pub fn apbadiv (& self) -> APBADIV_R { APBADIV_R :: new ((self . bits & 7) as u8) } } impl W { # [doc = "Bits 0:2 - APBA Prescaler Selection"]
# [inline (always)]
pub fn apbadiv (& mut self) -> APBADIV_W { APBADIV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "APBA Clock Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [apbasel](index.html) module"]
pub struct APBASEL_SPEC ; impl crate :: RegisterSpec for APBASEL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [apbasel::R](R) reader structure"]
impl crate :: Readable for APBASEL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [apbasel::W](W) writer structure"]
impl crate :: Writable for APBASEL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets APBASEL to value 0"]
impl crate :: Resettable for APBASEL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "APBBSEL register accessor: an alias for `Reg<APBBSEL_SPEC>`"]
pub type APBBSEL = crate :: Reg < apbbsel :: APBBSEL_SPEC > ; # [doc = "APBB Clock Select"]
pub mod apbbsel { # [doc = "Register `APBBSEL` reader"]
pub struct R (crate :: R < APBBSEL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < APBBSEL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < APBBSEL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < APBBSEL_SPEC >) -> Self { R (reader) } } # [doc = "Register `APBBSEL` writer"]
pub struct W (crate :: W < APBBSEL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < APBBSEL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < APBBSEL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < APBBSEL_SPEC >) -> Self { W (writer) } } # [doc = "APBB Prescaler Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum APBBDIV_A { # [doc = "0: Divide by 1"]
DIV1 = 0 , # [doc = "1: Divide by 2"]
DIV2 = 1 , # [doc = "2: Divide by 4"]
DIV4 = 2 , # [doc = "3: Divide by 8"]
DIV8 = 3 , # [doc = "4: Divide by 16"]
DIV16 = 4 , # [doc = "5: Divide by 32"]
DIV32 = 5 , # [doc = "6: Divide by 64"]
DIV64 = 6 , # [doc = "7: Divide by 128"]
DIV128 = 7 , } impl From < APBBDIV_A > for u8 { # [inline (always)]
fn from (variant : APBBDIV_A) -> Self { variant as _ } } # [doc = "Field `APBBDIV` reader - APBB Prescaler Selection"]
pub type APBBDIV_R = crate :: FieldReader < u8 , APBBDIV_A > ; impl APBBDIV_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> APBBDIV_A { match self . bits { 0 => APBBDIV_A :: DIV1 , 1 => APBBDIV_A :: DIV2 , 2 => APBBDIV_A :: DIV4 , 3 => APBBDIV_A :: DIV8 , 4 => APBBDIV_A :: DIV16 , 5 => APBBDIV_A :: DIV32 , 6 => APBBDIV_A :: DIV64 , 7 => APBBDIV_A :: DIV128 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == APBBDIV_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == APBBDIV_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == APBBDIV_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == APBBDIV_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == APBBDIV_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV32`"]
# [inline (always)]
pub fn is_div32 (& self) -> bool { * self == APBBDIV_A :: DIV32 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == APBBDIV_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV128`"]
# [inline (always)]
pub fn is_div128 (& self) -> bool { * self == APBBDIV_A :: DIV128 } } # [doc = "Field `APBBDIV` writer - APBB Prescaler Selection"]
pub type APBBDIV_W < 'a > = crate :: FieldWriterSafe < 'a , u8 , APBBSEL_SPEC , u8 , APBBDIV_A , 3 , 0 > ; impl < 'a > APBBDIV_W < 'a > { # [doc = "Divide by 1"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (APBBDIV_A :: DIV1) } # [doc = "Divide by 2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (APBBDIV_A :: DIV2) } # [doc = "Divide by 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (APBBDIV_A :: DIV4) } # [doc = "Divide by 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (APBBDIV_A :: DIV8) } # [doc = "Divide by 16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (APBBDIV_A :: DIV16) } # [doc = "Divide by 32"]
# [inline (always)]
pub fn div32 (self) -> & 'a mut W { self . variant (APBBDIV_A :: DIV32) } # [doc = "Divide by 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (APBBDIV_A :: DIV64) } # [doc = "Divide by 128"]
# [inline (always)]
pub fn div128 (self) -> & 'a mut W { self . variant (APBBDIV_A :: DIV128) } } impl R { # [doc = "Bits 0:2 - APBB Prescaler Selection"]
# [inline (always)]
pub fn apbbdiv (& self) -> APBBDIV_R { APBBDIV_R :: new ((self . bits & 7) as u8) } } impl W { # [doc = "Bits 0:2 - APBB Prescaler Selection"]
# [inline (always)]
pub fn apbbdiv (& mut self) -> APBBDIV_W { APBBDIV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "APBB Clock Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [apbbsel](index.html) module"]
pub struct APBBSEL_SPEC ; impl crate :: RegisterSpec for APBBSEL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [apbbsel::R](R) reader structure"]
impl crate :: Readable for APBBSEL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [apbbsel::W](W) writer structure"]
impl crate :: Writable for APBBSEL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets APBBSEL to value 0"]
impl crate :: Resettable for APBBSEL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "APBCSEL register accessor: an alias for `Reg<APBCSEL_SPEC>`"]
pub type APBCSEL = crate :: Reg < apbcsel :: APBCSEL_SPEC > ; # [doc = "APBC Clock Select"]
pub mod apbcsel { # [doc = "Register `APBCSEL` reader"]
pub struct R (crate :: R < APBCSEL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < APBCSEL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < APBCSEL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < APBCSEL_SPEC >) -> Self { R (reader) } } # [doc = "Register `APBCSEL` writer"]
pub struct W (crate :: W < APBCSEL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < APBCSEL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < APBCSEL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < APBCSEL_SPEC >) -> Self { W (writer) } } # [doc = "APBC Prescaler Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum APBCDIV_A { # [doc = "0: Divide by 1"]
DIV1 = 0 , # [doc = "1: Divide by 2"]
DIV2 = 1 , # [doc = "2: Divide by 4"]
DIV4 = 2 , # [doc = "3: Divide by 8"]
DIV8 = 3 , # [doc = "4: Divide by 16"]
DIV16 = 4 , # [doc = "5: Divide by 32"]
DIV32 = 5 , # [doc = "6: Divide by 64"]
DIV64 = 6 , # [doc = "7: Divide by 128"]
DIV128 = 7 , } impl From < APBCDIV_A > for u8 { # [inline (always)]
fn from (variant : APBCDIV_A) -> Self { variant as _ } } # [doc = "Field `APBCDIV` reader - APBC Prescaler Selection"]
pub type APBCDIV_R = crate :: FieldReader < u8 , APBCDIV_A > ; impl APBCDIV_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> APBCDIV_A { match self . bits { 0 => APBCDIV_A :: DIV1 , 1 => APBCDIV_A :: DIV2 , 2 => APBCDIV_A :: DIV4 , 3 => APBCDIV_A :: DIV8 , 4 => APBCDIV_A :: DIV16 , 5 => APBCDIV_A :: DIV32 , 6 => APBCDIV_A :: DIV64 , 7 => APBCDIV_A :: DIV128 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == APBCDIV_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == APBCDIV_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == APBCDIV_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == APBCDIV_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == APBCDIV_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV32`"]
# [inline (always)]
pub fn is_div32 (& self) -> bool { * self == APBCDIV_A :: DIV32 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == APBCDIV_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV128`"]
# [inline (always)]
pub fn is_div128 (& self) -> bool { * self == APBCDIV_A :: DIV128 } } # [doc = "Field `APBCDIV` writer - APBC Prescaler Selection"]
pub type APBCDIV_W < 'a > = crate :: FieldWriterSafe < 'a , u8 , APBCSEL_SPEC , u8 , APBCDIV_A , 3 , 0 > ; impl < 'a > APBCDIV_W < 'a > { # [doc = "Divide by 1"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (APBCDIV_A :: DIV1) } # [doc = "Divide by 2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (APBCDIV_A :: DIV2) } # [doc = "Divide by 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (APBCDIV_A :: DIV4) } # [doc = "Divide by 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (APBCDIV_A :: DIV8) } # [doc = "Divide by 16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (APBCDIV_A :: DIV16) } # [doc = "Divide by 32"]
# [inline (always)]
pub fn div32 (self) -> & 'a mut W { self . variant (APBCDIV_A :: DIV32) } # [doc = "Divide by 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (APBCDIV_A :: DIV64) } # [doc = "Divide by 128"]
# [inline (always)]
pub fn div128 (self) -> & 'a mut W { self . variant (APBCDIV_A :: DIV128) } } impl R { # [doc = "Bits 0:2 - APBC Prescaler Selection"]
# [inline (always)]
pub fn apbcdiv (& self) -> APBCDIV_R { APBCDIV_R :: new ((self . bits & 7) as u8) } } impl W { # [doc = "Bits 0:2 - APBC Prescaler Selection"]
# [inline (always)]
pub fn apbcdiv (& mut self) -> APBCDIV_W { APBCDIV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "APBC Clock Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [apbcsel](index.html) module"]
pub struct APBCSEL_SPEC ; impl crate :: RegisterSpec for APBCSEL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [apbcsel::R](R) reader structure"]
impl crate :: Readable for APBCSEL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [apbcsel::W](W) writer structure"]
impl crate :: Writable for APBCSEL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets APBCSEL to value 0"]
impl crate :: Resettable for APBCSEL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "AHBMASK register accessor: an alias for `Reg<AHBMASK_SPEC>`"]
pub type AHBMASK = crate :: Reg < ahbmask :: AHBMASK_SPEC > ; # [doc = "AHB Mask"]
pub mod ahbmask { # [doc = "Register `AHBMASK` reader"]
pub struct R (crate :: R < AHBMASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < AHBMASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < AHBMASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < AHBMASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `AHBMASK` writer"]
pub struct W (crate :: W < AHBMASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < AHBMASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < AHBMASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < AHBMASK_SPEC >) -> Self { W (writer) } } # [doc = "Field `HPB0_` reader - HPB0 AHB Clock Mask"]
pub type HPB0__R = crate :: BitReader < bool > ; # [doc = "Field `HPB0_` writer - HPB0 AHB Clock Mask"]
pub type HPB0__W < 'a > = crate :: BitWriter < 'a , u32 , AHBMASK_SPEC , bool , 0 > ; # [doc = "Field `HPB1_` reader - HPB1 AHB Clock Mask"]
pub type HPB1__R = crate :: BitReader < bool > ; # [doc = "Field `HPB1_` writer - HPB1 AHB Clock Mask"]
pub type HPB1__W < 'a > = crate :: BitWriter < 'a , u32 , AHBMASK_SPEC , bool , 1 > ; # [doc = "Field `HPB2_` reader - HPB2 AHB Clock Mask"]
pub type HPB2__R = crate :: BitReader < bool > ; # [doc = "Field `HPB2_` writer - HPB2 AHB Clock Mask"]
pub type HPB2__W < 'a > = crate :: BitWriter < 'a , u32 , AHBMASK_SPEC , bool , 2 > ; # [doc = "Field `DSU_` reader - DSU AHB Clock Mask"]
pub type DSU__R = crate :: BitReader < bool > ; # [doc = "Field `DSU_` writer - DSU AHB Clock Mask"]
pub type DSU__W < 'a > = crate :: BitWriter < 'a , u32 , AHBMASK_SPEC , bool , 3 > ; # [doc = "Field `NVMCTRL_` reader - NVMCTRL AHB Clock Mask"]
pub type NVMCTRL__R = crate :: BitReader < bool > ; # [doc = "Field `NVMCTRL_` writer - NVMCTRL AHB Clock Mask"]
pub type NVMCTRL__W < 'a > = crate :: BitWriter < 'a , u32 , AHBMASK_SPEC , bool , 4 > ; # [doc = "Field `DMAC_` reader - DMAC AHB Clock Mask"]
pub type DMAC__R = crate :: BitReader < bool > ; # [doc = "Field `DMAC_` writer - DMAC AHB Clock Mask"]
pub type DMAC__W < 'a > = crate :: BitWriter < 'a , u32 , AHBMASK_SPEC , bool , 5 > ; # [doc = "Field `USB_` reader - USB AHB Clock Mask"]
pub type USB__R = crate :: BitReader < bool > ; # [doc = "Field `USB_` writer - USB AHB Clock Mask"]
pub type USB__W < 'a > = crate :: BitWriter < 'a , u32 , AHBMASK_SPEC , bool , 6 > ; impl R { # [doc = "Bit 0 - HPB0 AHB Clock Mask"]
# [inline (always)]
pub fn hpb0_ (& self) -> HPB0__R { HPB0__R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - HPB1 AHB Clock Mask"]
# [inline (always)]
pub fn hpb1_ (& self) -> HPB1__R { HPB1__R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - HPB2 AHB Clock Mask"]
# [inline (always)]
pub fn hpb2_ (& self) -> HPB2__R { HPB2__R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - DSU AHB Clock Mask"]
# [inline (always)]
pub fn dsu_ (& self) -> DSU__R { DSU__R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - NVMCTRL AHB Clock Mask"]
# [inline (always)]
pub fn nvmctrl_ (& self) -> NVMCTRL__R { NVMCTRL__R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - DMAC AHB Clock Mask"]
# [inline (always)]
pub fn dmac_ (& self) -> DMAC__R { DMAC__R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - USB AHB Clock Mask"]
# [inline (always)]
pub fn usb_ (& self) -> USB__R { USB__R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - HPB0 AHB Clock Mask"]
# [inline (always)]
pub fn hpb0_ (& mut self) -> HPB0__W { HPB0__W :: new (self) } # [doc = "Bit 1 - HPB1 AHB Clock Mask"]
# [inline (always)]
pub fn hpb1_ (& mut self) -> HPB1__W { HPB1__W :: new (self) } # [doc = "Bit 2 - HPB2 AHB Clock Mask"]
# [inline (always)]
pub fn hpb2_ (& mut self) -> HPB2__W { HPB2__W :: new (self) } # [doc = "Bit 3 - DSU AHB Clock Mask"]
# [inline (always)]
pub fn dsu_ (& mut self) -> DSU__W { DSU__W :: new (self) } # [doc = "Bit 4 - NVMCTRL AHB Clock Mask"]
# [inline (always)]
pub fn nvmctrl_ (& mut self) -> NVMCTRL__W { NVMCTRL__W :: new (self) } # [doc = "Bit 5 - DMAC AHB Clock Mask"]
# [inline (always)]
pub fn dmac_ (& mut self) -> DMAC__W { DMAC__W :: new (self) } # [doc = "Bit 6 - USB AHB Clock Mask"]
# [inline (always)]
pub fn usb_ (& mut self) -> USB__W { USB__W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "AHB Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ahbmask](index.html) module"]
pub struct AHBMASK_SPEC ; impl crate :: RegisterSpec for AHBMASK_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ahbmask::R](R) reader structure"]
impl crate :: Readable for AHBMASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ahbmask::W](W) writer structure"]
impl crate :: Writable for AHBMASK_SPEC { type Writer = W ; } # [doc = "`reset()` method sets AHBMASK to value 0x7f"]
impl crate :: Resettable for AHBMASK_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x7f } } } # [doc = "APBAMASK register accessor: an alias for `Reg<APBAMASK_SPEC>`"]
pub type APBAMASK = crate :: Reg < apbamask :: APBAMASK_SPEC > ; # [doc = "APBA Mask"]
pub mod apbamask { # [doc = "Register `APBAMASK` reader"]
pub struct R (crate :: R < APBAMASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < APBAMASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < APBAMASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < APBAMASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `APBAMASK` writer"]
pub struct W (crate :: W < APBAMASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < APBAMASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < APBAMASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < APBAMASK_SPEC >) -> Self { W (writer) } } # [doc = "Field `PAC0_` reader - PAC0 APB Clock Enable"]
pub type PAC0__R = crate :: BitReader < bool > ; # [doc = "Field `PAC0_` writer - PAC0 APB Clock Enable"]
pub type PAC0__W < 'a > = crate :: BitWriter < 'a , u32 , APBAMASK_SPEC , bool , 0 > ; # [doc = "Field `PM_` reader - PM APB Clock Enable"]
pub type PM__R = crate :: BitReader < bool > ; # [doc = "Field `PM_` writer - PM APB Clock Enable"]
pub type PM__W < 'a > = crate :: BitWriter < 'a , u32 , APBAMASK_SPEC , bool , 1 > ; # [doc = "Field `SYSCTRL_` reader - SYSCTRL APB Clock Enable"]
pub type SYSCTRL__R = crate :: BitReader < bool > ; # [doc = "Field `SYSCTRL_` writer - SYSCTRL APB Clock Enable"]
pub type SYSCTRL__W < 'a > = crate :: BitWriter < 'a , u32 , APBAMASK_SPEC , bool , 2 > ; # [doc = "Field `GCLK_` reader - GCLK APB Clock Enable"]
pub type GCLK__R = crate :: BitReader < bool > ; # [doc = "Field `GCLK_` writer - GCLK APB Clock Enable"]
pub type GCLK__W < 'a > = crate :: BitWriter < 'a , u32 , APBAMASK_SPEC , bool , 3 > ; # [doc = "Field `WDT_` reader - WDT APB Clock Enable"]
pub type WDT__R = crate :: BitReader < bool > ; # [doc = "Field `WDT_` writer - WDT APB Clock Enable"]
pub type WDT__W < 'a > = crate :: BitWriter < 'a , u32 , APBAMASK_SPEC , bool , 4 > ; # [doc = "Field `RTC_` reader - RTC APB Clock Enable"]
pub type RTC__R = crate :: BitReader < bool > ; # [doc = "Field `RTC_` writer - RTC APB Clock Enable"]
pub type RTC__W < 'a > = crate :: BitWriter < 'a , u32 , APBAMASK_SPEC , bool , 5 > ; # [doc = "Field `EIC_` reader - EIC APB Clock Enable"]
pub type EIC__R = crate :: BitReader < bool > ; # [doc = "Field `EIC_` writer - EIC APB Clock Enable"]
pub type EIC__W < 'a > = crate :: BitWriter < 'a , u32 , APBAMASK_SPEC , bool , 6 > ; impl R { # [doc = "Bit 0 - PAC0 APB Clock Enable"]
# [inline (always)]
pub fn pac0_ (& self) -> PAC0__R { PAC0__R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - PM APB Clock Enable"]
# [inline (always)]
pub fn pm_ (& self) -> PM__R { PM__R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - SYSCTRL APB Clock Enable"]
# [inline (always)]
pub fn sysctrl_ (& self) -> SYSCTRL__R { SYSCTRL__R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - GCLK APB Clock Enable"]
# [inline (always)]
pub fn gclk_ (& self) -> GCLK__R { GCLK__R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - WDT APB Clock Enable"]
# [inline (always)]
pub fn wdt_ (& self) -> WDT__R { WDT__R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - RTC APB Clock Enable"]
# [inline (always)]
pub fn rtc_ (& self) -> RTC__R { RTC__R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - EIC APB Clock Enable"]
# [inline (always)]
pub fn eic_ (& self) -> EIC__R { EIC__R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - PAC0 APB Clock Enable"]
# [inline (always)]
pub fn pac0_ (& mut self) -> PAC0__W { PAC0__W :: new (self) } # [doc = "Bit 1 - PM APB Clock Enable"]
# [inline (always)]
pub fn pm_ (& mut self) -> PM__W { PM__W :: new (self) } # [doc = "Bit 2 - SYSCTRL APB Clock Enable"]
# [inline (always)]
pub fn sysctrl_ (& mut self) -> SYSCTRL__W { SYSCTRL__W :: new (self) } # [doc = "Bit 3 - GCLK APB Clock Enable"]
# [inline (always)]
pub fn gclk_ (& mut self) -> GCLK__W { GCLK__W :: new (self) } # [doc = "Bit 4 - WDT APB Clock Enable"]
# [inline (always)]
pub fn wdt_ (& mut self) -> WDT__W { WDT__W :: new (self) } # [doc = "Bit 5 - RTC APB Clock Enable"]
# [inline (always)]
pub fn rtc_ (& mut self) -> RTC__W { RTC__W :: new (self) } # [doc = "Bit 6 - EIC APB Clock Enable"]
# [inline (always)]
pub fn eic_ (& mut self) -> EIC__W { EIC__W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "APBA Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [apbamask](index.html) module"]
pub struct APBAMASK_SPEC ; impl crate :: RegisterSpec for APBAMASK_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [apbamask::R](R) reader structure"]
impl crate :: Readable for APBAMASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [apbamask::W](W) writer structure"]
impl crate :: Writable for APBAMASK_SPEC { type Writer = W ; } # [doc = "`reset()` method sets APBAMASK to value 0x7f"]
impl crate :: Resettable for APBAMASK_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x7f } } } # [doc = "APBBMASK register accessor: an alias for `Reg<APBBMASK_SPEC>`"]
pub type APBBMASK = crate :: Reg < apbbmask :: APBBMASK_SPEC > ; # [doc = "APBB Mask"]
pub mod apbbmask { # [doc = "Register `APBBMASK` reader"]
pub struct R (crate :: R < APBBMASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < APBBMASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < APBBMASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < APBBMASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `APBBMASK` writer"]
pub struct W (crate :: W < APBBMASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < APBBMASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < APBBMASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < APBBMASK_SPEC >) -> Self { W (writer) } } # [doc = "Field `PAC1_` reader - PAC1 APB Clock Enable"]
pub type PAC1__R = crate :: BitReader < bool > ; # [doc = "Field `PAC1_` writer - PAC1 APB Clock Enable"]
pub type PAC1__W < 'a > = crate :: BitWriter < 'a , u32 , APBBMASK_SPEC , bool , 0 > ; # [doc = "Field `DSU_` reader - DSU APB Clock Enable"]
pub type DSU__R = crate :: BitReader < bool > ; # [doc = "Field `DSU_` writer - DSU APB Clock Enable"]
pub type DSU__W < 'a > = crate :: BitWriter < 'a , u32 , APBBMASK_SPEC , bool , 1 > ; # [doc = "Field `NVMCTRL_` reader - NVMCTRL APB Clock Enable"]
pub type NVMCTRL__R = crate :: BitReader < bool > ; # [doc = "Field `NVMCTRL_` writer - NVMCTRL APB Clock Enable"]
pub type NVMCTRL__W < 'a > = crate :: BitWriter < 'a , u32 , APBBMASK_SPEC , bool , 2 > ; # [doc = "Field `PORT_` reader - PORT APB Clock Enable"]
pub type PORT__R = crate :: BitReader < bool > ; # [doc = "Field `PORT_` writer - PORT APB Clock Enable"]
pub type PORT__W < 'a > = crate :: BitWriter < 'a , u32 , APBBMASK_SPEC , bool , 3 > ; # [doc = "Field `DMAC_` reader - DMAC APB Clock Enable"]
pub type DMAC__R = crate :: BitReader < bool > ; # [doc = "Field `DMAC_` writer - DMAC APB Clock Enable"]
pub type DMAC__W < 'a > = crate :: BitWriter < 'a , u32 , APBBMASK_SPEC , bool , 4 > ; # [doc = "Field `USB_` reader - USB APB Clock Enable"]
pub type USB__R = crate :: BitReader < bool > ; # [doc = "Field `USB_` writer - USB APB Clock Enable"]
pub type USB__W < 'a > = crate :: BitWriter < 'a , u32 , APBBMASK_SPEC , bool , 5 > ; # [doc = "Field `HMATRIX_` reader - HMATRIX APB Clock Enable"]
pub type HMATRIX__R = crate :: BitReader < bool > ; # [doc = "Field `HMATRIX_` writer - HMATRIX APB Clock Enable"]
pub type HMATRIX__W < 'a > = crate :: BitWriter < 'a , u32 , APBBMASK_SPEC , bool , 6 > ; impl R { # [doc = "Bit 0 - PAC1 APB Clock Enable"]
# [inline (always)]
pub fn pac1_ (& self) -> PAC1__R { PAC1__R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - DSU APB Clock Enable"]
# [inline (always)]
pub fn dsu_ (& self) -> DSU__R { DSU__R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - NVMCTRL APB Clock Enable"]
# [inline (always)]
pub fn nvmctrl_ (& self) -> NVMCTRL__R { NVMCTRL__R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - PORT APB Clock Enable"]
# [inline (always)]
pub fn port_ (& self) -> PORT__R { PORT__R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - DMAC APB Clock Enable"]
# [inline (always)]
pub fn dmac_ (& self) -> DMAC__R { DMAC__R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - USB APB Clock Enable"]
# [inline (always)]
pub fn usb_ (& self) -> USB__R { USB__R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - HMATRIX APB Clock Enable"]
# [inline (always)]
pub fn hmatrix_ (& self) -> HMATRIX__R { HMATRIX__R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - PAC1 APB Clock Enable"]
# [inline (always)]
pub fn pac1_ (& mut self) -> PAC1__W { PAC1__W :: new (self) } # [doc = "Bit 1 - DSU APB Clock Enable"]
# [inline (always)]
pub fn dsu_ (& mut self) -> DSU__W { DSU__W :: new (self) } # [doc = "Bit 2 - NVMCTRL APB Clock Enable"]
# [inline (always)]
pub fn nvmctrl_ (& mut self) -> NVMCTRL__W { NVMCTRL__W :: new (self) } # [doc = "Bit 3 - PORT APB Clock Enable"]
# [inline (always)]
pub fn port_ (& mut self) -> PORT__W { PORT__W :: new (self) } # [doc = "Bit 4 - DMAC APB Clock Enable"]
# [inline (always)]
pub fn dmac_ (& mut self) -> DMAC__W { DMAC__W :: new (self) } # [doc = "Bit 5 - USB APB Clock Enable"]
# [inline (always)]
pub fn usb_ (& mut self) -> USB__W { USB__W :: new (self) } # [doc = "Bit 6 - HMATRIX APB Clock Enable"]
# [inline (always)]
pub fn hmatrix_ (& mut self) -> HMATRIX__W { HMATRIX__W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "APBB Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [apbbmask](index.html) module"]
pub struct APBBMASK_SPEC ; impl crate :: RegisterSpec for APBBMASK_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [apbbmask::R](R) reader structure"]
impl crate :: Readable for APBBMASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [apbbmask::W](W) writer structure"]
impl crate :: Writable for APBBMASK_SPEC { type Writer = W ; } # [doc = "`reset()` method sets APBBMASK to value 0x7f"]
impl crate :: Resettable for APBBMASK_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x7f } } } # [doc = "APBCMASK register accessor: an alias for `Reg<APBCMASK_SPEC>`"]
pub type APBCMASK = crate :: Reg < apbcmask :: APBCMASK_SPEC > ; # [doc = "APBC Mask"]
pub mod apbcmask { # [doc = "Register `APBCMASK` reader"]
pub struct R (crate :: R < APBCMASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < APBCMASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < APBCMASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < APBCMASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `APBCMASK` writer"]
pub struct W (crate :: W < APBCMASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < APBCMASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < APBCMASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < APBCMASK_SPEC >) -> Self { W (writer) } } # [doc = "Field `PAC2_` reader - PAC2 APB Clock Enable"]
pub type PAC2__R = crate :: BitReader < bool > ; # [doc = "Field `PAC2_` writer - PAC2 APB Clock Enable"]
pub type PAC2__W < 'a > = crate :: BitWriter < 'a , u32 , APBCMASK_SPEC , bool , 0 > ; # [doc = "Field `EVSYS_` reader - EVSYS APB Clock Enable"]
pub type EVSYS__R = crate :: BitReader < bool > ; # [doc = "Field `EVSYS_` writer - EVSYS APB Clock Enable"]
pub type EVSYS__W < 'a > = crate :: BitWriter < 'a , u32 , APBCMASK_SPEC , bool , 1 > ; # [doc = "Field `SERCOM0_` reader - SERCOM0 APB Clock Enable"]
pub type SERCOM0__R = crate :: BitReader < bool > ; # [doc = "Field `SERCOM0_` writer - SERCOM0 APB Clock Enable"]
pub type SERCOM0__W < 'a > = crate :: BitWriter < 'a , u32 , APBCMASK_SPEC , bool , 2 > ; # [doc = "Field `SERCOM1_` reader - SERCOM1 APB Clock Enable"]
pub type SERCOM1__R = crate :: BitReader < bool > ; # [doc = "Field `SERCOM1_` writer - SERCOM1 APB Clock Enable"]
pub type SERCOM1__W < 'a > = crate :: BitWriter < 'a , u32 , APBCMASK_SPEC , bool , 3 > ; # [doc = "Field `SERCOM2_` reader - SERCOM2 APB Clock Enable"]
pub type SERCOM2__R = crate :: BitReader < bool > ; # [doc = "Field `SERCOM2_` writer - SERCOM2 APB Clock Enable"]
pub type SERCOM2__W < 'a > = crate :: BitWriter < 'a , u32 , APBCMASK_SPEC , bool , 4 > ; # [doc = "Field `SERCOM3_` reader - SERCOM3 APB Clock Enable"]
pub type SERCOM3__R = crate :: BitReader < bool > ; # [doc = "Field `SERCOM3_` writer - SERCOM3 APB Clock Enable"]
pub type SERCOM3__W < 'a > = crate :: BitWriter < 'a , u32 , APBCMASK_SPEC , bool , 5 > ; # [doc = "Field `SERCOM4_` reader - SERCOM4 APB Clock Enable"]
pub type SERCOM4__R = crate :: BitReader < bool > ; # [doc = "Field `SERCOM4_` writer - SERCOM4 APB Clock Enable"]
pub type SERCOM4__W < 'a > = crate :: BitWriter < 'a , u32 , APBCMASK_SPEC , bool , 6 > ; # [doc = "Field `SERCOM5_` reader - SERCOM5 APB Clock Enable"]
pub type SERCOM5__R = crate :: BitReader < bool > ; # [doc = "Field `SERCOM5_` writer - SERCOM5 APB Clock Enable"]
pub type SERCOM5__W < 'a > = crate :: BitWriter < 'a , u32 , APBCMASK_SPEC , bool , 7 > ; # [doc = "Field `TCC0_` reader - TCC0 APB Clock Enable"]
pub type TCC0__R = crate :: BitReader < bool > ; # [doc = "Field `TCC0_` writer - TCC0 APB Clock Enable"]
pub type TCC0__W < 'a > = crate :: BitWriter < 'a , u32 , APBCMASK_SPEC , bool , 8 > ; # [doc = "Field `TCC1_` reader - TCC1 APB Clock Enable"]
pub type TCC1__R = crate :: BitReader < bool > ; # [doc = "Field `TCC1_` writer - TCC1 APB Clock Enable"]
pub type TCC1__W < 'a > = crate :: BitWriter < 'a , u32 , APBCMASK_SPEC , bool , 9 > ; # [doc = "Field `TCC2_` reader - TCC2 APB Clock Enable"]
pub type TCC2__R = crate :: BitReader < bool > ; # [doc = "Field `TCC2_` writer - TCC2 APB Clock Enable"]
pub type TCC2__W < 'a > = crate :: BitWriter < 'a , u32 , APBCMASK_SPEC , bool , 10 > ; # [doc = "Field `TC3_` reader - TC3 APB Clock Enable"]
pub type TC3__R = crate :: BitReader < bool > ; # [doc = "Field `TC3_` writer - TC3 APB Clock Enable"]
pub type TC3__W < 'a > = crate :: BitWriter < 'a , u32 , APBCMASK_SPEC , bool , 11 > ; # [doc = "Field `TC4_` reader - TC4 APB Clock Enable"]
pub type TC4__R = crate :: BitReader < bool > ; # [doc = "Field `TC4_` writer - TC4 APB Clock Enable"]
pub type TC4__W < 'a > = crate :: BitWriter < 'a , u32 , APBCMASK_SPEC , bool , 12 > ; # [doc = "Field `TC5_` reader - TC5 APB Clock Enable"]
pub type TC5__R = crate :: BitReader < bool > ; # [doc = "Field `TC5_` writer - TC5 APB Clock Enable"]
pub type TC5__W < 'a > = crate :: BitWriter < 'a , u32 , APBCMASK_SPEC , bool , 13 > ; # [doc = "Field `TC6_` reader - TC6 APB Clock Enable"]
pub type TC6__R = crate :: BitReader < bool > ; # [doc = "Field `TC6_` writer - TC6 APB Clock Enable"]
pub type TC6__W < 'a > = crate :: BitWriter < 'a , u32 , APBCMASK_SPEC , bool , 14 > ; # [doc = "Field `TC7_` reader - TC7 APB Clock Enable"]
pub type TC7__R = crate :: BitReader < bool > ; # [doc = "Field `TC7_` writer - TC7 APB Clock Enable"]
pub type TC7__W < 'a > = crate :: BitWriter < 'a , u32 , APBCMASK_SPEC , bool , 15 > ; # [doc = "Field `ADC_` reader - ADC APB Clock Enable"]
pub type ADC__R = crate :: BitReader < bool > ; # [doc = "Field `ADC_` writer - ADC APB Clock Enable"]
pub type ADC__W < 'a > = crate :: BitWriter < 'a , u32 , APBCMASK_SPEC , bool , 16 > ; # [doc = "Field `AC_` reader - AC APB Clock Enable"]
pub type AC__R = crate :: BitReader < bool > ; # [doc = "Field `AC_` writer - AC APB Clock Enable"]
pub type AC__W < 'a > = crate :: BitWriter < 'a , u32 , APBCMASK_SPEC , bool , 17 > ; # [doc = "Field `DAC_` reader - DAC APB Clock Enable"]
pub type DAC__R = crate :: BitReader < bool > ; # [doc = "Field `DAC_` writer - DAC APB Clock Enable"]
pub type DAC__W < 'a > = crate :: BitWriter < 'a , u32 , APBCMASK_SPEC , bool , 18 > ; # [doc = "Field `PTC_` reader - PTC APB Clock Enable"]
pub type PTC__R = crate :: BitReader < bool > ; # [doc = "Field `PTC_` writer - PTC APB Clock Enable"]
pub type PTC__W < 'a > = crate :: BitWriter < 'a , u32 , APBCMASK_SPEC , bool , 19 > ; # [doc = "Field `I2S_` reader - I2S APB Clock Enable"]
pub type I2S__R = crate :: BitReader < bool > ; # [doc = "Field `I2S_` writer - I2S APB Clock Enable"]
pub type I2S__W < 'a > = crate :: BitWriter < 'a , u32 , APBCMASK_SPEC , bool , 20 > ; impl R { # [doc = "Bit 0 - PAC2 APB Clock Enable"]
# [inline (always)]
pub fn pac2_ (& self) -> PAC2__R { PAC2__R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - EVSYS APB Clock Enable"]
# [inline (always)]
pub fn evsys_ (& self) -> EVSYS__R { EVSYS__R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - SERCOM0 APB Clock Enable"]
# [inline (always)]
pub fn sercom0_ (& self) -> SERCOM0__R { SERCOM0__R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - SERCOM1 APB Clock Enable"]
# [inline (always)]
pub fn sercom1_ (& self) -> SERCOM1__R { SERCOM1__R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - SERCOM2 APB Clock Enable"]
# [inline (always)]
pub fn sercom2_ (& self) -> SERCOM2__R { SERCOM2__R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - SERCOM3 APB Clock Enable"]
# [inline (always)]
pub fn sercom3_ (& self) -> SERCOM3__R { SERCOM3__R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - SERCOM4 APB Clock Enable"]
# [inline (always)]
pub fn sercom4_ (& self) -> SERCOM4__R { SERCOM4__R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - SERCOM5 APB Clock Enable"]
# [inline (always)]
pub fn sercom5_ (& self) -> SERCOM5__R { SERCOM5__R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - TCC0 APB Clock Enable"]
# [inline (always)]
pub fn tcc0_ (& self) -> TCC0__R { TCC0__R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - TCC1 APB Clock Enable"]
# [inline (always)]
pub fn tcc1_ (& self) -> TCC1__R { TCC1__R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - TCC2 APB Clock Enable"]
# [inline (always)]
pub fn tcc2_ (& self) -> TCC2__R { TCC2__R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - TC3 APB Clock Enable"]
# [inline (always)]
pub fn tc3_ (& self) -> TC3__R { TC3__R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - TC4 APB Clock Enable"]
# [inline (always)]
pub fn tc4_ (& self) -> TC4__R { TC4__R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - TC5 APB Clock Enable"]
# [inline (always)]
pub fn tc5_ (& self) -> TC5__R { TC5__R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - TC6 APB Clock Enable"]
# [inline (always)]
pub fn tc6_ (& self) -> TC6__R { TC6__R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - TC7 APB Clock Enable"]
# [inline (always)]
pub fn tc7_ (& self) -> TC7__R { TC7__R :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - ADC APB Clock Enable"]
# [inline (always)]
pub fn adc_ (& self) -> ADC__R { ADC__R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - AC APB Clock Enable"]
# [inline (always)]
pub fn ac_ (& self) -> AC__R { AC__R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - DAC APB Clock Enable"]
# [inline (always)]
pub fn dac_ (& self) -> DAC__R { DAC__R :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - PTC APB Clock Enable"]
# [inline (always)]
pub fn ptc_ (& self) -> PTC__R { PTC__R :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 20 - I2S APB Clock Enable"]
# [inline (always)]
pub fn i2s_ (& self) -> I2S__R { I2S__R :: new (((self . bits >> 20) & 1) != 0) } } impl W { # [doc = "Bit 0 - PAC2 APB Clock Enable"]
# [inline (always)]
pub fn pac2_ (& mut self) -> PAC2__W { PAC2__W :: new (self) } # [doc = "Bit 1 - EVSYS APB Clock Enable"]
# [inline (always)]
pub fn evsys_ (& mut self) -> EVSYS__W { EVSYS__W :: new (self) } # [doc = "Bit 2 - SERCOM0 APB Clock Enable"]
# [inline (always)]
pub fn sercom0_ (& mut self) -> SERCOM0__W { SERCOM0__W :: new (self) } # [doc = "Bit 3 - SERCOM1 APB Clock Enable"]
# [inline (always)]
pub fn sercom1_ (& mut self) -> SERCOM1__W { SERCOM1__W :: new (self) } # [doc = "Bit 4 - SERCOM2 APB Clock Enable"]
# [inline (always)]
pub fn sercom2_ (& mut self) -> SERCOM2__W { SERCOM2__W :: new (self) } # [doc = "Bit 5 - SERCOM3 APB Clock Enable"]
# [inline (always)]
pub fn sercom3_ (& mut self) -> SERCOM3__W { SERCOM3__W :: new (self) } # [doc = "Bit 6 - SERCOM4 APB Clock Enable"]
# [inline (always)]
pub fn sercom4_ (& mut self) -> SERCOM4__W { SERCOM4__W :: new (self) } # [doc = "Bit 7 - SERCOM5 APB Clock Enable"]
# [inline (always)]
pub fn sercom5_ (& mut self) -> SERCOM5__W { SERCOM5__W :: new (self) } # [doc = "Bit 8 - TCC0 APB Clock Enable"]
# [inline (always)]
pub fn tcc0_ (& mut self) -> TCC0__W { TCC0__W :: new (self) } # [doc = "Bit 9 - TCC1 APB Clock Enable"]
# [inline (always)]
pub fn tcc1_ (& mut self) -> TCC1__W { TCC1__W :: new (self) } # [doc = "Bit 10 - TCC2 APB Clock Enable"]
# [inline (always)]
pub fn tcc2_ (& mut self) -> TCC2__W { TCC2__W :: new (self) } # [doc = "Bit 11 - TC3 APB Clock Enable"]
# [inline (always)]
pub fn tc3_ (& mut self) -> TC3__W { TC3__W :: new (self) } # [doc = "Bit 12 - TC4 APB Clock Enable"]
# [inline (always)]
pub fn tc4_ (& mut self) -> TC4__W { TC4__W :: new (self) } # [doc = "Bit 13 - TC5 APB Clock Enable"]
# [inline (always)]
pub fn tc5_ (& mut self) -> TC5__W { TC5__W :: new (self) } # [doc = "Bit 14 - TC6 APB Clock Enable"]
# [inline (always)]
pub fn tc6_ (& mut self) -> TC6__W { TC6__W :: new (self) } # [doc = "Bit 15 - TC7 APB Clock Enable"]
# [inline (always)]
pub fn tc7_ (& mut self) -> TC7__W { TC7__W :: new (self) } # [doc = "Bit 16 - ADC APB Clock Enable"]
# [inline (always)]
pub fn adc_ (& mut self) -> ADC__W { ADC__W :: new (self) } # [doc = "Bit 17 - AC APB Clock Enable"]
# [inline (always)]
pub fn ac_ (& mut self) -> AC__W { AC__W :: new (self) } # [doc = "Bit 18 - DAC APB Clock Enable"]
# [inline (always)]
pub fn dac_ (& mut self) -> DAC__W { DAC__W :: new (self) } # [doc = "Bit 19 - PTC APB Clock Enable"]
# [inline (always)]
pub fn ptc_ (& mut self) -> PTC__W { PTC__W :: new (self) } # [doc = "Bit 20 - I2S APB Clock Enable"]
# [inline (always)]
pub fn i2s_ (& mut self) -> I2S__W { I2S__W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "APBC Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [apbcmask](index.html) module"]
pub struct APBCMASK_SPEC ; impl crate :: RegisterSpec for APBCMASK_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [apbcmask::R](R) reader structure"]
impl crate :: Readable for APBCMASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [apbcmask::W](W) writer structure"]
impl crate :: Writable for APBCMASK_SPEC { type Writer = W ; } # [doc = "`reset()` method sets APBCMASK to value 0x0001_0000"]
impl crate :: Resettable for APBCMASK_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x0001_0000 } } } # [doc = "INTENCLR register accessor: an alias for `Reg<INTENCLR_SPEC>`"]
pub type INTENCLR = crate :: Reg < intenclr :: INTENCLR_SPEC > ; # [doc = "Interrupt Enable Clear"]
pub mod intenclr { # [doc = "Register `INTENCLR` reader"]
pub struct R (crate :: R < INTENCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENCLR` writer"]
pub struct W (crate :: W < INTENCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `CKRDY` reader - Clock Ready Interrupt Enable"]
pub type CKRDY_R = crate :: BitReader < bool > ; # [doc = "Field `CKRDY` writer - Clock Ready Interrupt Enable"]
pub type CKRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 0 > ; impl R { # [doc = "Bit 0 - Clock Ready Interrupt Enable"]
# [inline (always)]
pub fn ckrdy (& self) -> CKRDY_R { CKRDY_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Clock Ready Interrupt Enable"]
# [inline (always)]
pub fn ckrdy (& mut self) -> CKRDY_W { CKRDY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenclr](index.html) module"]
pub struct INTENCLR_SPEC ; impl crate :: RegisterSpec for INTENCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenclr::R](R) reader structure"]
impl crate :: Readable for INTENCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenclr::W](W) writer structure"]
impl crate :: Writable for INTENCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENCLR to value 0"]
impl crate :: Resettable for INTENCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENSET register accessor: an alias for `Reg<INTENSET_SPEC>`"]
pub type INTENSET = crate :: Reg < intenset :: INTENSET_SPEC > ; # [doc = "Interrupt Enable Set"]
pub mod intenset { # [doc = "Register `INTENSET` reader"]
pub struct R (crate :: R < INTENSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENSET` writer"]
pub struct W (crate :: W < INTENSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `CKRDY` reader - Clock Ready Interrupt Enable"]
pub type CKRDY_R = crate :: BitReader < bool > ; # [doc = "Field `CKRDY` writer - Clock Ready Interrupt Enable"]
pub type CKRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 0 > ; impl R { # [doc = "Bit 0 - Clock Ready Interrupt Enable"]
# [inline (always)]
pub fn ckrdy (& self) -> CKRDY_R { CKRDY_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Clock Ready Interrupt Enable"]
# [inline (always)]
pub fn ckrdy (& mut self) -> CKRDY_W { CKRDY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenset](index.html) module"]
pub struct INTENSET_SPEC ; impl crate :: RegisterSpec for INTENSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenset::R](R) reader structure"]
impl crate :: Readable for INTENSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenset::W](W) writer structure"]
impl crate :: Writable for INTENSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENSET to value 0"]
impl crate :: Resettable for INTENSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTFLAG register accessor: an alias for `Reg<INTFLAG_SPEC>`"]
pub type INTFLAG = crate :: Reg < intflag :: INTFLAG_SPEC > ; # [doc = "Interrupt Flag Status and Clear"]
pub mod intflag { # [doc = "Register `INTFLAG` reader"]
pub struct R (crate :: R < INTFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAG` writer"]
pub struct W (crate :: W < INTFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `CKRDY` reader - Clock Ready"]
pub type CKRDY_R = crate :: BitReader < bool > ; # [doc = "Field `CKRDY` writer - Clock Ready"]
pub type CKRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 0 > ; impl R { # [doc = "Bit 0 - Clock Ready"]
# [inline (always)]
pub fn ckrdy (& self) -> CKRDY_R { CKRDY_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Clock Ready"]
# [inline (always)]
pub fn ckrdy (& mut self) -> CKRDY_W { CKRDY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflag](index.html) module"]
pub struct INTFLAG_SPEC ; impl crate :: RegisterSpec for INTFLAG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflag::R](R) reader structure"]
impl crate :: Readable for INTFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflag::W](W) writer structure"]
impl crate :: Writable for INTFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTFLAG to value 0"]
impl crate :: Resettable for INTFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "RCAUSE register accessor: an alias for `Reg<RCAUSE_SPEC>`"]
pub type RCAUSE = crate :: Reg < rcause :: RCAUSE_SPEC > ; # [doc = "Reset Cause"]
pub mod rcause { # [doc = "Register `RCAUSE` reader"]
pub struct R (crate :: R < RCAUSE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RCAUSE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RCAUSE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RCAUSE_SPEC >) -> Self { R (reader) } } # [doc = "Field `POR` reader - Power On Reset"]
pub type POR_R = crate :: BitReader < bool > ; # [doc = "Field `BOD12` reader - Brown Out 12 Detector Reset"]
pub type BOD12_R = crate :: BitReader < bool > ; # [doc = "Field `BOD33` reader - Brown Out 33 Detector Reset"]
pub type BOD33_R = crate :: BitReader < bool > ; # [doc = "Field `EXT` reader - External Reset"]
pub type EXT_R = crate :: BitReader < bool > ; # [doc = "Field `WDT` reader - Watchdog Reset"]
pub type WDT_R = crate :: BitReader < bool > ; # [doc = "Field `SYST` reader - System Reset Request"]
pub type SYST_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Power On Reset"]
# [inline (always)]
pub fn por (& self) -> POR_R { POR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Brown Out 12 Detector Reset"]
# [inline (always)]
pub fn bod12 (& self) -> BOD12_R { BOD12_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Brown Out 33 Detector Reset"]
# [inline (always)]
pub fn bod33 (& self) -> BOD33_R { BOD33_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 4 - External Reset"]
# [inline (always)]
pub fn ext (& self) -> EXT_R { EXT_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Watchdog Reset"]
# [inline (always)]
pub fn wdt (& self) -> WDT_R { WDT_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - System Reset Request"]
# [inline (always)]
pub fn syst (& self) -> SYST_R { SYST_R :: new (((self . bits >> 6) & 1) != 0) } } # [doc = "Reset Cause\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rcause](index.html) module"]
pub struct RCAUSE_SPEC ; impl crate :: RegisterSpec for RCAUSE_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rcause::R](R) reader structure"]
impl crate :: Readable for RCAUSE_SPEC { type Reader = R ; } # [doc = "`reset()` method sets RCAUSE to value 0x01"]
impl crate :: Resettable for RCAUSE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x01 } } } } # [doc = "Port Module"]
pub struct PORT { _marker : PhantomData < * const () > } unsafe impl Send for PORT { } impl PORT { # [doc = r"Pointer to the register block"]
pub const PTR : * const port :: RegisterBlock = 0x4100_4400 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const port :: RegisterBlock { Self :: PTR } } impl Deref for PORT { type Target = port :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORT { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORT") . finish () } } # [doc = "Port Module"]
pub mod port { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Data Direction"]
pub dir : [crate :: Reg < dir :: DIR_SPEC > ; 1]
, # [doc = "0x04 - Data Direction Clear"]
pub dirclr : [crate :: Reg < dirclr :: DIRCLR_SPEC > ; 1]
, # [doc = "0x08 - Data Direction Set"]
pub dirset : [crate :: Reg < dirset :: DIRSET_SPEC > ; 1]
, # [doc = "0x0c - Data Direction Toggle"]
pub dirtgl : [crate :: Reg < dirtgl :: DIRTGL_SPEC > ; 1]
, # [doc = "0x10 - Data Output Value"]
pub out : [crate :: Reg < out :: OUT_SPEC > ; 1]
, # [doc = "0x14 - Data Output Value Clear"]
pub outclr : [crate :: Reg < outclr :: OUTCLR_SPEC > ; 1]
, # [doc = "0x18 - Data Output Value Set"]
pub outset : [crate :: Reg < outset :: OUTSET_SPEC > ; 1]
, # [doc = "0x1c - Data Output Value Toggle"]
pub outtgl : [crate :: Reg < outtgl :: OUTTGL_SPEC > ; 1]
, # [doc = "0x20 - Data Input Value"]
pub in_ : [crate :: Reg < in_ :: IN_SPEC > ; 1]
, # [doc = "0x24 - Control"]
pub ctrl : [crate :: Reg < ctrl :: CTRL_SPEC > ; 1]
, # [doc = "0x28 - Write Configuration"]
pub wrconfig : [crate :: Reg < wrconfig :: WRCONFIG_SPEC > ; 1]
, _reserved11 : [u8 ; 0x04]
, # [doc = "0x30..0x40 - Peripheral Multiplexing n - Group 0"]
pub pmux0_ : [crate :: Reg < pmux0_ :: PMUX0__SPEC > ; 16]
, # [doc = "0x40..0x60 - Pin Configuration n - Group 0"]
pub pincfg0_ : [crate :: Reg < pincfg0_ :: PINCFG0__SPEC > ; 32]
, } # [doc = "DIR register accessor: an alias for `Reg<DIR_SPEC>`"]
pub type DIR = crate :: Reg < dir :: DIR_SPEC > ; # [doc = "Data Direction"]
pub mod dir { # [doc = "Register `DIR%s` reader"]
pub struct R (crate :: R < DIR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIR%s` writer"]
pub struct W (crate :: W < DIR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIR_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Port Data Direction"]
pub type DIR_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `DIR` writer - Port Data Direction"]
pub type DIR_W < 'a > = crate :: FieldWriter < 'a , u32 , DIR_SPEC , u32 , u32 , 32 , 0 > ; impl R { # [doc = "Bits 0:31 - Port Data Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Port Data Direction"]
# [inline (always)]
pub fn dir (& mut self) -> DIR_W { DIR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](index.html) module"]
pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [dir::R](R) reader structure"]
impl crate :: Readable for DIR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dir::W](W) writer structure"]
impl crate :: Writable for DIR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DIR%s to value 0"]
impl crate :: Resettable for DIR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DIRCLR register accessor: an alias for `Reg<DIRCLR_SPEC>`"]
pub type DIRCLR = crate :: Reg < dirclr :: DIRCLR_SPEC > ; # [doc = "Data Direction Clear"]
pub mod dirclr { # [doc = "Register `DIRCLR%s` reader"]
pub struct R (crate :: R < DIRCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRCLR%s` writer"]
pub struct W (crate :: W < DIRCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIRCLR` reader - Port Data Direction Clear"]
pub type DIRCLR_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `DIRCLR` writer - Port Data Direction Clear"]
pub type DIRCLR_W < 'a > = crate :: FieldWriter < 'a , u32 , DIRCLR_SPEC , u32 , u32 , 32 , 0 > ; impl R { # [doc = "Bits 0:31 - Port Data Direction Clear"]
# [inline (always)]
pub fn dirclr (& self) -> DIRCLR_R { DIRCLR_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Port Data Direction Clear"]
# [inline (always)]
pub fn dirclr (& mut self) -> DIRCLR_W { DIRCLR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirclr](index.html) module"]
pub struct DIRCLR_SPEC ; impl crate :: RegisterSpec for DIRCLR_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [dirclr::R](R) reader structure"]
impl crate :: Readable for DIRCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirclr::W](W) writer structure"]
impl crate :: Writable for DIRCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DIRCLR%s to value 0"]
impl crate :: Resettable for DIRCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DIRSET register accessor: an alias for `Reg<DIRSET_SPEC>`"]
pub type DIRSET = crate :: Reg < dirset :: DIRSET_SPEC > ; # [doc = "Data Direction Set"]
pub mod dirset { # [doc = "Register `DIRSET%s` reader"]
pub struct R (crate :: R < DIRSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRSET%s` writer"]
pub struct W (crate :: W < DIRSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIRSET` reader - Port Data Direction Set"]
pub type DIRSET_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `DIRSET` writer - Port Data Direction Set"]
pub type DIRSET_W < 'a > = crate :: FieldWriter < 'a , u32 , DIRSET_SPEC , u32 , u32 , 32 , 0 > ; impl R { # [doc = "Bits 0:31 - Port Data Direction Set"]
# [inline (always)]
pub fn dirset (& self) -> DIRSET_R { DIRSET_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Port Data Direction Set"]
# [inline (always)]
pub fn dirset (& mut self) -> DIRSET_W { DIRSET_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirset](index.html) module"]
pub struct DIRSET_SPEC ; impl crate :: RegisterSpec for DIRSET_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [dirset::R](R) reader structure"]
impl crate :: Readable for DIRSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirset::W](W) writer structure"]
impl crate :: Writable for DIRSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DIRSET%s to value 0"]
impl crate :: Resettable for DIRSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DIRTGL register accessor: an alias for `Reg<DIRTGL_SPEC>`"]
pub type DIRTGL = crate :: Reg < dirtgl :: DIRTGL_SPEC > ; # [doc = "Data Direction Toggle"]
pub mod dirtgl { # [doc = "Register `DIRTGL%s` reader"]
pub struct R (crate :: R < DIRTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DIRTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DIRTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DIRTGL%s` writer"]
pub struct W (crate :: W < DIRTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DIRTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DIRTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DIRTGL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIRTGL` reader - Port Data Direction Toggle"]
pub type DIRTGL_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `DIRTGL` writer - Port Data Direction Toggle"]
pub type DIRTGL_W < 'a > = crate :: FieldWriter < 'a , u32 , DIRTGL_SPEC , u32 , u32 , 32 , 0 > ; impl R { # [doc = "Bits 0:31 - Port Data Direction Toggle"]
# [inline (always)]
pub fn dirtgl (& self) -> DIRTGL_R { DIRTGL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Port Data Direction Toggle"]
# [inline (always)]
pub fn dirtgl (& mut self) -> DIRTGL_W { DIRTGL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Direction Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dirtgl](index.html) module"]
pub struct DIRTGL_SPEC ; impl crate :: RegisterSpec for DIRTGL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [dirtgl::R](R) reader structure"]
impl crate :: Readable for DIRTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dirtgl::W](W) writer structure"]
impl crate :: Writable for DIRTGL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DIRTGL%s to value 0"]
impl crate :: Resettable for DIRTGL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "OUT register accessor: an alias for `Reg<OUT_SPEC>`"]
pub type OUT = crate :: Reg < out :: OUT_SPEC > ; # [doc = "Data Output Value"]
pub mod out { # [doc = "Register `OUT%s` reader"]
pub struct R (crate :: R < OUT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUT_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUT%s` writer"]
pub struct W (crate :: W < OUT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUT_SPEC >) -> Self { W (writer) } } # [doc = "Field `OUT` reader - Port Data Output Value"]
pub type OUT_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `OUT` writer - Port Data Output Value"]
pub type OUT_W < 'a > = crate :: FieldWriter < 'a , u32 , OUT_SPEC , u32 , u32 , 32 , 0 > ; impl R { # [doc = "Bits 0:31 - Port Data Output Value"]
# [inline (always)]
pub fn out (& self) -> OUT_R { OUT_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Port Data Output Value"]
# [inline (always)]
pub fn out (& mut self) -> OUT_W { OUT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Output Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out](index.html) module"]
pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [out::R](R) reader structure"]
impl crate :: Readable for OUT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [out::W](W) writer structure"]
impl crate :: Writable for OUT_SPEC { type Writer = W ; } # [doc = "`reset()` method sets OUT%s to value 0"]
impl crate :: Resettable for OUT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "OUTCLR register accessor: an alias for `Reg<OUTCLR_SPEC>`"]
pub type OUTCLR = crate :: Reg < outclr :: OUTCLR_SPEC > ; # [doc = "Data Output Value Clear"]
pub mod outclr { # [doc = "Register `OUTCLR%s` reader"]
pub struct R (crate :: R < OUTCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTCLR%s` writer"]
pub struct W (crate :: W < OUTCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `OUTCLR` reader - Port Data Output Value Clear"]
pub type OUTCLR_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `OUTCLR` writer - Port Data Output Value Clear"]
pub type OUTCLR_W < 'a > = crate :: FieldWriter < 'a , u32 , OUTCLR_SPEC , u32 , u32 , 32 , 0 > ; impl R { # [doc = "Bits 0:31 - Port Data Output Value Clear"]
# [inline (always)]
pub fn outclr (& self) -> OUTCLR_R { OUTCLR_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Port Data Output Value Clear"]
# [inline (always)]
pub fn outclr (& mut self) -> OUTCLR_W { OUTCLR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Output Value Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outclr](index.html) module"]
pub struct OUTCLR_SPEC ; impl crate :: RegisterSpec for OUTCLR_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [outclr::R](R) reader structure"]
impl crate :: Readable for OUTCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outclr::W](W) writer structure"]
impl crate :: Writable for OUTCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets OUTCLR%s to value 0"]
impl crate :: Resettable for OUTCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "OUTSET register accessor: an alias for `Reg<OUTSET_SPEC>`"]
pub type OUTSET = crate :: Reg < outset :: OUTSET_SPEC > ; # [doc = "Data Output Value Set"]
pub mod outset { # [doc = "Register `OUTSET%s` reader"]
pub struct R (crate :: R < OUTSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTSET%s` writer"]
pub struct W (crate :: W < OUTSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `OUTSET` reader - Port Data Output Value Set"]
pub type OUTSET_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `OUTSET` writer - Port Data Output Value Set"]
pub type OUTSET_W < 'a > = crate :: FieldWriter < 'a , u32 , OUTSET_SPEC , u32 , u32 , 32 , 0 > ; impl R { # [doc = "Bits 0:31 - Port Data Output Value Set"]
# [inline (always)]
pub fn outset (& self) -> OUTSET_R { OUTSET_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Port Data Output Value Set"]
# [inline (always)]
pub fn outset (& mut self) -> OUTSET_W { OUTSET_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Output Value Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outset](index.html) module"]
pub struct OUTSET_SPEC ; impl crate :: RegisterSpec for OUTSET_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [outset::R](R) reader structure"]
impl crate :: Readable for OUTSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outset::W](W) writer structure"]
impl crate :: Writable for OUTSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets OUTSET%s to value 0"]
impl crate :: Resettable for OUTSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "OUTTGL register accessor: an alias for `Reg<OUTTGL_SPEC>`"]
pub type OUTTGL = crate :: Reg < outtgl :: OUTTGL_SPEC > ; # [doc = "Data Output Value Toggle"]
pub mod outtgl { # [doc = "Register `OUTTGL%s` reader"]
pub struct R (crate :: R < OUTTGL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OUTTGL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OUTTGL_SPEC >) -> Self { R (reader) } } # [doc = "Register `OUTTGL%s` writer"]
pub struct W (crate :: W < OUTTGL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OUTTGL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OUTTGL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OUTTGL_SPEC >) -> Self { W (writer) } } # [doc = "Field `OUTTGL` reader - Port Data Output Value Toggle"]
pub type OUTTGL_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `OUTTGL` writer - Port Data Output Value Toggle"]
pub type OUTTGL_W < 'a > = crate :: FieldWriter < 'a , u32 , OUTTGL_SPEC , u32 , u32 , 32 , 0 > ; impl R { # [doc = "Bits 0:31 - Port Data Output Value Toggle"]
# [inline (always)]
pub fn outtgl (& self) -> OUTTGL_R { OUTTGL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Port Data Output Value Toggle"]
# [inline (always)]
pub fn outtgl (& mut self) -> OUTTGL_W { OUTTGL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Data Output Value Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [outtgl](index.html) module"]
pub struct OUTTGL_SPEC ; impl crate :: RegisterSpec for OUTTGL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [outtgl::R](R) reader structure"]
impl crate :: Readable for OUTTGL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [outtgl::W](W) writer structure"]
impl crate :: Writable for OUTTGL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets OUTTGL%s to value 0"]
impl crate :: Resettable for OUTTGL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "IN register accessor: an alias for `Reg<IN_SPEC>`"]
pub type IN = crate :: Reg < in_ :: IN_SPEC > ; # [doc = "Data Input Value"]
pub mod in_ { # [doc = "Register `IN%s` reader"]
pub struct R (crate :: R < IN_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < IN_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < IN_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < IN_SPEC >) -> Self { R (reader) } } # [doc = "Field `IN` reader - Port Data Input Value"]
pub type IN_R = crate :: FieldReader < u32 , u32 > ; impl R { # [doc = "Bits 0:31 - Port Data Input Value"]
# [inline (always)]
pub fn in_ (& self) -> IN_R { IN_R :: new (self . bits) } } # [doc = "Data Input Value\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [in_](index.html) module"]
pub struct IN_SPEC ; impl crate :: RegisterSpec for IN_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [in_::R](R) reader structure"]
impl crate :: Readable for IN_SPEC { type Reader = R ; } # [doc = "`reset()` method sets IN%s to value 0"]
impl crate :: Resettable for IN_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CTRL register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control"]
pub mod ctrl { # [doc = "Register `CTRL%s` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL%s` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SAMPLING` writer - Input Sampling Mode"]
pub type SAMPLING_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRL_SPEC , u32 , u32 , 32 , 0 > ; impl W { # [doc = "Bits 0:31 - Input Sampling Mode"]
# [inline (always)]
pub fn sampling (& mut self) -> SAMPLING_W { SAMPLING_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRL%s to value 0"]
impl crate :: Resettable for CTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "WRCONFIG register accessor: an alias for `Reg<WRCONFIG_SPEC>`"]
pub type WRCONFIG = crate :: Reg < wrconfig :: WRCONFIG_SPEC > ; # [doc = "Write Configuration"]
pub mod wrconfig { # [doc = "Register `WRCONFIG%s` writer"]
pub struct W (crate :: W < WRCONFIG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < WRCONFIG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < WRCONFIG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < WRCONFIG_SPEC >) -> Self { W (writer) } } # [doc = "Field `PINMASK` writer - Pin Mask for Multiple Pin Configuration"]
pub type PINMASK_W < 'a > = crate :: FieldWriter < 'a , u32 , WRCONFIG_SPEC , u16 , u16 , 16 , 0 > ; # [doc = "Field `PMUXEN` writer - Peripheral Multiplexer Enable"]
pub type PMUXEN_W < 'a > = crate :: BitWriter < 'a , u32 , WRCONFIG_SPEC , bool , 16 > ; # [doc = "Field `INEN` writer - Input Enable"]
pub type INEN_W < 'a > = crate :: BitWriter < 'a , u32 , WRCONFIG_SPEC , bool , 17 > ; # [doc = "Field `PULLEN` writer - Pull Enable"]
pub type PULLEN_W < 'a > = crate :: BitWriter < 'a , u32 , WRCONFIG_SPEC , bool , 18 > ; # [doc = "Field `DRVSTR` writer - Output Driver Strength Selection"]
pub type DRVSTR_W < 'a > = crate :: BitWriter < 'a , u32 , WRCONFIG_SPEC , bool , 22 > ; # [doc = "Field `PMUX` writer - Peripheral Multiplexing"]
pub type PMUX_W < 'a > = crate :: FieldWriter < 'a , u32 , WRCONFIG_SPEC , u8 , u8 , 4 , 24 > ; # [doc = "Field `WRPMUX` writer - Write PMUX"]
pub type WRPMUX_W < 'a > = crate :: BitWriter < 'a , u32 , WRCONFIG_SPEC , bool , 28 > ; # [doc = "Field `WRPINCFG` writer - Write PINCFG"]
pub type WRPINCFG_W < 'a > = crate :: BitWriter < 'a , u32 , WRCONFIG_SPEC , bool , 30 > ; # [doc = "Field `HWSEL` writer - Half-Word Select"]
pub type HWSEL_W < 'a > = crate :: BitWriter < 'a , u32 , WRCONFIG_SPEC , bool , 31 > ; impl W { # [doc = "Bits 0:15 - Pin Mask for Multiple Pin Configuration"]
# [inline (always)]
pub fn pinmask (& mut self) -> PINMASK_W { PINMASK_W :: new (self) } # [doc = "Bit 16 - Peripheral Multiplexer Enable"]
# [inline (always)]
pub fn pmuxen (& mut self) -> PMUXEN_W { PMUXEN_W :: new (self) } # [doc = "Bit 17 - Input Enable"]
# [inline (always)]
pub fn inen (& mut self) -> INEN_W { INEN_W :: new (self) } # [doc = "Bit 18 - Pull Enable"]
# [inline (always)]
pub fn pullen (& mut self) -> PULLEN_W { PULLEN_W :: new (self) } # [doc = "Bit 22 - Output Driver Strength Selection"]
# [inline (always)]
pub fn drvstr (& mut self) -> DRVSTR_W { DRVSTR_W :: new (self) } # [doc = "Bits 24:27 - Peripheral Multiplexing"]
# [inline (always)]
pub fn pmux (& mut self) -> PMUX_W { PMUX_W :: new (self) } # [doc = "Bit 28 - Write PMUX"]
# [inline (always)]
pub fn wrpmux (& mut self) -> WRPMUX_W { WRPMUX_W :: new (self) } # [doc = "Bit 30 - Write PINCFG"]
# [inline (always)]
pub fn wrpincfg (& mut self) -> WRPINCFG_W { WRPINCFG_W :: new (self) } # [doc = "Bit 31 - Half-Word Select"]
# [inline (always)]
pub fn hwsel (& mut self) -> HWSEL_W { HWSEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Write Configuration\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [wrconfig](index.html) module"]
pub struct WRCONFIG_SPEC ; impl crate :: RegisterSpec for WRCONFIG_SPEC { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [wrconfig::W](W) writer structure"]
impl crate :: Writable for WRCONFIG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets WRCONFIG%s to value 0"]
impl crate :: Resettable for WRCONFIG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PMUX0_ register accessor: an alias for `Reg<PMUX0__SPEC>`"]
pub type PMUX0_ = crate :: Reg < pmux0_ :: PMUX0__SPEC > ; # [doc = "Peripheral Multiplexing n - Group 0"]
pub mod pmux0_ { # [doc = "Register `PMUX0_%s` reader"]
pub struct R (crate :: R < PMUX0__SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PMUX0__SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PMUX0__SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PMUX0__SPEC >) -> Self { R (reader) } } # [doc = "Register `PMUX0_%s` writer"]
pub struct W (crate :: W < PMUX0__SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PMUX0__SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PMUX0__SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PMUX0__SPEC >) -> Self { W (writer) } } # [doc = "Peripheral Multiplexing Even\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum PMUXE_A { # [doc = "0: Peripheral function A selected"]
A = 0 , # [doc = "1: Peripheral function B selected"]
B = 1 , # [doc = "2: Peripheral function C selected"]
C = 2 , # [doc = "3: Peripheral function D selected"]
D = 3 , # [doc = "4: Peripheral function E selected"]
E = 4 , # [doc = "5: Peripheral function F selected"]
F = 5 , # [doc = "6: Peripheral function G selected"]
G = 6 , # [doc = "7: Peripheral function H selected"]
H = 7 , } impl From < PMUXE_A > for u8 { # [inline (always)]
fn from (variant : PMUXE_A) -> Self { variant as _ } } # [doc = "Field `PMUXE` reader - Peripheral Multiplexing Even"]
pub type PMUXE_R = crate :: FieldReader < u8 , PMUXE_A > ; impl PMUXE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PMUXE_A > { match self . bits { 0 => Some (PMUXE_A :: A) , 1 => Some (PMUXE_A :: B) , 2 => Some (PMUXE_A :: C) , 3 => Some (PMUXE_A :: D) , 4 => Some (PMUXE_A :: E) , 5 => Some (PMUXE_A :: F) , 6 => Some (PMUXE_A :: G) , 7 => Some (PMUXE_A :: H) , _ => None , } } # [doc = "Checks if the value of the field is `A`"]
# [inline (always)]
pub fn is_a (& self) -> bool { * self == PMUXE_A :: A } # [doc = "Checks if the value of the field is `B`"]
# [inline (always)]
pub fn is_b (& self) -> bool { * self == PMUXE_A :: B } # [doc = "Checks if the value of the field is `C`"]
# [inline (always)]
pub fn is_c (& self) -> bool { * self == PMUXE_A :: C } # [doc = "Checks if the value of the field is `D`"]
# [inline (always)]
pub fn is_d (& self) -> bool { * self == PMUXE_A :: D } # [doc = "Checks if the value of the field is `E`"]
# [inline (always)]
pub fn is_e (& self) -> bool { * self == PMUXE_A :: E } # [doc = "Checks if the value of the field is `F`"]
# [inline (always)]
pub fn is_f (& self) -> bool { * self == PMUXE_A :: F } # [doc = "Checks if the value of the field is `G`"]
# [inline (always)]
pub fn is_g (& self) -> bool { * self == PMUXE_A :: G } # [doc = "Checks if the value of the field is `H`"]
# [inline (always)]
pub fn is_h (& self) -> bool { * self == PMUXE_A :: H } } # [doc = "Field `PMUXE` writer - Peripheral Multiplexing Even"]
pub type PMUXE_W < 'a > = crate :: FieldWriter < 'a , u8 , PMUX0__SPEC , u8 , PMUXE_A , 4 , 0 > ; impl < 'a > PMUXE_W < 'a > { # [doc = "Peripheral function A selected"]
# [inline (always)]
pub fn a (self) -> & 'a mut W { self . variant (PMUXE_A :: A) } # [doc = "Peripheral function B selected"]
# [inline (always)]
pub fn b (self) -> & 'a mut W { self . variant (PMUXE_A :: B) } # [doc = "Peripheral function C selected"]
# [inline (always)]
pub fn c (self) -> & 'a mut W { self . variant (PMUXE_A :: C) } # [doc = "Peripheral function D selected"]
# [inline (always)]
pub fn d (self) -> & 'a mut W { self . variant (PMUXE_A :: D) } # [doc = "Peripheral function E selected"]
# [inline (always)]
pub fn e (self) -> & 'a mut W { self . variant (PMUXE_A :: E) } # [doc = "Peripheral function F selected"]
# [inline (always)]
pub fn f (self) -> & 'a mut W { self . variant (PMUXE_A :: F) } # [doc = "Peripheral function G selected"]
# [inline (always)]
pub fn g (self) -> & 'a mut W { self . variant (PMUXE_A :: G) } # [doc = "Peripheral function H selected"]
# [inline (always)]
pub fn h (self) -> & 'a mut W { self . variant (PMUXE_A :: H) } } # [doc = "Peripheral Multiplexing Odd\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum PMUXO_A { # [doc = "0: Peripheral function A selected"]
A = 0 , # [doc = "1: Peripheral function B selected"]
B = 1 , # [doc = "2: Peripheral function C selected"]
C = 2 , # [doc = "3: Peripheral function D selected"]
D = 3 , # [doc = "4: Peripheral function E selected"]
E = 4 , # [doc = "5: Peripheral function F selected"]
F = 5 , # [doc = "6: Peripheral function G selected"]
G = 6 , # [doc = "7: Peripheral function H selected"]
H = 7 , } impl From < PMUXO_A > for u8 { # [inline (always)]
fn from (variant : PMUXO_A) -> Self { variant as _ } } # [doc = "Field `PMUXO` reader - Peripheral Multiplexing Odd"]
pub type PMUXO_R = crate :: FieldReader < u8 , PMUXO_A > ; impl PMUXO_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PMUXO_A > { match self . bits { 0 => Some (PMUXO_A :: A) , 1 => Some (PMUXO_A :: B) , 2 => Some (PMUXO_A :: C) , 3 => Some (PMUXO_A :: D) , 4 => Some (PMUXO_A :: E) , 5 => Some (PMUXO_A :: F) , 6 => Some (PMUXO_A :: G) , 7 => Some (PMUXO_A :: H) , _ => None , } } # [doc = "Checks if the value of the field is `A`"]
# [inline (always)]
pub fn is_a (& self) -> bool { * self == PMUXO_A :: A } # [doc = "Checks if the value of the field is `B`"]
# [inline (always)]
pub fn is_b (& self) -> bool { * self == PMUXO_A :: B } # [doc = "Checks if the value of the field is `C`"]
# [inline (always)]
pub fn is_c (& self) -> bool { * self == PMUXO_A :: C } # [doc = "Checks if the value of the field is `D`"]
# [inline (always)]
pub fn is_d (& self) -> bool { * self == PMUXO_A :: D } # [doc = "Checks if the value of the field is `E`"]
# [inline (always)]
pub fn is_e (& self) -> bool { * self == PMUXO_A :: E } # [doc = "Checks if the value of the field is `F`"]
# [inline (always)]
pub fn is_f (& self) -> bool { * self == PMUXO_A :: F } # [doc = "Checks if the value of the field is `G`"]
# [inline (always)]
pub fn is_g (& self) -> bool { * self == PMUXO_A :: G } # [doc = "Checks if the value of the field is `H`"]
# [inline (always)]
pub fn is_h (& self) -> bool { * self == PMUXO_A :: H } } # [doc = "Field `PMUXO` writer - Peripheral Multiplexing Odd"]
pub type PMUXO_W < 'a > = crate :: FieldWriter < 'a , u8 , PMUX0__SPEC , u8 , PMUXO_A , 4 , 4 > ; impl < 'a > PMUXO_W < 'a > { # [doc = "Peripheral function A selected"]
# [inline (always)]
pub fn a (self) -> & 'a mut W { self . variant (PMUXO_A :: A) } # [doc = "Peripheral function B selected"]
# [inline (always)]
pub fn b (self) -> & 'a mut W { self . variant (PMUXO_A :: B) } # [doc = "Peripheral function C selected"]
# [inline (always)]
pub fn c (self) -> & 'a mut W { self . variant (PMUXO_A :: C) } # [doc = "Peripheral function D selected"]
# [inline (always)]
pub fn d (self) -> & 'a mut W { self . variant (PMUXO_A :: D) } # [doc = "Peripheral function E selected"]
# [inline (always)]
pub fn e (self) -> & 'a mut W { self . variant (PMUXO_A :: E) } # [doc = "Peripheral function F selected"]
# [inline (always)]
pub fn f (self) -> & 'a mut W { self . variant (PMUXO_A :: F) } # [doc = "Peripheral function G selected"]
# [inline (always)]
pub fn g (self) -> & 'a mut W { self . variant (PMUXO_A :: G) } # [doc = "Peripheral function H selected"]
# [inline (always)]
pub fn h (self) -> & 'a mut W { self . variant (PMUXO_A :: H) } } impl R { # [doc = "Bits 0:3 - Peripheral Multiplexing Even"]
# [inline (always)]
pub fn pmuxe (& self) -> PMUXE_R { PMUXE_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bits 4:7 - Peripheral Multiplexing Odd"]
# [inline (always)]
pub fn pmuxo (& self) -> PMUXO_R { PMUXO_R :: new (((self . bits >> 4) & 0x0f) as u8) } } impl W { # [doc = "Bits 0:3 - Peripheral Multiplexing Even"]
# [inline (always)]
pub fn pmuxe (& mut self) -> PMUXE_W { PMUXE_W :: new (self) } # [doc = "Bits 4:7 - Peripheral Multiplexing Odd"]
# [inline (always)]
pub fn pmuxo (& mut self) -> PMUXO_W { PMUXO_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Peripheral Multiplexing n - Group 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pmux0_](index.html) module"]
pub struct PMUX0__SPEC ; impl crate :: RegisterSpec for PMUX0__SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pmux0_::R](R) reader structure"]
impl crate :: Readable for PMUX0__SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pmux0_::W](W) writer structure"]
impl crate :: Writable for PMUX0__SPEC { type Writer = W ; } # [doc = "`reset()` method sets PMUX0_%s to value 0"]
impl crate :: Resettable for PMUX0__SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PINCFG0_ register accessor: an alias for `Reg<PINCFG0__SPEC>`"]
pub type PINCFG0_ = crate :: Reg < pincfg0_ :: PINCFG0__SPEC > ; # [doc = "Pin Configuration n - Group 0"]
pub mod pincfg0_ { # [doc = "Register `PINCFG0_%s` reader"]
pub struct R (crate :: R < PINCFG0__SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PINCFG0__SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PINCFG0__SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PINCFG0__SPEC >) -> Self { R (reader) } } # [doc = "Register `PINCFG0_%s` writer"]
pub struct W (crate :: W < PINCFG0__SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PINCFG0__SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PINCFG0__SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PINCFG0__SPEC >) -> Self { W (writer) } } # [doc = "Field `PMUXEN` reader - Peripheral Multiplexer Enable"]
pub type PMUXEN_R = crate :: BitReader < bool > ; # [doc = "Field `PMUXEN` writer - Peripheral Multiplexer Enable"]
pub type PMUXEN_W < 'a > = crate :: BitWriter < 'a , u8 , PINCFG0__SPEC , bool , 0 > ; # [doc = "Field `INEN` reader - Input Enable"]
pub type INEN_R = crate :: BitReader < bool > ; # [doc = "Field `INEN` writer - Input Enable"]
pub type INEN_W < 'a > = crate :: BitWriter < 'a , u8 , PINCFG0__SPEC , bool , 1 > ; # [doc = "Field `PULLEN` reader - Pull Enable"]
pub type PULLEN_R = crate :: BitReader < bool > ; # [doc = "Field `PULLEN` writer - Pull Enable"]
pub type PULLEN_W < 'a > = crate :: BitWriter < 'a , u8 , PINCFG0__SPEC , bool , 2 > ; # [doc = "Field `DRVSTR` writer - Output Driver Strength Selection"]
pub type DRVSTR_W < 'a > = crate :: BitWriter < 'a , u8 , PINCFG0__SPEC , bool , 6 > ; impl R { # [doc = "Bit 0 - Peripheral Multiplexer Enable"]
# [inline (always)]
pub fn pmuxen (& self) -> PMUXEN_R { PMUXEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Input Enable"]
# [inline (always)]
pub fn inen (& self) -> INEN_R { INEN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pull Enable"]
# [inline (always)]
pub fn pullen (& self) -> PULLEN_R { PULLEN_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Peripheral Multiplexer Enable"]
# [inline (always)]
pub fn pmuxen (& mut self) -> PMUXEN_W { PMUXEN_W :: new (self) } # [doc = "Bit 1 - Input Enable"]
# [inline (always)]
pub fn inen (& mut self) -> INEN_W { INEN_W :: new (self) } # [doc = "Bit 2 - Pull Enable"]
# [inline (always)]
pub fn pullen (& mut self) -> PULLEN_W { PULLEN_W :: new (self) } # [doc = "Bit 6 - Output Driver Strength Selection"]
# [inline (always)]
pub fn drvstr (& mut self) -> DRVSTR_W { DRVSTR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pin Configuration n - Group 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pincfg0_](index.html) module"]
pub struct PINCFG0__SPEC ; impl crate :: RegisterSpec for PINCFG0__SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pincfg0_::R](R) reader structure"]
impl crate :: Readable for PINCFG0__SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pincfg0_::W](W) writer structure"]
impl crate :: Writable for PINCFG0__SPEC { type Writer = W ; } # [doc = "`reset()` method sets PINCFG0_%s to value 0"]
impl crate :: Resettable for PINCFG0__SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "Port Module (IOBUS)"]
pub struct PORT_IOBUS { _marker : PhantomData < * const () > } unsafe impl Send for PORT_IOBUS { } impl PORT_IOBUS { # [doc = r"Pointer to the register block"]
pub const PTR : * const port :: RegisterBlock = 0x6000_0000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const port :: RegisterBlock { Self :: PTR } } impl Deref for PORT_IOBUS { type Target = port :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PORT_IOBUS { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PORT_IOBUS") . finish () } } # [doc = "Port Module (IOBUS)"]
pub use port as port_iobus ; # [doc = "Real-Time Counter"]
pub struct RTC { _marker : PhantomData < * const () > } unsafe impl Send for RTC { } impl RTC { # [doc = r"Pointer to the register block"]
pub const PTR : * const rtc :: RegisterBlock = 0x4000_1400 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const rtc :: RegisterBlock { Self :: PTR } } impl Deref for RTC { type Target = rtc :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for RTC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("RTC") . finish () } } # [doc = "Real-Time Counter"]
pub mod rtc { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { _reserved_0_mode0 : [u8 ; 0x1d]
, } impl RegisterBlock { # [doc = "0x00..0x1d - Clock/Calendar with Alarm"]
# [inline (always)]
pub fn mode2 (& self) -> & MODE2 { unsafe { & * (((self as * const Self) as * const u8) . add (0usize) as * const MODE2) } } # [doc = "0x00..0x1c - 16-bit Counter with Two 16-bit Compares"]
# [inline (always)]
pub fn mode1 (& self) -> & MODE1 { unsafe { & * (((self as * const Self) as * const u8) . add (0usize) as * const MODE1) } } # [doc = "0x00..0x1c - 32-bit Counter with Single 32-bit Compare"]
# [inline (always)]
pub fn mode0 (& self) -> & MODE0 { unsafe { & * (((self as * const Self) as * const u8) . add (0usize) as * const MODE0) } } } # [doc = r"Register block"]
# [repr (C)]
pub struct MODE0 { # [doc = "0x00 - MODE0 Control"]
pub ctrl : crate :: Reg < self :: mode0 :: ctrl :: CTRL_SPEC > , # [doc = "0x02 - Read Request"]
pub readreq : crate :: Reg < self :: mode0 :: readreq :: READREQ_SPEC > , # [doc = "0x04 - MODE0 Event Control"]
pub evctrl : crate :: Reg < self :: mode0 :: evctrl :: EVCTRL_SPEC > , # [doc = "0x06 - MODE0 Interrupt Enable Clear"]
pub intenclr : crate :: Reg < self :: mode0 :: intenclr :: INTENCLR_SPEC > , # [doc = "0x07 - MODE0 Interrupt Enable Set"]
pub intenset : crate :: Reg < self :: mode0 :: intenset :: INTENSET_SPEC > , # [doc = "0x08 - MODE0 Interrupt Flag Status and Clear"]
pub intflag : crate :: Reg < self :: mode0 :: intflag :: INTFLAG_SPEC > , _reserved6 : [u8 ; 0x01]
, # [doc = "0x0a - Status"]
pub status : crate :: Reg < self :: mode0 :: status :: STATUS_SPEC > , # [doc = "0x0b - Debug Control"]
pub dbgctrl : crate :: Reg < self :: mode0 :: dbgctrl :: DBGCTRL_SPEC > , # [doc = "0x0c - Frequency Correction"]
pub freqcorr : crate :: Reg < self :: mode0 :: freqcorr :: FREQCORR_SPEC > , _reserved9 : [u8 ; 0x03]
, # [doc = "0x10 - MODE0 Counter Value"]
pub count : crate :: Reg < self :: mode0 :: count :: COUNT_SPEC > , _reserved10 : [u8 ; 0x04]
, # [doc = "0x18 - MODE0 Compare n Value"]
pub comp : [crate :: Reg < self :: mode0 :: comp :: COMP_SPEC > ; 1]
, } # [doc = r"Register block"]
# [doc = "32-bit Counter with Single 32-bit Compare"]
pub mod mode0 { # [doc = "CTRL register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "MODE0 Control"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWRST` writer - Software Reset"]
pub type SWRST_W < 'a > = crate :: BitWriter < 'a , u16 , CTRL_SPEC , bool , 0 > ; # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u16 , CTRL_SPEC , bool , 1 > ; # [doc = "Operating Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum MODE_A { # [doc = "0: Mode 0: 32-bit Counter"]
COUNT32 = 0 , # [doc = "1: Mode 1: 16-bit Counter"]
COUNT16 = 1 , # [doc = "2: Mode 2: Clock/Calendar"]
CLOCK = 2 , } impl From < MODE_A > for u8 { # [inline (always)]
fn from (variant : MODE_A) -> Self { variant as _ } } # [doc = "Field `MODE` reader - Operating Mode"]
pub type MODE_R = crate :: FieldReader < u8 , MODE_A > ; impl MODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < MODE_A > { match self . bits { 0 => Some (MODE_A :: COUNT32) , 1 => Some (MODE_A :: COUNT16) , 2 => Some (MODE_A :: CLOCK) , _ => None , } } # [doc = "Checks if the value of the field is `COUNT32`"]
# [inline (always)]
pub fn is_count32 (& self) -> bool { * self == MODE_A :: COUNT32 } # [doc = "Checks if the value of the field is `COUNT16`"]
# [inline (always)]
pub fn is_count16 (& self) -> bool { * self == MODE_A :: COUNT16 } # [doc = "Checks if the value of the field is `CLOCK`"]
# [inline (always)]
pub fn is_clock (& self) -> bool { * self == MODE_A :: CLOCK } } # [doc = "Field `MODE` writer - Operating Mode"]
pub type MODE_W < 'a > = crate :: FieldWriter < 'a , u16 , CTRL_SPEC , u8 , MODE_A , 2 , 2 > ; impl < 'a > MODE_W < 'a > { # [doc = "Mode 0: 32-bit Counter"]
# [inline (always)]
pub fn count32 (self) -> & 'a mut W { self . variant (MODE_A :: COUNT32) } # [doc = "Mode 1: 16-bit Counter"]
# [inline (always)]
pub fn count16 (self) -> & 'a mut W { self . variant (MODE_A :: COUNT16) } # [doc = "Mode 2: Clock/Calendar"]
# [inline (always)]
pub fn clock (self) -> & 'a mut W { self . variant (MODE_A :: CLOCK) } } # [doc = "Field `MATCHCLR` reader - Clear on Match"]
pub type MATCHCLR_R = crate :: BitReader < bool > ; # [doc = "Field `MATCHCLR` writer - Clear on Match"]
pub type MATCHCLR_W < 'a > = crate :: BitWriter < 'a , u16 , CTRL_SPEC , bool , 7 > ; # [doc = "Prescaler\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum PRESCALER_A { # [doc = "0: CLK_RTC_CNT = GCLK_RTC/1"]
DIV1 = 0 , # [doc = "1: CLK_RTC_CNT = GCLK_RTC/2"]
DIV2 = 1 , # [doc = "2: CLK_RTC_CNT = GCLK_RTC/4"]
DIV4 = 2 , # [doc = "3: CLK_RTC_CNT = GCLK_RTC/8"]
DIV8 = 3 , # [doc = "4: CLK_RTC_CNT = GCLK_RTC/16"]
DIV16 = 4 , # [doc = "5: CLK_RTC_CNT = GCLK_RTC/32"]
DIV32 = 5 , # [doc = "6: CLK_RTC_CNT = GCLK_RTC/64"]
DIV64 = 6 , # [doc = "7: CLK_RTC_CNT = GCLK_RTC/128"]
DIV128 = 7 , # [doc = "8: CLK_RTC_CNT = GCLK_RTC/256"]
DIV256 = 8 , # [doc = "9: CLK_RTC_CNT = GCLK_RTC/512"]
DIV512 = 9 , # [doc = "10: CLK_RTC_CNT = GCLK_RTC/1024"]
DIV1024 = 10 , } impl From < PRESCALER_A > for u8 { # [inline (always)]
fn from (variant : PRESCALER_A) -> Self { variant as _ } } # [doc = "Field `PRESCALER` reader - Prescaler"]
pub type PRESCALER_R = crate :: FieldReader < u8 , PRESCALER_A > ; impl PRESCALER_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PRESCALER_A > { match self . bits { 0 => Some (PRESCALER_A :: DIV1) , 1 => Some (PRESCALER_A :: DIV2) , 2 => Some (PRESCALER_A :: DIV4) , 3 => Some (PRESCALER_A :: DIV8) , 4 => Some (PRESCALER_A :: DIV16) , 5 => Some (PRESCALER_A :: DIV32) , 6 => Some (PRESCALER_A :: DIV64) , 7 => Some (PRESCALER_A :: DIV128) , 8 => Some (PRESCALER_A :: DIV256) , 9 => Some (PRESCALER_A :: DIV512) , 10 => Some (PRESCALER_A :: DIV1024) , _ => None , } } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == PRESCALER_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == PRESCALER_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == PRESCALER_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == PRESCALER_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == PRESCALER_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV32`"]
# [inline (always)]
pub fn is_div32 (& self) -> bool { * self == PRESCALER_A :: DIV32 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == PRESCALER_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV128`"]
# [inline (always)]
pub fn is_div128 (& self) -> bool { * self == PRESCALER_A :: DIV128 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == PRESCALER_A :: DIV256 } # [doc = "Checks if the value of the field is `DIV512`"]
# [inline (always)]
pub fn is_div512 (& self) -> bool { * self == PRESCALER_A :: DIV512 } # [doc = "Checks if the value of the field is `DIV1024`"]
# [inline (always)]
pub fn is_div1024 (& self) -> bool { * self == PRESCALER_A :: DIV1024 } } # [doc = "Field `PRESCALER` writer - Prescaler"]
pub type PRESCALER_W < 'a > = crate :: FieldWriter < 'a , u16 , CTRL_SPEC , u8 , PRESCALER_A , 4 , 8 > ; impl < 'a > PRESCALER_W < 'a > { # [doc = "CLK_RTC_CNT = GCLK_RTC/1"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV1) } # [doc = "CLK_RTC_CNT = GCLK_RTC/2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV2) } # [doc = "CLK_RTC_CNT = GCLK_RTC/4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV4) } # [doc = "CLK_RTC_CNT = GCLK_RTC/8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV8) } # [doc = "CLK_RTC_CNT = GCLK_RTC/16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV16) } # [doc = "CLK_RTC_CNT = GCLK_RTC/32"]
# [inline (always)]
pub fn div32 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV32) } # [doc = "CLK_RTC_CNT = GCLK_RTC/64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV64) } # [doc = "CLK_RTC_CNT = GCLK_RTC/128"]
# [inline (always)]
pub fn div128 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV128) } # [doc = "CLK_RTC_CNT = GCLK_RTC/256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV256) } # [doc = "CLK_RTC_CNT = GCLK_RTC/512"]
# [inline (always)]
pub fn div512 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV512) } # [doc = "CLK_RTC_CNT = GCLK_RTC/1024"]
# [inline (always)]
pub fn div1024 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV1024) } } impl R { # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Operating Mode"]
# [inline (always)]
pub fn mode (& self) -> MODE_R { MODE_R :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bit 7 - Clear on Match"]
# [inline (always)]
pub fn matchclr (& self) -> MATCHCLR_R { MATCHCLR_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bits 8:11 - Prescaler"]
# [inline (always)]
pub fn prescaler (& self) -> PRESCALER_R { PRESCALER_R :: new (((self . bits >> 8) & 0x0f) as u8) } } impl W { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& mut self) -> SWRST_W { SWRST_W :: new (self) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Bits 2:3 - Operating Mode"]
# [inline (always)]
pub fn mode (& mut self) -> MODE_W { MODE_W :: new (self) } # [doc = "Bit 7 - Clear on Match"]
# [inline (always)]
pub fn matchclr (& mut self) -> MATCHCLR_W { MATCHCLR_W :: new (self) } # [doc = "Bits 8:11 - Prescaler"]
# [inline (always)]
pub fn prescaler (& mut self) -> PRESCALER_W { PRESCALER_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MODE0 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "READREQ register accessor: an alias for `Reg<READREQ_SPEC>`"]
pub type READREQ = crate :: Reg < readreq :: READREQ_SPEC > ; # [doc = "Read Request"]
pub mod readreq { # [doc = "Register `READREQ` reader"]
pub struct R (crate :: R < READREQ_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < READREQ_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < READREQ_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < READREQ_SPEC >) -> Self { R (reader) } } # [doc = "Register `READREQ` writer"]
pub struct W (crate :: W < READREQ_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < READREQ_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < READREQ_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < READREQ_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADDR` reader - Address"]
pub type ADDR_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `RCONT` reader - Read Continuously"]
pub type RCONT_R = crate :: BitReader < bool > ; # [doc = "Field `RCONT` writer - Read Continuously"]
pub type RCONT_W < 'a > = crate :: BitWriter < 'a , u16 , READREQ_SPEC , bool , 14 > ; # [doc = "Field `RREQ` writer - Read Request"]
pub type RREQ_W < 'a > = crate :: BitWriter < 'a , u16 , READREQ_SPEC , bool , 15 > ; impl R { # [doc = "Bits 0:5 - Address"]
# [inline (always)]
pub fn addr (& self) -> ADDR_R { ADDR_R :: new ((self . bits & 0x3f) as u8) } # [doc = "Bit 14 - Read Continuously"]
# [inline (always)]
pub fn rcont (& self) -> RCONT_R { RCONT_R :: new (((self . bits >> 14) & 1) != 0) } } impl W { # [doc = "Bit 14 - Read Continuously"]
# [inline (always)]
pub fn rcont (& mut self) -> RCONT_W { RCONT_W :: new (self) } # [doc = "Bit 15 - Read Request"]
# [inline (always)]
pub fn rreq (& mut self) -> RREQ_W { RREQ_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Read Request\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [readreq](index.html) module"]
pub struct READREQ_SPEC ; impl crate :: RegisterSpec for READREQ_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [readreq::R](R) reader structure"]
impl crate :: Readable for READREQ_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [readreq::W](W) writer structure"]
impl crate :: Writable for READREQ_SPEC { type Writer = W ; } # [doc = "`reset()` method sets READREQ to value 0x10"]
impl crate :: Resettable for READREQ_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x10 } } } # [doc = "EVCTRL register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "MODE0 Event Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PEREO0` reader - Periodic Interval 0 Event Output Enable"]
pub type PEREO0_R = crate :: BitReader < bool > ; # [doc = "Field `PEREO0` writer - Periodic Interval 0 Event Output Enable"]
pub type PEREO0_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 0 > ; # [doc = "Field `PEREO1` reader - Periodic Interval 1 Event Output Enable"]
pub type PEREO1_R = crate :: BitReader < bool > ; # [doc = "Field `PEREO1` writer - Periodic Interval 1 Event Output Enable"]
pub type PEREO1_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 1 > ; # [doc = "Field `PEREO2` reader - Periodic Interval 2 Event Output Enable"]
pub type PEREO2_R = crate :: BitReader < bool > ; # [doc = "Field `PEREO2` writer - Periodic Interval 2 Event Output Enable"]
pub type PEREO2_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 2 > ; # [doc = "Field `PEREO3` reader - Periodic Interval 3 Event Output Enable"]
pub type PEREO3_R = crate :: BitReader < bool > ; # [doc = "Field `PEREO3` writer - Periodic Interval 3 Event Output Enable"]
pub type PEREO3_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 3 > ; # [doc = "Field `PEREO4` reader - Periodic Interval 4 Event Output Enable"]
pub type PEREO4_R = crate :: BitReader < bool > ; # [doc = "Field `PEREO4` writer - Periodic Interval 4 Event Output Enable"]
pub type PEREO4_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 4 > ; # [doc = "Field `PEREO5` reader - Periodic Interval 5 Event Output Enable"]
pub type PEREO5_R = crate :: BitReader < bool > ; # [doc = "Field `PEREO5` writer - Periodic Interval 5 Event Output Enable"]
pub type PEREO5_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 5 > ; # [doc = "Field `PEREO6` reader - Periodic Interval 6 Event Output Enable"]
pub type PEREO6_R = crate :: BitReader < bool > ; # [doc = "Field `PEREO6` writer - Periodic Interval 6 Event Output Enable"]
pub type PEREO6_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 6 > ; # [doc = "Field `PEREO7` reader - Periodic Interval 7 Event Output Enable"]
pub type PEREO7_R = crate :: BitReader < bool > ; # [doc = "Field `PEREO7` writer - Periodic Interval 7 Event Output Enable"]
pub type PEREO7_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 7 > ; # [doc = "Field `CMPEO0` reader - Compare 0 Event Output Enable"]
pub type CMPEO0_R = crate :: BitReader < bool > ; # [doc = "Field `CMPEO0` writer - Compare 0 Event Output Enable"]
pub type CMPEO0_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 8 > ; # [doc = "Field `OVFEO` reader - Overflow Event Output Enable"]
pub type OVFEO_R = crate :: BitReader < bool > ; # [doc = "Field `OVFEO` writer - Overflow Event Output Enable"]
pub type OVFEO_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 15 > ; impl R { # [doc = "Bit 0 - Periodic Interval 0 Event Output Enable"]
# [inline (always)]
pub fn pereo0 (& self) -> PEREO0_R { PEREO0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Periodic Interval 1 Event Output Enable"]
# [inline (always)]
pub fn pereo1 (& self) -> PEREO1_R { PEREO1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Periodic Interval 2 Event Output Enable"]
# [inline (always)]
pub fn pereo2 (& self) -> PEREO2_R { PEREO2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Periodic Interval 3 Event Output Enable"]
# [inline (always)]
pub fn pereo3 (& self) -> PEREO3_R { PEREO3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Periodic Interval 4 Event Output Enable"]
# [inline (always)]
pub fn pereo4 (& self) -> PEREO4_R { PEREO4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Periodic Interval 5 Event Output Enable"]
# [inline (always)]
pub fn pereo5 (& self) -> PEREO5_R { PEREO5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Periodic Interval 6 Event Output Enable"]
# [inline (always)]
pub fn pereo6 (& self) -> PEREO6_R { PEREO6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Periodic Interval 7 Event Output Enable"]
# [inline (always)]
pub fn pereo7 (& self) -> PEREO7_R { PEREO7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Compare 0 Event Output Enable"]
# [inline (always)]
pub fn cmpeo0 (& self) -> CMPEO0_R { CMPEO0_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 15 - Overflow Event Output Enable"]
# [inline (always)]
pub fn ovfeo (& self) -> OVFEO_R { OVFEO_R :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bit 0 - Periodic Interval 0 Event Output Enable"]
# [inline (always)]
pub fn pereo0 (& mut self) -> PEREO0_W { PEREO0_W :: new (self) } # [doc = "Bit 1 - Periodic Interval 1 Event Output Enable"]
# [inline (always)]
pub fn pereo1 (& mut self) -> PEREO1_W { PEREO1_W :: new (self) } # [doc = "Bit 2 - Periodic Interval 2 Event Output Enable"]
# [inline (always)]
pub fn pereo2 (& mut self) -> PEREO2_W { PEREO2_W :: new (self) } # [doc = "Bit 3 - Periodic Interval 3 Event Output Enable"]
# [inline (always)]
pub fn pereo3 (& mut self) -> PEREO3_W { PEREO3_W :: new (self) } # [doc = "Bit 4 - Periodic Interval 4 Event Output Enable"]
# [inline (always)]
pub fn pereo4 (& mut self) -> PEREO4_W { PEREO4_W :: new (self) } # [doc = "Bit 5 - Periodic Interval 5 Event Output Enable"]
# [inline (always)]
pub fn pereo5 (& mut self) -> PEREO5_W { PEREO5_W :: new (self) } # [doc = "Bit 6 - Periodic Interval 6 Event Output Enable"]
# [inline (always)]
pub fn pereo6 (& mut self) -> PEREO6_W { PEREO6_W :: new (self) } # [doc = "Bit 7 - Periodic Interval 7 Event Output Enable"]
# [inline (always)]
pub fn pereo7 (& mut self) -> PEREO7_W { PEREO7_W :: new (self) } # [doc = "Bit 8 - Compare 0 Event Output Enable"]
# [inline (always)]
pub fn cmpeo0 (& mut self) -> CMPEO0_W { CMPEO0_W :: new (self) } # [doc = "Bit 15 - Overflow Event Output Enable"]
# [inline (always)]
pub fn ovfeo (& mut self) -> OVFEO_W { OVFEO_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MODE0 Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENCLR register accessor: an alias for `Reg<INTENCLR_SPEC>`"]
pub type INTENCLR = crate :: Reg < intenclr :: INTENCLR_SPEC > ; # [doc = "MODE0 Interrupt Enable Clear"]
pub mod intenclr { # [doc = "Register `INTENCLR` reader"]
pub struct R (crate :: R < INTENCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENCLR` writer"]
pub struct W (crate :: W < INTENCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMP0` reader - Compare 0 Interrupt Enable"]
pub type CMP0_R = crate :: BitReader < bool > ; # [doc = "Field `CMP0` writer - Compare 0 Interrupt Enable"]
pub type CMP0_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 0 > ; # [doc = "Field `SYNCRDY` reader - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCRDY` writer - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 6 > ; # [doc = "Field `OVF` reader - Overflow Interrupt Enable"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow Interrupt Enable"]
pub type OVF_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 7 > ; impl R { # [doc = "Bit 0 - Compare 0 Interrupt Enable"]
# [inline (always)]
pub fn cmp0 (& self) -> CMP0_R { CMP0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 6 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& self) -> SYNCRDY_R { SYNCRDY_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Compare 0 Interrupt Enable"]
# [inline (always)]
pub fn cmp0 (& mut self) -> CMP0_W { CMP0_W :: new (self) } # [doc = "Bit 6 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& mut self) -> SYNCRDY_W { SYNCRDY_W :: new (self) } # [doc = "Bit 7 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& mut self) -> OVF_W { OVF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MODE0 Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenclr](index.html) module"]
pub struct INTENCLR_SPEC ; impl crate :: RegisterSpec for INTENCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenclr::R](R) reader structure"]
impl crate :: Readable for INTENCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenclr::W](W) writer structure"]
impl crate :: Writable for INTENCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENCLR to value 0"]
impl crate :: Resettable for INTENCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENSET register accessor: an alias for `Reg<INTENSET_SPEC>`"]
pub type INTENSET = crate :: Reg < intenset :: INTENSET_SPEC > ; # [doc = "MODE0 Interrupt Enable Set"]
pub mod intenset { # [doc = "Register `INTENSET` reader"]
pub struct R (crate :: R < INTENSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENSET` writer"]
pub struct W (crate :: W < INTENSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMP0` reader - Compare 0 Interrupt Enable"]
pub type CMP0_R = crate :: BitReader < bool > ; # [doc = "Field `CMP0` writer - Compare 0 Interrupt Enable"]
pub type CMP0_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 0 > ; # [doc = "Field `SYNCRDY` reader - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCRDY` writer - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 6 > ; # [doc = "Field `OVF` reader - Overflow Interrupt Enable"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow Interrupt Enable"]
pub type OVF_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 7 > ; impl R { # [doc = "Bit 0 - Compare 0 Interrupt Enable"]
# [inline (always)]
pub fn cmp0 (& self) -> CMP0_R { CMP0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 6 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& self) -> SYNCRDY_R { SYNCRDY_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Compare 0 Interrupt Enable"]
# [inline (always)]
pub fn cmp0 (& mut self) -> CMP0_W { CMP0_W :: new (self) } # [doc = "Bit 6 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& mut self) -> SYNCRDY_W { SYNCRDY_W :: new (self) } # [doc = "Bit 7 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& mut self) -> OVF_W { OVF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MODE0 Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenset](index.html) module"]
pub struct INTENSET_SPEC ; impl crate :: RegisterSpec for INTENSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenset::R](R) reader structure"]
impl crate :: Readable for INTENSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenset::W](W) writer structure"]
impl crate :: Writable for INTENSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENSET to value 0"]
impl crate :: Resettable for INTENSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTFLAG register accessor: an alias for `Reg<INTFLAG_SPEC>`"]
pub type INTFLAG = crate :: Reg < intflag :: INTFLAG_SPEC > ; # [doc = "MODE0 Interrupt Flag Status and Clear"]
pub mod intflag { # [doc = "Register `INTFLAG` reader"]
pub struct R (crate :: R < INTFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAG` writer"]
pub struct W (crate :: W < INTFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMP0` reader - Compare 0"]
pub type CMP0_R = crate :: BitReader < bool > ; # [doc = "Field `CMP0` writer - Compare 0"]
pub type CMP0_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 0 > ; # [doc = "Field `SYNCRDY` reader - Synchronization Ready"]
pub type SYNCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCRDY` writer - Synchronization Ready"]
pub type SYNCRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 6 > ; # [doc = "Field `OVF` reader - Overflow"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow"]
pub type OVF_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 7 > ; impl R { # [doc = "Bit 0 - Compare 0"]
# [inline (always)]
pub fn cmp0 (& self) -> CMP0_R { CMP0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 6 - Synchronization Ready"]
# [inline (always)]
pub fn syncrdy (& self) -> SYNCRDY_R { SYNCRDY_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Overflow"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Compare 0"]
# [inline (always)]
pub fn cmp0 (& mut self) -> CMP0_W { CMP0_W :: new (self) } # [doc = "Bit 6 - Synchronization Ready"]
# [inline (always)]
pub fn syncrdy (& mut self) -> SYNCRDY_W { SYNCRDY_W :: new (self) } # [doc = "Bit 7 - Overflow"]
# [inline (always)]
pub fn ovf (& mut self) -> OVF_W { OVF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MODE0 Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflag](index.html) module"]
pub struct INTFLAG_SPEC ; impl crate :: RegisterSpec for INTFLAG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflag::R](R) reader structure"]
impl crate :: Readable for INTFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflag::W](W) writer structure"]
impl crate :: Writable for INTFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTFLAG to value 0"]
impl crate :: Resettable for INTFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATUS register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `SYNCBUSY` reader - Synchronization Busy"]
pub type SYNCBUSY_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 7 - Synchronization Busy"]
# [inline (always)]
pub fn syncbusy (& self) -> SYNCBUSY_R { SYNCBUSY_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DBGCTRL register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Debug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Run During Debug"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Run During Debug"]
pub type DBGRUN_W < 'a > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , 0 > ; impl R { # [doc = "Bit 0 - Run During Debug"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Run During Debug"]
# [inline (always)]
pub fn dbgrun (& mut self) -> DBGRUN_W { DBGRUN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "FREQCORR register accessor: an alias for `Reg<FREQCORR_SPEC>`"]
pub type FREQCORR = crate :: Reg < freqcorr :: FREQCORR_SPEC > ; # [doc = "Frequency Correction"]
pub mod freqcorr { # [doc = "Register `FREQCORR` reader"]
pub struct R (crate :: R < FREQCORR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < FREQCORR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < FREQCORR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < FREQCORR_SPEC >) -> Self { R (reader) } } # [doc = "Register `FREQCORR` writer"]
pub struct W (crate :: W < FREQCORR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < FREQCORR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < FREQCORR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < FREQCORR_SPEC >) -> Self { W (writer) } } # [doc = "Field `VALUE` reader - Correction Value"]
pub type VALUE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `VALUE` writer - Correction Value"]
pub type VALUE_W < 'a > = crate :: FieldWriter < 'a , u8 , FREQCORR_SPEC , u8 , u8 , 7 , 0 > ; # [doc = "Field `SIGN` reader - Correction Sign"]
pub type SIGN_R = crate :: BitReader < bool > ; # [doc = "Field `SIGN` writer - Correction Sign"]
pub type SIGN_W < 'a > = crate :: BitWriter < 'a , u8 , FREQCORR_SPEC , bool , 7 > ; impl R { # [doc = "Bits 0:6 - Correction Value"]
# [inline (always)]
pub fn value (& self) -> VALUE_R { VALUE_R :: new ((self . bits & 0x7f) as u8) } # [doc = "Bit 7 - Correction Sign"]
# [inline (always)]
pub fn sign (& self) -> SIGN_R { SIGN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:6 - Correction Value"]
# [inline (always)]
pub fn value (& mut self) -> VALUE_W { VALUE_W :: new (self) } # [doc = "Bit 7 - Correction Sign"]
# [inline (always)]
pub fn sign (& mut self) -> SIGN_W { SIGN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Frequency Correction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [freqcorr](index.html) module"]
pub struct FREQCORR_SPEC ; impl crate :: RegisterSpec for FREQCORR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [freqcorr::R](R) reader structure"]
impl crate :: Readable for FREQCORR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [freqcorr::W](W) writer structure"]
impl crate :: Writable for FREQCORR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets FREQCORR to value 0"]
impl crate :: Resettable for FREQCORR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "COUNT register accessor: an alias for `Reg<COUNT_SPEC>`"]
pub type COUNT = crate :: Reg < count :: COUNT_SPEC > ; # [doc = "MODE0 Counter Value"]
pub mod count { # [doc = "Register `COUNT` reader"]
pub struct R (crate :: R < COUNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < COUNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < COUNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < COUNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `COUNT` writer"]
pub struct W (crate :: W < COUNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < COUNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < COUNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < COUNT_SPEC >) -> Self { W (writer) } } # [doc = "Field `COUNT` reader - Counter Value"]
pub type COUNT_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `COUNT` writer - Counter Value"]
pub type COUNT_W < 'a > = crate :: FieldWriter < 'a , u32 , COUNT_SPEC , u32 , u32 , 32 , 0 > ; impl R { # [doc = "Bits 0:31 - Counter Value"]
# [inline (always)]
pub fn count (& self) -> COUNT_R { COUNT_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Counter Value"]
# [inline (always)]
pub fn count (& mut self) -> COUNT_W { COUNT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MODE0 Counter Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [count](index.html) module"]
pub struct COUNT_SPEC ; impl crate :: RegisterSpec for COUNT_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [count::R](R) reader structure"]
impl crate :: Readable for COUNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [count::W](W) writer structure"]
impl crate :: Writable for COUNT_SPEC { type Writer = W ; } # [doc = "`reset()` method sets COUNT to value 0"]
impl crate :: Resettable for COUNT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "COMP register accessor: an alias for `Reg<COMP_SPEC>`"]
pub type COMP = crate :: Reg < comp :: COMP_SPEC > ; # [doc = "MODE0 Compare n Value"]
pub mod comp { # [doc = "Register `COMP%s` reader"]
pub struct R (crate :: R < COMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < COMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < COMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < COMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `COMP%s` writer"]
pub struct W (crate :: W < COMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < COMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < COMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < COMP_SPEC >) -> Self { W (writer) } } # [doc = "Field `COMP` reader - Compare Value"]
pub type COMP_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `COMP` writer - Compare Value"]
pub type COMP_W < 'a > = crate :: FieldWriter < 'a , u32 , COMP_SPEC , u32 , u32 , 32 , 0 > ; impl R { # [doc = "Bits 0:31 - Compare Value"]
# [inline (always)]
pub fn comp (& self) -> COMP_R { COMP_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Compare Value"]
# [inline (always)]
pub fn comp (& mut self) -> COMP_W { COMP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MODE0 Compare n Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [comp](index.html) module"]
pub struct COMP_SPEC ; impl crate :: RegisterSpec for COMP_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [comp::R](R) reader structure"]
impl crate :: Readable for COMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [comp::W](W) writer structure"]
impl crate :: Writable for COMP_SPEC { type Writer = W ; } # [doc = "`reset()` method sets COMP%s to value 0"]
impl crate :: Resettable for COMP_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = r"Register block"]
# [repr (C)]
pub struct MODE1 { # [doc = "0x00 - MODE1 Control"]
pub ctrl : crate :: Reg < self :: mode1 :: ctrl :: CTRL_SPEC > , # [doc = "0x02 - Read Request"]
pub readreq : crate :: Reg < self :: mode1 :: readreq :: READREQ_SPEC > , # [doc = "0x04 - MODE1 Event Control"]
pub evctrl : crate :: Reg < self :: mode1 :: evctrl :: EVCTRL_SPEC > , # [doc = "0x06 - MODE1 Interrupt Enable Clear"]
pub intenclr : crate :: Reg < self :: mode1 :: intenclr :: INTENCLR_SPEC > , # [doc = "0x07 - MODE1 Interrupt Enable Set"]
pub intenset : crate :: Reg < self :: mode1 :: intenset :: INTENSET_SPEC > , # [doc = "0x08 - MODE1 Interrupt Flag Status and Clear"]
pub intflag : crate :: Reg < self :: mode1 :: intflag :: INTFLAG_SPEC > , _reserved6 : [u8 ; 0x01]
, # [doc = "0x0a - Status"]
pub status : crate :: Reg < self :: mode1 :: status :: STATUS_SPEC > , # [doc = "0x0b - Debug Control"]
pub dbgctrl : crate :: Reg < self :: mode1 :: dbgctrl :: DBGCTRL_SPEC > , # [doc = "0x0c - Frequency Correction"]
pub freqcorr : crate :: Reg < self :: mode1 :: freqcorr :: FREQCORR_SPEC > , _reserved9 : [u8 ; 0x03]
, # [doc = "0x10 - MODE1 Counter Value"]
pub count : crate :: Reg < self :: mode1 :: count :: COUNT_SPEC > , _reserved10 : [u8 ; 0x02]
, # [doc = "0x14 - MODE1 Counter Period"]
pub per : crate :: Reg < self :: mode1 :: per :: PER_SPEC > , _reserved11 : [u8 ; 0x02]
, # [doc = "0x18 - MODE1 Compare n Value"]
pub comp : [crate :: Reg < self :: mode1 :: comp :: COMP_SPEC > ; 2]
, } # [doc = r"Register block"]
# [doc = "16-bit Counter with Two 16-bit Compares"]
pub mod mode1 { # [doc = "CTRL register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "MODE1 Control"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWRST` writer - Software Reset"]
pub type SWRST_W < 'a > = crate :: BitWriter < 'a , u16 , CTRL_SPEC , bool , 0 > ; # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u16 , CTRL_SPEC , bool , 1 > ; # [doc = "Operating Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum MODE_A { # [doc = "0: Mode 0: 32-bit Counter"]
COUNT32 = 0 , # [doc = "1: Mode 1: 16-bit Counter"]
COUNT16 = 1 , # [doc = "2: Mode 2: Clock/Calendar"]
CLOCK = 2 , } impl From < MODE_A > for u8 { # [inline (always)]
fn from (variant : MODE_A) -> Self { variant as _ } } # [doc = "Field `MODE` reader - Operating Mode"]
pub type MODE_R = crate :: FieldReader < u8 , MODE_A > ; impl MODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < MODE_A > { match self . bits { 0 => Some (MODE_A :: COUNT32) , 1 => Some (MODE_A :: COUNT16) , 2 => Some (MODE_A :: CLOCK) , _ => None , } } # [doc = "Checks if the value of the field is `COUNT32`"]
# [inline (always)]
pub fn is_count32 (& self) -> bool { * self == MODE_A :: COUNT32 } # [doc = "Checks if the value of the field is `COUNT16`"]
# [inline (always)]
pub fn is_count16 (& self) -> bool { * self == MODE_A :: COUNT16 } # [doc = "Checks if the value of the field is `CLOCK`"]
# [inline (always)]
pub fn is_clock (& self) -> bool { * self == MODE_A :: CLOCK } } # [doc = "Field `MODE` writer - Operating Mode"]
pub type MODE_W < 'a > = crate :: FieldWriter < 'a , u16 , CTRL_SPEC , u8 , MODE_A , 2 , 2 > ; impl < 'a > MODE_W < 'a > { # [doc = "Mode 0: 32-bit Counter"]
# [inline (always)]
pub fn count32 (self) -> & 'a mut W { self . variant (MODE_A :: COUNT32) } # [doc = "Mode 1: 16-bit Counter"]
# [inline (always)]
pub fn count16 (self) -> & 'a mut W { self . variant (MODE_A :: COUNT16) } # [doc = "Mode 2: Clock/Calendar"]
# [inline (always)]
pub fn clock (self) -> & 'a mut W { self . variant (MODE_A :: CLOCK) } } # [doc = "Prescaler\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum PRESCALER_A { # [doc = "0: CLK_RTC_CNT = GCLK_RTC/1"]
DIV1 = 0 , # [doc = "1: CLK_RTC_CNT = GCLK_RTC/2"]
DIV2 = 1 , # [doc = "2: CLK_RTC_CNT = GCLK_RTC/4"]
DIV4 = 2 , # [doc = "3: CLK_RTC_CNT = GCLK_RTC/8"]
DIV8 = 3 , # [doc = "4: CLK_RTC_CNT = GCLK_RTC/16"]
DIV16 = 4 , # [doc = "5: CLK_RTC_CNT = GCLK_RTC/32"]
DIV32 = 5 , # [doc = "6: CLK_RTC_CNT = GCLK_RTC/64"]
DIV64 = 6 , # [doc = "7: CLK_RTC_CNT = GCLK_RTC/128"]
DIV128 = 7 , # [doc = "8: CLK_RTC_CNT = GCLK_RTC/256"]
DIV256 = 8 , # [doc = "9: CLK_RTC_CNT = GCLK_RTC/512"]
DIV512 = 9 , # [doc = "10: CLK_RTC_CNT = GCLK_RTC/1024"]
DIV1024 = 10 , } impl From < PRESCALER_A > for u8 { # [inline (always)]
fn from (variant : PRESCALER_A) -> Self { variant as _ } } # [doc = "Field `PRESCALER` reader - Prescaler"]
pub type PRESCALER_R = crate :: FieldReader < u8 , PRESCALER_A > ; impl PRESCALER_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PRESCALER_A > { match self . bits { 0 => Some (PRESCALER_A :: DIV1) , 1 => Some (PRESCALER_A :: DIV2) , 2 => Some (PRESCALER_A :: DIV4) , 3 => Some (PRESCALER_A :: DIV8) , 4 => Some (PRESCALER_A :: DIV16) , 5 => Some (PRESCALER_A :: DIV32) , 6 => Some (PRESCALER_A :: DIV64) , 7 => Some (PRESCALER_A :: DIV128) , 8 => Some (PRESCALER_A :: DIV256) , 9 => Some (PRESCALER_A :: DIV512) , 10 => Some (PRESCALER_A :: DIV1024) , _ => None , } } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == PRESCALER_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == PRESCALER_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == PRESCALER_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == PRESCALER_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == PRESCALER_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV32`"]
# [inline (always)]
pub fn is_div32 (& self) -> bool { * self == PRESCALER_A :: DIV32 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == PRESCALER_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV128`"]
# [inline (always)]
pub fn is_div128 (& self) -> bool { * self == PRESCALER_A :: DIV128 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == PRESCALER_A :: DIV256 } # [doc = "Checks if the value of the field is `DIV512`"]
# [inline (always)]
pub fn is_div512 (& self) -> bool { * self == PRESCALER_A :: DIV512 } # [doc = "Checks if the value of the field is `DIV1024`"]
# [inline (always)]
pub fn is_div1024 (& self) -> bool { * self == PRESCALER_A :: DIV1024 } } # [doc = "Field `PRESCALER` writer - Prescaler"]
pub type PRESCALER_W < 'a > = crate :: FieldWriter < 'a , u16 , CTRL_SPEC , u8 , PRESCALER_A , 4 , 8 > ; impl < 'a > PRESCALER_W < 'a > { # [doc = "CLK_RTC_CNT = GCLK_RTC/1"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV1) } # [doc = "CLK_RTC_CNT = GCLK_RTC/2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV2) } # [doc = "CLK_RTC_CNT = GCLK_RTC/4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV4) } # [doc = "CLK_RTC_CNT = GCLK_RTC/8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV8) } # [doc = "CLK_RTC_CNT = GCLK_RTC/16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV16) } # [doc = "CLK_RTC_CNT = GCLK_RTC/32"]
# [inline (always)]
pub fn div32 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV32) } # [doc = "CLK_RTC_CNT = GCLK_RTC/64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV64) } # [doc = "CLK_RTC_CNT = GCLK_RTC/128"]
# [inline (always)]
pub fn div128 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV128) } # [doc = "CLK_RTC_CNT = GCLK_RTC/256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV256) } # [doc = "CLK_RTC_CNT = GCLK_RTC/512"]
# [inline (always)]
pub fn div512 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV512) } # [doc = "CLK_RTC_CNT = GCLK_RTC/1024"]
# [inline (always)]
pub fn div1024 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV1024) } } impl R { # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Operating Mode"]
# [inline (always)]
pub fn mode (& self) -> MODE_R { MODE_R :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bits 8:11 - Prescaler"]
# [inline (always)]
pub fn prescaler (& self) -> PRESCALER_R { PRESCALER_R :: new (((self . bits >> 8) & 0x0f) as u8) } } impl W { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& mut self) -> SWRST_W { SWRST_W :: new (self) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Bits 2:3 - Operating Mode"]
# [inline (always)]
pub fn mode (& mut self) -> MODE_W { MODE_W :: new (self) } # [doc = "Bits 8:11 - Prescaler"]
# [inline (always)]
pub fn prescaler (& mut self) -> PRESCALER_W { PRESCALER_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MODE1 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "READREQ register accessor: an alias for `Reg<READREQ_SPEC>`"]
pub type READREQ = crate :: Reg < readreq :: READREQ_SPEC > ; # [doc = "Read Request"]
pub mod readreq { # [doc = "Register `READREQ` reader"]
pub struct R (crate :: R < READREQ_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < READREQ_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < READREQ_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < READREQ_SPEC >) -> Self { R (reader) } } # [doc = "Register `READREQ` writer"]
pub struct W (crate :: W < READREQ_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < READREQ_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < READREQ_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < READREQ_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADDR` reader - Address"]
pub type ADDR_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `RCONT` reader - Read Continuously"]
pub type RCONT_R = crate :: BitReader < bool > ; # [doc = "Field `RCONT` writer - Read Continuously"]
pub type RCONT_W < 'a > = crate :: BitWriter < 'a , u16 , READREQ_SPEC , bool , 14 > ; # [doc = "Field `RREQ` writer - Read Request"]
pub type RREQ_W < 'a > = crate :: BitWriter < 'a , u16 , READREQ_SPEC , bool , 15 > ; impl R { # [doc = "Bits 0:5 - Address"]
# [inline (always)]
pub fn addr (& self) -> ADDR_R { ADDR_R :: new ((self . bits & 0x3f) as u8) } # [doc = "Bit 14 - Read Continuously"]
# [inline (always)]
pub fn rcont (& self) -> RCONT_R { RCONT_R :: new (((self . bits >> 14) & 1) != 0) } } impl W { # [doc = "Bit 14 - Read Continuously"]
# [inline (always)]
pub fn rcont (& mut self) -> RCONT_W { RCONT_W :: new (self) } # [doc = "Bit 15 - Read Request"]
# [inline (always)]
pub fn rreq (& mut self) -> RREQ_W { RREQ_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Read Request\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [readreq](index.html) module"]
pub struct READREQ_SPEC ; impl crate :: RegisterSpec for READREQ_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [readreq::R](R) reader structure"]
impl crate :: Readable for READREQ_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [readreq::W](W) writer structure"]
impl crate :: Writable for READREQ_SPEC { type Writer = W ; } # [doc = "`reset()` method sets READREQ to value 0x10"]
impl crate :: Resettable for READREQ_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x10 } } } # [doc = "EVCTRL register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "MODE1 Event Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PEREO0` reader - Periodic Interval 0 Event Output Enable"]
pub type PEREO0_R = crate :: BitReader < bool > ; # [doc = "Field `PEREO0` writer - Periodic Interval 0 Event Output Enable"]
pub type PEREO0_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 0 > ; # [doc = "Field `PEREO1` reader - Periodic Interval 1 Event Output Enable"]
pub type PEREO1_R = crate :: BitReader < bool > ; # [doc = "Field `PEREO1` writer - Periodic Interval 1 Event Output Enable"]
pub type PEREO1_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 1 > ; # [doc = "Field `PEREO2` reader - Periodic Interval 2 Event Output Enable"]
pub type PEREO2_R = crate :: BitReader < bool > ; # [doc = "Field `PEREO2` writer - Periodic Interval 2 Event Output Enable"]
pub type PEREO2_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 2 > ; # [doc = "Field `PEREO3` reader - Periodic Interval 3 Event Output Enable"]
pub type PEREO3_R = crate :: BitReader < bool > ; # [doc = "Field `PEREO3` writer - Periodic Interval 3 Event Output Enable"]
pub type PEREO3_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 3 > ; # [doc = "Field `PEREO4` reader - Periodic Interval 4 Event Output Enable"]
pub type PEREO4_R = crate :: BitReader < bool > ; # [doc = "Field `PEREO4` writer - Periodic Interval 4 Event Output Enable"]
pub type PEREO4_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 4 > ; # [doc = "Field `PEREO5` reader - Periodic Interval 5 Event Output Enable"]
pub type PEREO5_R = crate :: BitReader < bool > ; # [doc = "Field `PEREO5` writer - Periodic Interval 5 Event Output Enable"]
pub type PEREO5_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 5 > ; # [doc = "Field `PEREO6` reader - Periodic Interval 6 Event Output Enable"]
pub type PEREO6_R = crate :: BitReader < bool > ; # [doc = "Field `PEREO6` writer - Periodic Interval 6 Event Output Enable"]
pub type PEREO6_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 6 > ; # [doc = "Field `PEREO7` reader - Periodic Interval 7 Event Output Enable"]
pub type PEREO7_R = crate :: BitReader < bool > ; # [doc = "Field `PEREO7` writer - Periodic Interval 7 Event Output Enable"]
pub type PEREO7_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 7 > ; # [doc = "Field `CMPEO0` reader - Compare 0 Event Output Enable"]
pub type CMPEO0_R = crate :: BitReader < bool > ; # [doc = "Field `CMPEO0` writer - Compare 0 Event Output Enable"]
pub type CMPEO0_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 8 > ; # [doc = "Field `CMPEO1` reader - Compare 1 Event Output Enable"]
pub type CMPEO1_R = crate :: BitReader < bool > ; # [doc = "Field `CMPEO1` writer - Compare 1 Event Output Enable"]
pub type CMPEO1_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 9 > ; # [doc = "Field `OVFEO` reader - Overflow Event Output Enable"]
pub type OVFEO_R = crate :: BitReader < bool > ; # [doc = "Field `OVFEO` writer - Overflow Event Output Enable"]
pub type OVFEO_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 15 > ; impl R { # [doc = "Bit 0 - Periodic Interval 0 Event Output Enable"]
# [inline (always)]
pub fn pereo0 (& self) -> PEREO0_R { PEREO0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Periodic Interval 1 Event Output Enable"]
# [inline (always)]
pub fn pereo1 (& self) -> PEREO1_R { PEREO1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Periodic Interval 2 Event Output Enable"]
# [inline (always)]
pub fn pereo2 (& self) -> PEREO2_R { PEREO2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Periodic Interval 3 Event Output Enable"]
# [inline (always)]
pub fn pereo3 (& self) -> PEREO3_R { PEREO3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Periodic Interval 4 Event Output Enable"]
# [inline (always)]
pub fn pereo4 (& self) -> PEREO4_R { PEREO4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Periodic Interval 5 Event Output Enable"]
# [inline (always)]
pub fn pereo5 (& self) -> PEREO5_R { PEREO5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Periodic Interval 6 Event Output Enable"]
# [inline (always)]
pub fn pereo6 (& self) -> PEREO6_R { PEREO6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Periodic Interval 7 Event Output Enable"]
# [inline (always)]
pub fn pereo7 (& self) -> PEREO7_R { PEREO7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Compare 0 Event Output Enable"]
# [inline (always)]
pub fn cmpeo0 (& self) -> CMPEO0_R { CMPEO0_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Compare 1 Event Output Enable"]
# [inline (always)]
pub fn cmpeo1 (& self) -> CMPEO1_R { CMPEO1_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 15 - Overflow Event Output Enable"]
# [inline (always)]
pub fn ovfeo (& self) -> OVFEO_R { OVFEO_R :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bit 0 - Periodic Interval 0 Event Output Enable"]
# [inline (always)]
pub fn pereo0 (& mut self) -> PEREO0_W { PEREO0_W :: new (self) } # [doc = "Bit 1 - Periodic Interval 1 Event Output Enable"]
# [inline (always)]
pub fn pereo1 (& mut self) -> PEREO1_W { PEREO1_W :: new (self) } # [doc = "Bit 2 - Periodic Interval 2 Event Output Enable"]
# [inline (always)]
pub fn pereo2 (& mut self) -> PEREO2_W { PEREO2_W :: new (self) } # [doc = "Bit 3 - Periodic Interval 3 Event Output Enable"]
# [inline (always)]
pub fn pereo3 (& mut self) -> PEREO3_W { PEREO3_W :: new (self) } # [doc = "Bit 4 - Periodic Interval 4 Event Output Enable"]
# [inline (always)]
pub fn pereo4 (& mut self) -> PEREO4_W { PEREO4_W :: new (self) } # [doc = "Bit 5 - Periodic Interval 5 Event Output Enable"]
# [inline (always)]
pub fn pereo5 (& mut self) -> PEREO5_W { PEREO5_W :: new (self) } # [doc = "Bit 6 - Periodic Interval 6 Event Output Enable"]
# [inline (always)]
pub fn pereo6 (& mut self) -> PEREO6_W { PEREO6_W :: new (self) } # [doc = "Bit 7 - Periodic Interval 7 Event Output Enable"]
# [inline (always)]
pub fn pereo7 (& mut self) -> PEREO7_W { PEREO7_W :: new (self) } # [doc = "Bit 8 - Compare 0 Event Output Enable"]
# [inline (always)]
pub fn cmpeo0 (& mut self) -> CMPEO0_W { CMPEO0_W :: new (self) } # [doc = "Bit 9 - Compare 1 Event Output Enable"]
# [inline (always)]
pub fn cmpeo1 (& mut self) -> CMPEO1_W { CMPEO1_W :: new (self) } # [doc = "Bit 15 - Overflow Event Output Enable"]
# [inline (always)]
pub fn ovfeo (& mut self) -> OVFEO_W { OVFEO_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MODE1 Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENCLR register accessor: an alias for `Reg<INTENCLR_SPEC>`"]
pub type INTENCLR = crate :: Reg < intenclr :: INTENCLR_SPEC > ; # [doc = "MODE1 Interrupt Enable Clear"]
pub mod intenclr { # [doc = "Register `INTENCLR` reader"]
pub struct R (crate :: R < INTENCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENCLR` writer"]
pub struct W (crate :: W < INTENCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMP0` reader - Compare 0 Interrupt Enable"]
pub type CMP0_R = crate :: BitReader < bool > ; # [doc = "Field `CMP0` writer - Compare 0 Interrupt Enable"]
pub type CMP0_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 0 > ; # [doc = "Field `CMP1` reader - Compare 1 Interrupt Enable"]
pub type CMP1_R = crate :: BitReader < bool > ; # [doc = "Field `CMP1` writer - Compare 1 Interrupt Enable"]
pub type CMP1_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 1 > ; # [doc = "Field `SYNCRDY` reader - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCRDY` writer - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 6 > ; # [doc = "Field `OVF` reader - Overflow Interrupt Enable"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow Interrupt Enable"]
pub type OVF_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 7 > ; impl R { # [doc = "Bit 0 - Compare 0 Interrupt Enable"]
# [inline (always)]
pub fn cmp0 (& self) -> CMP0_R { CMP0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare 1 Interrupt Enable"]
# [inline (always)]
pub fn cmp1 (& self) -> CMP1_R { CMP1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 6 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& self) -> SYNCRDY_R { SYNCRDY_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Compare 0 Interrupt Enable"]
# [inline (always)]
pub fn cmp0 (& mut self) -> CMP0_W { CMP0_W :: new (self) } # [doc = "Bit 1 - Compare 1 Interrupt Enable"]
# [inline (always)]
pub fn cmp1 (& mut self) -> CMP1_W { CMP1_W :: new (self) } # [doc = "Bit 6 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& mut self) -> SYNCRDY_W { SYNCRDY_W :: new (self) } # [doc = "Bit 7 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& mut self) -> OVF_W { OVF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MODE1 Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenclr](index.html) module"]
pub struct INTENCLR_SPEC ; impl crate :: RegisterSpec for INTENCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenclr::R](R) reader structure"]
impl crate :: Readable for INTENCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenclr::W](W) writer structure"]
impl crate :: Writable for INTENCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENCLR to value 0"]
impl crate :: Resettable for INTENCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENSET register accessor: an alias for `Reg<INTENSET_SPEC>`"]
pub type INTENSET = crate :: Reg < intenset :: INTENSET_SPEC > ; # [doc = "MODE1 Interrupt Enable Set"]
pub mod intenset { # [doc = "Register `INTENSET` reader"]
pub struct R (crate :: R < INTENSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENSET` writer"]
pub struct W (crate :: W < INTENSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMP0` reader - Compare 0 Interrupt Enable"]
pub type CMP0_R = crate :: BitReader < bool > ; # [doc = "Field `CMP0` writer - Compare 0 Interrupt Enable"]
pub type CMP0_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 0 > ; # [doc = "Field `CMP1` reader - Compare 1 Interrupt Enable"]
pub type CMP1_R = crate :: BitReader < bool > ; # [doc = "Field `CMP1` writer - Compare 1 Interrupt Enable"]
pub type CMP1_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 1 > ; # [doc = "Field `SYNCRDY` reader - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCRDY` writer - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 6 > ; # [doc = "Field `OVF` reader - Overflow Interrupt Enable"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow Interrupt Enable"]
pub type OVF_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 7 > ; impl R { # [doc = "Bit 0 - Compare 0 Interrupt Enable"]
# [inline (always)]
pub fn cmp0 (& self) -> CMP0_R { CMP0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare 1 Interrupt Enable"]
# [inline (always)]
pub fn cmp1 (& self) -> CMP1_R { CMP1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 6 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& self) -> SYNCRDY_R { SYNCRDY_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Compare 0 Interrupt Enable"]
# [inline (always)]
pub fn cmp0 (& mut self) -> CMP0_W { CMP0_W :: new (self) } # [doc = "Bit 1 - Compare 1 Interrupt Enable"]
# [inline (always)]
pub fn cmp1 (& mut self) -> CMP1_W { CMP1_W :: new (self) } # [doc = "Bit 6 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& mut self) -> SYNCRDY_W { SYNCRDY_W :: new (self) } # [doc = "Bit 7 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& mut self) -> OVF_W { OVF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MODE1 Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenset](index.html) module"]
pub struct INTENSET_SPEC ; impl crate :: RegisterSpec for INTENSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenset::R](R) reader structure"]
impl crate :: Readable for INTENSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenset::W](W) writer structure"]
impl crate :: Writable for INTENSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENSET to value 0"]
impl crate :: Resettable for INTENSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTFLAG register accessor: an alias for `Reg<INTFLAG_SPEC>`"]
pub type INTFLAG = crate :: Reg < intflag :: INTFLAG_SPEC > ; # [doc = "MODE1 Interrupt Flag Status and Clear"]
pub mod intflag { # [doc = "Register `INTFLAG` reader"]
pub struct R (crate :: R < INTFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAG` writer"]
pub struct W (crate :: W < INTFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `CMP0` reader - Compare 0"]
pub type CMP0_R = crate :: BitReader < bool > ; # [doc = "Field `CMP0` writer - Compare 0"]
pub type CMP0_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 0 > ; # [doc = "Field `CMP1` reader - Compare 1"]
pub type CMP1_R = crate :: BitReader < bool > ; # [doc = "Field `CMP1` writer - Compare 1"]
pub type CMP1_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 1 > ; # [doc = "Field `SYNCRDY` reader - Synchronization Ready"]
pub type SYNCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCRDY` writer - Synchronization Ready"]
pub type SYNCRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 6 > ; # [doc = "Field `OVF` reader - Overflow"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow"]
pub type OVF_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 7 > ; impl R { # [doc = "Bit 0 - Compare 0"]
# [inline (always)]
pub fn cmp0 (& self) -> CMP0_R { CMP0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Compare 1"]
# [inline (always)]
pub fn cmp1 (& self) -> CMP1_R { CMP1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 6 - Synchronization Ready"]
# [inline (always)]
pub fn syncrdy (& self) -> SYNCRDY_R { SYNCRDY_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Overflow"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Compare 0"]
# [inline (always)]
pub fn cmp0 (& mut self) -> CMP0_W { CMP0_W :: new (self) } # [doc = "Bit 1 - Compare 1"]
# [inline (always)]
pub fn cmp1 (& mut self) -> CMP1_W { CMP1_W :: new (self) } # [doc = "Bit 6 - Synchronization Ready"]
# [inline (always)]
pub fn syncrdy (& mut self) -> SYNCRDY_W { SYNCRDY_W :: new (self) } # [doc = "Bit 7 - Overflow"]
# [inline (always)]
pub fn ovf (& mut self) -> OVF_W { OVF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MODE1 Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflag](index.html) module"]
pub struct INTFLAG_SPEC ; impl crate :: RegisterSpec for INTFLAG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflag::R](R) reader structure"]
impl crate :: Readable for INTFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflag::W](W) writer structure"]
impl crate :: Writable for INTFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTFLAG to value 0"]
impl crate :: Resettable for INTFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATUS register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `SYNCBUSY` reader - Synchronization Busy"]
pub type SYNCBUSY_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 7 - Synchronization Busy"]
# [inline (always)]
pub fn syncbusy (& self) -> SYNCBUSY_R { SYNCBUSY_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DBGCTRL register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Debug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Run During Debug"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Run During Debug"]
pub type DBGRUN_W < 'a > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , 0 > ; impl R { # [doc = "Bit 0 - Run During Debug"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Run During Debug"]
# [inline (always)]
pub fn dbgrun (& mut self) -> DBGRUN_W { DBGRUN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "FREQCORR register accessor: an alias for `Reg<FREQCORR_SPEC>`"]
pub type FREQCORR = crate :: Reg < freqcorr :: FREQCORR_SPEC > ; # [doc = "Frequency Correction"]
pub mod freqcorr { # [doc = "Register `FREQCORR` reader"]
pub struct R (crate :: R < FREQCORR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < FREQCORR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < FREQCORR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < FREQCORR_SPEC >) -> Self { R (reader) } } # [doc = "Register `FREQCORR` writer"]
pub struct W (crate :: W < FREQCORR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < FREQCORR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < FREQCORR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < FREQCORR_SPEC >) -> Self { W (writer) } } # [doc = "Field `VALUE` reader - Correction Value"]
pub type VALUE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `VALUE` writer - Correction Value"]
pub type VALUE_W < 'a > = crate :: FieldWriter < 'a , u8 , FREQCORR_SPEC , u8 , u8 , 7 , 0 > ; # [doc = "Field `SIGN` reader - Correction Sign"]
pub type SIGN_R = crate :: BitReader < bool > ; # [doc = "Field `SIGN` writer - Correction Sign"]
pub type SIGN_W < 'a > = crate :: BitWriter < 'a , u8 , FREQCORR_SPEC , bool , 7 > ; impl R { # [doc = "Bits 0:6 - Correction Value"]
# [inline (always)]
pub fn value (& self) -> VALUE_R { VALUE_R :: new ((self . bits & 0x7f) as u8) } # [doc = "Bit 7 - Correction Sign"]
# [inline (always)]
pub fn sign (& self) -> SIGN_R { SIGN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:6 - Correction Value"]
# [inline (always)]
pub fn value (& mut self) -> VALUE_W { VALUE_W :: new (self) } # [doc = "Bit 7 - Correction Sign"]
# [inline (always)]
pub fn sign (& mut self) -> SIGN_W { SIGN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Frequency Correction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [freqcorr](index.html) module"]
pub struct FREQCORR_SPEC ; impl crate :: RegisterSpec for FREQCORR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [freqcorr::R](R) reader structure"]
impl crate :: Readable for FREQCORR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [freqcorr::W](W) writer structure"]
impl crate :: Writable for FREQCORR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets FREQCORR to value 0"]
impl crate :: Resettable for FREQCORR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "COUNT register accessor: an alias for `Reg<COUNT_SPEC>`"]
pub type COUNT = crate :: Reg < count :: COUNT_SPEC > ; # [doc = "MODE1 Counter Value"]
pub mod count { # [doc = "Register `COUNT` reader"]
pub struct R (crate :: R < COUNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < COUNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < COUNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < COUNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `COUNT` writer"]
pub struct W (crate :: W < COUNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < COUNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < COUNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < COUNT_SPEC >) -> Self { W (writer) } } # [doc = "Field `COUNT` reader - Counter Value"]
pub type COUNT_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `COUNT` writer - Counter Value"]
pub type COUNT_W < 'a > = crate :: FieldWriter < 'a , u16 , COUNT_SPEC , u16 , u16 , 16 , 0 > ; impl R { # [doc = "Bits 0:15 - Counter Value"]
# [inline (always)]
pub fn count (& self) -> COUNT_R { COUNT_R :: new (self . bits) } } impl W { # [doc = "Bits 0:15 - Counter Value"]
# [inline (always)]
pub fn count (& mut self) -> COUNT_W { COUNT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MODE1 Counter Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [count](index.html) module"]
pub struct COUNT_SPEC ; impl crate :: RegisterSpec for COUNT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [count::R](R) reader structure"]
impl crate :: Readable for COUNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [count::W](W) writer structure"]
impl crate :: Writable for COUNT_SPEC { type Writer = W ; } # [doc = "`reset()` method sets COUNT to value 0"]
impl crate :: Resettable for COUNT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PER register accessor: an alias for `Reg<PER_SPEC>`"]
pub type PER = crate :: Reg < per :: PER_SPEC > ; # [doc = "MODE1 Counter Period"]
pub mod per { # [doc = "Register `PER` reader"]
pub struct R (crate :: R < PER_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PER_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PER_SPEC >) -> Self { R (reader) } } # [doc = "Register `PER` writer"]
pub struct W (crate :: W < PER_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PER_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PER_SPEC >) -> Self { W (writer) } } # [doc = "Field `PER` reader - Counter Period"]
pub type PER_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `PER` writer - Counter Period"]
pub type PER_W < 'a > = crate :: FieldWriter < 'a , u16 , PER_SPEC , u16 , u16 , 16 , 0 > ; impl R { # [doc = "Bits 0:15 - Counter Period"]
# [inline (always)]
pub fn per (& self) -> PER_R { PER_R :: new (self . bits) } } impl W { # [doc = "Bits 0:15 - Counter Period"]
# [inline (always)]
pub fn per (& mut self) -> PER_W { PER_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MODE1 Counter Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [per](index.html) module"]
pub struct PER_SPEC ; impl crate :: RegisterSpec for PER_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [per::R](R) reader structure"]
impl crate :: Readable for PER_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [per::W](W) writer structure"]
impl crate :: Writable for PER_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PER to value 0"]
impl crate :: Resettable for PER_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "COMP register accessor: an alias for `Reg<COMP_SPEC>`"]
pub type COMP = crate :: Reg < comp :: COMP_SPEC > ; # [doc = "MODE1 Compare n Value"]
pub mod comp { # [doc = "Register `COMP%s` reader"]
pub struct R (crate :: R < COMP_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < COMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < COMP_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < COMP_SPEC >) -> Self { R (reader) } } # [doc = "Register `COMP%s` writer"]
pub struct W (crate :: W < COMP_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < COMP_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < COMP_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < COMP_SPEC >) -> Self { W (writer) } } # [doc = "Field `COMP` reader - Compare Value"]
pub type COMP_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `COMP` writer - Compare Value"]
pub type COMP_W < 'a > = crate :: FieldWriter < 'a , u16 , COMP_SPEC , u16 , u16 , 16 , 0 > ; impl R { # [doc = "Bits 0:15 - Compare Value"]
# [inline (always)]
pub fn comp (& self) -> COMP_R { COMP_R :: new (self . bits) } } impl W { # [doc = "Bits 0:15 - Compare Value"]
# [inline (always)]
pub fn comp (& mut self) -> COMP_W { COMP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MODE1 Compare n Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [comp](index.html) module"]
pub struct COMP_SPEC ; impl crate :: RegisterSpec for COMP_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [comp::R](R) reader structure"]
impl crate :: Readable for COMP_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [comp::W](W) writer structure"]
impl crate :: Writable for COMP_SPEC { type Writer = W ; } # [doc = "`reset()` method sets COMP%s to value 0"]
impl crate :: Resettable for COMP_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = r"Register block"]
# [repr (C)]
pub struct MODE2 { # [doc = "0x00 - MODE2 Control"]
pub ctrl : crate :: Reg < self :: mode2 :: ctrl :: CTRL_SPEC > , # [doc = "0x02 - Read Request"]
pub readreq : crate :: Reg < self :: mode2 :: readreq :: READREQ_SPEC > , # [doc = "0x04 - MODE2 Event Control"]
pub evctrl : crate :: Reg < self :: mode2 :: evctrl :: EVCTRL_SPEC > , # [doc = "0x06 - MODE2 Interrupt Enable Clear"]
pub intenclr : crate :: Reg < self :: mode2 :: intenclr :: INTENCLR_SPEC > , # [doc = "0x07 - MODE2 Interrupt Enable Set"]
pub intenset : crate :: Reg < self :: mode2 :: intenset :: INTENSET_SPEC > , # [doc = "0x08 - MODE2 Interrupt Flag Status and Clear"]
pub intflag : crate :: Reg < self :: mode2 :: intflag :: INTFLAG_SPEC > , _reserved6 : [u8 ; 0x01]
, # [doc = "0x0a - Status"]
pub status : crate :: Reg < self :: mode2 :: status :: STATUS_SPEC > , # [doc = "0x0b - Debug Control"]
pub dbgctrl : crate :: Reg < self :: mode2 :: dbgctrl :: DBGCTRL_SPEC > , # [doc = "0x0c - Frequency Correction"]
pub freqcorr : crate :: Reg < self :: mode2 :: freqcorr :: FREQCORR_SPEC > , _reserved9 : [u8 ; 0x03]
, # [doc = "0x10 - MODE2 Clock Value"]
pub clock : crate :: Reg < self :: mode2 :: clock :: CLOCK_SPEC > , _reserved10 : [u8 ; 0x04]
, # [doc = "0x18 - MODE2 Alarm n Value"]
pub alarm : [crate :: Reg < self :: mode2 :: alarm :: ALARM_SPEC > ; 1]
, # [doc = "0x1c - MODE2 Alarm n Mask"]
pub mask : [crate :: Reg < self :: mode2 :: mask :: MASK_SPEC > ; 1]
, } # [doc = r"Register block"]
# [doc = "Clock/Calendar with Alarm"]
pub mod mode2 { # [doc = "CTRL register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "MODE2 Control"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWRST` writer - Software Reset"]
pub type SWRST_W < 'a > = crate :: BitWriter < 'a , u16 , CTRL_SPEC , bool , 0 > ; # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u16 , CTRL_SPEC , bool , 1 > ; # [doc = "Operating Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum MODE_A { # [doc = "0: Mode 0: 32-bit Counter"]
COUNT32 = 0 , # [doc = "1: Mode 1: 16-bit Counter"]
COUNT16 = 1 , # [doc = "2: Mode 2: Clock/Calendar"]
CLOCK = 2 , } impl From < MODE_A > for u8 { # [inline (always)]
fn from (variant : MODE_A) -> Self { variant as _ } } # [doc = "Field `MODE` reader - Operating Mode"]
pub type MODE_R = crate :: FieldReader < u8 , MODE_A > ; impl MODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < MODE_A > { match self . bits { 0 => Some (MODE_A :: COUNT32) , 1 => Some (MODE_A :: COUNT16) , 2 => Some (MODE_A :: CLOCK) , _ => None , } } # [doc = "Checks if the value of the field is `COUNT32`"]
# [inline (always)]
pub fn is_count32 (& self) -> bool { * self == MODE_A :: COUNT32 } # [doc = "Checks if the value of the field is `COUNT16`"]
# [inline (always)]
pub fn is_count16 (& self) -> bool { * self == MODE_A :: COUNT16 } # [doc = "Checks if the value of the field is `CLOCK`"]
# [inline (always)]
pub fn is_clock (& self) -> bool { * self == MODE_A :: CLOCK } } # [doc = "Field `MODE` writer - Operating Mode"]
pub type MODE_W < 'a > = crate :: FieldWriter < 'a , u16 , CTRL_SPEC , u8 , MODE_A , 2 , 2 > ; impl < 'a > MODE_W < 'a > { # [doc = "Mode 0: 32-bit Counter"]
# [inline (always)]
pub fn count32 (self) -> & 'a mut W { self . variant (MODE_A :: COUNT32) } # [doc = "Mode 1: 16-bit Counter"]
# [inline (always)]
pub fn count16 (self) -> & 'a mut W { self . variant (MODE_A :: COUNT16) } # [doc = "Mode 2: Clock/Calendar"]
# [inline (always)]
pub fn clock (self) -> & 'a mut W { self . variant (MODE_A :: CLOCK) } } # [doc = "Field `CLKREP` reader - Clock Representation"]
pub type CLKREP_R = crate :: BitReader < bool > ; # [doc = "Field `CLKREP` writer - Clock Representation"]
pub type CLKREP_W < 'a > = crate :: BitWriter < 'a , u16 , CTRL_SPEC , bool , 6 > ; # [doc = "Field `MATCHCLR` reader - Clear on Match"]
pub type MATCHCLR_R = crate :: BitReader < bool > ; # [doc = "Field `MATCHCLR` writer - Clear on Match"]
pub type MATCHCLR_W < 'a > = crate :: BitWriter < 'a , u16 , CTRL_SPEC , bool , 7 > ; # [doc = "Prescaler\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum PRESCALER_A { # [doc = "0: CLK_RTC_CNT = GCLK_RTC/1"]
DIV1 = 0 , # [doc = "1: CLK_RTC_CNT = GCLK_RTC/2"]
DIV2 = 1 , # [doc = "2: CLK_RTC_CNT = GCLK_RTC/4"]
DIV4 = 2 , # [doc = "3: CLK_RTC_CNT = GCLK_RTC/8"]
DIV8 = 3 , # [doc = "4: CLK_RTC_CNT = GCLK_RTC/16"]
DIV16 = 4 , # [doc = "5: CLK_RTC_CNT = GCLK_RTC/32"]
DIV32 = 5 , # [doc = "6: CLK_RTC_CNT = GCLK_RTC/64"]
DIV64 = 6 , # [doc = "7: CLK_RTC_CNT = GCLK_RTC/128"]
DIV128 = 7 , # [doc = "8: CLK_RTC_CNT = GCLK_RTC/256"]
DIV256 = 8 , # [doc = "9: CLK_RTC_CNT = GCLK_RTC/512"]
DIV512 = 9 , # [doc = "10: CLK_RTC_CNT = GCLK_RTC/1024"]
DIV1024 = 10 , } impl From < PRESCALER_A > for u8 { # [inline (always)]
fn from (variant : PRESCALER_A) -> Self { variant as _ } } # [doc = "Field `PRESCALER` reader - Prescaler"]
pub type PRESCALER_R = crate :: FieldReader < u8 , PRESCALER_A > ; impl PRESCALER_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PRESCALER_A > { match self . bits { 0 => Some (PRESCALER_A :: DIV1) , 1 => Some (PRESCALER_A :: DIV2) , 2 => Some (PRESCALER_A :: DIV4) , 3 => Some (PRESCALER_A :: DIV8) , 4 => Some (PRESCALER_A :: DIV16) , 5 => Some (PRESCALER_A :: DIV32) , 6 => Some (PRESCALER_A :: DIV64) , 7 => Some (PRESCALER_A :: DIV128) , 8 => Some (PRESCALER_A :: DIV256) , 9 => Some (PRESCALER_A :: DIV512) , 10 => Some (PRESCALER_A :: DIV1024) , _ => None , } } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == PRESCALER_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == PRESCALER_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == PRESCALER_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == PRESCALER_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == PRESCALER_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV32`"]
# [inline (always)]
pub fn is_div32 (& self) -> bool { * self == PRESCALER_A :: DIV32 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == PRESCALER_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV128`"]
# [inline (always)]
pub fn is_div128 (& self) -> bool { * self == PRESCALER_A :: DIV128 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == PRESCALER_A :: DIV256 } # [doc = "Checks if the value of the field is `DIV512`"]
# [inline (always)]
pub fn is_div512 (& self) -> bool { * self == PRESCALER_A :: DIV512 } # [doc = "Checks if the value of the field is `DIV1024`"]
# [inline (always)]
pub fn is_div1024 (& self) -> bool { * self == PRESCALER_A :: DIV1024 } } # [doc = "Field `PRESCALER` writer - Prescaler"]
pub type PRESCALER_W < 'a > = crate :: FieldWriter < 'a , u16 , CTRL_SPEC , u8 , PRESCALER_A , 4 , 8 > ; impl < 'a > PRESCALER_W < 'a > { # [doc = "CLK_RTC_CNT = GCLK_RTC/1"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV1) } # [doc = "CLK_RTC_CNT = GCLK_RTC/2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV2) } # [doc = "CLK_RTC_CNT = GCLK_RTC/4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV4) } # [doc = "CLK_RTC_CNT = GCLK_RTC/8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV8) } # [doc = "CLK_RTC_CNT = GCLK_RTC/16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV16) } # [doc = "CLK_RTC_CNT = GCLK_RTC/32"]
# [inline (always)]
pub fn div32 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV32) } # [doc = "CLK_RTC_CNT = GCLK_RTC/64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV64) } # [doc = "CLK_RTC_CNT = GCLK_RTC/128"]
# [inline (always)]
pub fn div128 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV128) } # [doc = "CLK_RTC_CNT = GCLK_RTC/256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV256) } # [doc = "CLK_RTC_CNT = GCLK_RTC/512"]
# [inline (always)]
pub fn div512 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV512) } # [doc = "CLK_RTC_CNT = GCLK_RTC/1024"]
# [inline (always)]
pub fn div1024 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV1024) } } impl R { # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Operating Mode"]
# [inline (always)]
pub fn mode (& self) -> MODE_R { MODE_R :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bit 6 - Clock Representation"]
# [inline (always)]
pub fn clkrep (& self) -> CLKREP_R { CLKREP_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Clear on Match"]
# [inline (always)]
pub fn matchclr (& self) -> MATCHCLR_R { MATCHCLR_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bits 8:11 - Prescaler"]
# [inline (always)]
pub fn prescaler (& self) -> PRESCALER_R { PRESCALER_R :: new (((self . bits >> 8) & 0x0f) as u8) } } impl W { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& mut self) -> SWRST_W { SWRST_W :: new (self) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Bits 2:3 - Operating Mode"]
# [inline (always)]
pub fn mode (& mut self) -> MODE_W { MODE_W :: new (self) } # [doc = "Bit 6 - Clock Representation"]
# [inline (always)]
pub fn clkrep (& mut self) -> CLKREP_W { CLKREP_W :: new (self) } # [doc = "Bit 7 - Clear on Match"]
# [inline (always)]
pub fn matchclr (& mut self) -> MATCHCLR_W { MATCHCLR_W :: new (self) } # [doc = "Bits 8:11 - Prescaler"]
# [inline (always)]
pub fn prescaler (& mut self) -> PRESCALER_W { PRESCALER_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MODE2 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "READREQ register accessor: an alias for `Reg<READREQ_SPEC>`"]
pub type READREQ = crate :: Reg < readreq :: READREQ_SPEC > ; # [doc = "Read Request"]
pub mod readreq { # [doc = "Register `READREQ` reader"]
pub struct R (crate :: R < READREQ_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < READREQ_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < READREQ_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < READREQ_SPEC >) -> Self { R (reader) } } # [doc = "Register `READREQ` writer"]
pub struct W (crate :: W < READREQ_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < READREQ_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < READREQ_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < READREQ_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADDR` reader - Address"]
pub type ADDR_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `RCONT` reader - Read Continuously"]
pub type RCONT_R = crate :: BitReader < bool > ; # [doc = "Field `RCONT` writer - Read Continuously"]
pub type RCONT_W < 'a > = crate :: BitWriter < 'a , u16 , READREQ_SPEC , bool , 14 > ; # [doc = "Field `RREQ` writer - Read Request"]
pub type RREQ_W < 'a > = crate :: BitWriter < 'a , u16 , READREQ_SPEC , bool , 15 > ; impl R { # [doc = "Bits 0:5 - Address"]
# [inline (always)]
pub fn addr (& self) -> ADDR_R { ADDR_R :: new ((self . bits & 0x3f) as u8) } # [doc = "Bit 14 - Read Continuously"]
# [inline (always)]
pub fn rcont (& self) -> RCONT_R { RCONT_R :: new (((self . bits >> 14) & 1) != 0) } } impl W { # [doc = "Bit 14 - Read Continuously"]
# [inline (always)]
pub fn rcont (& mut self) -> RCONT_W { RCONT_W :: new (self) } # [doc = "Bit 15 - Read Request"]
# [inline (always)]
pub fn rreq (& mut self) -> RREQ_W { RREQ_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Read Request\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [readreq](index.html) module"]
pub struct READREQ_SPEC ; impl crate :: RegisterSpec for READREQ_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [readreq::R](R) reader structure"]
impl crate :: Readable for READREQ_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [readreq::W](W) writer structure"]
impl crate :: Writable for READREQ_SPEC { type Writer = W ; } # [doc = "`reset()` method sets READREQ to value 0x10"]
impl crate :: Resettable for READREQ_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x10 } } } # [doc = "EVCTRL register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "MODE2 Event Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `PEREO0` reader - Periodic Interval 0 Event Output Enable"]
pub type PEREO0_R = crate :: BitReader < bool > ; # [doc = "Field `PEREO0` writer - Periodic Interval 0 Event Output Enable"]
pub type PEREO0_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 0 > ; # [doc = "Field `PEREO1` reader - Periodic Interval 1 Event Output Enable"]
pub type PEREO1_R = crate :: BitReader < bool > ; # [doc = "Field `PEREO1` writer - Periodic Interval 1 Event Output Enable"]
pub type PEREO1_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 1 > ; # [doc = "Field `PEREO2` reader - Periodic Interval 2 Event Output Enable"]
pub type PEREO2_R = crate :: BitReader < bool > ; # [doc = "Field `PEREO2` writer - Periodic Interval 2 Event Output Enable"]
pub type PEREO2_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 2 > ; # [doc = "Field `PEREO3` reader - Periodic Interval 3 Event Output Enable"]
pub type PEREO3_R = crate :: BitReader < bool > ; # [doc = "Field `PEREO3` writer - Periodic Interval 3 Event Output Enable"]
pub type PEREO3_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 3 > ; # [doc = "Field `PEREO4` reader - Periodic Interval 4 Event Output Enable"]
pub type PEREO4_R = crate :: BitReader < bool > ; # [doc = "Field `PEREO4` writer - Periodic Interval 4 Event Output Enable"]
pub type PEREO4_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 4 > ; # [doc = "Field `PEREO5` reader - Periodic Interval 5 Event Output Enable"]
pub type PEREO5_R = crate :: BitReader < bool > ; # [doc = "Field `PEREO5` writer - Periodic Interval 5 Event Output Enable"]
pub type PEREO5_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 5 > ; # [doc = "Field `PEREO6` reader - Periodic Interval 6 Event Output Enable"]
pub type PEREO6_R = crate :: BitReader < bool > ; # [doc = "Field `PEREO6` writer - Periodic Interval 6 Event Output Enable"]
pub type PEREO6_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 6 > ; # [doc = "Field `PEREO7` reader - Periodic Interval 7 Event Output Enable"]
pub type PEREO7_R = crate :: BitReader < bool > ; # [doc = "Field `PEREO7` writer - Periodic Interval 7 Event Output Enable"]
pub type PEREO7_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 7 > ; # [doc = "Field `ALARMEO0` reader - Alarm 0 Event Output Enable"]
pub type ALARMEO0_R = crate :: BitReader < bool > ; # [doc = "Field `ALARMEO0` writer - Alarm 0 Event Output Enable"]
pub type ALARMEO0_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 8 > ; # [doc = "Field `OVFEO` reader - Overflow Event Output Enable"]
pub type OVFEO_R = crate :: BitReader < bool > ; # [doc = "Field `OVFEO` writer - Overflow Event Output Enable"]
pub type OVFEO_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 15 > ; impl R { # [doc = "Bit 0 - Periodic Interval 0 Event Output Enable"]
# [inline (always)]
pub fn pereo0 (& self) -> PEREO0_R { PEREO0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Periodic Interval 1 Event Output Enable"]
# [inline (always)]
pub fn pereo1 (& self) -> PEREO1_R { PEREO1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Periodic Interval 2 Event Output Enable"]
# [inline (always)]
pub fn pereo2 (& self) -> PEREO2_R { PEREO2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Periodic Interval 3 Event Output Enable"]
# [inline (always)]
pub fn pereo3 (& self) -> PEREO3_R { PEREO3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Periodic Interval 4 Event Output Enable"]
# [inline (always)]
pub fn pereo4 (& self) -> PEREO4_R { PEREO4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Periodic Interval 5 Event Output Enable"]
# [inline (always)]
pub fn pereo5 (& self) -> PEREO5_R { PEREO5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Periodic Interval 6 Event Output Enable"]
# [inline (always)]
pub fn pereo6 (& self) -> PEREO6_R { PEREO6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Periodic Interval 7 Event Output Enable"]
# [inline (always)]
pub fn pereo7 (& self) -> PEREO7_R { PEREO7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Alarm 0 Event Output Enable"]
# [inline (always)]
pub fn alarmeo0 (& self) -> ALARMEO0_R { ALARMEO0_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 15 - Overflow Event Output Enable"]
# [inline (always)]
pub fn ovfeo (& self) -> OVFEO_R { OVFEO_R :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bit 0 - Periodic Interval 0 Event Output Enable"]
# [inline (always)]
pub fn pereo0 (& mut self) -> PEREO0_W { PEREO0_W :: new (self) } # [doc = "Bit 1 - Periodic Interval 1 Event Output Enable"]
# [inline (always)]
pub fn pereo1 (& mut self) -> PEREO1_W { PEREO1_W :: new (self) } # [doc = "Bit 2 - Periodic Interval 2 Event Output Enable"]
# [inline (always)]
pub fn pereo2 (& mut self) -> PEREO2_W { PEREO2_W :: new (self) } # [doc = "Bit 3 - Periodic Interval 3 Event Output Enable"]
# [inline (always)]
pub fn pereo3 (& mut self) -> PEREO3_W { PEREO3_W :: new (self) } # [doc = "Bit 4 - Periodic Interval 4 Event Output Enable"]
# [inline (always)]
pub fn pereo4 (& mut self) -> PEREO4_W { PEREO4_W :: new (self) } # [doc = "Bit 5 - Periodic Interval 5 Event Output Enable"]
# [inline (always)]
pub fn pereo5 (& mut self) -> PEREO5_W { PEREO5_W :: new (self) } # [doc = "Bit 6 - Periodic Interval 6 Event Output Enable"]
# [inline (always)]
pub fn pereo6 (& mut self) -> PEREO6_W { PEREO6_W :: new (self) } # [doc = "Bit 7 - Periodic Interval 7 Event Output Enable"]
# [inline (always)]
pub fn pereo7 (& mut self) -> PEREO7_W { PEREO7_W :: new (self) } # [doc = "Bit 8 - Alarm 0 Event Output Enable"]
# [inline (always)]
pub fn alarmeo0 (& mut self) -> ALARMEO0_W { ALARMEO0_W :: new (self) } # [doc = "Bit 15 - Overflow Event Output Enable"]
# [inline (always)]
pub fn ovfeo (& mut self) -> OVFEO_W { OVFEO_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MODE2 Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENCLR register accessor: an alias for `Reg<INTENCLR_SPEC>`"]
pub type INTENCLR = crate :: Reg < intenclr :: INTENCLR_SPEC > ; # [doc = "MODE2 Interrupt Enable Clear"]
pub mod intenclr { # [doc = "Register `INTENCLR` reader"]
pub struct R (crate :: R < INTENCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENCLR` writer"]
pub struct W (crate :: W < INTENCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `ALARM0` reader - Alarm 0 Interrupt Enable"]
pub type ALARM0_R = crate :: BitReader < bool > ; # [doc = "Field `ALARM0` writer - Alarm 0 Interrupt Enable"]
pub type ALARM0_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 0 > ; # [doc = "Field `SYNCRDY` reader - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCRDY` writer - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 6 > ; # [doc = "Field `OVF` reader - Overflow Interrupt Enable"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow Interrupt Enable"]
pub type OVF_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 7 > ; impl R { # [doc = "Bit 0 - Alarm 0 Interrupt Enable"]
# [inline (always)]
pub fn alarm0 (& self) -> ALARM0_R { ALARM0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 6 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& self) -> SYNCRDY_R { SYNCRDY_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Alarm 0 Interrupt Enable"]
# [inline (always)]
pub fn alarm0 (& mut self) -> ALARM0_W { ALARM0_W :: new (self) } # [doc = "Bit 6 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& mut self) -> SYNCRDY_W { SYNCRDY_W :: new (self) } # [doc = "Bit 7 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& mut self) -> OVF_W { OVF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MODE2 Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenclr](index.html) module"]
pub struct INTENCLR_SPEC ; impl crate :: RegisterSpec for INTENCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenclr::R](R) reader structure"]
impl crate :: Readable for INTENCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenclr::W](W) writer structure"]
impl crate :: Writable for INTENCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENCLR to value 0"]
impl crate :: Resettable for INTENCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENSET register accessor: an alias for `Reg<INTENSET_SPEC>`"]
pub type INTENSET = crate :: Reg < intenset :: INTENSET_SPEC > ; # [doc = "MODE2 Interrupt Enable Set"]
pub mod intenset { # [doc = "Register `INTENSET` reader"]
pub struct R (crate :: R < INTENSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENSET` writer"]
pub struct W (crate :: W < INTENSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `ALARM0` reader - Alarm 0 Interrupt Enable"]
pub type ALARM0_R = crate :: BitReader < bool > ; # [doc = "Field `ALARM0` writer - Alarm 0 Interrupt Enable"]
pub type ALARM0_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 0 > ; # [doc = "Field `SYNCRDY` reader - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCRDY` writer - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 6 > ; # [doc = "Field `OVF` reader - Overflow Interrupt Enable"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow Interrupt Enable"]
pub type OVF_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 7 > ; impl R { # [doc = "Bit 0 - Alarm 0 Interrupt Enable"]
# [inline (always)]
pub fn alarm0 (& self) -> ALARM0_R { ALARM0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 6 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& self) -> SYNCRDY_R { SYNCRDY_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Alarm 0 Interrupt Enable"]
# [inline (always)]
pub fn alarm0 (& mut self) -> ALARM0_W { ALARM0_W :: new (self) } # [doc = "Bit 6 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& mut self) -> SYNCRDY_W { SYNCRDY_W :: new (self) } # [doc = "Bit 7 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& mut self) -> OVF_W { OVF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MODE2 Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenset](index.html) module"]
pub struct INTENSET_SPEC ; impl crate :: RegisterSpec for INTENSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenset::R](R) reader structure"]
impl crate :: Readable for INTENSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenset::W](W) writer structure"]
impl crate :: Writable for INTENSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENSET to value 0"]
impl crate :: Resettable for INTENSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTFLAG register accessor: an alias for `Reg<INTFLAG_SPEC>`"]
pub type INTFLAG = crate :: Reg < intflag :: INTFLAG_SPEC > ; # [doc = "MODE2 Interrupt Flag Status and Clear"]
pub mod intflag { # [doc = "Register `INTFLAG` reader"]
pub struct R (crate :: R < INTFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAG` writer"]
pub struct W (crate :: W < INTFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `ALARM0` reader - Alarm 0"]
pub type ALARM0_R = crate :: BitReader < bool > ; # [doc = "Field `ALARM0` writer - Alarm 0"]
pub type ALARM0_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 0 > ; # [doc = "Field `SYNCRDY` reader - Synchronization Ready"]
pub type SYNCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCRDY` writer - Synchronization Ready"]
pub type SYNCRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 6 > ; # [doc = "Field `OVF` reader - Overflow"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow"]
pub type OVF_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 7 > ; impl R { # [doc = "Bit 0 - Alarm 0"]
# [inline (always)]
pub fn alarm0 (& self) -> ALARM0_R { ALARM0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 6 - Synchronization Ready"]
# [inline (always)]
pub fn syncrdy (& self) -> SYNCRDY_R { SYNCRDY_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Overflow"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Alarm 0"]
# [inline (always)]
pub fn alarm0 (& mut self) -> ALARM0_W { ALARM0_W :: new (self) } # [doc = "Bit 6 - Synchronization Ready"]
# [inline (always)]
pub fn syncrdy (& mut self) -> SYNCRDY_W { SYNCRDY_W :: new (self) } # [doc = "Bit 7 - Overflow"]
# [inline (always)]
pub fn ovf (& mut self) -> OVF_W { OVF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MODE2 Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflag](index.html) module"]
pub struct INTFLAG_SPEC ; impl crate :: RegisterSpec for INTFLAG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflag::R](R) reader structure"]
impl crate :: Readable for INTFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflag::W](W) writer structure"]
impl crate :: Writable for INTFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTFLAG to value 0"]
impl crate :: Resettable for INTFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATUS register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `SYNCBUSY` reader - Synchronization Busy"]
pub type SYNCBUSY_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 7 - Synchronization Busy"]
# [inline (always)]
pub fn syncbusy (& self) -> SYNCBUSY_R { SYNCBUSY_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DBGCTRL register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Debug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Run During Debug"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Run During Debug"]
pub type DBGRUN_W < 'a > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , 0 > ; impl R { # [doc = "Bit 0 - Run During Debug"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Run During Debug"]
# [inline (always)]
pub fn dbgrun (& mut self) -> DBGRUN_W { DBGRUN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "FREQCORR register accessor: an alias for `Reg<FREQCORR_SPEC>`"]
pub type FREQCORR = crate :: Reg < freqcorr :: FREQCORR_SPEC > ; # [doc = "Frequency Correction"]
pub mod freqcorr { # [doc = "Register `FREQCORR` reader"]
pub struct R (crate :: R < FREQCORR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < FREQCORR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < FREQCORR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < FREQCORR_SPEC >) -> Self { R (reader) } } # [doc = "Register `FREQCORR` writer"]
pub struct W (crate :: W < FREQCORR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < FREQCORR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < FREQCORR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < FREQCORR_SPEC >) -> Self { W (writer) } } # [doc = "Field `VALUE` reader - Correction Value"]
pub type VALUE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `VALUE` writer - Correction Value"]
pub type VALUE_W < 'a > = crate :: FieldWriter < 'a , u8 , FREQCORR_SPEC , u8 , u8 , 7 , 0 > ; # [doc = "Field `SIGN` reader - Correction Sign"]
pub type SIGN_R = crate :: BitReader < bool > ; # [doc = "Field `SIGN` writer - Correction Sign"]
pub type SIGN_W < 'a > = crate :: BitWriter < 'a , u8 , FREQCORR_SPEC , bool , 7 > ; impl R { # [doc = "Bits 0:6 - Correction Value"]
# [inline (always)]
pub fn value (& self) -> VALUE_R { VALUE_R :: new ((self . bits & 0x7f) as u8) } # [doc = "Bit 7 - Correction Sign"]
# [inline (always)]
pub fn sign (& self) -> SIGN_R { SIGN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:6 - Correction Value"]
# [inline (always)]
pub fn value (& mut self) -> VALUE_W { VALUE_W :: new (self) } # [doc = "Bit 7 - Correction Sign"]
# [inline (always)]
pub fn sign (& mut self) -> SIGN_W { SIGN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Frequency Correction\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [freqcorr](index.html) module"]
pub struct FREQCORR_SPEC ; impl crate :: RegisterSpec for FREQCORR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [freqcorr::R](R) reader structure"]
impl crate :: Readable for FREQCORR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [freqcorr::W](W) writer structure"]
impl crate :: Writable for FREQCORR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets FREQCORR to value 0"]
impl crate :: Resettable for FREQCORR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CLOCK register accessor: an alias for `Reg<CLOCK_SPEC>`"]
pub type CLOCK = crate :: Reg < clock :: CLOCK_SPEC > ; # [doc = "MODE2 Clock Value"]
pub mod clock { # [doc = "Register `CLOCK` reader"]
pub struct R (crate :: R < CLOCK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CLOCK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CLOCK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CLOCK_SPEC >) -> Self { R (reader) } } # [doc = "Register `CLOCK` writer"]
pub struct W (crate :: W < CLOCK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CLOCK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CLOCK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CLOCK_SPEC >) -> Self { W (writer) } } # [doc = "Field `SECOND` reader - Second"]
pub type SECOND_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SECOND` writer - Second"]
pub type SECOND_W < 'a > = crate :: FieldWriter < 'a , u32 , CLOCK_SPEC , u8 , u8 , 6 , 0 > ; # [doc = "Field `MINUTE` reader - Minute"]
pub type MINUTE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `MINUTE` writer - Minute"]
pub type MINUTE_W < 'a > = crate :: FieldWriter < 'a , u32 , CLOCK_SPEC , u8 , u8 , 6 , 6 > ; # [doc = "Hour\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum HOUR_A { # [doc = "0: AM when CLKREP in 12-hour"]
AM = 0 , # [doc = "16: PM when CLKREP in 12-hour"]
PM = 16 , } impl From < HOUR_A > for u8 { # [inline (always)]
fn from (variant : HOUR_A) -> Self { variant as _ } } # [doc = "Field `HOUR` reader - Hour"]
pub type HOUR_R = crate :: FieldReader < u8 , HOUR_A > ; impl HOUR_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < HOUR_A > { match self . bits { 0 => Some (HOUR_A :: AM) , 16 => Some (HOUR_A :: PM) , _ => None , } } # [doc = "Checks if the value of the field is `AM`"]
# [inline (always)]
pub fn is_am (& self) -> bool { * self == HOUR_A :: AM } # [doc = "Checks if the value of the field is `PM`"]
# [inline (always)]
pub fn is_pm (& self) -> bool { * self == HOUR_A :: PM } } # [doc = "Field `HOUR` writer - Hour"]
pub type HOUR_W < 'a > = crate :: FieldWriter < 'a , u32 , CLOCK_SPEC , u8 , HOUR_A , 5 , 12 > ; impl < 'a > HOUR_W < 'a > { # [doc = "AM when CLKREP in 12-hour"]
# [inline (always)]
pub fn am (self) -> & 'a mut W { self . variant (HOUR_A :: AM) } # [doc = "PM when CLKREP in 12-hour"]
# [inline (always)]
pub fn pm (self) -> & 'a mut W { self . variant (HOUR_A :: PM) } } # [doc = "Field `DAY` reader - Day"]
pub type DAY_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DAY` writer - Day"]
pub type DAY_W < 'a > = crate :: FieldWriter < 'a , u32 , CLOCK_SPEC , u8 , u8 , 5 , 17 > ; # [doc = "Field `MONTH` reader - Month"]
pub type MONTH_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `MONTH` writer - Month"]
pub type MONTH_W < 'a > = crate :: FieldWriter < 'a , u32 , CLOCK_SPEC , u8 , u8 , 4 , 22 > ; # [doc = "Field `YEAR` reader - Year"]
pub type YEAR_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `YEAR` writer - Year"]
pub type YEAR_W < 'a > = crate :: FieldWriter < 'a , u32 , CLOCK_SPEC , u8 , u8 , 6 , 26 > ; impl R { # [doc = "Bits 0:5 - Second"]
# [inline (always)]
pub fn second (& self) -> SECOND_R { SECOND_R :: new ((self . bits & 0x3f) as u8) } # [doc = "Bits 6:11 - Minute"]
# [inline (always)]
pub fn minute (& self) -> MINUTE_R { MINUTE_R :: new (((self . bits >> 6) & 0x3f) as u8) } # [doc = "Bits 12:16 - Hour"]
# [inline (always)]
pub fn hour (& self) -> HOUR_R { HOUR_R :: new (((self . bits >> 12) & 0x1f) as u8) } # [doc = "Bits 17:21 - Day"]
# [inline (always)]
pub fn day (& self) -> DAY_R { DAY_R :: new (((self . bits >> 17) & 0x1f) as u8) } # [doc = "Bits 22:25 - Month"]
# [inline (always)]
pub fn month (& self) -> MONTH_R { MONTH_R :: new (((self . bits >> 22) & 0x0f) as u8) } # [doc = "Bits 26:31 - Year"]
# [inline (always)]
pub fn year (& self) -> YEAR_R { YEAR_R :: new (((self . bits >> 26) & 0x3f) as u8) } } impl W { # [doc = "Bits 0:5 - Second"]
# [inline (always)]
pub fn second (& mut self) -> SECOND_W { SECOND_W :: new (self) } # [doc = "Bits 6:11 - Minute"]
# [inline (always)]
pub fn minute (& mut self) -> MINUTE_W { MINUTE_W :: new (self) } # [doc = "Bits 12:16 - Hour"]
# [inline (always)]
pub fn hour (& mut self) -> HOUR_W { HOUR_W :: new (self) } # [doc = "Bits 17:21 - Day"]
# [inline (always)]
pub fn day (& mut self) -> DAY_W { DAY_W :: new (self) } # [doc = "Bits 22:25 - Month"]
# [inline (always)]
pub fn month (& mut self) -> MONTH_W { MONTH_W :: new (self) } # [doc = "Bits 26:31 - Year"]
# [inline (always)]
pub fn year (& mut self) -> YEAR_W { YEAR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MODE2 Clock Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clock](index.html) module"]
pub struct CLOCK_SPEC ; impl crate :: RegisterSpec for CLOCK_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [clock::R](R) reader structure"]
impl crate :: Readable for CLOCK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [clock::W](W) writer structure"]
impl crate :: Writable for CLOCK_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CLOCK to value 0"]
impl crate :: Resettable for CLOCK_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "ALARM register accessor: an alias for `Reg<ALARM_SPEC>`"]
pub type ALARM = crate :: Reg < alarm :: ALARM_SPEC > ; # [doc = "MODE2 Alarm n Value"]
pub mod alarm { # [doc = "Register `ALARM%s` reader"]
pub struct R (crate :: R < ALARM_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ALARM_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ALARM_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ALARM_SPEC >) -> Self { R (reader) } } # [doc = "Register `ALARM%s` writer"]
pub struct W (crate :: W < ALARM_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ALARM_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ALARM_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ALARM_SPEC >) -> Self { W (writer) } } # [doc = "Field `SECOND` reader - Second"]
pub type SECOND_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SECOND` writer - Second"]
pub type SECOND_W < 'a > = crate :: FieldWriter < 'a , u32 , ALARM_SPEC , u8 , u8 , 6 , 0 > ; # [doc = "Field `MINUTE` reader - Minute"]
pub type MINUTE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `MINUTE` writer - Minute"]
pub type MINUTE_W < 'a > = crate :: FieldWriter < 'a , u32 , ALARM_SPEC , u8 , u8 , 6 , 6 > ; # [doc = "Hour\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum HOUR_A { # [doc = "0: Morning hour"]
AM = 0 , # [doc = "16: Afternoon hour"]
PM = 16 , } impl From < HOUR_A > for u8 { # [inline (always)]
fn from (variant : HOUR_A) -> Self { variant as _ } } # [doc = "Field `HOUR` reader - Hour"]
pub type HOUR_R = crate :: FieldReader < u8 , HOUR_A > ; impl HOUR_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < HOUR_A > { match self . bits { 0 => Some (HOUR_A :: AM) , 16 => Some (HOUR_A :: PM) , _ => None , } } # [doc = "Checks if the value of the field is `AM`"]
# [inline (always)]
pub fn is_am (& self) -> bool { * self == HOUR_A :: AM } # [doc = "Checks if the value of the field is `PM`"]
# [inline (always)]
pub fn is_pm (& self) -> bool { * self == HOUR_A :: PM } } # [doc = "Field `HOUR` writer - Hour"]
pub type HOUR_W < 'a > = crate :: FieldWriter < 'a , u32 , ALARM_SPEC , u8 , HOUR_A , 5 , 12 > ; impl < 'a > HOUR_W < 'a > { # [doc = "Morning hour"]
# [inline (always)]
pub fn am (self) -> & 'a mut W { self . variant (HOUR_A :: AM) } # [doc = "Afternoon hour"]
# [inline (always)]
pub fn pm (self) -> & 'a mut W { self . variant (HOUR_A :: PM) } } # [doc = "Field `DAY` reader - Day"]
pub type DAY_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DAY` writer - Day"]
pub type DAY_W < 'a > = crate :: FieldWriter < 'a , u32 , ALARM_SPEC , u8 , u8 , 5 , 17 > ; # [doc = "Field `MONTH` reader - Month"]
pub type MONTH_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `MONTH` writer - Month"]
pub type MONTH_W < 'a > = crate :: FieldWriter < 'a , u32 , ALARM_SPEC , u8 , u8 , 4 , 22 > ; # [doc = "Field `YEAR` reader - Year"]
pub type YEAR_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `YEAR` writer - Year"]
pub type YEAR_W < 'a > = crate :: FieldWriter < 'a , u32 , ALARM_SPEC , u8 , u8 , 6 , 26 > ; impl R { # [doc = "Bits 0:5 - Second"]
# [inline (always)]
pub fn second (& self) -> SECOND_R { SECOND_R :: new ((self . bits & 0x3f) as u8) } # [doc = "Bits 6:11 - Minute"]
# [inline (always)]
pub fn minute (& self) -> MINUTE_R { MINUTE_R :: new (((self . bits >> 6) & 0x3f) as u8) } # [doc = "Bits 12:16 - Hour"]
# [inline (always)]
pub fn hour (& self) -> HOUR_R { HOUR_R :: new (((self . bits >> 12) & 0x1f) as u8) } # [doc = "Bits 17:21 - Day"]
# [inline (always)]
pub fn day (& self) -> DAY_R { DAY_R :: new (((self . bits >> 17) & 0x1f) as u8) } # [doc = "Bits 22:25 - Month"]
# [inline (always)]
pub fn month (& self) -> MONTH_R { MONTH_R :: new (((self . bits >> 22) & 0x0f) as u8) } # [doc = "Bits 26:31 - Year"]
# [inline (always)]
pub fn year (& self) -> YEAR_R { YEAR_R :: new (((self . bits >> 26) & 0x3f) as u8) } } impl W { # [doc = "Bits 0:5 - Second"]
# [inline (always)]
pub fn second (& mut self) -> SECOND_W { SECOND_W :: new (self) } # [doc = "Bits 6:11 - Minute"]
# [inline (always)]
pub fn minute (& mut self) -> MINUTE_W { MINUTE_W :: new (self) } # [doc = "Bits 12:16 - Hour"]
# [inline (always)]
pub fn hour (& mut self) -> HOUR_W { HOUR_W :: new (self) } # [doc = "Bits 17:21 - Day"]
# [inline (always)]
pub fn day (& mut self) -> DAY_W { DAY_W :: new (self) } # [doc = "Bits 22:25 - Month"]
# [inline (always)]
pub fn month (& mut self) -> MONTH_W { MONTH_W :: new (self) } # [doc = "Bits 26:31 - Year"]
# [inline (always)]
pub fn year (& mut self) -> YEAR_W { YEAR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MODE2 Alarm n Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [alarm](index.html) module"]
pub struct ALARM_SPEC ; impl crate :: RegisterSpec for ALARM_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [alarm::R](R) reader structure"]
impl crate :: Readable for ALARM_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [alarm::W](W) writer structure"]
impl crate :: Writable for ALARM_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ALARM%s to value 0"]
impl crate :: Resettable for ALARM_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "MASK register accessor: an alias for `Reg<MASK_SPEC>`"]
pub type MASK = crate :: Reg < mask :: MASK_SPEC > ; # [doc = "MODE2 Alarm n Mask"]
pub mod mask { # [doc = "Register `MASK%s` reader"]
pub struct R (crate :: R < MASK_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < MASK_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < MASK_SPEC >) -> Self { R (reader) } } # [doc = "Register `MASK%s` writer"]
pub struct W (crate :: W < MASK_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < MASK_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < MASK_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < MASK_SPEC >) -> Self { W (writer) } } # [doc = "Alarm Mask Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum SEL_A { # [doc = "0: Alarm Disabled"]
OFF = 0 , # [doc = "1: Match seconds only"]
SS = 1 , # [doc = "2: Match seconds and minutes only"]
MMSS = 2 , # [doc = "3: Match seconds, minutes, and hours only"]
HHMMSS = 3 , # [doc = "4: Match seconds, minutes, hours, and days only"]
DDHHMMSS = 4 , # [doc = "5: Match seconds, minutes, hours, days, and months only"]
MMDDHHMMSS = 5 , # [doc = "6: Match seconds, minutes, hours, days, months, and years"]
YYMMDDHHMMSS = 6 , } impl From < SEL_A > for u8 { # [inline (always)]
fn from (variant : SEL_A) -> Self { variant as _ } } # [doc = "Field `SEL` reader - Alarm Mask Selection"]
pub type SEL_R = crate :: FieldReader < u8 , SEL_A > ; impl SEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SEL_A > { match self . bits { 0 => Some (SEL_A :: OFF) , 1 => Some (SEL_A :: SS) , 2 => Some (SEL_A :: MMSS) , 3 => Some (SEL_A :: HHMMSS) , 4 => Some (SEL_A :: DDHHMMSS) , 5 => Some (SEL_A :: MMDDHHMMSS) , 6 => Some (SEL_A :: YYMMDDHHMMSS) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == SEL_A :: OFF } # [doc = "Checks if the value of the field is `SS`"]
# [inline (always)]
pub fn is_ss (& self) -> bool { * self == SEL_A :: SS } # [doc = "Checks if the value of the field is `MMSS`"]
# [inline (always)]
pub fn is_mmss (& self) -> bool { * self == SEL_A :: MMSS } # [doc = "Checks if the value of the field is `HHMMSS`"]
# [inline (always)]
pub fn is_hhmmss (& self) -> bool { * self == SEL_A :: HHMMSS } # [doc = "Checks if the value of the field is `DDHHMMSS`"]
# [inline (always)]
pub fn is_ddhhmmss (& self) -> bool { * self == SEL_A :: DDHHMMSS } # [doc = "Checks if the value of the field is `MMDDHHMMSS`"]
# [inline (always)]
pub fn is_mmddhhmmss (& self) -> bool { * self == SEL_A :: MMDDHHMMSS } # [doc = "Checks if the value of the field is `YYMMDDHHMMSS`"]
# [inline (always)]
pub fn is_yymmddhhmmss (& self) -> bool { * self == SEL_A :: YYMMDDHHMMSS } } # [doc = "Field `SEL` writer - Alarm Mask Selection"]
pub type SEL_W < 'a > = crate :: FieldWriter < 'a , u8 , MASK_SPEC , u8 , SEL_A , 3 , 0 > ; impl < 'a > SEL_W < 'a > { # [doc = "Alarm Disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (SEL_A :: OFF) } # [doc = "Match seconds only"]
# [inline (always)]
pub fn ss (self) -> & 'a mut W { self . variant (SEL_A :: SS) } # [doc = "Match seconds and minutes only"]
# [inline (always)]
pub fn mmss (self) -> & 'a mut W { self . variant (SEL_A :: MMSS) } # [doc = "Match seconds, minutes, and hours only"]
# [inline (always)]
pub fn hhmmss (self) -> & 'a mut W { self . variant (SEL_A :: HHMMSS) } # [doc = "Match seconds, minutes, hours, and days only"]
# [inline (always)]
pub fn ddhhmmss (self) -> & 'a mut W { self . variant (SEL_A :: DDHHMMSS) } # [doc = "Match seconds, minutes, hours, days, and months only"]
# [inline (always)]
pub fn mmddhhmmss (self) -> & 'a mut W { self . variant (SEL_A :: MMDDHHMMSS) } # [doc = "Match seconds, minutes, hours, days, months, and years"]
# [inline (always)]
pub fn yymmddhhmmss (self) -> & 'a mut W { self . variant (SEL_A :: YYMMDDHHMMSS) } } impl R { # [doc = "Bits 0:2 - Alarm Mask Selection"]
# [inline (always)]
pub fn sel (& self) -> SEL_R { SEL_R :: new ((self . bits & 7) as u8) } } impl W { # [doc = "Bits 0:2 - Alarm Mask Selection"]
# [inline (always)]
pub fn sel (& mut self) -> SEL_W { SEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "MODE2 Alarm n Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mask](index.html) module"]
pub struct MASK_SPEC ; impl crate :: RegisterSpec for MASK_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [mask::R](R) reader structure"]
impl crate :: Readable for MASK_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [mask::W](W) writer structure"]
impl crate :: Writable for MASK_SPEC { type Writer = W ; } # [doc = "`reset()` method sets MASK%s to value 0"]
impl crate :: Resettable for MASK_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } } # [doc = "Serial Communication Interface 0"]
pub struct SERCOM0 { _marker : PhantomData < * const () > } unsafe impl Send for SERCOM0 { } impl SERCOM0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const sercom0 :: RegisterBlock = 0x4200_0800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const sercom0 :: RegisterBlock { Self :: PTR } } impl Deref for SERCOM0 { type Target = sercom0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SERCOM0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SERCOM0") . finish () } } # [doc = "Serial Communication Interface 0"]
pub mod sercom0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { _reserved_0_spi : [u8 ; 0x31]
, } impl RegisterBlock { # [doc = "0x00..0x31 - USART Mode"]
# [inline (always)]
pub fn usart (& self) -> & USART { unsafe { & * (((self as * const Self) as * const u8) . add (0usize) as * const USART) } } # [doc = "0x00..0x31 - SPI Mode"]
# [inline (always)]
pub fn spi (& self) -> & SPI { unsafe { & * (((self as * const Self) as * const u8) . add (0usize) as * const SPI) } } # [doc = "0x00..0x29 - I2C Slave Mode"]
# [inline (always)]
pub fn i2cs (& self) -> & I2CS { unsafe { & * (((self as * const Self) as * const u8) . add (0usize) as * const I2CS) } } # [doc = "0x00..0x31 - I2C Master Mode"]
# [inline (always)]
pub fn i2cm (& self) -> & I2CM { unsafe { & * (((self as * const Self) as * const u8) . add (0usize) as * const I2CM) } } } # [doc = r"Register block"]
# [repr (C)]
pub struct I2CM { # [doc = "0x00 - I2CM Control A"]
pub ctrla : crate :: Reg < self :: i2cm :: ctrla :: CTRLA_SPEC > , # [doc = "0x04 - I2CM Control B"]
pub ctrlb : crate :: Reg < self :: i2cm :: ctrlb :: CTRLB_SPEC > , _reserved2 : [u8 ; 0x04]
, # [doc = "0x0c - I2CM Baud Rate"]
pub baud : crate :: Reg < self :: i2cm :: baud :: BAUD_SPEC > , _reserved3 : [u8 ; 0x04]
, # [doc = "0x14 - I2CM Interrupt Enable Clear"]
pub intenclr : crate :: Reg < self :: i2cm :: intenclr :: INTENCLR_SPEC > , _reserved4 : [u8 ; 0x01]
, # [doc = "0x16 - I2CM Interrupt Enable Set"]
pub intenset : crate :: Reg < self :: i2cm :: intenset :: INTENSET_SPEC > , _reserved5 : [u8 ; 0x01]
, # [doc = "0x18 - I2CM Interrupt Flag Status and Clear"]
pub intflag : crate :: Reg < self :: i2cm :: intflag :: INTFLAG_SPEC > , _reserved6 : [u8 ; 0x01]
, # [doc = "0x1a - I2CM Status"]
pub status : crate :: Reg < self :: i2cm :: status :: STATUS_SPEC > , # [doc = "0x1c - I2CM Synchronization Busy"]
pub syncbusy : crate :: Reg < self :: i2cm :: syncbusy :: SYNCBUSY_SPEC > , _reserved8 : [u8 ; 0x04]
, # [doc = "0x24 - I2CM Address"]
pub addr : crate :: Reg < self :: i2cm :: addr :: ADDR_SPEC > , # [doc = "0x28 - I2CM Data"]
pub data : crate :: Reg < self :: i2cm :: data :: DATA_SPEC > , _reserved10 : [u8 ; 0x07]
, # [doc = "0x30 - I2CM Debug Control"]
pub dbgctrl : crate :: Reg < self :: i2cm :: dbgctrl :: DBGCTRL_SPEC > , } # [doc = r"Register block"]
# [doc = "I2C Master Mode"]
pub mod i2cm { # [doc = "CTRLA register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "I2CM Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWRST` reader - Software Reset"]
pub type SWRST_R = crate :: BitReader < bool > ; # [doc = "Field `SWRST` writer - Software Reset"]
pub type SWRST_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 0 > ; # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 1 > ; # [doc = "Operating Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum MODE_A { # [doc = "0: USART mode with external clock"]
USART_EXT_CLK = 0 , # [doc = "1: USART mode with internal clock"]
USART_INT_CLK = 1 , # [doc = "2: SPI mode with external clock"]
SPI_SLAVE = 2 , # [doc = "3: SPI mode with internal clock"]
SPI_MASTER = 3 , # [doc = "4: I2C mode with external clock"]
I2C_SLAVE = 4 , # [doc = "5: I2C mode with internal clock"]
I2C_MASTER = 5 , } impl From < MODE_A > for u8 { # [inline (always)]
fn from (variant : MODE_A) -> Self { variant as _ } } # [doc = "Field `MODE` reader - Operating Mode"]
pub type MODE_R = crate :: FieldReader < u8 , MODE_A > ; impl MODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < MODE_A > { match self . bits { 0 => Some (MODE_A :: USART_EXT_CLK) , 1 => Some (MODE_A :: USART_INT_CLK) , 2 => Some (MODE_A :: SPI_SLAVE) , 3 => Some (MODE_A :: SPI_MASTER) , 4 => Some (MODE_A :: I2C_SLAVE) , 5 => Some (MODE_A :: I2C_MASTER) , _ => None , } } # [doc = "Checks if the value of the field is `USART_EXT_CLK`"]
# [inline (always)]
pub fn is_usart_ext_clk (& self) -> bool { * self == MODE_A :: USART_EXT_CLK } # [doc = "Checks if the value of the field is `USART_INT_CLK`"]
# [inline (always)]
pub fn is_usart_int_clk (& self) -> bool { * self == MODE_A :: USART_INT_CLK } # [doc = "Checks if the value of the field is `SPI_SLAVE`"]
# [inline (always)]
pub fn is_spi_slave (& self) -> bool { * self == MODE_A :: SPI_SLAVE } # [doc = "Checks if the value of the field is `SPI_MASTER`"]
# [inline (always)]
pub fn is_spi_master (& self) -> bool { * self == MODE_A :: SPI_MASTER } # [doc = "Checks if the value of the field is `I2C_SLAVE`"]
# [inline (always)]
pub fn is_i2c_slave (& self) -> bool { * self == MODE_A :: I2C_SLAVE } # [doc = "Checks if the value of the field is `I2C_MASTER`"]
# [inline (always)]
pub fn is_i2c_master (& self) -> bool { * self == MODE_A :: I2C_MASTER } } # [doc = "Field `MODE` writer - Operating Mode"]
pub type MODE_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLA_SPEC , u8 , MODE_A , 3 , 2 > ; impl < 'a > MODE_W < 'a > { # [doc = "USART mode with external clock"]
# [inline (always)]
pub fn usart_ext_clk (self) -> & 'a mut W { self . variant (MODE_A :: USART_EXT_CLK) } # [doc = "USART mode with internal clock"]
# [inline (always)]
pub fn usart_int_clk (self) -> & 'a mut W { self . variant (MODE_A :: USART_INT_CLK) } # [doc = "SPI mode with external clock"]
# [inline (always)]
pub fn spi_slave (self) -> & 'a mut W { self . variant (MODE_A :: SPI_SLAVE) } # [doc = "SPI mode with internal clock"]
# [inline (always)]
pub fn spi_master (self) -> & 'a mut W { self . variant (MODE_A :: SPI_MASTER) } # [doc = "I2C mode with external clock"]
# [inline (always)]
pub fn i2c_slave (self) -> & 'a mut W { self . variant (MODE_A :: I2C_SLAVE) } # [doc = "I2C mode with internal clock"]
# [inline (always)]
pub fn i2c_master (self) -> & 'a mut W { self . variant (MODE_A :: I2C_MASTER) } } # [doc = "Field `RUNSTDBY` reader - Run in Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run in Standby"]
pub type RUNSTDBY_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 7 > ; # [doc = "Field `PINOUT` reader - Pin Usage"]
pub type PINOUT_R = crate :: BitReader < bool > ; # [doc = "Field `PINOUT` writer - Pin Usage"]
pub type PINOUT_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 16 > ; # [doc = "Field `SDAHOLD` reader - SDA Hold Time"]
pub type SDAHOLD_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SDAHOLD` writer - SDA Hold Time"]
pub type SDAHOLD_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLA_SPEC , u8 , u8 , 2 , 20 > ; # [doc = "Field `MEXTTOEN` reader - Master SCL Low Extend Timeout"]
pub type MEXTTOEN_R = crate :: BitReader < bool > ; # [doc = "Field `MEXTTOEN` writer - Master SCL Low Extend Timeout"]
pub type MEXTTOEN_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 22 > ; # [doc = "Field `SEXTTOEN` reader - Slave SCL Low Extend Timeout"]
pub type SEXTTOEN_R = crate :: BitReader < bool > ; # [doc = "Field `SEXTTOEN` writer - Slave SCL Low Extend Timeout"]
pub type SEXTTOEN_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 23 > ; # [doc = "Field `SPEED` reader - Transfer Speed"]
pub type SPEED_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SPEED` writer - Transfer Speed"]
pub type SPEED_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLA_SPEC , u8 , u8 , 2 , 24 > ; # [doc = "Field `SCLSM` reader - SCL Clock Stretch Mode"]
pub type SCLSM_R = crate :: BitReader < bool > ; # [doc = "Field `SCLSM` writer - SCL Clock Stretch Mode"]
pub type SCLSM_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 27 > ; # [doc = "Field `INACTOUT` reader - Inactive Time-Out"]
pub type INACTOUT_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `INACTOUT` writer - Inactive Time-Out"]
pub type INACTOUT_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLA_SPEC , u8 , u8 , 2 , 28 > ; # [doc = "Field `LOWTOUTEN` reader - SCL Low Timeout Enable"]
pub type LOWTOUTEN_R = crate :: BitReader < bool > ; # [doc = "Field `LOWTOUTEN` writer - SCL Low Timeout Enable"]
pub type LOWTOUTEN_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 30 > ; impl R { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& self) -> SWRST_R { SWRST_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:4 - Operating Mode"]
# [inline (always)]
pub fn mode (& self) -> MODE_R { MODE_R :: new (((self . bits >> 2) & 7) as u8) } # [doc = "Bit 7 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 16 - Pin Usage"]
# [inline (always)]
pub fn pinout (& self) -> PINOUT_R { PINOUT_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bits 20:21 - SDA Hold Time"]
# [inline (always)]
pub fn sdahold (& self) -> SDAHOLD_R { SDAHOLD_R :: new (((self . bits >> 20) & 3) as u8) } # [doc = "Bit 22 - Master SCL Low Extend Timeout"]
# [inline (always)]
pub fn mexttoen (& self) -> MEXTTOEN_R { MEXTTOEN_R :: new (((self . bits >> 22) & 1) != 0) } # [doc = "Bit 23 - Slave SCL Low Extend Timeout"]
# [inline (always)]
pub fn sexttoen (& self) -> SEXTTOEN_R { SEXTTOEN_R :: new (((self . bits >> 23) & 1) != 0) } # [doc = "Bits 24:25 - Transfer Speed"]
# [inline (always)]
pub fn speed (& self) -> SPEED_R { SPEED_R :: new (((self . bits >> 24) & 3) as u8) } # [doc = "Bit 27 - SCL Clock Stretch Mode"]
# [inline (always)]
pub fn sclsm (& self) -> SCLSM_R { SCLSM_R :: new (((self . bits >> 27) & 1) != 0) } # [doc = "Bits 28:29 - Inactive Time-Out"]
# [inline (always)]
pub fn inactout (& self) -> INACTOUT_R { INACTOUT_R :: new (((self . bits >> 28) & 3) as u8) } # [doc = "Bit 30 - SCL Low Timeout Enable"]
# [inline (always)]
pub fn lowtouten (& self) -> LOWTOUTEN_R { LOWTOUTEN_R :: new (((self . bits >> 30) & 1) != 0) } } impl W { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& mut self) -> SWRST_W { SWRST_W :: new (self) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Bits 2:4 - Operating Mode"]
# [inline (always)]
pub fn mode (& mut self) -> MODE_W { MODE_W :: new (self) } # [doc = "Bit 7 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& mut self) -> RUNSTDBY_W { RUNSTDBY_W :: new (self) } # [doc = "Bit 16 - Pin Usage"]
# [inline (always)]
pub fn pinout (& mut self) -> PINOUT_W { PINOUT_W :: new (self) } # [doc = "Bits 20:21 - SDA Hold Time"]
# [inline (always)]
pub fn sdahold (& mut self) -> SDAHOLD_W { SDAHOLD_W :: new (self) } # [doc = "Bit 22 - Master SCL Low Extend Timeout"]
# [inline (always)]
pub fn mexttoen (& mut self) -> MEXTTOEN_W { MEXTTOEN_W :: new (self) } # [doc = "Bit 23 - Slave SCL Low Extend Timeout"]
# [inline (always)]
pub fn sexttoen (& mut self) -> SEXTTOEN_W { SEXTTOEN_W :: new (self) } # [doc = "Bits 24:25 - Transfer Speed"]
# [inline (always)]
pub fn speed (& mut self) -> SPEED_W { SPEED_W :: new (self) } # [doc = "Bit 27 - SCL Clock Stretch Mode"]
# [inline (always)]
pub fn sclsm (& mut self) -> SCLSM_W { SCLSM_W :: new (self) } # [doc = "Bits 28:29 - Inactive Time-Out"]
# [inline (always)]
pub fn inactout (& mut self) -> INACTOUT_W { INACTOUT_W :: new (self) } # [doc = "Bit 30 - SCL Low Timeout Enable"]
# [inline (always)]
pub fn lowtouten (& mut self) -> LOWTOUTEN_W { LOWTOUTEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "I2CM Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CTRLB register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "I2CM Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `SMEN` reader - Smart Mode Enable"]
pub type SMEN_R = crate :: BitReader < bool > ; # [doc = "Field `SMEN` writer - Smart Mode Enable"]
pub type SMEN_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLB_SPEC , bool , 8 > ; # [doc = "Field `QCEN` reader - Quick Command Enable"]
pub type QCEN_R = crate :: BitReader < bool > ; # [doc = "Field `QCEN` writer - Quick Command Enable"]
pub type QCEN_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLB_SPEC , bool , 9 > ; # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLB_SPEC , u8 , u8 , 2 , 16 > ; # [doc = "Field `ACKACT` reader - Acknowledge Action"]
pub type ACKACT_R = crate :: BitReader < bool > ; # [doc = "Field `ACKACT` writer - Acknowledge Action"]
pub type ACKACT_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLB_SPEC , bool , 18 > ; impl R { # [doc = "Bit 8 - Smart Mode Enable"]
# [inline (always)]
pub fn smen (& self) -> SMEN_R { SMEN_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Quick Command Enable"]
# [inline (always)]
pub fn qcen (& self) -> QCEN_R { QCEN_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 18 - Acknowledge Action"]
# [inline (always)]
pub fn ackact (& self) -> ACKACT_R { ACKACT_R :: new (((self . bits >> 18) & 1) != 0) } } impl W { # [doc = "Bit 8 - Smart Mode Enable"]
# [inline (always)]
pub fn smen (& mut self) -> SMEN_W { SMEN_W :: new (self) } # [doc = "Bit 9 - Quick Command Enable"]
# [inline (always)]
pub fn qcen (& mut self) -> QCEN_W { QCEN_W :: new (self) } # [doc = "Bits 16:17 - Command"]
# [inline (always)]
pub fn cmd (& mut self) -> CMD_W { CMD_W :: new (self) } # [doc = "Bit 18 - Acknowledge Action"]
# [inline (always)]
pub fn ackact (& mut self) -> ACKACT_W { ACKACT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "I2CM Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "BAUD register accessor: an alias for `Reg<BAUD_SPEC>`"]
pub type BAUD = crate :: Reg < baud :: BAUD_SPEC > ; # [doc = "I2CM Baud Rate"]
pub mod baud { # [doc = "Register `BAUD` reader"]
pub struct R (crate :: R < BAUD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUD_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUD` writer"]
pub struct W (crate :: W < BAUD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUD_SPEC >) -> Self { W (writer) } } # [doc = "Field `BAUD` reader - Baud Rate Value"]
pub type BAUD_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BAUD` writer - Baud Rate Value"]
pub type BAUD_W < 'a > = crate :: FieldWriter < 'a , u32 , BAUD_SPEC , u8 , u8 , 8 , 0 > ; # [doc = "Field `BAUDLOW` reader - Baud Rate Value Low"]
pub type BAUDLOW_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BAUDLOW` writer - Baud Rate Value Low"]
pub type BAUDLOW_W < 'a > = crate :: FieldWriter < 'a , u32 , BAUD_SPEC , u8 , u8 , 8 , 8 > ; # [doc = "Field `HSBAUD` reader - High Speed Baud Rate Value"]
pub type HSBAUD_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `HSBAUD` writer - High Speed Baud Rate Value"]
pub type HSBAUD_W < 'a > = crate :: FieldWriter < 'a , u32 , BAUD_SPEC , u8 , u8 , 8 , 16 > ; # [doc = "Field `HSBAUDLOW` reader - High Speed Baud Rate Value Low"]
pub type HSBAUDLOW_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `HSBAUDLOW` writer - High Speed Baud Rate Value Low"]
pub type HSBAUDLOW_W < 'a > = crate :: FieldWriter < 'a , u32 , BAUD_SPEC , u8 , u8 , 8 , 24 > ; impl R { # [doc = "Bits 0:7 - Baud Rate Value"]
# [inline (always)]
pub fn baud (& self) -> BAUD_R { BAUD_R :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - Baud Rate Value Low"]
# [inline (always)]
pub fn baudlow (& self) -> BAUDLOW_R { BAUDLOW_R :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:23 - High Speed Baud Rate Value"]
# [inline (always)]
pub fn hsbaud (& self) -> HSBAUD_R { HSBAUD_R :: new (((self . bits >> 16) & 0xff) as u8) } # [doc = "Bits 24:31 - High Speed Baud Rate Value Low"]
# [inline (always)]
pub fn hsbaudlow (& self) -> HSBAUDLOW_R { HSBAUDLOW_R :: new (((self . bits >> 24) & 0xff) as u8) } } impl W { # [doc = "Bits 0:7 - Baud Rate Value"]
# [inline (always)]
pub fn baud (& mut self) -> BAUD_W { BAUD_W :: new (self) } # [doc = "Bits 8:15 - Baud Rate Value Low"]
# [inline (always)]
pub fn baudlow (& mut self) -> BAUDLOW_W { BAUDLOW_W :: new (self) } # [doc = "Bits 16:23 - High Speed Baud Rate Value"]
# [inline (always)]
pub fn hsbaud (& mut self) -> HSBAUD_W { HSBAUD_W :: new (self) } # [doc = "Bits 24:31 - High Speed Baud Rate Value Low"]
# [inline (always)]
pub fn hsbaudlow (& mut self) -> HSBAUDLOW_W { HSBAUDLOW_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "I2CM Baud Rate\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baud](index.html) module"]
pub struct BAUD_SPEC ; impl crate :: RegisterSpec for BAUD_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [baud::R](R) reader structure"]
impl crate :: Readable for BAUD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baud::W](W) writer structure"]
impl crate :: Writable for BAUD_SPEC { type Writer = W ; } # [doc = "`reset()` method sets BAUD to value 0"]
impl crate :: Resettable for BAUD_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENCLR register accessor: an alias for `Reg<INTENCLR_SPEC>`"]
pub type INTENCLR = crate :: Reg < intenclr :: INTENCLR_SPEC > ; # [doc = "I2CM Interrupt Enable Clear"]
pub mod intenclr { # [doc = "Register `INTENCLR` reader"]
pub struct R (crate :: R < INTENCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENCLR` writer"]
pub struct W (crate :: W < INTENCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `MB` reader - Master On Bus Interrupt Disable"]
pub type MB_R = crate :: BitReader < bool > ; # [doc = "Field `MB` writer - Master On Bus Interrupt Disable"]
pub type MB_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 0 > ; # [doc = "Field `SB` reader - Slave On Bus Interrupt Disable"]
pub type SB_R = crate :: BitReader < bool > ; # [doc = "Field `SB` writer - Slave On Bus Interrupt Disable"]
pub type SB_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 1 > ; # [doc = "Field `ERROR` reader - Combined Error Interrupt Disable"]
pub type ERROR_R = crate :: BitReader < bool > ; # [doc = "Field `ERROR` writer - Combined Error Interrupt Disable"]
pub type ERROR_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 7 > ; impl R { # [doc = "Bit 0 - Master On Bus Interrupt Disable"]
# [inline (always)]
pub fn mb (& self) -> MB_R { MB_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Slave On Bus Interrupt Disable"]
# [inline (always)]
pub fn sb (& self) -> SB_R { SB_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 7 - Combined Error Interrupt Disable"]
# [inline (always)]
pub fn error (& self) -> ERROR_R { ERROR_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Master On Bus Interrupt Disable"]
# [inline (always)]
pub fn mb (& mut self) -> MB_W { MB_W :: new (self) } # [doc = "Bit 1 - Slave On Bus Interrupt Disable"]
# [inline (always)]
pub fn sb (& mut self) -> SB_W { SB_W :: new (self) } # [doc = "Bit 7 - Combined Error Interrupt Disable"]
# [inline (always)]
pub fn error (& mut self) -> ERROR_W { ERROR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "I2CM Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenclr](index.html) module"]
pub struct INTENCLR_SPEC ; impl crate :: RegisterSpec for INTENCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenclr::R](R) reader structure"]
impl crate :: Readable for INTENCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenclr::W](W) writer structure"]
impl crate :: Writable for INTENCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENCLR to value 0"]
impl crate :: Resettable for INTENCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENSET register accessor: an alias for `Reg<INTENSET_SPEC>`"]
pub type INTENSET = crate :: Reg < intenset :: INTENSET_SPEC > ; # [doc = "I2CM Interrupt Enable Set"]
pub mod intenset { # [doc = "Register `INTENSET` reader"]
pub struct R (crate :: R < INTENSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENSET` writer"]
pub struct W (crate :: W < INTENSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `MB` reader - Master On Bus Interrupt Enable"]
pub type MB_R = crate :: BitReader < bool > ; # [doc = "Field `MB` writer - Master On Bus Interrupt Enable"]
pub type MB_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 0 > ; # [doc = "Field `SB` reader - Slave On Bus Interrupt Enable"]
pub type SB_R = crate :: BitReader < bool > ; # [doc = "Field `SB` writer - Slave On Bus Interrupt Enable"]
pub type SB_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 1 > ; # [doc = "Field `ERROR` reader - Combined Error Interrupt Enable"]
pub type ERROR_R = crate :: BitReader < bool > ; # [doc = "Field `ERROR` writer - Combined Error Interrupt Enable"]
pub type ERROR_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 7 > ; impl R { # [doc = "Bit 0 - Master On Bus Interrupt Enable"]
# [inline (always)]
pub fn mb (& self) -> MB_R { MB_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Slave On Bus Interrupt Enable"]
# [inline (always)]
pub fn sb (& self) -> SB_R { SB_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 7 - Combined Error Interrupt Enable"]
# [inline (always)]
pub fn error (& self) -> ERROR_R { ERROR_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Master On Bus Interrupt Enable"]
# [inline (always)]
pub fn mb (& mut self) -> MB_W { MB_W :: new (self) } # [doc = "Bit 1 - Slave On Bus Interrupt Enable"]
# [inline (always)]
pub fn sb (& mut self) -> SB_W { SB_W :: new (self) } # [doc = "Bit 7 - Combined Error Interrupt Enable"]
# [inline (always)]
pub fn error (& mut self) -> ERROR_W { ERROR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "I2CM Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenset](index.html) module"]
pub struct INTENSET_SPEC ; impl crate :: RegisterSpec for INTENSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenset::R](R) reader structure"]
impl crate :: Readable for INTENSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenset::W](W) writer structure"]
impl crate :: Writable for INTENSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENSET to value 0"]
impl crate :: Resettable for INTENSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTFLAG register accessor: an alias for `Reg<INTFLAG_SPEC>`"]
pub type INTFLAG = crate :: Reg < intflag :: INTFLAG_SPEC > ; # [doc = "I2CM Interrupt Flag Status and Clear"]
pub mod intflag { # [doc = "Register `INTFLAG` reader"]
pub struct R (crate :: R < INTFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAG` writer"]
pub struct W (crate :: W < INTFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `MB` reader - Master On Bus Interrupt"]
pub type MB_R = crate :: BitReader < bool > ; # [doc = "Field `MB` writer - Master On Bus Interrupt"]
pub type MB_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 0 > ; # [doc = "Field `SB` reader - Slave On Bus Interrupt"]
pub type SB_R = crate :: BitReader < bool > ; # [doc = "Field `SB` writer - Slave On Bus Interrupt"]
pub type SB_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 1 > ; # [doc = "Field `ERROR` reader - Combined Error Interrupt"]
pub type ERROR_R = crate :: BitReader < bool > ; # [doc = "Field `ERROR` writer - Combined Error Interrupt"]
pub type ERROR_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 7 > ; impl R { # [doc = "Bit 0 - Master On Bus Interrupt"]
# [inline (always)]
pub fn mb (& self) -> MB_R { MB_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Slave On Bus Interrupt"]
# [inline (always)]
pub fn sb (& self) -> SB_R { SB_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 7 - Combined Error Interrupt"]
# [inline (always)]
pub fn error (& self) -> ERROR_R { ERROR_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Master On Bus Interrupt"]
# [inline (always)]
pub fn mb (& mut self) -> MB_W { MB_W :: new (self) } # [doc = "Bit 1 - Slave On Bus Interrupt"]
# [inline (always)]
pub fn sb (& mut self) -> SB_W { SB_W :: new (self) } # [doc = "Bit 7 - Combined Error Interrupt"]
# [inline (always)]
pub fn error (& mut self) -> ERROR_W { ERROR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "I2CM Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflag](index.html) module"]
pub struct INTFLAG_SPEC ; impl crate :: RegisterSpec for INTFLAG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflag::R](R) reader structure"]
impl crate :: Readable for INTFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflag::W](W) writer structure"]
impl crate :: Writable for INTFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTFLAG to value 0"]
impl crate :: Resettable for INTFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATUS register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "I2CM Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `BUSERR` reader - Bus Error"]
pub type BUSERR_R = crate :: BitReader < bool > ; # [doc = "Field `BUSERR` writer - Bus Error"]
pub type BUSERR_W < 'a > = crate :: BitWriter < 'a , u16 , STATUS_SPEC , bool , 0 > ; # [doc = "Field `ARBLOST` reader - Arbitration Lost"]
pub type ARBLOST_R = crate :: BitReader < bool > ; # [doc = "Field `ARBLOST` writer - Arbitration Lost"]
pub type ARBLOST_W < 'a > = crate :: BitWriter < 'a , u16 , STATUS_SPEC , bool , 1 > ; # [doc = "Field `RXNACK` reader - Received Not Acknowledge"]
pub type RXNACK_R = crate :: BitReader < bool > ; # [doc = "Field `BUSSTATE` reader - Bus State"]
pub type BUSSTATE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BUSSTATE` writer - Bus State"]
pub type BUSSTATE_W < 'a > = crate :: FieldWriter < 'a , u16 , STATUS_SPEC , u8 , u8 , 2 , 4 > ; # [doc = "Field `LOWTOUT` reader - SCL Low Timeout"]
pub type LOWTOUT_R = crate :: BitReader < bool > ; # [doc = "Field `LOWTOUT` writer - SCL Low Timeout"]
pub type LOWTOUT_W < 'a > = crate :: BitWriter < 'a , u16 , STATUS_SPEC , bool , 6 > ; # [doc = "Field `CLKHOLD` reader - Clock Hold"]
pub type CLKHOLD_R = crate :: BitReader < bool > ; # [doc = "Field `MEXTTOUT` reader - Master SCL Low Extend Timeout"]
pub type MEXTTOUT_R = crate :: BitReader < bool > ; # [doc = "Field `MEXTTOUT` writer - Master SCL Low Extend Timeout"]
pub type MEXTTOUT_W < 'a > = crate :: BitWriter < 'a , u16 , STATUS_SPEC , bool , 8 > ; # [doc = "Field `SEXTTOUT` reader - Slave SCL Low Extend Timeout"]
pub type SEXTTOUT_R = crate :: BitReader < bool > ; # [doc = "Field `SEXTTOUT` writer - Slave SCL Low Extend Timeout"]
pub type SEXTTOUT_W < 'a > = crate :: BitWriter < 'a , u16 , STATUS_SPEC , bool , 9 > ; # [doc = "Field `LENERR` reader - Length Error"]
pub type LENERR_R = crate :: BitReader < bool > ; # [doc = "Field `LENERR` writer - Length Error"]
pub type LENERR_W < 'a > = crate :: BitWriter < 'a , u16 , STATUS_SPEC , bool , 10 > ; impl R { # [doc = "Bit 0 - Bus Error"]
# [inline (always)]
pub fn buserr (& self) -> BUSERR_R { BUSERR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Arbitration Lost"]
# [inline (always)]
pub fn arblost (& self) -> ARBLOST_R { ARBLOST_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Received Not Acknowledge"]
# [inline (always)]
pub fn rxnack (& self) -> RXNACK_R { RXNACK_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 4:5 - Bus State"]
# [inline (always)]
pub fn busstate (& self) -> BUSSTATE_R { BUSSTATE_R :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bit 6 - SCL Low Timeout"]
# [inline (always)]
pub fn lowtout (& self) -> LOWTOUT_R { LOWTOUT_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Clock Hold"]
# [inline (always)]
pub fn clkhold (& self) -> CLKHOLD_R { CLKHOLD_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Master SCL Low Extend Timeout"]
# [inline (always)]
pub fn mexttout (& self) -> MEXTTOUT_R { MEXTTOUT_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Slave SCL Low Extend Timeout"]
# [inline (always)]
pub fn sexttout (& self) -> SEXTTOUT_R { SEXTTOUT_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Length Error"]
# [inline (always)]
pub fn lenerr (& self) -> LENERR_R { LENERR_R :: new (((self . bits >> 10) & 1) != 0) } } impl W { # [doc = "Bit 0 - Bus Error"]
# [inline (always)]
pub fn buserr (& mut self) -> BUSERR_W { BUSERR_W :: new (self) } # [doc = "Bit 1 - Arbitration Lost"]
# [inline (always)]
pub fn arblost (& mut self) -> ARBLOST_W { ARBLOST_W :: new (self) } # [doc = "Bits 4:5 - Bus State"]
# [inline (always)]
pub fn busstate (& mut self) -> BUSSTATE_W { BUSSTATE_W :: new (self) } # [doc = "Bit 6 - SCL Low Timeout"]
# [inline (always)]
pub fn lowtout (& mut self) -> LOWTOUT_W { LOWTOUT_W :: new (self) } # [doc = "Bit 8 - Master SCL Low Extend Timeout"]
# [inline (always)]
pub fn mexttout (& mut self) -> MEXTTOUT_W { MEXTTOUT_W :: new (self) } # [doc = "Bit 9 - Slave SCL Low Extend Timeout"]
# [inline (always)]
pub fn sexttout (& mut self) -> SEXTTOUT_W { SEXTTOUT_W :: new (self) } # [doc = "Bit 10 - Length Error"]
# [inline (always)]
pub fn lenerr (& mut self) -> LENERR_W { LENERR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "I2CM Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYNCBUSY register accessor: an alias for `Reg<SYNCBUSY_SPEC>`"]
pub type SYNCBUSY = crate :: Reg < syncbusy :: SYNCBUSY_SPEC > ; # [doc = "I2CM Synchronization Busy"]
pub mod syncbusy { # [doc = "Register `SYNCBUSY` reader"]
pub struct R (crate :: R < SYNCBUSY_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYNCBUSY_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYNCBUSY_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYNCBUSY_SPEC >) -> Self { R (reader) } } # [doc = "Field `SWRST` reader - Software Reset Synchronization Busy"]
pub type SWRST_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` reader - SERCOM Enable Synchronization Busy"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `SYSOP` reader - System Operation Synchronization Busy"]
pub type SYSOP_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Software Reset Synchronization Busy"]
# [inline (always)]
pub fn swrst (& self) -> SWRST_R { SWRST_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - SERCOM Enable Synchronization Busy"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - System Operation Synchronization Busy"]
# [inline (always)]
pub fn sysop (& self) -> SYSOP_R { SYSOP_R :: new (((self . bits >> 2) & 1) != 0) } } # [doc = "I2CM Synchronization Busy\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [syncbusy](index.html) module"]
pub struct SYNCBUSY_SPEC ; impl crate :: RegisterSpec for SYNCBUSY_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [syncbusy::R](R) reader structure"]
impl crate :: Readable for SYNCBUSY_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SYNCBUSY to value 0"]
impl crate :: Resettable for SYNCBUSY_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "ADDR register accessor: an alias for `Reg<ADDR_SPEC>`"]
pub type ADDR = crate :: Reg < addr :: ADDR_SPEC > ; # [doc = "I2CM Address"]
pub mod addr { # [doc = "Register `ADDR` reader"]
pub struct R (crate :: R < ADDR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADDR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADDR_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADDR` writer"]
pub struct W (crate :: W < ADDR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADDR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADDR_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADDR` reader - Address Value"]
pub type ADDR_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `ADDR` writer - Address Value"]
pub type ADDR_W < 'a > = crate :: FieldWriter < 'a , u32 , ADDR_SPEC , u16 , u16 , 11 , 0 > ; # [doc = "Field `LENEN` reader - Length Enable"]
pub type LENEN_R = crate :: BitReader < bool > ; # [doc = "Field `LENEN` writer - Length Enable"]
pub type LENEN_W < 'a > = crate :: BitWriter < 'a , u32 , ADDR_SPEC , bool , 13 > ; # [doc = "Field `HS` reader - High Speed Mode"]
pub type HS_R = crate :: BitReader < bool > ; # [doc = "Field `HS` writer - High Speed Mode"]
pub type HS_W < 'a > = crate :: BitWriter < 'a , u32 , ADDR_SPEC , bool , 14 > ; # [doc = "Field `TENBITEN` reader - Ten Bit Addressing Enable"]
pub type TENBITEN_R = crate :: BitReader < bool > ; # [doc = "Field `TENBITEN` writer - Ten Bit Addressing Enable"]
pub type TENBITEN_W < 'a > = crate :: BitWriter < 'a , u32 , ADDR_SPEC , bool , 15 > ; # [doc = "Field `LEN` reader - Length"]
pub type LEN_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `LEN` writer - Length"]
pub type LEN_W < 'a > = crate :: FieldWriter < 'a , u32 , ADDR_SPEC , u8 , u8 , 8 , 16 > ; impl R { # [doc = "Bits 0:10 - Address Value"]
# [inline (always)]
pub fn addr (& self) -> ADDR_R { ADDR_R :: new ((self . bits & 0x07ff) as u16) } # [doc = "Bit 13 - Length Enable"]
# [inline (always)]
pub fn lenen (& self) -> LENEN_R { LENEN_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - High Speed Mode"]
# [inline (always)]
pub fn hs (& self) -> HS_R { HS_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Ten Bit Addressing Enable"]
# [inline (always)]
pub fn tenbiten (& self) -> TENBITEN_R { TENBITEN_R :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bits 16:23 - Length"]
# [inline (always)]
pub fn len (& self) -> LEN_R { LEN_R :: new (((self . bits >> 16) & 0xff) as u8) } } impl W { # [doc = "Bits 0:10 - Address Value"]
# [inline (always)]
pub fn addr (& mut self) -> ADDR_W { ADDR_W :: new (self) } # [doc = "Bit 13 - Length Enable"]
# [inline (always)]
pub fn lenen (& mut self) -> LENEN_W { LENEN_W :: new (self) } # [doc = "Bit 14 - High Speed Mode"]
# [inline (always)]
pub fn hs (& mut self) -> HS_W { HS_W :: new (self) } # [doc = "Bit 15 - Ten Bit Addressing Enable"]
# [inline (always)]
pub fn tenbiten (& mut self) -> TENBITEN_W { TENBITEN_W :: new (self) } # [doc = "Bits 16:23 - Length"]
# [inline (always)]
pub fn len (& mut self) -> LEN_W { LEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "I2CM Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [addr](index.html) module"]
pub struct ADDR_SPEC ; impl crate :: RegisterSpec for ADDR_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [addr::R](R) reader structure"]
impl crate :: Readable for ADDR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [addr::W](W) writer structure"]
impl crate :: Writable for ADDR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ADDR to value 0"]
impl crate :: Resettable for ADDR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DATA register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "I2CM Data"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } # [doc = "Field `DATA` reader - Data Value"]
pub type DATA_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DATA` writer - Data Value"]
pub type DATA_W < 'a > = crate :: FieldWriter < 'a , u8 , DATA_SPEC , u8 , u8 , 8 , 0 > ; impl R { # [doc = "Bits 0:7 - Data Value"]
# [inline (always)]
pub fn data (& self) -> DATA_R { DATA_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Data Value"]
# [inline (always)]
pub fn data (& mut self) -> DATA_W { DATA_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "I2CM Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DBGCTRL register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "I2CM Debug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGSTOP` reader - Debug Mode"]
pub type DBGSTOP_R = crate :: BitReader < bool > ; # [doc = "Field `DBGSTOP` writer - Debug Mode"]
pub type DBGSTOP_W < 'a > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , 0 > ; impl R { # [doc = "Bit 0 - Debug Mode"]
# [inline (always)]
pub fn dbgstop (& self) -> DBGSTOP_R { DBGSTOP_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug Mode"]
# [inline (always)]
pub fn dbgstop (& mut self) -> DBGSTOP_W { DBGSTOP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "I2CM Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = r"Register block"]
# [repr (C)]
pub struct I2CS { # [doc = "0x00 - I2CS Control A"]
pub ctrla : crate :: Reg < self :: i2cs :: ctrla :: CTRLA_SPEC > , # [doc = "0x04 - I2CS Control B"]
pub ctrlb : crate :: Reg < self :: i2cs :: ctrlb :: CTRLB_SPEC > , _reserved2 : [u8 ; 0x0c]
, # [doc = "0x14 - I2CS Interrupt Enable Clear"]
pub intenclr : crate :: Reg < self :: i2cs :: intenclr :: INTENCLR_SPEC > , _reserved3 : [u8 ; 0x01]
, # [doc = "0x16 - I2CS Interrupt Enable Set"]
pub intenset : crate :: Reg < self :: i2cs :: intenset :: INTENSET_SPEC > , _reserved4 : [u8 ; 0x01]
, # [doc = "0x18 - I2CS Interrupt Flag Status and Clear"]
pub intflag : crate :: Reg < self :: i2cs :: intflag :: INTFLAG_SPEC > , _reserved5 : [u8 ; 0x01]
, # [doc = "0x1a - I2CS Status"]
pub status : crate :: Reg < self :: i2cs :: status :: STATUS_SPEC > , # [doc = "0x1c - I2CS Synchronization Busy"]
pub syncbusy : crate :: Reg < self :: i2cs :: syncbusy :: SYNCBUSY_SPEC > , _reserved7 : [u8 ; 0x04]
, # [doc = "0x24 - I2CS Address"]
pub addr : crate :: Reg < self :: i2cs :: addr :: ADDR_SPEC > , # [doc = "0x28 - I2CS Data"]
pub data : crate :: Reg < self :: i2cs :: data :: DATA_SPEC > , } # [doc = r"Register block"]
# [doc = "I2C Slave Mode"]
pub mod i2cs { # [doc = "CTRLA register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "I2CS Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWRST` reader - Software Reset"]
pub type SWRST_R = crate :: BitReader < bool > ; # [doc = "Field `SWRST` writer - Software Reset"]
pub type SWRST_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 0 > ; # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 1 > ; # [doc = "Operating Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum MODE_A { # [doc = "0: USART mode with external clock"]
USART_EXT_CLK = 0 , # [doc = "1: USART mode with internal clock"]
USART_INT_CLK = 1 , # [doc = "2: SPI mode with external clock"]
SPI_SLAVE = 2 , # [doc = "3: SPI mode with internal clock"]
SPI_MASTER = 3 , # [doc = "4: I2C mode with external clock"]
I2C_SLAVE = 4 , # [doc = "5: I2C mode with internal clock"]
I2C_MASTER = 5 , } impl From < MODE_A > for u8 { # [inline (always)]
fn from (variant : MODE_A) -> Self { variant as _ } } # [doc = "Field `MODE` reader - Operating Mode"]
pub type MODE_R = crate :: FieldReader < u8 , MODE_A > ; impl MODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < MODE_A > { match self . bits { 0 => Some (MODE_A :: USART_EXT_CLK) , 1 => Some (MODE_A :: USART_INT_CLK) , 2 => Some (MODE_A :: SPI_SLAVE) , 3 => Some (MODE_A :: SPI_MASTER) , 4 => Some (MODE_A :: I2C_SLAVE) , 5 => Some (MODE_A :: I2C_MASTER) , _ => None , } } # [doc = "Checks if the value of the field is `USART_EXT_CLK`"]
# [inline (always)]
pub fn is_usart_ext_clk (& self) -> bool { * self == MODE_A :: USART_EXT_CLK } # [doc = "Checks if the value of the field is `USART_INT_CLK`"]
# [inline (always)]
pub fn is_usart_int_clk (& self) -> bool { * self == MODE_A :: USART_INT_CLK } # [doc = "Checks if the value of the field is `SPI_SLAVE`"]
# [inline (always)]
pub fn is_spi_slave (& self) -> bool { * self == MODE_A :: SPI_SLAVE } # [doc = "Checks if the value of the field is `SPI_MASTER`"]
# [inline (always)]
pub fn is_spi_master (& self) -> bool { * self == MODE_A :: SPI_MASTER } # [doc = "Checks if the value of the field is `I2C_SLAVE`"]
# [inline (always)]
pub fn is_i2c_slave (& self) -> bool { * self == MODE_A :: I2C_SLAVE } # [doc = "Checks if the value of the field is `I2C_MASTER`"]
# [inline (always)]
pub fn is_i2c_master (& self) -> bool { * self == MODE_A :: I2C_MASTER } } # [doc = "Field `MODE` writer - Operating Mode"]
pub type MODE_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLA_SPEC , u8 , MODE_A , 3 , 2 > ; impl < 'a > MODE_W < 'a > { # [doc = "USART mode with external clock"]
# [inline (always)]
pub fn usart_ext_clk (self) -> & 'a mut W { self . variant (MODE_A :: USART_EXT_CLK) } # [doc = "USART mode with internal clock"]
# [inline (always)]
pub fn usart_int_clk (self) -> & 'a mut W { self . variant (MODE_A :: USART_INT_CLK) } # [doc = "SPI mode with external clock"]
# [inline (always)]
pub fn spi_slave (self) -> & 'a mut W { self . variant (MODE_A :: SPI_SLAVE) } # [doc = "SPI mode with internal clock"]
# [inline (always)]
pub fn spi_master (self) -> & 'a mut W { self . variant (MODE_A :: SPI_MASTER) } # [doc = "I2C mode with external clock"]
# [inline (always)]
pub fn i2c_slave (self) -> & 'a mut W { self . variant (MODE_A :: I2C_SLAVE) } # [doc = "I2C mode with internal clock"]
# [inline (always)]
pub fn i2c_master (self) -> & 'a mut W { self . variant (MODE_A :: I2C_MASTER) } } # [doc = "Field `RUNSTDBY` reader - Run during Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run during Standby"]
pub type RUNSTDBY_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 7 > ; # [doc = "Field `PINOUT` reader - Pin Usage"]
pub type PINOUT_R = crate :: BitReader < bool > ; # [doc = "Field `PINOUT` writer - Pin Usage"]
pub type PINOUT_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 16 > ; # [doc = "Field `SDAHOLD` reader - SDA Hold Time"]
pub type SDAHOLD_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SDAHOLD` writer - SDA Hold Time"]
pub type SDAHOLD_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLA_SPEC , u8 , u8 , 2 , 20 > ; # [doc = "Field `SEXTTOEN` reader - Slave SCL Low Extend Timeout"]
pub type SEXTTOEN_R = crate :: BitReader < bool > ; # [doc = "Field `SEXTTOEN` writer - Slave SCL Low Extend Timeout"]
pub type SEXTTOEN_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 23 > ; # [doc = "Field `SPEED` reader - Transfer Speed"]
pub type SPEED_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SPEED` writer - Transfer Speed"]
pub type SPEED_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLA_SPEC , u8 , u8 , 2 , 24 > ; # [doc = "Field `SCLSM` reader - SCL Clock Stretch Mode"]
pub type SCLSM_R = crate :: BitReader < bool > ; # [doc = "Field `SCLSM` writer - SCL Clock Stretch Mode"]
pub type SCLSM_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 27 > ; # [doc = "Field `LOWTOUTEN` reader - SCL Low Timeout Enable"]
pub type LOWTOUTEN_R = crate :: BitReader < bool > ; # [doc = "Field `LOWTOUTEN` writer - SCL Low Timeout Enable"]
pub type LOWTOUTEN_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 30 > ; impl R { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& self) -> SWRST_R { SWRST_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:4 - Operating Mode"]
# [inline (always)]
pub fn mode (& self) -> MODE_R { MODE_R :: new (((self . bits >> 2) & 7) as u8) } # [doc = "Bit 7 - Run during Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 16 - Pin Usage"]
# [inline (always)]
pub fn pinout (& self) -> PINOUT_R { PINOUT_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bits 20:21 - SDA Hold Time"]
# [inline (always)]
pub fn sdahold (& self) -> SDAHOLD_R { SDAHOLD_R :: new (((self . bits >> 20) & 3) as u8) } # [doc = "Bit 23 - Slave SCL Low Extend Timeout"]
# [inline (always)]
pub fn sexttoen (& self) -> SEXTTOEN_R { SEXTTOEN_R :: new (((self . bits >> 23) & 1) != 0) } # [doc = "Bits 24:25 - Transfer Speed"]
# [inline (always)]
pub fn speed (& self) -> SPEED_R { SPEED_R :: new (((self . bits >> 24) & 3) as u8) } # [doc = "Bit 27 - SCL Clock Stretch Mode"]
# [inline (always)]
pub fn sclsm (& self) -> SCLSM_R { SCLSM_R :: new (((self . bits >> 27) & 1) != 0) } # [doc = "Bit 30 - SCL Low Timeout Enable"]
# [inline (always)]
pub fn lowtouten (& self) -> LOWTOUTEN_R { LOWTOUTEN_R :: new (((self . bits >> 30) & 1) != 0) } } impl W { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& mut self) -> SWRST_W { SWRST_W :: new (self) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Bits 2:4 - Operating Mode"]
# [inline (always)]
pub fn mode (& mut self) -> MODE_W { MODE_W :: new (self) } # [doc = "Bit 7 - Run during Standby"]
# [inline (always)]
pub fn runstdby (& mut self) -> RUNSTDBY_W { RUNSTDBY_W :: new (self) } # [doc = "Bit 16 - Pin Usage"]
# [inline (always)]
pub fn pinout (& mut self) -> PINOUT_W { PINOUT_W :: new (self) } # [doc = "Bits 20:21 - SDA Hold Time"]
# [inline (always)]
pub fn sdahold (& mut self) -> SDAHOLD_W { SDAHOLD_W :: new (self) } # [doc = "Bit 23 - Slave SCL Low Extend Timeout"]
# [inline (always)]
pub fn sexttoen (& mut self) -> SEXTTOEN_W { SEXTTOEN_W :: new (self) } # [doc = "Bits 24:25 - Transfer Speed"]
# [inline (always)]
pub fn speed (& mut self) -> SPEED_W { SPEED_W :: new (self) } # [doc = "Bit 27 - SCL Clock Stretch Mode"]
# [inline (always)]
pub fn sclsm (& mut self) -> SCLSM_W { SCLSM_W :: new (self) } # [doc = "Bit 30 - SCL Low Timeout Enable"]
# [inline (always)]
pub fn lowtouten (& mut self) -> LOWTOUTEN_W { LOWTOUTEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "I2CS Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CTRLB register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "I2CS Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `SMEN` reader - Smart Mode Enable"]
pub type SMEN_R = crate :: BitReader < bool > ; # [doc = "Field `SMEN` writer - Smart Mode Enable"]
pub type SMEN_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLB_SPEC , bool , 8 > ; # [doc = "Field `GCMD` reader - PMBus Group Command"]
pub type GCMD_R = crate :: BitReader < bool > ; # [doc = "Field `GCMD` writer - PMBus Group Command"]
pub type GCMD_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLB_SPEC , bool , 9 > ; # [doc = "Field `AACKEN` reader - Automatic Address Acknowledge"]
pub type AACKEN_R = crate :: BitReader < bool > ; # [doc = "Field `AACKEN` writer - Automatic Address Acknowledge"]
pub type AACKEN_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLB_SPEC , bool , 10 > ; # [doc = "Field `AMODE` reader - Address Mode"]
pub type AMODE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `AMODE` writer - Address Mode"]
pub type AMODE_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLB_SPEC , u8 , u8 , 2 , 14 > ; # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLB_SPEC , u8 , u8 , 2 , 16 > ; # [doc = "Field `ACKACT` reader - Acknowledge Action"]
pub type ACKACT_R = crate :: BitReader < bool > ; # [doc = "Field `ACKACT` writer - Acknowledge Action"]
pub type ACKACT_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLB_SPEC , bool , 18 > ; impl R { # [doc = "Bit 8 - Smart Mode Enable"]
# [inline (always)]
pub fn smen (& self) -> SMEN_R { SMEN_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - PMBus Group Command"]
# [inline (always)]
pub fn gcmd (& self) -> GCMD_R { GCMD_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Automatic Address Acknowledge"]
# [inline (always)]
pub fn aacken (& self) -> AACKEN_R { AACKEN_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bits 14:15 - Address Mode"]
# [inline (always)]
pub fn amode (& self) -> AMODE_R { AMODE_R :: new (((self . bits >> 14) & 3) as u8) } # [doc = "Bit 18 - Acknowledge Action"]
# [inline (always)]
pub fn ackact (& self) -> ACKACT_R { ACKACT_R :: new (((self . bits >> 18) & 1) != 0) } } impl W { # [doc = "Bit 8 - Smart Mode Enable"]
# [inline (always)]
pub fn smen (& mut self) -> SMEN_W { SMEN_W :: new (self) } # [doc = "Bit 9 - PMBus Group Command"]
# [inline (always)]
pub fn gcmd (& mut self) -> GCMD_W { GCMD_W :: new (self) } # [doc = "Bit 10 - Automatic Address Acknowledge"]
# [inline (always)]
pub fn aacken (& mut self) -> AACKEN_W { AACKEN_W :: new (self) } # [doc = "Bits 14:15 - Address Mode"]
# [inline (always)]
pub fn amode (& mut self) -> AMODE_W { AMODE_W :: new (self) } # [doc = "Bits 16:17 - Command"]
# [inline (always)]
pub fn cmd (& mut self) -> CMD_W { CMD_W :: new (self) } # [doc = "Bit 18 - Acknowledge Action"]
# [inline (always)]
pub fn ackact (& mut self) -> ACKACT_W { ACKACT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "I2CS Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENCLR register accessor: an alias for `Reg<INTENCLR_SPEC>`"]
pub type INTENCLR = crate :: Reg < intenclr :: INTENCLR_SPEC > ; # [doc = "I2CS Interrupt Enable Clear"]
pub mod intenclr { # [doc = "Register `INTENCLR` reader"]
pub struct R (crate :: R < INTENCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENCLR` writer"]
pub struct W (crate :: W < INTENCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `PREC` reader - Stop Received Interrupt Disable"]
pub type PREC_R = crate :: BitReader < bool > ; # [doc = "Field `PREC` writer - Stop Received Interrupt Disable"]
pub type PREC_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 0 > ; # [doc = "Field `AMATCH` reader - Address Match Interrupt Disable"]
pub type AMATCH_R = crate :: BitReader < bool > ; # [doc = "Field `AMATCH` writer - Address Match Interrupt Disable"]
pub type AMATCH_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 1 > ; # [doc = "Field `DRDY` reader - Data Interrupt Disable"]
pub type DRDY_R = crate :: BitReader < bool > ; # [doc = "Field `DRDY` writer - Data Interrupt Disable"]
pub type DRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 2 > ; # [doc = "Field `ERROR` reader - Combined Error Interrupt Disable"]
pub type ERROR_R = crate :: BitReader < bool > ; # [doc = "Field `ERROR` writer - Combined Error Interrupt Disable"]
pub type ERROR_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 7 > ; impl R { # [doc = "Bit 0 - Stop Received Interrupt Disable"]
# [inline (always)]
pub fn prec (& self) -> PREC_R { PREC_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Address Match Interrupt Disable"]
# [inline (always)]
pub fn amatch (& self) -> AMATCH_R { AMATCH_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Data Interrupt Disable"]
# [inline (always)]
pub fn drdy (& self) -> DRDY_R { DRDY_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 7 - Combined Error Interrupt Disable"]
# [inline (always)]
pub fn error (& self) -> ERROR_R { ERROR_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Stop Received Interrupt Disable"]
# [inline (always)]
pub fn prec (& mut self) -> PREC_W { PREC_W :: new (self) } # [doc = "Bit 1 - Address Match Interrupt Disable"]
# [inline (always)]
pub fn amatch (& mut self) -> AMATCH_W { AMATCH_W :: new (self) } # [doc = "Bit 2 - Data Interrupt Disable"]
# [inline (always)]
pub fn drdy (& mut self) -> DRDY_W { DRDY_W :: new (self) } # [doc = "Bit 7 - Combined Error Interrupt Disable"]
# [inline (always)]
pub fn error (& mut self) -> ERROR_W { ERROR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "I2CS Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenclr](index.html) module"]
pub struct INTENCLR_SPEC ; impl crate :: RegisterSpec for INTENCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenclr::R](R) reader structure"]
impl crate :: Readable for INTENCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenclr::W](W) writer structure"]
impl crate :: Writable for INTENCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENCLR to value 0"]
impl crate :: Resettable for INTENCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENSET register accessor: an alias for `Reg<INTENSET_SPEC>`"]
pub type INTENSET = crate :: Reg < intenset :: INTENSET_SPEC > ; # [doc = "I2CS Interrupt Enable Set"]
pub mod intenset { # [doc = "Register `INTENSET` reader"]
pub struct R (crate :: R < INTENSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENSET` writer"]
pub struct W (crate :: W < INTENSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `PREC` reader - Stop Received Interrupt Enable"]
pub type PREC_R = crate :: BitReader < bool > ; # [doc = "Field `PREC` writer - Stop Received Interrupt Enable"]
pub type PREC_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 0 > ; # [doc = "Field `AMATCH` reader - Address Match Interrupt Enable"]
pub type AMATCH_R = crate :: BitReader < bool > ; # [doc = "Field `AMATCH` writer - Address Match Interrupt Enable"]
pub type AMATCH_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 1 > ; # [doc = "Field `DRDY` reader - Data Interrupt Enable"]
pub type DRDY_R = crate :: BitReader < bool > ; # [doc = "Field `DRDY` writer - Data Interrupt Enable"]
pub type DRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 2 > ; # [doc = "Field `ERROR` reader - Combined Error Interrupt Enable"]
pub type ERROR_R = crate :: BitReader < bool > ; # [doc = "Field `ERROR` writer - Combined Error Interrupt Enable"]
pub type ERROR_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 7 > ; impl R { # [doc = "Bit 0 - Stop Received Interrupt Enable"]
# [inline (always)]
pub fn prec (& self) -> PREC_R { PREC_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Address Match Interrupt Enable"]
# [inline (always)]
pub fn amatch (& self) -> AMATCH_R { AMATCH_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Data Interrupt Enable"]
# [inline (always)]
pub fn drdy (& self) -> DRDY_R { DRDY_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 7 - Combined Error Interrupt Enable"]
# [inline (always)]
pub fn error (& self) -> ERROR_R { ERROR_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Stop Received Interrupt Enable"]
# [inline (always)]
pub fn prec (& mut self) -> PREC_W { PREC_W :: new (self) } # [doc = "Bit 1 - Address Match Interrupt Enable"]
# [inline (always)]
pub fn amatch (& mut self) -> AMATCH_W { AMATCH_W :: new (self) } # [doc = "Bit 2 - Data Interrupt Enable"]
# [inline (always)]
pub fn drdy (& mut self) -> DRDY_W { DRDY_W :: new (self) } # [doc = "Bit 7 - Combined Error Interrupt Enable"]
# [inline (always)]
pub fn error (& mut self) -> ERROR_W { ERROR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "I2CS Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenset](index.html) module"]
pub struct INTENSET_SPEC ; impl crate :: RegisterSpec for INTENSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenset::R](R) reader structure"]
impl crate :: Readable for INTENSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenset::W](W) writer structure"]
impl crate :: Writable for INTENSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENSET to value 0"]
impl crate :: Resettable for INTENSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTFLAG register accessor: an alias for `Reg<INTFLAG_SPEC>`"]
pub type INTFLAG = crate :: Reg < intflag :: INTFLAG_SPEC > ; # [doc = "I2CS Interrupt Flag Status and Clear"]
pub mod intflag { # [doc = "Register `INTFLAG` reader"]
pub struct R (crate :: R < INTFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAG` writer"]
pub struct W (crate :: W < INTFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `PREC` reader - Stop Received Interrupt"]
pub type PREC_R = crate :: BitReader < bool > ; # [doc = "Field `PREC` writer - Stop Received Interrupt"]
pub type PREC_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 0 > ; # [doc = "Field `AMATCH` reader - Address Match Interrupt"]
pub type AMATCH_R = crate :: BitReader < bool > ; # [doc = "Field `AMATCH` writer - Address Match Interrupt"]
pub type AMATCH_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 1 > ; # [doc = "Field `DRDY` reader - Data Interrupt"]
pub type DRDY_R = crate :: BitReader < bool > ; # [doc = "Field `DRDY` writer - Data Interrupt"]
pub type DRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 2 > ; # [doc = "Field `ERROR` reader - Combined Error Interrupt"]
pub type ERROR_R = crate :: BitReader < bool > ; # [doc = "Field `ERROR` writer - Combined Error Interrupt"]
pub type ERROR_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 7 > ; impl R { # [doc = "Bit 0 - Stop Received Interrupt"]
# [inline (always)]
pub fn prec (& self) -> PREC_R { PREC_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Address Match Interrupt"]
# [inline (always)]
pub fn amatch (& self) -> AMATCH_R { AMATCH_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Data Interrupt"]
# [inline (always)]
pub fn drdy (& self) -> DRDY_R { DRDY_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 7 - Combined Error Interrupt"]
# [inline (always)]
pub fn error (& self) -> ERROR_R { ERROR_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Stop Received Interrupt"]
# [inline (always)]
pub fn prec (& mut self) -> PREC_W { PREC_W :: new (self) } # [doc = "Bit 1 - Address Match Interrupt"]
# [inline (always)]
pub fn amatch (& mut self) -> AMATCH_W { AMATCH_W :: new (self) } # [doc = "Bit 2 - Data Interrupt"]
# [inline (always)]
pub fn drdy (& mut self) -> DRDY_W { DRDY_W :: new (self) } # [doc = "Bit 7 - Combined Error Interrupt"]
# [inline (always)]
pub fn error (& mut self) -> ERROR_W { ERROR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "I2CS Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflag](index.html) module"]
pub struct INTFLAG_SPEC ; impl crate :: RegisterSpec for INTFLAG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflag::R](R) reader structure"]
impl crate :: Readable for INTFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflag::W](W) writer structure"]
impl crate :: Writable for INTFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTFLAG to value 0"]
impl crate :: Resettable for INTFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATUS register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "I2CS Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `BUSERR` reader - Bus Error"]
pub type BUSERR_R = crate :: BitReader < bool > ; # [doc = "Field `BUSERR` writer - Bus Error"]
pub type BUSERR_W < 'a > = crate :: BitWriter < 'a , u16 , STATUS_SPEC , bool , 0 > ; # [doc = "Field `COLL` reader - Transmit Collision"]
pub type COLL_R = crate :: BitReader < bool > ; # [doc = "Field `COLL` writer - Transmit Collision"]
pub type COLL_W < 'a > = crate :: BitWriter < 'a , u16 , STATUS_SPEC , bool , 1 > ; # [doc = "Field `RXNACK` reader - Received Not Acknowledge"]
pub type RXNACK_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` reader - Read/Write Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `SR` reader - Repeated Start"]
pub type SR_R = crate :: BitReader < bool > ; # [doc = "Field `LOWTOUT` reader - SCL Low Timeout"]
pub type LOWTOUT_R = crate :: BitReader < bool > ; # [doc = "Field `LOWTOUT` writer - SCL Low Timeout"]
pub type LOWTOUT_W < 'a > = crate :: BitWriter < 'a , u16 , STATUS_SPEC , bool , 6 > ; # [doc = "Field `CLKHOLD` reader - Clock Hold"]
pub type CLKHOLD_R = crate :: BitReader < bool > ; # [doc = "Field `SEXTTOUT` reader - Slave SCL Low Extend Timeout"]
pub type SEXTTOUT_R = crate :: BitReader < bool > ; # [doc = "Field `SEXTTOUT` writer - Slave SCL Low Extend Timeout"]
pub type SEXTTOUT_W < 'a > = crate :: BitWriter < 'a , u16 , STATUS_SPEC , bool , 9 > ; # [doc = "Field `HS` reader - High Speed"]
pub type HS_R = crate :: BitReader < bool > ; # [doc = "Field `HS` writer - High Speed"]
pub type HS_W < 'a > = crate :: BitWriter < 'a , u16 , STATUS_SPEC , bool , 10 > ; impl R { # [doc = "Bit 0 - Bus Error"]
# [inline (always)]
pub fn buserr (& self) -> BUSERR_R { BUSERR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Transmit Collision"]
# [inline (always)]
pub fn coll (& self) -> COLL_R { COLL_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Received Not Acknowledge"]
# [inline (always)]
pub fn rxnack (& self) -> RXNACK_R { RXNACK_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Read/Write Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Repeated Start"]
# [inline (always)]
pub fn sr (& self) -> SR_R { SR_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - SCL Low Timeout"]
# [inline (always)]
pub fn lowtout (& self) -> LOWTOUT_R { LOWTOUT_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Clock Hold"]
# [inline (always)]
pub fn clkhold (& self) -> CLKHOLD_R { CLKHOLD_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 9 - Slave SCL Low Extend Timeout"]
# [inline (always)]
pub fn sexttout (& self) -> SEXTTOUT_R { SEXTTOUT_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - High Speed"]
# [inline (always)]
pub fn hs (& self) -> HS_R { HS_R :: new (((self . bits >> 10) & 1) != 0) } } impl W { # [doc = "Bit 0 - Bus Error"]
# [inline (always)]
pub fn buserr (& mut self) -> BUSERR_W { BUSERR_W :: new (self) } # [doc = "Bit 1 - Transmit Collision"]
# [inline (always)]
pub fn coll (& mut self) -> COLL_W { COLL_W :: new (self) } # [doc = "Bit 6 - SCL Low Timeout"]
# [inline (always)]
pub fn lowtout (& mut self) -> LOWTOUT_W { LOWTOUT_W :: new (self) } # [doc = "Bit 9 - Slave SCL Low Extend Timeout"]
# [inline (always)]
pub fn sexttout (& mut self) -> SEXTTOUT_W { SEXTTOUT_W :: new (self) } # [doc = "Bit 10 - High Speed"]
# [inline (always)]
pub fn hs (& mut self) -> HS_W { HS_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "I2CS Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYNCBUSY register accessor: an alias for `Reg<SYNCBUSY_SPEC>`"]
pub type SYNCBUSY = crate :: Reg < syncbusy :: SYNCBUSY_SPEC > ; # [doc = "I2CS Synchronization Busy"]
pub mod syncbusy { # [doc = "Register `SYNCBUSY` reader"]
pub struct R (crate :: R < SYNCBUSY_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYNCBUSY_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYNCBUSY_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYNCBUSY_SPEC >) -> Self { R (reader) } } # [doc = "Field `SWRST` reader - Software Reset Synchronization Busy"]
pub type SWRST_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` reader - SERCOM Enable Synchronization Busy"]
pub type ENABLE_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Software Reset Synchronization Busy"]
# [inline (always)]
pub fn swrst (& self) -> SWRST_R { SWRST_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - SERCOM Enable Synchronization Busy"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } } # [doc = "I2CS Synchronization Busy\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [syncbusy](index.html) module"]
pub struct SYNCBUSY_SPEC ; impl crate :: RegisterSpec for SYNCBUSY_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [syncbusy::R](R) reader structure"]
impl crate :: Readable for SYNCBUSY_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SYNCBUSY to value 0"]
impl crate :: Resettable for SYNCBUSY_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "ADDR register accessor: an alias for `Reg<ADDR_SPEC>`"]
pub type ADDR = crate :: Reg < addr :: ADDR_SPEC > ; # [doc = "I2CS Address"]
pub mod addr { # [doc = "Register `ADDR` reader"]
pub struct R (crate :: R < ADDR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADDR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADDR_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADDR` writer"]
pub struct W (crate :: W < ADDR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADDR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADDR_SPEC >) -> Self { W (writer) } } # [doc = "Field `GENCEN` reader - General Call Address Enable"]
pub type GENCEN_R = crate :: BitReader < bool > ; # [doc = "Field `GENCEN` writer - General Call Address Enable"]
pub type GENCEN_W < 'a > = crate :: BitWriter < 'a , u32 , ADDR_SPEC , bool , 0 > ; # [doc = "Field `ADDR` reader - Address Value"]
pub type ADDR_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `ADDR` writer - Address Value"]
pub type ADDR_W < 'a > = crate :: FieldWriter < 'a , u32 , ADDR_SPEC , u16 , u16 , 10 , 1 > ; # [doc = "Field `TENBITEN` reader - Ten Bit Addressing Enable"]
pub type TENBITEN_R = crate :: BitReader < bool > ; # [doc = "Field `TENBITEN` writer - Ten Bit Addressing Enable"]
pub type TENBITEN_W < 'a > = crate :: BitWriter < 'a , u32 , ADDR_SPEC , bool , 15 > ; # [doc = "Field `ADDRMASK` reader - Address Mask"]
pub type ADDRMASK_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `ADDRMASK` writer - Address Mask"]
pub type ADDRMASK_W < 'a > = crate :: FieldWriter < 'a , u32 , ADDR_SPEC , u16 , u16 , 10 , 17 > ; impl R { # [doc = "Bit 0 - General Call Address Enable"]
# [inline (always)]
pub fn gencen (& self) -> GENCEN_R { GENCEN_R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:10 - Address Value"]
# [inline (always)]
pub fn addr (& self) -> ADDR_R { ADDR_R :: new (((self . bits >> 1) & 0x03ff) as u16) } # [doc = "Bit 15 - Ten Bit Addressing Enable"]
# [inline (always)]
pub fn tenbiten (& self) -> TENBITEN_R { TENBITEN_R :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bits 17:26 - Address Mask"]
# [inline (always)]
pub fn addrmask (& self) -> ADDRMASK_R { ADDRMASK_R :: new (((self . bits >> 17) & 0x03ff) as u16) } } impl W { # [doc = "Bit 0 - General Call Address Enable"]
# [inline (always)]
pub fn gencen (& mut self) -> GENCEN_W { GENCEN_W :: new (self) } # [doc = "Bits 1:10 - Address Value"]
# [inline (always)]
pub fn addr (& mut self) -> ADDR_W { ADDR_W :: new (self) } # [doc = "Bit 15 - Ten Bit Addressing Enable"]
# [inline (always)]
pub fn tenbiten (& mut self) -> TENBITEN_W { TENBITEN_W :: new (self) } # [doc = "Bits 17:26 - Address Mask"]
# [inline (always)]
pub fn addrmask (& mut self) -> ADDRMASK_W { ADDRMASK_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "I2CS Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [addr](index.html) module"]
pub struct ADDR_SPEC ; impl crate :: RegisterSpec for ADDR_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [addr::R](R) reader structure"]
impl crate :: Readable for ADDR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [addr::W](W) writer structure"]
impl crate :: Writable for ADDR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ADDR to value 0"]
impl crate :: Resettable for ADDR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DATA register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "I2CS Data"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } # [doc = "Field `DATA` reader - Data Value"]
pub type DATA_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DATA` writer - Data Value"]
pub type DATA_W < 'a > = crate :: FieldWriter < 'a , u8 , DATA_SPEC , u8 , u8 , 8 , 0 > ; impl R { # [doc = "Bits 0:7 - Data Value"]
# [inline (always)]
pub fn data (& self) -> DATA_R { DATA_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Data Value"]
# [inline (always)]
pub fn data (& mut self) -> DATA_W { DATA_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "I2CS Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = r"Register block"]
# [repr (C)]
pub struct SPI { # [doc = "0x00 - SPI Control A"]
pub ctrla : crate :: Reg < self :: spi :: ctrla :: CTRLA_SPEC > , # [doc = "0x04 - SPI Control B"]
pub ctrlb : crate :: Reg < self :: spi :: ctrlb :: CTRLB_SPEC > , _reserved2 : [u8 ; 0x04]
, # [doc = "0x0c - SPI Baud Rate"]
pub baud : crate :: Reg < self :: spi :: baud :: BAUD_SPEC > , _reserved3 : [u8 ; 0x07]
, # [doc = "0x14 - SPI Interrupt Enable Clear"]
pub intenclr : crate :: Reg < self :: spi :: intenclr :: INTENCLR_SPEC > , _reserved4 : [u8 ; 0x01]
, # [doc = "0x16 - SPI Interrupt Enable Set"]
pub intenset : crate :: Reg < self :: spi :: intenset :: INTENSET_SPEC > , _reserved5 : [u8 ; 0x01]
, # [doc = "0x18 - SPI Interrupt Flag Status and Clear"]
pub intflag : crate :: Reg < self :: spi :: intflag :: INTFLAG_SPEC > , _reserved6 : [u8 ; 0x01]
, # [doc = "0x1a - SPI Status"]
pub status : crate :: Reg < self :: spi :: status :: STATUS_SPEC > , # [doc = "0x1c - SPI Synchronization Busy"]
pub syncbusy : crate :: Reg < self :: spi :: syncbusy :: SYNCBUSY_SPEC > , _reserved8 : [u8 ; 0x04]
, # [doc = "0x24 - SPI Address"]
pub addr : crate :: Reg < self :: spi :: addr :: ADDR_SPEC > , # [doc = "0x28 - SPI Data"]
pub data : crate :: Reg < self :: spi :: data :: DATA_SPEC > , _reserved10 : [u8 ; 0x04]
, # [doc = "0x30 - SPI Debug Control"]
pub dbgctrl : crate :: Reg < self :: spi :: dbgctrl :: DBGCTRL_SPEC > , } # [doc = r"Register block"]
# [doc = "SPI Mode"]
pub mod spi { # [doc = "CTRLA register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "SPI Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWRST` reader - Software Reset"]
pub type SWRST_R = crate :: BitReader < bool > ; # [doc = "Field `SWRST` writer - Software Reset"]
pub type SWRST_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 0 > ; # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 1 > ; # [doc = "Operating Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum MODE_A { # [doc = "0: USART mode with external clock"]
USART_EXT_CLK = 0 , # [doc = "1: USART mode with internal clock"]
USART_INT_CLK = 1 , # [doc = "2: SPI mode with external clock"]
SPI_SLAVE = 2 , # [doc = "3: SPI mode with internal clock"]
SPI_MASTER = 3 , # [doc = "4: I2C mode with external clock"]
I2C_SLAVE = 4 , # [doc = "5: I2C mode with internal clock"]
I2C_MASTER = 5 , } impl From < MODE_A > for u8 { # [inline (always)]
fn from (variant : MODE_A) -> Self { variant as _ } } # [doc = "Field `MODE` reader - Operating Mode"]
pub type MODE_R = crate :: FieldReader < u8 , MODE_A > ; impl MODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < MODE_A > { match self . bits { 0 => Some (MODE_A :: USART_EXT_CLK) , 1 => Some (MODE_A :: USART_INT_CLK) , 2 => Some (MODE_A :: SPI_SLAVE) , 3 => Some (MODE_A :: SPI_MASTER) , 4 => Some (MODE_A :: I2C_SLAVE) , 5 => Some (MODE_A :: I2C_MASTER) , _ => None , } } # [doc = "Checks if the value of the field is `USART_EXT_CLK`"]
# [inline (always)]
pub fn is_usart_ext_clk (& self) -> bool { * self == MODE_A :: USART_EXT_CLK } # [doc = "Checks if the value of the field is `USART_INT_CLK`"]
# [inline (always)]
pub fn is_usart_int_clk (& self) -> bool { * self == MODE_A :: USART_INT_CLK } # [doc = "Checks if the value of the field is `SPI_SLAVE`"]
# [inline (always)]
pub fn is_spi_slave (& self) -> bool { * self == MODE_A :: SPI_SLAVE } # [doc = "Checks if the value of the field is `SPI_MASTER`"]
# [inline (always)]
pub fn is_spi_master (& self) -> bool { * self == MODE_A :: SPI_MASTER } # [doc = "Checks if the value of the field is `I2C_SLAVE`"]
# [inline (always)]
pub fn is_i2c_slave (& self) -> bool { * self == MODE_A :: I2C_SLAVE } # [doc = "Checks if the value of the field is `I2C_MASTER`"]
# [inline (always)]
pub fn is_i2c_master (& self) -> bool { * self == MODE_A :: I2C_MASTER } } # [doc = "Field `MODE` writer - Operating Mode"]
pub type MODE_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLA_SPEC , u8 , MODE_A , 3 , 2 > ; impl < 'a > MODE_W < 'a > { # [doc = "USART mode with external clock"]
# [inline (always)]
pub fn usart_ext_clk (self) -> & 'a mut W { self . variant (MODE_A :: USART_EXT_CLK) } # [doc = "USART mode with internal clock"]
# [inline (always)]
pub fn usart_int_clk (self) -> & 'a mut W { self . variant (MODE_A :: USART_INT_CLK) } # [doc = "SPI mode with external clock"]
# [inline (always)]
pub fn spi_slave (self) -> & 'a mut W { self . variant (MODE_A :: SPI_SLAVE) } # [doc = "SPI mode with internal clock"]
# [inline (always)]
pub fn spi_master (self) -> & 'a mut W { self . variant (MODE_A :: SPI_MASTER) } # [doc = "I2C mode with external clock"]
# [inline (always)]
pub fn i2c_slave (self) -> & 'a mut W { self . variant (MODE_A :: I2C_SLAVE) } # [doc = "I2C mode with internal clock"]
# [inline (always)]
pub fn i2c_master (self) -> & 'a mut W { self . variant (MODE_A :: I2C_MASTER) } } # [doc = "Field `RUNSTDBY` reader - Run during Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run during Standby"]
pub type RUNSTDBY_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 7 > ; # [doc = "Field `IBON` reader - Immediate Buffer Overflow Notification"]
pub type IBON_R = crate :: BitReader < bool > ; # [doc = "Field `IBON` writer - Immediate Buffer Overflow Notification"]
pub type IBON_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 8 > ; # [doc = "Field `DOPO` reader - Data Out Pinout"]
pub type DOPO_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DOPO` writer - Data Out Pinout"]
pub type DOPO_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLA_SPEC , u8 , u8 , 2 , 16 > ; # [doc = "Field `DIPO` reader - Data In Pinout"]
pub type DIPO_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DIPO` writer - Data In Pinout"]
pub type DIPO_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLA_SPEC , u8 , u8 , 2 , 20 > ; # [doc = "Field `FORM` reader - Frame Format"]
pub type FORM_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `FORM` writer - Frame Format"]
pub type FORM_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLA_SPEC , u8 , u8 , 4 , 24 > ; # [doc = "Field `CPHA` reader - Clock Phase"]
pub type CPHA_R = crate :: BitReader < bool > ; # [doc = "Field `CPHA` writer - Clock Phase"]
pub type CPHA_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 28 > ; # [doc = "Field `CPOL` reader - Clock Polarity"]
pub type CPOL_R = crate :: BitReader < bool > ; # [doc = "Field `CPOL` writer - Clock Polarity"]
pub type CPOL_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 29 > ; # [doc = "Field `DORD` reader - Data Order"]
pub type DORD_R = crate :: BitReader < bool > ; # [doc = "Field `DORD` writer - Data Order"]
pub type DORD_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 30 > ; impl R { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& self) -> SWRST_R { SWRST_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:4 - Operating Mode"]
# [inline (always)]
pub fn mode (& self) -> MODE_R { MODE_R :: new (((self . bits >> 2) & 7) as u8) } # [doc = "Bit 7 - Run during Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Immediate Buffer Overflow Notification"]
# [inline (always)]
pub fn ibon (& self) -> IBON_R { IBON_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bits 16:17 - Data Out Pinout"]
# [inline (always)]
pub fn dopo (& self) -> DOPO_R { DOPO_R :: new (((self . bits >> 16) & 3) as u8) } # [doc = "Bits 20:21 - Data In Pinout"]
# [inline (always)]
pub fn dipo (& self) -> DIPO_R { DIPO_R :: new (((self . bits >> 20) & 3) as u8) } # [doc = "Bits 24:27 - Frame Format"]
# [inline (always)]
pub fn form (& self) -> FORM_R { FORM_R :: new (((self . bits >> 24) & 0x0f) as u8) } # [doc = "Bit 28 - Clock Phase"]
# [inline (always)]
pub fn cpha (& self) -> CPHA_R { CPHA_R :: new (((self . bits >> 28) & 1) != 0) } # [doc = "Bit 29 - Clock Polarity"]
# [inline (always)]
pub fn cpol (& self) -> CPOL_R { CPOL_R :: new (((self . bits >> 29) & 1) != 0) } # [doc = "Bit 30 - Data Order"]
# [inline (always)]
pub fn dord (& self) -> DORD_R { DORD_R :: new (((self . bits >> 30) & 1) != 0) } } impl W { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& mut self) -> SWRST_W { SWRST_W :: new (self) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Bits 2:4 - Operating Mode"]
# [inline (always)]
pub fn mode (& mut self) -> MODE_W { MODE_W :: new (self) } # [doc = "Bit 7 - Run during Standby"]
# [inline (always)]
pub fn runstdby (& mut self) -> RUNSTDBY_W { RUNSTDBY_W :: new (self) } # [doc = "Bit 8 - Immediate Buffer Overflow Notification"]
# [inline (always)]
pub fn ibon (& mut self) -> IBON_W { IBON_W :: new (self) } # [doc = "Bits 16:17 - Data Out Pinout"]
# [inline (always)]
pub fn dopo (& mut self) -> DOPO_W { DOPO_W :: new (self) } # [doc = "Bits 20:21 - Data In Pinout"]
# [inline (always)]
pub fn dipo (& mut self) -> DIPO_W { DIPO_W :: new (self) } # [doc = "Bits 24:27 - Frame Format"]
# [inline (always)]
pub fn form (& mut self) -> FORM_W { FORM_W :: new (self) } # [doc = "Bit 28 - Clock Phase"]
# [inline (always)]
pub fn cpha (& mut self) -> CPHA_W { CPHA_W :: new (self) } # [doc = "Bit 29 - Clock Polarity"]
# [inline (always)]
pub fn cpol (& mut self) -> CPOL_W { CPOL_W :: new (self) } # [doc = "Bit 30 - Data Order"]
# [inline (always)]
pub fn dord (& mut self) -> DORD_W { DORD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "SPI Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CTRLB register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "SPI Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHSIZE` reader - Character Size"]
pub type CHSIZE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CHSIZE` writer - Character Size"]
pub type CHSIZE_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLB_SPEC , u8 , u8 , 3 , 0 > ; # [doc = "Field `PLOADEN` reader - Data Preload Enable"]
pub type PLOADEN_R = crate :: BitReader < bool > ; # [doc = "Field `PLOADEN` writer - Data Preload Enable"]
pub type PLOADEN_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLB_SPEC , bool , 6 > ; # [doc = "Field `SSDE` reader - Slave Select Low Detect Enable"]
pub type SSDE_R = crate :: BitReader < bool > ; # [doc = "Field `SSDE` writer - Slave Select Low Detect Enable"]
pub type SSDE_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLB_SPEC , bool , 9 > ; # [doc = "Field `MSSEN` reader - Master Slave Select Enable"]
pub type MSSEN_R = crate :: BitReader < bool > ; # [doc = "Field `MSSEN` writer - Master Slave Select Enable"]
pub type MSSEN_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLB_SPEC , bool , 13 > ; # [doc = "Field `AMODE` reader - Address Mode"]
pub type AMODE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `AMODE` writer - Address Mode"]
pub type AMODE_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLB_SPEC , u8 , u8 , 2 , 14 > ; # [doc = "Field `RXEN` reader - Receiver Enable"]
pub type RXEN_R = crate :: BitReader < bool > ; # [doc = "Field `RXEN` writer - Receiver Enable"]
pub type RXEN_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLB_SPEC , bool , 17 > ; impl R { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
pub fn chsize (& self) -> CHSIZE_R { CHSIZE_R :: new ((self . bits & 7) as u8) } # [doc = "Bit 6 - Data Preload Enable"]
# [inline (always)]
pub fn ploaden (& self) -> PLOADEN_R { PLOADEN_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 9 - Slave Select Low Detect Enable"]
# [inline (always)]
pub fn ssde (& self) -> SSDE_R { SSDE_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 13 - Master Slave Select Enable"]
# [inline (always)]
pub fn mssen (& self) -> MSSEN_R { MSSEN_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bits 14:15 - Address Mode"]
# [inline (always)]
pub fn amode (& self) -> AMODE_R { AMODE_R :: new (((self . bits >> 14) & 3) as u8) } # [doc = "Bit 17 - Receiver Enable"]
# [inline (always)]
pub fn rxen (& self) -> RXEN_R { RXEN_R :: new (((self . bits >> 17) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
pub fn chsize (& mut self) -> CHSIZE_W { CHSIZE_W :: new (self) } # [doc = "Bit 6 - Data Preload Enable"]
# [inline (always)]
pub fn ploaden (& mut self) -> PLOADEN_W { PLOADEN_W :: new (self) } # [doc = "Bit 9 - Slave Select Low Detect Enable"]
# [inline (always)]
pub fn ssde (& mut self) -> SSDE_W { SSDE_W :: new (self) } # [doc = "Bit 13 - Master Slave Select Enable"]
# [inline (always)]
pub fn mssen (& mut self) -> MSSEN_W { MSSEN_W :: new (self) } # [doc = "Bits 14:15 - Address Mode"]
# [inline (always)]
pub fn amode (& mut self) -> AMODE_W { AMODE_W :: new (self) } # [doc = "Bit 17 - Receiver Enable"]
# [inline (always)]
pub fn rxen (& mut self) -> RXEN_W { RXEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "SPI Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "BAUD register accessor: an alias for `Reg<BAUD_SPEC>`"]
pub type BAUD = crate :: Reg < baud :: BAUD_SPEC > ; # [doc = "SPI Baud Rate"]
pub mod baud { # [doc = "Register `BAUD` reader"]
pub struct R (crate :: R < BAUD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUD_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUD` writer"]
pub struct W (crate :: W < BAUD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUD_SPEC >) -> Self { W (writer) } } # [doc = "Field `BAUD` reader - Baud Rate Value"]
pub type BAUD_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BAUD` writer - Baud Rate Value"]
pub type BAUD_W < 'a > = crate :: FieldWriter < 'a , u8 , BAUD_SPEC , u8 , u8 , 8 , 0 > ; impl R { # [doc = "Bits 0:7 - Baud Rate Value"]
# [inline (always)]
pub fn baud (& self) -> BAUD_R { BAUD_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Baud Rate Value"]
# [inline (always)]
pub fn baud (& mut self) -> BAUD_W { BAUD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "SPI Baud Rate\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baud](index.html) module"]
pub struct BAUD_SPEC ; impl crate :: RegisterSpec for BAUD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [baud::R](R) reader structure"]
impl crate :: Readable for BAUD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baud::W](W) writer structure"]
impl crate :: Writable for BAUD_SPEC { type Writer = W ; } # [doc = "`reset()` method sets BAUD to value 0"]
impl crate :: Resettable for BAUD_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENCLR register accessor: an alias for `Reg<INTENCLR_SPEC>`"]
pub type INTENCLR = crate :: Reg < intenclr :: INTENCLR_SPEC > ; # [doc = "SPI Interrupt Enable Clear"]
pub mod intenclr { # [doc = "Register `INTENCLR` reader"]
pub struct R (crate :: R < INTENCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENCLR` writer"]
pub struct W (crate :: W < INTENCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `DRE` reader - Data Register Empty Interrupt Disable"]
pub type DRE_R = crate :: BitReader < bool > ; # [doc = "Field `DRE` writer - Data Register Empty Interrupt Disable"]
pub type DRE_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 0 > ; # [doc = "Field `TXC` reader - Transmit Complete Interrupt Disable"]
pub type TXC_R = crate :: BitReader < bool > ; # [doc = "Field `TXC` writer - Transmit Complete Interrupt Disable"]
pub type TXC_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 1 > ; # [doc = "Field `RXC` reader - Receive Complete Interrupt Disable"]
pub type RXC_R = crate :: BitReader < bool > ; # [doc = "Field `RXC` writer - Receive Complete Interrupt Disable"]
pub type RXC_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 2 > ; # [doc = "Field `SSL` reader - Slave Select Low Interrupt Disable"]
pub type SSL_R = crate :: BitReader < bool > ; # [doc = "Field `SSL` writer - Slave Select Low Interrupt Disable"]
pub type SSL_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 3 > ; # [doc = "Field `ERROR` reader - Combined Error Interrupt Disable"]
pub type ERROR_R = crate :: BitReader < bool > ; # [doc = "Field `ERROR` writer - Combined Error Interrupt Disable"]
pub type ERROR_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 7 > ; impl R { # [doc = "Bit 0 - Data Register Empty Interrupt Disable"]
# [inline (always)]
pub fn dre (& self) -> DRE_R { DRE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Transmit Complete Interrupt Disable"]
# [inline (always)]
pub fn txc (& self) -> TXC_R { TXC_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Receive Complete Interrupt Disable"]
# [inline (always)]
pub fn rxc (& self) -> RXC_R { RXC_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Slave Select Low Interrupt Disable"]
# [inline (always)]
pub fn ssl (& self) -> SSL_R { SSL_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Combined Error Interrupt Disable"]
# [inline (always)]
pub fn error (& self) -> ERROR_R { ERROR_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Data Register Empty Interrupt Disable"]
# [inline (always)]
pub fn dre (& mut self) -> DRE_W { DRE_W :: new (self) } # [doc = "Bit 1 - Transmit Complete Interrupt Disable"]
# [inline (always)]
pub fn txc (& mut self) -> TXC_W { TXC_W :: new (self) } # [doc = "Bit 2 - Receive Complete Interrupt Disable"]
# [inline (always)]
pub fn rxc (& mut self) -> RXC_W { RXC_W :: new (self) } # [doc = "Bit 3 - Slave Select Low Interrupt Disable"]
# [inline (always)]
pub fn ssl (& mut self) -> SSL_W { SSL_W :: new (self) } # [doc = "Bit 7 - Combined Error Interrupt Disable"]
# [inline (always)]
pub fn error (& mut self) -> ERROR_W { ERROR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "SPI Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenclr](index.html) module"]
pub struct INTENCLR_SPEC ; impl crate :: RegisterSpec for INTENCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenclr::R](R) reader structure"]
impl crate :: Readable for INTENCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenclr::W](W) writer structure"]
impl crate :: Writable for INTENCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENCLR to value 0"]
impl crate :: Resettable for INTENCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENSET register accessor: an alias for `Reg<INTENSET_SPEC>`"]
pub type INTENSET = crate :: Reg < intenset :: INTENSET_SPEC > ; # [doc = "SPI Interrupt Enable Set"]
pub mod intenset { # [doc = "Register `INTENSET` reader"]
pub struct R (crate :: R < INTENSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENSET` writer"]
pub struct W (crate :: W < INTENSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `DRE` reader - Data Register Empty Interrupt Enable"]
pub type DRE_R = crate :: BitReader < bool > ; # [doc = "Field `DRE` writer - Data Register Empty Interrupt Enable"]
pub type DRE_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 0 > ; # [doc = "Field `TXC` reader - Transmit Complete Interrupt Enable"]
pub type TXC_R = crate :: BitReader < bool > ; # [doc = "Field `TXC` writer - Transmit Complete Interrupt Enable"]
pub type TXC_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 1 > ; # [doc = "Field `RXC` reader - Receive Complete Interrupt Enable"]
pub type RXC_R = crate :: BitReader < bool > ; # [doc = "Field `RXC` writer - Receive Complete Interrupt Enable"]
pub type RXC_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 2 > ; # [doc = "Field `SSL` reader - Slave Select Low Interrupt Enable"]
pub type SSL_R = crate :: BitReader < bool > ; # [doc = "Field `SSL` writer - Slave Select Low Interrupt Enable"]
pub type SSL_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 3 > ; # [doc = "Field `ERROR` reader - Combined Error Interrupt Enable"]
pub type ERROR_R = crate :: BitReader < bool > ; # [doc = "Field `ERROR` writer - Combined Error Interrupt Enable"]
pub type ERROR_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 7 > ; impl R { # [doc = "Bit 0 - Data Register Empty Interrupt Enable"]
# [inline (always)]
pub fn dre (& self) -> DRE_R { DRE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Transmit Complete Interrupt Enable"]
# [inline (always)]
pub fn txc (& self) -> TXC_R { TXC_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Receive Complete Interrupt Enable"]
# [inline (always)]
pub fn rxc (& self) -> RXC_R { RXC_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Slave Select Low Interrupt Enable"]
# [inline (always)]
pub fn ssl (& self) -> SSL_R { SSL_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Combined Error Interrupt Enable"]
# [inline (always)]
pub fn error (& self) -> ERROR_R { ERROR_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Data Register Empty Interrupt Enable"]
# [inline (always)]
pub fn dre (& mut self) -> DRE_W { DRE_W :: new (self) } # [doc = "Bit 1 - Transmit Complete Interrupt Enable"]
# [inline (always)]
pub fn txc (& mut self) -> TXC_W { TXC_W :: new (self) } # [doc = "Bit 2 - Receive Complete Interrupt Enable"]
# [inline (always)]
pub fn rxc (& mut self) -> RXC_W { RXC_W :: new (self) } # [doc = "Bit 3 - Slave Select Low Interrupt Enable"]
# [inline (always)]
pub fn ssl (& mut self) -> SSL_W { SSL_W :: new (self) } # [doc = "Bit 7 - Combined Error Interrupt Enable"]
# [inline (always)]
pub fn error (& mut self) -> ERROR_W { ERROR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "SPI Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenset](index.html) module"]
pub struct INTENSET_SPEC ; impl crate :: RegisterSpec for INTENSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenset::R](R) reader structure"]
impl crate :: Readable for INTENSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenset::W](W) writer structure"]
impl crate :: Writable for INTENSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENSET to value 0"]
impl crate :: Resettable for INTENSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTFLAG register accessor: an alias for `Reg<INTFLAG_SPEC>`"]
pub type INTFLAG = crate :: Reg < intflag :: INTFLAG_SPEC > ; # [doc = "SPI Interrupt Flag Status and Clear"]
pub mod intflag { # [doc = "Register `INTFLAG` reader"]
pub struct R (crate :: R < INTFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAG` writer"]
pub struct W (crate :: W < INTFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `DRE` reader - Data Register Empty Interrupt"]
pub type DRE_R = crate :: BitReader < bool > ; # [doc = "Field `TXC` reader - Transmit Complete Interrupt"]
pub type TXC_R = crate :: BitReader < bool > ; # [doc = "Field `TXC` writer - Transmit Complete Interrupt"]
pub type TXC_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 1 > ; # [doc = "Field `RXC` reader - Receive Complete Interrupt"]
pub type RXC_R = crate :: BitReader < bool > ; # [doc = "Field `SSL` reader - Slave Select Low Interrupt Flag"]
pub type SSL_R = crate :: BitReader < bool > ; # [doc = "Field `SSL` writer - Slave Select Low Interrupt Flag"]
pub type SSL_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 3 > ; # [doc = "Field `ERROR` reader - Combined Error Interrupt"]
pub type ERROR_R = crate :: BitReader < bool > ; # [doc = "Field `ERROR` writer - Combined Error Interrupt"]
pub type ERROR_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 7 > ; impl R { # [doc = "Bit 0 - Data Register Empty Interrupt"]
# [inline (always)]
pub fn dre (& self) -> DRE_R { DRE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Transmit Complete Interrupt"]
# [inline (always)]
pub fn txc (& self) -> TXC_R { TXC_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Receive Complete Interrupt"]
# [inline (always)]
pub fn rxc (& self) -> RXC_R { RXC_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Slave Select Low Interrupt Flag"]
# [inline (always)]
pub fn ssl (& self) -> SSL_R { SSL_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 7 - Combined Error Interrupt"]
# [inline (always)]
pub fn error (& self) -> ERROR_R { ERROR_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 1 - Transmit Complete Interrupt"]
# [inline (always)]
pub fn txc (& mut self) -> TXC_W { TXC_W :: new (self) } # [doc = "Bit 3 - Slave Select Low Interrupt Flag"]
# [inline (always)]
pub fn ssl (& mut self) -> SSL_W { SSL_W :: new (self) } # [doc = "Bit 7 - Combined Error Interrupt"]
# [inline (always)]
pub fn error (& mut self) -> ERROR_W { ERROR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "SPI Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflag](index.html) module"]
pub struct INTFLAG_SPEC ; impl crate :: RegisterSpec for INTFLAG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflag::R](R) reader structure"]
impl crate :: Readable for INTFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflag::W](W) writer structure"]
impl crate :: Writable for INTFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTFLAG to value 0"]
impl crate :: Resettable for INTFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATUS register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "SPI Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `BUFOVF` reader - Buffer Overflow"]
pub type BUFOVF_R = crate :: BitReader < bool > ; # [doc = "Field `BUFOVF` writer - Buffer Overflow"]
pub type BUFOVF_W < 'a > = crate :: BitWriter < 'a , u16 , STATUS_SPEC , bool , 2 > ; impl R { # [doc = "Bit 2 - Buffer Overflow"]
# [inline (always)]
pub fn bufovf (& self) -> BUFOVF_R { BUFOVF_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 2 - Buffer Overflow"]
# [inline (always)]
pub fn bufovf (& mut self) -> BUFOVF_W { BUFOVF_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "SPI Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYNCBUSY register accessor: an alias for `Reg<SYNCBUSY_SPEC>`"]
pub type SYNCBUSY = crate :: Reg < syncbusy :: SYNCBUSY_SPEC > ; # [doc = "SPI Synchronization Busy"]
pub mod syncbusy { # [doc = "Register `SYNCBUSY` reader"]
pub struct R (crate :: R < SYNCBUSY_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYNCBUSY_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYNCBUSY_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYNCBUSY_SPEC >) -> Self { R (reader) } } # [doc = "Field `SWRST` reader - Software Reset Synchronization Busy"]
pub type SWRST_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` reader - SERCOM Enable Synchronization Busy"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `CTRLB` reader - CTRLB Synchronization Busy"]
pub type CTRLB_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Software Reset Synchronization Busy"]
# [inline (always)]
pub fn swrst (& self) -> SWRST_R { SWRST_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - SERCOM Enable Synchronization Busy"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - CTRLB Synchronization Busy"]
# [inline (always)]
pub fn ctrlb (& self) -> CTRLB_R { CTRLB_R :: new (((self . bits >> 2) & 1) != 0) } } # [doc = "SPI Synchronization Busy\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [syncbusy](index.html) module"]
pub struct SYNCBUSY_SPEC ; impl crate :: RegisterSpec for SYNCBUSY_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [syncbusy::R](R) reader structure"]
impl crate :: Readable for SYNCBUSY_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SYNCBUSY to value 0"]
impl crate :: Resettable for SYNCBUSY_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "ADDR register accessor: an alias for `Reg<ADDR_SPEC>`"]
pub type ADDR = crate :: Reg < addr :: ADDR_SPEC > ; # [doc = "SPI Address"]
pub mod addr { # [doc = "Register `ADDR` reader"]
pub struct R (crate :: R < ADDR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < ADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < ADDR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < ADDR_SPEC >) -> Self { R (reader) } } # [doc = "Register `ADDR` writer"]
pub struct W (crate :: W < ADDR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < ADDR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < ADDR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < ADDR_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADDR` reader - Address Value"]
pub type ADDR_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `ADDR` writer - Address Value"]
pub type ADDR_W < 'a > = crate :: FieldWriter < 'a , u32 , ADDR_SPEC , u8 , u8 , 8 , 0 > ; # [doc = "Field `ADDRMASK` reader - Address Mask"]
pub type ADDRMASK_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `ADDRMASK` writer - Address Mask"]
pub type ADDRMASK_W < 'a > = crate :: FieldWriter < 'a , u32 , ADDR_SPEC , u8 , u8 , 8 , 16 > ; impl R { # [doc = "Bits 0:7 - Address Value"]
# [inline (always)]
pub fn addr (& self) -> ADDR_R { ADDR_R :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 16:23 - Address Mask"]
# [inline (always)]
pub fn addrmask (& self) -> ADDRMASK_R { ADDRMASK_R :: new (((self . bits >> 16) & 0xff) as u8) } } impl W { # [doc = "Bits 0:7 - Address Value"]
# [inline (always)]
pub fn addr (& mut self) -> ADDR_W { ADDR_W :: new (self) } # [doc = "Bits 16:23 - Address Mask"]
# [inline (always)]
pub fn addrmask (& mut self) -> ADDRMASK_W { ADDRMASK_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "SPI Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [addr](index.html) module"]
pub struct ADDR_SPEC ; impl crate :: RegisterSpec for ADDR_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [addr::R](R) reader structure"]
impl crate :: Readable for ADDR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [addr::W](W) writer structure"]
impl crate :: Writable for ADDR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets ADDR to value 0"]
impl crate :: Resettable for ADDR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DATA register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "SPI Data"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } # [doc = "Field `DATA` reader - Data Value"]
pub type DATA_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `DATA` writer - Data Value"]
pub type DATA_W < 'a > = crate :: FieldWriter < 'a , u32 , DATA_SPEC , u16 , u16 , 9 , 0 > ; impl R { # [doc = "Bits 0:8 - Data Value"]
# [inline (always)]
pub fn data (& self) -> DATA_R { DATA_R :: new ((self . bits & 0x01ff) as u16) } } impl W { # [doc = "Bits 0:8 - Data Value"]
# [inline (always)]
pub fn data (& mut self) -> DATA_W { DATA_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "SPI Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DBGCTRL register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "SPI Debug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGSTOP` reader - Debug Mode"]
pub type DBGSTOP_R = crate :: BitReader < bool > ; # [doc = "Field `DBGSTOP` writer - Debug Mode"]
pub type DBGSTOP_W < 'a > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , 0 > ; impl R { # [doc = "Bit 0 - Debug Mode"]
# [inline (always)]
pub fn dbgstop (& self) -> DBGSTOP_R { DBGSTOP_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug Mode"]
# [inline (always)]
pub fn dbgstop (& mut self) -> DBGSTOP_W { DBGSTOP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "SPI Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = r"Register block"]
# [repr (C)]
pub struct USART { # [doc = "0x00 - USART Control A"]
pub ctrla : crate :: Reg < self :: usart :: ctrla :: CTRLA_SPEC > , # [doc = "0x04 - USART Control B"]
pub ctrlb : crate :: Reg < self :: usart :: ctrlb :: CTRLB_SPEC > , _reserved2 : [u8 ; 0x04]
, _reserved_2_baud : [u8 ; 0x02]
, # [doc = "0x0e - USART Receive Pulse Length"]
pub rxpl : crate :: Reg < self :: usart :: rxpl :: RXPL_SPEC > , _reserved4 : [u8 ; 0x05]
, # [doc = "0x14 - USART Interrupt Enable Clear"]
pub intenclr : crate :: Reg < self :: usart :: intenclr :: INTENCLR_SPEC > , _reserved5 : [u8 ; 0x01]
, # [doc = "0x16 - USART Interrupt Enable Set"]
pub intenset : crate :: Reg < self :: usart :: intenset :: INTENSET_SPEC > , _reserved6 : [u8 ; 0x01]
, # [doc = "0x18 - USART Interrupt Flag Status and Clear"]
pub intflag : crate :: Reg < self :: usart :: intflag :: INTFLAG_SPEC > , _reserved7 : [u8 ; 0x01]
, # [doc = "0x1a - USART Status"]
pub status : crate :: Reg < self :: usart :: status :: STATUS_SPEC > , # [doc = "0x1c - USART Synchronization Busy"]
pub syncbusy : crate :: Reg < self :: usart :: syncbusy :: SYNCBUSY_SPEC > , _reserved9 : [u8 ; 0x08]
, # [doc = "0x28 - USART Data"]
pub data : crate :: Reg < self :: usart :: data :: DATA_SPEC > , _reserved10 : [u8 ; 0x06]
, # [doc = "0x30 - USART Debug Control"]
pub dbgctrl : crate :: Reg < self :: usart :: dbgctrl :: DBGCTRL_SPEC > , } impl USART { # [doc = "0x0c - USART Baud Rate"]
# [inline (always)]
pub fn baud_usartfp_mode (& self) -> & crate :: Reg < self :: usart :: baud_usartfp_mode :: BAUD_USARTFP_MODE_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (12usize) as * const crate :: Reg < self :: usart :: baud_usartfp_mode :: BAUD_USARTFP_MODE_SPEC >) } } # [doc = "0x0c - USART Baud Rate"]
# [inline (always)]
pub fn baud_fracfp_mode (& self) -> & crate :: Reg < self :: usart :: baud_fracfp_mode :: BAUD_FRACFP_MODE_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (12usize) as * const crate :: Reg < self :: usart :: baud_fracfp_mode :: BAUD_FRACFP_MODE_SPEC >) } } # [doc = "0x0c - USART Baud Rate"]
# [inline (always)]
pub fn baud_frac_mode (& self) -> & crate :: Reg < self :: usart :: baud_frac_mode :: BAUD_FRAC_MODE_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (12usize) as * const crate :: Reg < self :: usart :: baud_frac_mode :: BAUD_FRAC_MODE_SPEC >) } } # [doc = "0x0c - USART Baud Rate"]
# [inline (always)]
pub fn baud (& self) -> & crate :: Reg < self :: usart :: baud :: BAUD_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (12usize) as * const crate :: Reg < self :: usart :: baud :: BAUD_SPEC >) } } } # [doc = r"Register block"]
# [doc = "USART Mode"]
pub mod usart { # [doc = "CTRLA register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "USART Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWRST` reader - Software Reset"]
pub type SWRST_R = crate :: BitReader < bool > ; # [doc = "Field `SWRST` writer - Software Reset"]
pub type SWRST_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 0 > ; # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 1 > ; # [doc = "Operating Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum MODE_A { # [doc = "0: USART mode with external clock"]
USART_EXT_CLK = 0 , # [doc = "1: USART mode with internal clock"]
USART_INT_CLK = 1 , # [doc = "2: SPI mode with external clock"]
SPI_SLAVE = 2 , # [doc = "3: SPI mode with internal clock"]
SPI_MASTER = 3 , # [doc = "4: I2C mode with external clock"]
I2C_SLAVE = 4 , # [doc = "5: I2C mode with internal clock"]
I2C_MASTER = 5 , } impl From < MODE_A > for u8 { # [inline (always)]
fn from (variant : MODE_A) -> Self { variant as _ } } # [doc = "Field `MODE` reader - Operating Mode"]
pub type MODE_R = crate :: FieldReader < u8 , MODE_A > ; impl MODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < MODE_A > { match self . bits { 0 => Some (MODE_A :: USART_EXT_CLK) , 1 => Some (MODE_A :: USART_INT_CLK) , 2 => Some (MODE_A :: SPI_SLAVE) , 3 => Some (MODE_A :: SPI_MASTER) , 4 => Some (MODE_A :: I2C_SLAVE) , 5 => Some (MODE_A :: I2C_MASTER) , _ => None , } } # [doc = "Checks if the value of the field is `USART_EXT_CLK`"]
# [inline (always)]
pub fn is_usart_ext_clk (& self) -> bool { * self == MODE_A :: USART_EXT_CLK } # [doc = "Checks if the value of the field is `USART_INT_CLK`"]
# [inline (always)]
pub fn is_usart_int_clk (& self) -> bool { * self == MODE_A :: USART_INT_CLK } # [doc = "Checks if the value of the field is `SPI_SLAVE`"]
# [inline (always)]
pub fn is_spi_slave (& self) -> bool { * self == MODE_A :: SPI_SLAVE } # [doc = "Checks if the value of the field is `SPI_MASTER`"]
# [inline (always)]
pub fn is_spi_master (& self) -> bool { * self == MODE_A :: SPI_MASTER } # [doc = "Checks if the value of the field is `I2C_SLAVE`"]
# [inline (always)]
pub fn is_i2c_slave (& self) -> bool { * self == MODE_A :: I2C_SLAVE } # [doc = "Checks if the value of the field is `I2C_MASTER`"]
# [inline (always)]
pub fn is_i2c_master (& self) -> bool { * self == MODE_A :: I2C_MASTER } } # [doc = "Field `MODE` writer - Operating Mode"]
pub type MODE_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLA_SPEC , u8 , MODE_A , 3 , 2 > ; impl < 'a > MODE_W < 'a > { # [doc = "USART mode with external clock"]
# [inline (always)]
pub fn usart_ext_clk (self) -> & 'a mut W { self . variant (MODE_A :: USART_EXT_CLK) } # [doc = "USART mode with internal clock"]
# [inline (always)]
pub fn usart_int_clk (self) -> & 'a mut W { self . variant (MODE_A :: USART_INT_CLK) } # [doc = "SPI mode with external clock"]
# [inline (always)]
pub fn spi_slave (self) -> & 'a mut W { self . variant (MODE_A :: SPI_SLAVE) } # [doc = "SPI mode with internal clock"]
# [inline (always)]
pub fn spi_master (self) -> & 'a mut W { self . variant (MODE_A :: SPI_MASTER) } # [doc = "I2C mode with external clock"]
# [inline (always)]
pub fn i2c_slave (self) -> & 'a mut W { self . variant (MODE_A :: I2C_SLAVE) } # [doc = "I2C mode with internal clock"]
# [inline (always)]
pub fn i2c_master (self) -> & 'a mut W { self . variant (MODE_A :: I2C_MASTER) } } # [doc = "Field `RUNSTDBY` reader - Run during Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run during Standby"]
pub type RUNSTDBY_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 7 > ; # [doc = "Field `IBON` reader - Immediate Buffer Overflow Notification"]
pub type IBON_R = crate :: BitReader < bool > ; # [doc = "Field `IBON` writer - Immediate Buffer Overflow Notification"]
pub type IBON_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 8 > ; # [doc = "Field `SAMPR` reader - Sample"]
pub type SAMPR_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SAMPR` writer - Sample"]
pub type SAMPR_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLA_SPEC , u8 , u8 , 3 , 13 > ; # [doc = "Field `TXPO` reader - Transmit Data Pinout"]
pub type TXPO_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `TXPO` writer - Transmit Data Pinout"]
pub type TXPO_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLA_SPEC , u8 , u8 , 2 , 16 > ; # [doc = "Field `RXPO` reader - Receive Data Pinout"]
pub type RXPO_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `RXPO` writer - Receive Data Pinout"]
pub type RXPO_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLA_SPEC , u8 , u8 , 2 , 20 > ; # [doc = "Field `SAMPA` reader - Sample Adjustment"]
pub type SAMPA_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SAMPA` writer - Sample Adjustment"]
pub type SAMPA_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLA_SPEC , u8 , u8 , 2 , 22 > ; # [doc = "Field `FORM` reader - Frame Format"]
pub type FORM_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `FORM` writer - Frame Format"]
pub type FORM_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLA_SPEC , u8 , u8 , 4 , 24 > ; # [doc = "Field `CMODE` reader - Communication Mode"]
pub type CMODE_R = crate :: BitReader < bool > ; # [doc = "Field `CMODE` writer - Communication Mode"]
pub type CMODE_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 28 > ; # [doc = "Field `CPOL` reader - Clock Polarity"]
pub type CPOL_R = crate :: BitReader < bool > ; # [doc = "Field `CPOL` writer - Clock Polarity"]
pub type CPOL_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 29 > ; # [doc = "Field `DORD` reader - Data Order"]
pub type DORD_R = crate :: BitReader < bool > ; # [doc = "Field `DORD` writer - Data Order"]
pub type DORD_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 30 > ; impl R { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& self) -> SWRST_R { SWRST_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:4 - Operating Mode"]
# [inline (always)]
pub fn mode (& self) -> MODE_R { MODE_R :: new (((self . bits >> 2) & 7) as u8) } # [doc = "Bit 7 - Run during Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Immediate Buffer Overflow Notification"]
# [inline (always)]
pub fn ibon (& self) -> IBON_R { IBON_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bits 13:15 - Sample"]
# [inline (always)]
pub fn sampr (& self) -> SAMPR_R { SAMPR_R :: new (((self . bits >> 13) & 7) as u8) } # [doc = "Bits 16:17 - Transmit Data Pinout"]
# [inline (always)]
pub fn txpo (& self) -> TXPO_R { TXPO_R :: new (((self . bits >> 16) & 3) as u8) } # [doc = "Bits 20:21 - Receive Data Pinout"]
# [inline (always)]
pub fn rxpo (& self) -> RXPO_R { RXPO_R :: new (((self . bits >> 20) & 3) as u8) } # [doc = "Bits 22:23 - Sample Adjustment"]
# [inline (always)]
pub fn sampa (& self) -> SAMPA_R { SAMPA_R :: new (((self . bits >> 22) & 3) as u8) } # [doc = "Bits 24:27 - Frame Format"]
# [inline (always)]
pub fn form (& self) -> FORM_R { FORM_R :: new (((self . bits >> 24) & 0x0f) as u8) } # [doc = "Bit 28 - Communication Mode"]
# [inline (always)]
pub fn cmode (& self) -> CMODE_R { CMODE_R :: new (((self . bits >> 28) & 1) != 0) } # [doc = "Bit 29 - Clock Polarity"]
# [inline (always)]
pub fn cpol (& self) -> CPOL_R { CPOL_R :: new (((self . bits >> 29) & 1) != 0) } # [doc = "Bit 30 - Data Order"]
# [inline (always)]
pub fn dord (& self) -> DORD_R { DORD_R :: new (((self . bits >> 30) & 1) != 0) } } impl W { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& mut self) -> SWRST_W { SWRST_W :: new (self) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Bits 2:4 - Operating Mode"]
# [inline (always)]
pub fn mode (& mut self) -> MODE_W { MODE_W :: new (self) } # [doc = "Bit 7 - Run during Standby"]
# [inline (always)]
pub fn runstdby (& mut self) -> RUNSTDBY_W { RUNSTDBY_W :: new (self) } # [doc = "Bit 8 - Immediate Buffer Overflow Notification"]
# [inline (always)]
pub fn ibon (& mut self) -> IBON_W { IBON_W :: new (self) } # [doc = "Bits 13:15 - Sample"]
# [inline (always)]
pub fn sampr (& mut self) -> SAMPR_W { SAMPR_W :: new (self) } # [doc = "Bits 16:17 - Transmit Data Pinout"]
# [inline (always)]
pub fn txpo (& mut self) -> TXPO_W { TXPO_W :: new (self) } # [doc = "Bits 20:21 - Receive Data Pinout"]
# [inline (always)]
pub fn rxpo (& mut self) -> RXPO_W { RXPO_W :: new (self) } # [doc = "Bits 22:23 - Sample Adjustment"]
# [inline (always)]
pub fn sampa (& mut self) -> SAMPA_W { SAMPA_W :: new (self) } # [doc = "Bits 24:27 - Frame Format"]
# [inline (always)]
pub fn form (& mut self) -> FORM_W { FORM_W :: new (self) } # [doc = "Bit 28 - Communication Mode"]
# [inline (always)]
pub fn cmode (& mut self) -> CMODE_W { CMODE_W :: new (self) } # [doc = "Bit 29 - Clock Polarity"]
# [inline (always)]
pub fn cpol (& mut self) -> CPOL_W { CPOL_W :: new (self) } # [doc = "Bit 30 - Data Order"]
# [inline (always)]
pub fn dord (& mut self) -> DORD_W { DORD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CTRLB register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "USART Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `CHSIZE` reader - Character Size"]
pub type CHSIZE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CHSIZE` writer - Character Size"]
pub type CHSIZE_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLB_SPEC , u8 , u8 , 3 , 0 > ; # [doc = "Field `SBMODE` reader - Stop Bit Mode"]
pub type SBMODE_R = crate :: BitReader < bool > ; # [doc = "Field `SBMODE` writer - Stop Bit Mode"]
pub type SBMODE_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLB_SPEC , bool , 6 > ; # [doc = "Field `COLDEN` reader - Collision Detection Enable"]
pub type COLDEN_R = crate :: BitReader < bool > ; # [doc = "Field `COLDEN` writer - Collision Detection Enable"]
pub type COLDEN_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLB_SPEC , bool , 8 > ; # [doc = "Field `SFDE` reader - Start of Frame Detection Enable"]
pub type SFDE_R = crate :: BitReader < bool > ; # [doc = "Field `SFDE` writer - Start of Frame Detection Enable"]
pub type SFDE_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLB_SPEC , bool , 9 > ; # [doc = "Field `ENC` reader - Encoding Format"]
pub type ENC_R = crate :: BitReader < bool > ; # [doc = "Field `ENC` writer - Encoding Format"]
pub type ENC_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLB_SPEC , bool , 10 > ; # [doc = "Field `PMODE` reader - Parity Mode"]
pub type PMODE_R = crate :: BitReader < bool > ; # [doc = "Field `PMODE` writer - Parity Mode"]
pub type PMODE_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLB_SPEC , bool , 13 > ; # [doc = "Field `TXEN` reader - Transmitter Enable"]
pub type TXEN_R = crate :: BitReader < bool > ; # [doc = "Field `TXEN` writer - Transmitter Enable"]
pub type TXEN_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLB_SPEC , bool , 16 > ; # [doc = "Field `RXEN` reader - Receiver Enable"]
pub type RXEN_R = crate :: BitReader < bool > ; # [doc = "Field `RXEN` writer - Receiver Enable"]
pub type RXEN_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLB_SPEC , bool , 17 > ; impl R { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
pub fn chsize (& self) -> CHSIZE_R { CHSIZE_R :: new ((self . bits & 7) as u8) } # [doc = "Bit 6 - Stop Bit Mode"]
# [inline (always)]
pub fn sbmode (& self) -> SBMODE_R { SBMODE_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 8 - Collision Detection Enable"]
# [inline (always)]
pub fn colden (& self) -> COLDEN_R { COLDEN_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Start of Frame Detection Enable"]
# [inline (always)]
pub fn sfde (& self) -> SFDE_R { SFDE_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Encoding Format"]
# [inline (always)]
pub fn enc (& self) -> ENC_R { ENC_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 13 - Parity Mode"]
# [inline (always)]
pub fn pmode (& self) -> PMODE_R { PMODE_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 16 - Transmitter Enable"]
# [inline (always)]
pub fn txen (& self) -> TXEN_R { TXEN_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Receiver Enable"]
# [inline (always)]
pub fn rxen (& self) -> RXEN_R { RXEN_R :: new (((self . bits >> 17) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Character Size"]
# [inline (always)]
pub fn chsize (& mut self) -> CHSIZE_W { CHSIZE_W :: new (self) } # [doc = "Bit 6 - Stop Bit Mode"]
# [inline (always)]
pub fn sbmode (& mut self) -> SBMODE_W { SBMODE_W :: new (self) } # [doc = "Bit 8 - Collision Detection Enable"]
# [inline (always)]
pub fn colden (& mut self) -> COLDEN_W { COLDEN_W :: new (self) } # [doc = "Bit 9 - Start of Frame Detection Enable"]
# [inline (always)]
pub fn sfde (& mut self) -> SFDE_W { SFDE_W :: new (self) } # [doc = "Bit 10 - Encoding Format"]
# [inline (always)]
pub fn enc (& mut self) -> ENC_W { ENC_W :: new (self) } # [doc = "Bit 13 - Parity Mode"]
# [inline (always)]
pub fn pmode (& mut self) -> PMODE_W { PMODE_W :: new (self) } # [doc = "Bit 16 - Transmitter Enable"]
# [inline (always)]
pub fn txen (& mut self) -> TXEN_W { TXEN_W :: new (self) } # [doc = "Bit 17 - Receiver Enable"]
# [inline (always)]
pub fn rxen (& mut self) -> RXEN_W { RXEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "BAUD register accessor: an alias for `Reg<BAUD_SPEC>`"]
pub type BAUD = crate :: Reg < baud :: BAUD_SPEC > ; # [doc = "USART Baud Rate"]
pub mod baud { # [doc = "Register `BAUD` reader"]
pub struct R (crate :: R < BAUD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUD_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUD` writer"]
pub struct W (crate :: W < BAUD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUD_SPEC >) -> Self { W (writer) } } # [doc = "Field `BAUD` reader - Baud Rate Value"]
pub type BAUD_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `BAUD` writer - Baud Rate Value"]
pub type BAUD_W < 'a > = crate :: FieldWriter < 'a , u16 , BAUD_SPEC , u16 , u16 , 16 , 0 > ; impl R { # [doc = "Bits 0:15 - Baud Rate Value"]
# [inline (always)]
pub fn baud (& self) -> BAUD_R { BAUD_R :: new (self . bits) } } impl W { # [doc = "Bits 0:15 - Baud Rate Value"]
# [inline (always)]
pub fn baud (& mut self) -> BAUD_W { BAUD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART Baud Rate\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baud](index.html) module"]
pub struct BAUD_SPEC ; impl crate :: RegisterSpec for BAUD_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [baud::R](R) reader structure"]
impl crate :: Readable for BAUD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baud::W](W) writer structure"]
impl crate :: Writable for BAUD_SPEC { type Writer = W ; } # [doc = "`reset()` method sets BAUD to value 0"]
impl crate :: Resettable for BAUD_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "BAUD_FRAC_MODE register accessor: an alias for `Reg<BAUD_FRAC_MODE_SPEC>`"]
pub type BAUD_FRAC_MODE = crate :: Reg < baud_frac_mode :: BAUD_FRAC_MODE_SPEC > ; # [doc = "USART Baud Rate"]
pub mod baud_frac_mode { # [doc = "Register `BAUD_FRAC_MODE` reader"]
pub struct R (crate :: R < BAUD_FRAC_MODE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUD_FRAC_MODE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUD_FRAC_MODE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUD_FRAC_MODE_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUD_FRAC_MODE` writer"]
pub struct W (crate :: W < BAUD_FRAC_MODE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUD_FRAC_MODE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUD_FRAC_MODE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUD_FRAC_MODE_SPEC >) -> Self { W (writer) } } # [doc = "Field `BAUD` reader - Baud Rate Value"]
pub type BAUD_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `BAUD` writer - Baud Rate Value"]
pub type BAUD_W < 'a > = crate :: FieldWriter < 'a , u16 , BAUD_FRAC_MODE_SPEC , u16 , u16 , 13 , 0 > ; # [doc = "Field `FP` reader - Fractional Part"]
pub type FP_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `FP` writer - Fractional Part"]
pub type FP_W < 'a > = crate :: FieldWriter < 'a , u16 , BAUD_FRAC_MODE_SPEC , u8 , u8 , 3 , 13 > ; impl R { # [doc = "Bits 0:12 - Baud Rate Value"]
# [inline (always)]
pub fn baud (& self) -> BAUD_R { BAUD_R :: new ((self . bits & 0x1fff) as u16) } # [doc = "Bits 13:15 - Fractional Part"]
# [inline (always)]
pub fn fp (& self) -> FP_R { FP_R :: new (((self . bits >> 13) & 7) as u8) } } impl W { # [doc = "Bits 0:12 - Baud Rate Value"]
# [inline (always)]
pub fn baud (& mut self) -> BAUD_W { BAUD_W :: new (self) } # [doc = "Bits 13:15 - Fractional Part"]
# [inline (always)]
pub fn fp (& mut self) -> FP_W { FP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART Baud Rate\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baud_frac_mode](index.html) module"]
pub struct BAUD_FRAC_MODE_SPEC ; impl crate :: RegisterSpec for BAUD_FRAC_MODE_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [baud_frac_mode::R](R) reader structure"]
impl crate :: Readable for BAUD_FRAC_MODE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baud_frac_mode::W](W) writer structure"]
impl crate :: Writable for BAUD_FRAC_MODE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets BAUD_FRAC_MODE to value 0"]
impl crate :: Resettable for BAUD_FRAC_MODE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "BAUD_FRACFP_MODE register accessor: an alias for `Reg<BAUD_FRACFP_MODE_SPEC>`"]
pub type BAUD_FRACFP_MODE = crate :: Reg < baud_fracfp_mode :: BAUD_FRACFP_MODE_SPEC > ; # [doc = "USART Baud Rate"]
pub mod baud_fracfp_mode { # [doc = "Register `BAUD_FRACFP_MODE` reader"]
pub struct R (crate :: R < BAUD_FRACFP_MODE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUD_FRACFP_MODE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUD_FRACFP_MODE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUD_FRACFP_MODE_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUD_FRACFP_MODE` writer"]
pub struct W (crate :: W < BAUD_FRACFP_MODE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUD_FRACFP_MODE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUD_FRACFP_MODE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUD_FRACFP_MODE_SPEC >) -> Self { W (writer) } } # [doc = "Field `BAUD` reader - Baud Rate Value"]
pub type BAUD_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `BAUD` writer - Baud Rate Value"]
pub type BAUD_W < 'a > = crate :: FieldWriter < 'a , u16 , BAUD_FRACFP_MODE_SPEC , u16 , u16 , 13 , 0 > ; # [doc = "Field `FP` reader - Fractional Part"]
pub type FP_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `FP` writer - Fractional Part"]
pub type FP_W < 'a > = crate :: FieldWriter < 'a , u16 , BAUD_FRACFP_MODE_SPEC , u8 , u8 , 3 , 13 > ; impl R { # [doc = "Bits 0:12 - Baud Rate Value"]
# [inline (always)]
pub fn baud (& self) -> BAUD_R { BAUD_R :: new ((self . bits & 0x1fff) as u16) } # [doc = "Bits 13:15 - Fractional Part"]
# [inline (always)]
pub fn fp (& self) -> FP_R { FP_R :: new (((self . bits >> 13) & 7) as u8) } } impl W { # [doc = "Bits 0:12 - Baud Rate Value"]
# [inline (always)]
pub fn baud (& mut self) -> BAUD_W { BAUD_W :: new (self) } # [doc = "Bits 13:15 - Fractional Part"]
# [inline (always)]
pub fn fp (& mut self) -> FP_W { FP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART Baud Rate\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baud_fracfp_mode](index.html) module"]
pub struct BAUD_FRACFP_MODE_SPEC ; impl crate :: RegisterSpec for BAUD_FRACFP_MODE_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [baud_fracfp_mode::R](R) reader structure"]
impl crate :: Readable for BAUD_FRACFP_MODE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baud_fracfp_mode::W](W) writer structure"]
impl crate :: Writable for BAUD_FRACFP_MODE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets BAUD_FRACFP_MODE to value 0"]
impl crate :: Resettable for BAUD_FRACFP_MODE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "BAUD_USARTFP_MODE register accessor: an alias for `Reg<BAUD_USARTFP_MODE_SPEC>`"]
pub type BAUD_USARTFP_MODE = crate :: Reg < baud_usartfp_mode :: BAUD_USARTFP_MODE_SPEC > ; # [doc = "USART Baud Rate"]
pub mod baud_usartfp_mode { # [doc = "Register `BAUD_USARTFP_MODE` reader"]
pub struct R (crate :: R < BAUD_USARTFP_MODE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BAUD_USARTFP_MODE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BAUD_USARTFP_MODE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BAUD_USARTFP_MODE_SPEC >) -> Self { R (reader) } } # [doc = "Register `BAUD_USARTFP_MODE` writer"]
pub struct W (crate :: W < BAUD_USARTFP_MODE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BAUD_USARTFP_MODE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BAUD_USARTFP_MODE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BAUD_USARTFP_MODE_SPEC >) -> Self { W (writer) } } # [doc = "Field `BAUD` reader - Baud Rate Value"]
pub type BAUD_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `BAUD` writer - Baud Rate Value"]
pub type BAUD_W < 'a > = crate :: FieldWriter < 'a , u16 , BAUD_USARTFP_MODE_SPEC , u16 , u16 , 16 , 0 > ; impl R { # [doc = "Bits 0:15 - Baud Rate Value"]
# [inline (always)]
pub fn baud (& self) -> BAUD_R { BAUD_R :: new (self . bits) } } impl W { # [doc = "Bits 0:15 - Baud Rate Value"]
# [inline (always)]
pub fn baud (& mut self) -> BAUD_W { BAUD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART Baud Rate\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baud_usartfp_mode](index.html) module"]
pub struct BAUD_USARTFP_MODE_SPEC ; impl crate :: RegisterSpec for BAUD_USARTFP_MODE_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [baud_usartfp_mode::R](R) reader structure"]
impl crate :: Readable for BAUD_USARTFP_MODE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [baud_usartfp_mode::W](W) writer structure"]
impl crate :: Writable for BAUD_USARTFP_MODE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets BAUD_USARTFP_MODE to value 0"]
impl crate :: Resettable for BAUD_USARTFP_MODE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "RXPL register accessor: an alias for `Reg<RXPL_SPEC>`"]
pub type RXPL = crate :: Reg < rxpl :: RXPL_SPEC > ; # [doc = "USART Receive Pulse Length"]
pub mod rxpl { # [doc = "Register `RXPL` reader"]
pub struct R (crate :: R < RXPL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < RXPL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < RXPL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < RXPL_SPEC >) -> Self { R (reader) } } # [doc = "Register `RXPL` writer"]
pub struct W (crate :: W < RXPL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < RXPL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < RXPL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < RXPL_SPEC >) -> Self { W (writer) } } # [doc = "Field `RXPL` reader - Receive Pulse Length"]
pub type RXPL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `RXPL` writer - Receive Pulse Length"]
pub type RXPL_W < 'a > = crate :: FieldWriter < 'a , u8 , RXPL_SPEC , u8 , u8 , 8 , 0 > ; impl R { # [doc = "Bits 0:7 - Receive Pulse Length"]
# [inline (always)]
pub fn rxpl (& self) -> RXPL_R { RXPL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Receive Pulse Length"]
# [inline (always)]
pub fn rxpl (& mut self) -> RXPL_W { RXPL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART Receive Pulse Length\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxpl](index.html) module"]
pub struct RXPL_SPEC ; impl crate :: RegisterSpec for RXPL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [rxpl::R](R) reader structure"]
impl crate :: Readable for RXPL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [rxpl::W](W) writer structure"]
impl crate :: Writable for RXPL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets RXPL to value 0"]
impl crate :: Resettable for RXPL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENCLR register accessor: an alias for `Reg<INTENCLR_SPEC>`"]
pub type INTENCLR = crate :: Reg < intenclr :: INTENCLR_SPEC > ; # [doc = "USART Interrupt Enable Clear"]
pub mod intenclr { # [doc = "Register `INTENCLR` reader"]
pub struct R (crate :: R < INTENCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENCLR` writer"]
pub struct W (crate :: W < INTENCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `DRE` reader - Data Register Empty Interrupt Disable"]
pub type DRE_R = crate :: BitReader < bool > ; # [doc = "Field `DRE` writer - Data Register Empty Interrupt Disable"]
pub type DRE_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 0 > ; # [doc = "Field `TXC` reader - Transmit Complete Interrupt Disable"]
pub type TXC_R = crate :: BitReader < bool > ; # [doc = "Field `TXC` writer - Transmit Complete Interrupt Disable"]
pub type TXC_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 1 > ; # [doc = "Field `RXC` reader - Receive Complete Interrupt Disable"]
pub type RXC_R = crate :: BitReader < bool > ; # [doc = "Field `RXC` writer - Receive Complete Interrupt Disable"]
pub type RXC_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 2 > ; # [doc = "Field `RXS` reader - Receive Start Interrupt Disable"]
pub type RXS_R = crate :: BitReader < bool > ; # [doc = "Field `RXS` writer - Receive Start Interrupt Disable"]
pub type RXS_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 3 > ; # [doc = "Field `CTSIC` reader - Clear To Send Input Change Interrupt Disable"]
pub type CTSIC_R = crate :: BitReader < bool > ; # [doc = "Field `CTSIC` writer - Clear To Send Input Change Interrupt Disable"]
pub type CTSIC_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 4 > ; # [doc = "Field `RXBRK` reader - Break Received Interrupt Disable"]
pub type RXBRK_R = crate :: BitReader < bool > ; # [doc = "Field `RXBRK` writer - Break Received Interrupt Disable"]
pub type RXBRK_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 5 > ; # [doc = "Field `ERROR` reader - Combined Error Interrupt Disable"]
pub type ERROR_R = crate :: BitReader < bool > ; # [doc = "Field `ERROR` writer - Combined Error Interrupt Disable"]
pub type ERROR_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 7 > ; impl R { # [doc = "Bit 0 - Data Register Empty Interrupt Disable"]
# [inline (always)]
pub fn dre (& self) -> DRE_R { DRE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Transmit Complete Interrupt Disable"]
# [inline (always)]
pub fn txc (& self) -> TXC_R { TXC_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Receive Complete Interrupt Disable"]
# [inline (always)]
pub fn rxc (& self) -> RXC_R { RXC_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Receive Start Interrupt Disable"]
# [inline (always)]
pub fn rxs (& self) -> RXS_R { RXS_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Clear To Send Input Change Interrupt Disable"]
# [inline (always)]
pub fn ctsic (& self) -> CTSIC_R { CTSIC_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Break Received Interrupt Disable"]
# [inline (always)]
pub fn rxbrk (& self) -> RXBRK_R { RXBRK_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 7 - Combined Error Interrupt Disable"]
# [inline (always)]
pub fn error (& self) -> ERROR_R { ERROR_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Data Register Empty Interrupt Disable"]
# [inline (always)]
pub fn dre (& mut self) -> DRE_W { DRE_W :: new (self) } # [doc = "Bit 1 - Transmit Complete Interrupt Disable"]
# [inline (always)]
pub fn txc (& mut self) -> TXC_W { TXC_W :: new (self) } # [doc = "Bit 2 - Receive Complete Interrupt Disable"]
# [inline (always)]
pub fn rxc (& mut self) -> RXC_W { RXC_W :: new (self) } # [doc = "Bit 3 - Receive Start Interrupt Disable"]
# [inline (always)]
pub fn rxs (& mut self) -> RXS_W { RXS_W :: new (self) } # [doc = "Bit 4 - Clear To Send Input Change Interrupt Disable"]
# [inline (always)]
pub fn ctsic (& mut self) -> CTSIC_W { CTSIC_W :: new (self) } # [doc = "Bit 5 - Break Received Interrupt Disable"]
# [inline (always)]
pub fn rxbrk (& mut self) -> RXBRK_W { RXBRK_W :: new (self) } # [doc = "Bit 7 - Combined Error Interrupt Disable"]
# [inline (always)]
pub fn error (& mut self) -> ERROR_W { ERROR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenclr](index.html) module"]
pub struct INTENCLR_SPEC ; impl crate :: RegisterSpec for INTENCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenclr::R](R) reader structure"]
impl crate :: Readable for INTENCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenclr::W](W) writer structure"]
impl crate :: Writable for INTENCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENCLR to value 0"]
impl crate :: Resettable for INTENCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENSET register accessor: an alias for `Reg<INTENSET_SPEC>`"]
pub type INTENSET = crate :: Reg < intenset :: INTENSET_SPEC > ; # [doc = "USART Interrupt Enable Set"]
pub mod intenset { # [doc = "Register `INTENSET` reader"]
pub struct R (crate :: R < INTENSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENSET` writer"]
pub struct W (crate :: W < INTENSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `DRE` reader - Data Register Empty Interrupt Enable"]
pub type DRE_R = crate :: BitReader < bool > ; # [doc = "Field `DRE` writer - Data Register Empty Interrupt Enable"]
pub type DRE_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 0 > ; # [doc = "Field `TXC` reader - Transmit Complete Interrupt Enable"]
pub type TXC_R = crate :: BitReader < bool > ; # [doc = "Field `TXC` writer - Transmit Complete Interrupt Enable"]
pub type TXC_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 1 > ; # [doc = "Field `RXC` reader - Receive Complete Interrupt Enable"]
pub type RXC_R = crate :: BitReader < bool > ; # [doc = "Field `RXC` writer - Receive Complete Interrupt Enable"]
pub type RXC_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 2 > ; # [doc = "Field `RXS` reader - Receive Start Interrupt Enable"]
pub type RXS_R = crate :: BitReader < bool > ; # [doc = "Field `RXS` writer - Receive Start Interrupt Enable"]
pub type RXS_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 3 > ; # [doc = "Field `CTSIC` reader - Clear To Send Input Change Interrupt Enable"]
pub type CTSIC_R = crate :: BitReader < bool > ; # [doc = "Field `CTSIC` writer - Clear To Send Input Change Interrupt Enable"]
pub type CTSIC_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 4 > ; # [doc = "Field `RXBRK` reader - Break Received Interrupt Enable"]
pub type RXBRK_R = crate :: BitReader < bool > ; # [doc = "Field `RXBRK` writer - Break Received Interrupt Enable"]
pub type RXBRK_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 5 > ; # [doc = "Field `ERROR` reader - Combined Error Interrupt Enable"]
pub type ERROR_R = crate :: BitReader < bool > ; # [doc = "Field `ERROR` writer - Combined Error Interrupt Enable"]
pub type ERROR_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 7 > ; impl R { # [doc = "Bit 0 - Data Register Empty Interrupt Enable"]
# [inline (always)]
pub fn dre (& self) -> DRE_R { DRE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Transmit Complete Interrupt Enable"]
# [inline (always)]
pub fn txc (& self) -> TXC_R { TXC_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Receive Complete Interrupt Enable"]
# [inline (always)]
pub fn rxc (& self) -> RXC_R { RXC_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Receive Start Interrupt Enable"]
# [inline (always)]
pub fn rxs (& self) -> RXS_R { RXS_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Clear To Send Input Change Interrupt Enable"]
# [inline (always)]
pub fn ctsic (& self) -> CTSIC_R { CTSIC_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Break Received Interrupt Enable"]
# [inline (always)]
pub fn rxbrk (& self) -> RXBRK_R { RXBRK_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 7 - Combined Error Interrupt Enable"]
# [inline (always)]
pub fn error (& self) -> ERROR_R { ERROR_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Data Register Empty Interrupt Enable"]
# [inline (always)]
pub fn dre (& mut self) -> DRE_W { DRE_W :: new (self) } # [doc = "Bit 1 - Transmit Complete Interrupt Enable"]
# [inline (always)]
pub fn txc (& mut self) -> TXC_W { TXC_W :: new (self) } # [doc = "Bit 2 - Receive Complete Interrupt Enable"]
# [inline (always)]
pub fn rxc (& mut self) -> RXC_W { RXC_W :: new (self) } # [doc = "Bit 3 - Receive Start Interrupt Enable"]
# [inline (always)]
pub fn rxs (& mut self) -> RXS_W { RXS_W :: new (self) } # [doc = "Bit 4 - Clear To Send Input Change Interrupt Enable"]
# [inline (always)]
pub fn ctsic (& mut self) -> CTSIC_W { CTSIC_W :: new (self) } # [doc = "Bit 5 - Break Received Interrupt Enable"]
# [inline (always)]
pub fn rxbrk (& mut self) -> RXBRK_W { RXBRK_W :: new (self) } # [doc = "Bit 7 - Combined Error Interrupt Enable"]
# [inline (always)]
pub fn error (& mut self) -> ERROR_W { ERROR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenset](index.html) module"]
pub struct INTENSET_SPEC ; impl crate :: RegisterSpec for INTENSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenset::R](R) reader structure"]
impl crate :: Readable for INTENSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenset::W](W) writer structure"]
impl crate :: Writable for INTENSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENSET to value 0"]
impl crate :: Resettable for INTENSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTFLAG register accessor: an alias for `Reg<INTFLAG_SPEC>`"]
pub type INTFLAG = crate :: Reg < intflag :: INTFLAG_SPEC > ; # [doc = "USART Interrupt Flag Status and Clear"]
pub mod intflag { # [doc = "Register `INTFLAG` reader"]
pub struct R (crate :: R < INTFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAG` writer"]
pub struct W (crate :: W < INTFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `DRE` reader - Data Register Empty Interrupt"]
pub type DRE_R = crate :: BitReader < bool > ; # [doc = "Field `TXC` reader - Transmit Complete Interrupt"]
pub type TXC_R = crate :: BitReader < bool > ; # [doc = "Field `TXC` writer - Transmit Complete Interrupt"]
pub type TXC_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 1 > ; # [doc = "Field `RXC` reader - Receive Complete Interrupt"]
pub type RXC_R = crate :: BitReader < bool > ; # [doc = "Field `RXS` writer - Receive Start Interrupt"]
pub type RXS_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 3 > ; # [doc = "Field `CTSIC` reader - Clear To Send Input Change Interrupt"]
pub type CTSIC_R = crate :: BitReader < bool > ; # [doc = "Field `CTSIC` writer - Clear To Send Input Change Interrupt"]
pub type CTSIC_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 4 > ; # [doc = "Field `RXBRK` reader - Break Received Interrupt"]
pub type RXBRK_R = crate :: BitReader < bool > ; # [doc = "Field `RXBRK` writer - Break Received Interrupt"]
pub type RXBRK_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 5 > ; # [doc = "Field `ERROR` reader - Combined Error Interrupt"]
pub type ERROR_R = crate :: BitReader < bool > ; # [doc = "Field `ERROR` writer - Combined Error Interrupt"]
pub type ERROR_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 7 > ; impl R { # [doc = "Bit 0 - Data Register Empty Interrupt"]
# [inline (always)]
pub fn dre (& self) -> DRE_R { DRE_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Transmit Complete Interrupt"]
# [inline (always)]
pub fn txc (& self) -> TXC_R { TXC_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Receive Complete Interrupt"]
# [inline (always)]
pub fn rxc (& self) -> RXC_R { RXC_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 4 - Clear To Send Input Change Interrupt"]
# [inline (always)]
pub fn ctsic (& self) -> CTSIC_R { CTSIC_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Break Received Interrupt"]
# [inline (always)]
pub fn rxbrk (& self) -> RXBRK_R { RXBRK_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 7 - Combined Error Interrupt"]
# [inline (always)]
pub fn error (& self) -> ERROR_R { ERROR_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 1 - Transmit Complete Interrupt"]
# [inline (always)]
pub fn txc (& mut self) -> TXC_W { TXC_W :: new (self) } # [doc = "Bit 3 - Receive Start Interrupt"]
# [inline (always)]
pub fn rxs (& mut self) -> RXS_W { RXS_W :: new (self) } # [doc = "Bit 4 - Clear To Send Input Change Interrupt"]
# [inline (always)]
pub fn ctsic (& mut self) -> CTSIC_W { CTSIC_W :: new (self) } # [doc = "Bit 5 - Break Received Interrupt"]
# [inline (always)]
pub fn rxbrk (& mut self) -> RXBRK_W { RXBRK_W :: new (self) } # [doc = "Bit 7 - Combined Error Interrupt"]
# [inline (always)]
pub fn error (& mut self) -> ERROR_W { ERROR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflag](index.html) module"]
pub struct INTFLAG_SPEC ; impl crate :: RegisterSpec for INTFLAG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflag::R](R) reader structure"]
impl crate :: Readable for INTFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflag::W](W) writer structure"]
impl crate :: Writable for INTFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTFLAG to value 0"]
impl crate :: Resettable for INTFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATUS register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "USART Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `PERR` reader - Parity Error"]
pub type PERR_R = crate :: BitReader < bool > ; # [doc = "Field `PERR` writer - Parity Error"]
pub type PERR_W < 'a > = crate :: BitWriter < 'a , u16 , STATUS_SPEC , bool , 0 > ; # [doc = "Field `FERR` reader - Frame Error"]
pub type FERR_R = crate :: BitReader < bool > ; # [doc = "Field `FERR` writer - Frame Error"]
pub type FERR_W < 'a > = crate :: BitWriter < 'a , u16 , STATUS_SPEC , bool , 1 > ; # [doc = "Field `BUFOVF` reader - Buffer Overflow"]
pub type BUFOVF_R = crate :: BitReader < bool > ; # [doc = "Field `BUFOVF` writer - Buffer Overflow"]
pub type BUFOVF_W < 'a > = crate :: BitWriter < 'a , u16 , STATUS_SPEC , bool , 2 > ; # [doc = "Field `CTS` reader - Clear To Send"]
pub type CTS_R = crate :: BitReader < bool > ; # [doc = "Field `ISF` reader - Inconsistent Sync Field"]
pub type ISF_R = crate :: BitReader < bool > ; # [doc = "Field `ISF` writer - Inconsistent Sync Field"]
pub type ISF_W < 'a > = crate :: BitWriter < 'a , u16 , STATUS_SPEC , bool , 4 > ; # [doc = "Field `COLL` reader - Collision Detected"]
pub type COLL_R = crate :: BitReader < bool > ; # [doc = "Field `COLL` writer - Collision Detected"]
pub type COLL_W < 'a > = crate :: BitWriter < 'a , u16 , STATUS_SPEC , bool , 5 > ; impl R { # [doc = "Bit 0 - Parity Error"]
# [inline (always)]
pub fn perr (& self) -> PERR_R { PERR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Frame Error"]
# [inline (always)]
pub fn ferr (& self) -> FERR_R { FERR_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Buffer Overflow"]
# [inline (always)]
pub fn bufovf (& self) -> BUFOVF_R { BUFOVF_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Clear To Send"]
# [inline (always)]
pub fn cts (& self) -> CTS_R { CTS_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Inconsistent Sync Field"]
# [inline (always)]
pub fn isf (& self) -> ISF_R { ISF_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Collision Detected"]
# [inline (always)]
pub fn coll (& self) -> COLL_R { COLL_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Parity Error"]
# [inline (always)]
pub fn perr (& mut self) -> PERR_W { PERR_W :: new (self) } # [doc = "Bit 1 - Frame Error"]
# [inline (always)]
pub fn ferr (& mut self) -> FERR_W { FERR_W :: new (self) } # [doc = "Bit 2 - Buffer Overflow"]
# [inline (always)]
pub fn bufovf (& mut self) -> BUFOVF_W { BUFOVF_W :: new (self) } # [doc = "Bit 4 - Inconsistent Sync Field"]
# [inline (always)]
pub fn isf (& mut self) -> ISF_W { ISF_W :: new (self) } # [doc = "Bit 5 - Collision Detected"]
# [inline (always)]
pub fn coll (& mut self) -> COLL_W { COLL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYNCBUSY register accessor: an alias for `Reg<SYNCBUSY_SPEC>`"]
pub type SYNCBUSY = crate :: Reg < syncbusy :: SYNCBUSY_SPEC > ; # [doc = "USART Synchronization Busy"]
pub mod syncbusy { # [doc = "Register `SYNCBUSY` reader"]
pub struct R (crate :: R < SYNCBUSY_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYNCBUSY_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYNCBUSY_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYNCBUSY_SPEC >) -> Self { R (reader) } } # [doc = "Field `SWRST` reader - Software Reset Synchronization Busy"]
pub type SWRST_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` reader - SERCOM Enable Synchronization Busy"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `CTRLB` reader - CTRLB Synchronization Busy"]
pub type CTRLB_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Software Reset Synchronization Busy"]
# [inline (always)]
pub fn swrst (& self) -> SWRST_R { SWRST_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - SERCOM Enable Synchronization Busy"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - CTRLB Synchronization Busy"]
# [inline (always)]
pub fn ctrlb (& self) -> CTRLB_R { CTRLB_R :: new (((self . bits >> 2) & 1) != 0) } } # [doc = "USART Synchronization Busy\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [syncbusy](index.html) module"]
pub struct SYNCBUSY_SPEC ; impl crate :: RegisterSpec for SYNCBUSY_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [syncbusy::R](R) reader structure"]
impl crate :: Readable for SYNCBUSY_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SYNCBUSY to value 0"]
impl crate :: Resettable for SYNCBUSY_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DATA register accessor: an alias for `Reg<DATA_SPEC>`"]
pub type DATA = crate :: Reg < data :: DATA_SPEC > ; # [doc = "USART Data"]
pub mod data { # [doc = "Register `DATA` reader"]
pub struct R (crate :: R < DATA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DATA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DATA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DATA` writer"]
pub struct W (crate :: W < DATA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DATA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DATA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DATA_SPEC >) -> Self { W (writer) } } # [doc = "Field `DATA` reader - Data Value"]
pub type DATA_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `DATA` writer - Data Value"]
pub type DATA_W < 'a > = crate :: FieldWriter < 'a , u16 , DATA_SPEC , u16 , u16 , 9 , 0 > ; impl R { # [doc = "Bits 0:8 - Data Value"]
# [inline (always)]
pub fn data (& self) -> DATA_R { DATA_R :: new ((self . bits & 0x01ff) as u16) } } impl W { # [doc = "Bits 0:8 - Data Value"]
# [inline (always)]
pub fn data (& mut self) -> DATA_W { DATA_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](index.html) module"]
pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [data::R](R) reader structure"]
impl crate :: Readable for DATA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [data::W](W) writer structure"]
impl crate :: Writable for DATA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DATA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DBGCTRL register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "USART Debug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGSTOP` reader - Debug Mode"]
pub type DBGSTOP_R = crate :: BitReader < bool > ; # [doc = "Field `DBGSTOP` writer - Debug Mode"]
pub type DBGSTOP_W < 'a > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , 0 > ; impl R { # [doc = "Bit 0 - Debug Mode"]
# [inline (always)]
pub fn dbgstop (& self) -> DBGSTOP_R { DBGSTOP_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug Mode"]
# [inline (always)]
pub fn dbgstop (& mut self) -> DBGSTOP_W { DBGSTOP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USART Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } } # [doc = "Serial Communication Interface 1"]
pub struct SERCOM1 { _marker : PhantomData < * const () > } unsafe impl Send for SERCOM1 { } impl SERCOM1 { # [doc = r"Pointer to the register block"]
pub const PTR : * const sercom0 :: RegisterBlock = 0x4200_0c00 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const sercom0 :: RegisterBlock { Self :: PTR } } impl Deref for SERCOM1 { type Target = sercom0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SERCOM1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SERCOM1") . finish () } } # [doc = "Serial Communication Interface 1"]
pub use sercom0 as sercom1 ; # [doc = "Serial Communication Interface 2"]
pub struct SERCOM2 { _marker : PhantomData < * const () > } unsafe impl Send for SERCOM2 { } impl SERCOM2 { # [doc = r"Pointer to the register block"]
pub const PTR : * const sercom0 :: RegisterBlock = 0x4200_1000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const sercom0 :: RegisterBlock { Self :: PTR } } impl Deref for SERCOM2 { type Target = sercom0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SERCOM2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SERCOM2") . finish () } } # [doc = "Serial Communication Interface 2"]
pub use sercom0 as sercom2 ; # [doc = "Serial Communication Interface 3"]
pub struct SERCOM3 { _marker : PhantomData < * const () > } unsafe impl Send for SERCOM3 { } impl SERCOM3 { # [doc = r"Pointer to the register block"]
pub const PTR : * const sercom0 :: RegisterBlock = 0x4200_1400 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const sercom0 :: RegisterBlock { Self :: PTR } } impl Deref for SERCOM3 { type Target = sercom0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SERCOM3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SERCOM3") . finish () } } # [doc = "Serial Communication Interface 3"]
pub use sercom0 as sercom3 ; # [doc = "Serial Communication Interface 4"]
pub struct SERCOM4 { _marker : PhantomData < * const () > } unsafe impl Send for SERCOM4 { } impl SERCOM4 { # [doc = r"Pointer to the register block"]
pub const PTR : * const sercom0 :: RegisterBlock = 0x4200_1800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const sercom0 :: RegisterBlock { Self :: PTR } } impl Deref for SERCOM4 { type Target = sercom0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SERCOM4 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SERCOM4") . finish () } } # [doc = "Serial Communication Interface 4"]
pub use sercom0 as sercom4 ; # [doc = "Serial Communication Interface 5"]
pub struct SERCOM5 { _marker : PhantomData < * const () > } unsafe impl Send for SERCOM5 { } impl SERCOM5 { # [doc = r"Pointer to the register block"]
pub const PTR : * const sercom0 :: RegisterBlock = 0x4200_1c00 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const sercom0 :: RegisterBlock { Self :: PTR } } impl Deref for SERCOM5 { type Target = sercom0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SERCOM5 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SERCOM5") . finish () } } # [doc = "Serial Communication Interface 5"]
pub use sercom0 as sercom5 ; # [doc = "System Control"]
pub struct SYSCTRL { _marker : PhantomData < * const () > } unsafe impl Send for SYSCTRL { } impl SYSCTRL { # [doc = r"Pointer to the register block"]
pub const PTR : * const sysctrl :: RegisterBlock = 0x4000_0800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const sysctrl :: RegisterBlock { Self :: PTR } } impl Deref for SYSCTRL { type Target = sysctrl :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SYSCTRL { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SYSCTRL") . finish () } } # [doc = "System Control"]
pub mod sysctrl { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Interrupt Enable Clear"]
pub intenclr : crate :: Reg < intenclr :: INTENCLR_SPEC > , # [doc = "0x04 - Interrupt Enable Set"]
pub intenset : crate :: Reg < intenset :: INTENSET_SPEC > , # [doc = "0x08 - Interrupt Flag Status and Clear"]
pub intflag : crate :: Reg < intflag :: INTFLAG_SPEC > , # [doc = "0x0c - Power and Clocks Status"]
pub pclksr : crate :: Reg < pclksr :: PCLKSR_SPEC > , # [doc = "0x10 - External Multipurpose Crystal Oscillator (XOSC) Control"]
pub xosc : crate :: Reg < xosc :: XOSC_SPEC > , _reserved5 : [u8 ; 0x02]
, # [doc = "0x14 - 32kHz External Crystal Oscillator (XOSC32K) Control"]
pub xosc32k : crate :: Reg < xosc32k :: XOSC32K_SPEC > , _reserved6 : [u8 ; 0x02]
, # [doc = "0x18 - 32kHz Internal Oscillator (OSC32K) Control"]
pub osc32k : crate :: Reg < osc32k :: OSC32K_SPEC > , # [doc = "0x1c - 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control"]
pub osculp32k : crate :: Reg < osculp32k :: OSCULP32K_SPEC > , _reserved8 : [u8 ; 0x03]
, # [doc = "0x20 - 8MHz Internal Oscillator (OSC8M) Control"]
pub osc8m : crate :: Reg < osc8m :: OSC8M_SPEC > , # [doc = "0x24 - DFLL48M Control"]
pub dfllctrl : crate :: Reg < dfllctrl :: DFLLCTRL_SPEC > , _reserved10 : [u8 ; 0x02]
, # [doc = "0x28 - DFLL48M Value"]
pub dfllval : crate :: Reg < dfllval :: DFLLVAL_SPEC > , # [doc = "0x2c - DFLL48M Multiplier"]
pub dfllmul : crate :: Reg < dfllmul :: DFLLMUL_SPEC > , # [doc = "0x30 - DFLL48M Synchronization"]
pub dfllsync : crate :: Reg < dfllsync :: DFLLSYNC_SPEC > , _reserved13 : [u8 ; 0x03]
, # [doc = "0x34 - 3.3V Brown-Out Detector (BOD33) Control"]
pub bod33 : crate :: Reg < bod33 :: BOD33_SPEC > , _reserved14 : [u8 ; 0x04]
, # [doc = "0x3c - Voltage Regulator System (VREG) Control"]
pub vreg : crate :: Reg < vreg :: VREG_SPEC > , _reserved15 : [u8 ; 0x02]
, # [doc = "0x40 - Voltage References System (VREF) Control"]
pub vref : crate :: Reg < vref :: VREF_SPEC > , # [doc = "0x44 - DPLL Control A"]
pub dpllctrla : crate :: Reg < dpllctrla :: DPLLCTRLA_SPEC > , _reserved17 : [u8 ; 0x03]
, # [doc = "0x48 - DPLL Ratio Control"]
pub dpllratio : crate :: Reg < dpllratio :: DPLLRATIO_SPEC > , # [doc = "0x4c - DPLL Control B"]
pub dpllctrlb : crate :: Reg < dpllctrlb :: DPLLCTRLB_SPEC > , # [doc = "0x50 - DPLL Status"]
pub dpllstatus : crate :: Reg < dpllstatus :: DPLLSTATUS_SPEC > , } # [doc = "INTENCLR register accessor: an alias for `Reg<INTENCLR_SPEC>`"]
pub type INTENCLR = crate :: Reg < intenclr :: INTENCLR_SPEC > ; # [doc = "Interrupt Enable Clear"]
pub mod intenclr { # [doc = "Register `INTENCLR` reader"]
pub struct R (crate :: R < INTENCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENCLR` writer"]
pub struct W (crate :: W < INTENCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `XOSCRDY` reader - XOSC Ready Interrupt Enable"]
pub type XOSCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `XOSCRDY` writer - XOSC Ready Interrupt Enable"]
pub type XOSCRDY_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 0 > ; # [doc = "Field `XOSC32KRDY` reader - XOSC32K Ready Interrupt Enable"]
pub type XOSC32KRDY_R = crate :: BitReader < bool > ; # [doc = "Field `XOSC32KRDY` writer - XOSC32K Ready Interrupt Enable"]
pub type XOSC32KRDY_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 1 > ; # [doc = "Field `OSC32KRDY` reader - OSC32K Ready Interrupt Enable"]
pub type OSC32KRDY_R = crate :: BitReader < bool > ; # [doc = "Field `OSC32KRDY` writer - OSC32K Ready Interrupt Enable"]
pub type OSC32KRDY_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 2 > ; # [doc = "Field `OSC8MRDY` reader - OSC8M Ready Interrupt Enable"]
pub type OSC8MRDY_R = crate :: BitReader < bool > ; # [doc = "Field `OSC8MRDY` writer - OSC8M Ready Interrupt Enable"]
pub type OSC8MRDY_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 3 > ; # [doc = "Field `DFLLRDY` reader - DFLL Ready Interrupt Enable"]
pub type DFLLRDY_R = crate :: BitReader < bool > ; # [doc = "Field `DFLLRDY` writer - DFLL Ready Interrupt Enable"]
pub type DFLLRDY_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 4 > ; # [doc = "Field `DFLLOOB` reader - DFLL Out Of Bounds Interrupt Enable"]
pub type DFLLOOB_R = crate :: BitReader < bool > ; # [doc = "Field `DFLLOOB` writer - DFLL Out Of Bounds Interrupt Enable"]
pub type DFLLOOB_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 5 > ; # [doc = "Field `DFLLLCKF` reader - DFLL Lock Fine Interrupt Enable"]
pub type DFLLLCKF_R = crate :: BitReader < bool > ; # [doc = "Field `DFLLLCKF` writer - DFLL Lock Fine Interrupt Enable"]
pub type DFLLLCKF_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 6 > ; # [doc = "Field `DFLLLCKC` reader - DFLL Lock Coarse Interrupt Enable"]
pub type DFLLLCKC_R = crate :: BitReader < bool > ; # [doc = "Field `DFLLLCKC` writer - DFLL Lock Coarse Interrupt Enable"]
pub type DFLLLCKC_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 7 > ; # [doc = "Field `DFLLRCS` reader - DFLL Reference Clock Stopped Interrupt Enable"]
pub type DFLLRCS_R = crate :: BitReader < bool > ; # [doc = "Field `DFLLRCS` writer - DFLL Reference Clock Stopped Interrupt Enable"]
pub type DFLLRCS_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 8 > ; # [doc = "Field `BOD33RDY` reader - BOD33 Ready Interrupt Enable"]
pub type BOD33RDY_R = crate :: BitReader < bool > ; # [doc = "Field `BOD33RDY` writer - BOD33 Ready Interrupt Enable"]
pub type BOD33RDY_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 9 > ; # [doc = "Field `BOD33DET` reader - BOD33 Detection Interrupt Enable"]
pub type BOD33DET_R = crate :: BitReader < bool > ; # [doc = "Field `BOD33DET` writer - BOD33 Detection Interrupt Enable"]
pub type BOD33DET_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 10 > ; # [doc = "Field `B33SRDY` reader - BOD33 Synchronization Ready Interrupt Enable"]
pub type B33SRDY_R = crate :: BitReader < bool > ; # [doc = "Field `B33SRDY` writer - BOD33 Synchronization Ready Interrupt Enable"]
pub type B33SRDY_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 11 > ; # [doc = "Field `DPLLLCKR` reader - DPLL Lock Rise Interrupt Enable"]
pub type DPLLLCKR_R = crate :: BitReader < bool > ; # [doc = "Field `DPLLLCKR` writer - DPLL Lock Rise Interrupt Enable"]
pub type DPLLLCKR_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 15 > ; # [doc = "Field `DPLLLCKF` reader - DPLL Lock Fall Interrupt Enable"]
pub type DPLLLCKF_R = crate :: BitReader < bool > ; # [doc = "Field `DPLLLCKF` writer - DPLL Lock Fall Interrupt Enable"]
pub type DPLLLCKF_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 16 > ; # [doc = "Field `DPLLLTO` reader - DPLL Lock Timeout Interrupt Enable"]
pub type DPLLLTO_R = crate :: BitReader < bool > ; # [doc = "Field `DPLLLTO` writer - DPLL Lock Timeout Interrupt Enable"]
pub type DPLLLTO_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 17 > ; impl R { # [doc = "Bit 0 - XOSC Ready Interrupt Enable"]
# [inline (always)]
pub fn xoscrdy (& self) -> XOSCRDY_R { XOSCRDY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - XOSC32K Ready Interrupt Enable"]
# [inline (always)]
pub fn xosc32krdy (& self) -> XOSC32KRDY_R { XOSC32KRDY_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - OSC32K Ready Interrupt Enable"]
# [inline (always)]
pub fn osc32krdy (& self) -> OSC32KRDY_R { OSC32KRDY_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - OSC8M Ready Interrupt Enable"]
# [inline (always)]
pub fn osc8mrdy (& self) -> OSC8MRDY_R { OSC8MRDY_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - DFLL Ready Interrupt Enable"]
# [inline (always)]
pub fn dfllrdy (& self) -> DFLLRDY_R { DFLLRDY_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - DFLL Out Of Bounds Interrupt Enable"]
# [inline (always)]
pub fn dflloob (& self) -> DFLLOOB_R { DFLLOOB_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - DFLL Lock Fine Interrupt Enable"]
# [inline (always)]
pub fn dflllckf (& self) -> DFLLLCKF_R { DFLLLCKF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - DFLL Lock Coarse Interrupt Enable"]
# [inline (always)]
pub fn dflllckc (& self) -> DFLLLCKC_R { DFLLLCKC_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - DFLL Reference Clock Stopped Interrupt Enable"]
# [inline (always)]
pub fn dfllrcs (& self) -> DFLLRCS_R { DFLLRCS_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - BOD33 Ready Interrupt Enable"]
# [inline (always)]
pub fn bod33rdy (& self) -> BOD33RDY_R { BOD33RDY_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - BOD33 Detection Interrupt Enable"]
# [inline (always)]
pub fn bod33det (& self) -> BOD33DET_R { BOD33DET_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - BOD33 Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn b33srdy (& self) -> B33SRDY_R { B33SRDY_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 15 - DPLL Lock Rise Interrupt Enable"]
# [inline (always)]
pub fn dplllckr (& self) -> DPLLLCKR_R { DPLLLCKR_R :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - DPLL Lock Fall Interrupt Enable"]
# [inline (always)]
pub fn dplllckf (& self) -> DPLLLCKF_R { DPLLLCKF_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - DPLL Lock Timeout Interrupt Enable"]
# [inline (always)]
pub fn dplllto (& self) -> DPLLLTO_R { DPLLLTO_R :: new (((self . bits >> 17) & 1) != 0) } } impl W { # [doc = "Bit 0 - XOSC Ready Interrupt Enable"]
# [inline (always)]
pub fn xoscrdy (& mut self) -> XOSCRDY_W { XOSCRDY_W :: new (self) } # [doc = "Bit 1 - XOSC32K Ready Interrupt Enable"]
# [inline (always)]
pub fn xosc32krdy (& mut self) -> XOSC32KRDY_W { XOSC32KRDY_W :: new (self) } # [doc = "Bit 2 - OSC32K Ready Interrupt Enable"]
# [inline (always)]
pub fn osc32krdy (& mut self) -> OSC32KRDY_W { OSC32KRDY_W :: new (self) } # [doc = "Bit 3 - OSC8M Ready Interrupt Enable"]
# [inline (always)]
pub fn osc8mrdy (& mut self) -> OSC8MRDY_W { OSC8MRDY_W :: new (self) } # [doc = "Bit 4 - DFLL Ready Interrupt Enable"]
# [inline (always)]
pub fn dfllrdy (& mut self) -> DFLLRDY_W { DFLLRDY_W :: new (self) } # [doc = "Bit 5 - DFLL Out Of Bounds Interrupt Enable"]
# [inline (always)]
pub fn dflloob (& mut self) -> DFLLOOB_W { DFLLOOB_W :: new (self) } # [doc = "Bit 6 - DFLL Lock Fine Interrupt Enable"]
# [inline (always)]
pub fn dflllckf (& mut self) -> DFLLLCKF_W { DFLLLCKF_W :: new (self) } # [doc = "Bit 7 - DFLL Lock Coarse Interrupt Enable"]
# [inline (always)]
pub fn dflllckc (& mut self) -> DFLLLCKC_W { DFLLLCKC_W :: new (self) } # [doc = "Bit 8 - DFLL Reference Clock Stopped Interrupt Enable"]
# [inline (always)]
pub fn dfllrcs (& mut self) -> DFLLRCS_W { DFLLRCS_W :: new (self) } # [doc = "Bit 9 - BOD33 Ready Interrupt Enable"]
# [inline (always)]
pub fn bod33rdy (& mut self) -> BOD33RDY_W { BOD33RDY_W :: new (self) } # [doc = "Bit 10 - BOD33 Detection Interrupt Enable"]
# [inline (always)]
pub fn bod33det (& mut self) -> BOD33DET_W { BOD33DET_W :: new (self) } # [doc = "Bit 11 - BOD33 Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn b33srdy (& mut self) -> B33SRDY_W { B33SRDY_W :: new (self) } # [doc = "Bit 15 - DPLL Lock Rise Interrupt Enable"]
# [inline (always)]
pub fn dplllckr (& mut self) -> DPLLLCKR_W { DPLLLCKR_W :: new (self) } # [doc = "Bit 16 - DPLL Lock Fall Interrupt Enable"]
# [inline (always)]
pub fn dplllckf (& mut self) -> DPLLLCKF_W { DPLLLCKF_W :: new (self) } # [doc = "Bit 17 - DPLL Lock Timeout Interrupt Enable"]
# [inline (always)]
pub fn dplllto (& mut self) -> DPLLLTO_W { DPLLLTO_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenclr](index.html) module"]
pub struct INTENCLR_SPEC ; impl crate :: RegisterSpec for INTENCLR_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [intenclr::R](R) reader structure"]
impl crate :: Readable for INTENCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenclr::W](W) writer structure"]
impl crate :: Writable for INTENCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENCLR to value 0"]
impl crate :: Resettable for INTENCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENSET register accessor: an alias for `Reg<INTENSET_SPEC>`"]
pub type INTENSET = crate :: Reg < intenset :: INTENSET_SPEC > ; # [doc = "Interrupt Enable Set"]
pub mod intenset { # [doc = "Register `INTENSET` reader"]
pub struct R (crate :: R < INTENSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENSET` writer"]
pub struct W (crate :: W < INTENSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `XOSCRDY` reader - XOSC Ready Interrupt Enable"]
pub type XOSCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `XOSCRDY` writer - XOSC Ready Interrupt Enable"]
pub type XOSCRDY_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 0 > ; # [doc = "Field `XOSC32KRDY` reader - XOSC32K Ready Interrupt Enable"]
pub type XOSC32KRDY_R = crate :: BitReader < bool > ; # [doc = "Field `XOSC32KRDY` writer - XOSC32K Ready Interrupt Enable"]
pub type XOSC32KRDY_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 1 > ; # [doc = "Field `OSC32KRDY` reader - OSC32K Ready Interrupt Enable"]
pub type OSC32KRDY_R = crate :: BitReader < bool > ; # [doc = "Field `OSC32KRDY` writer - OSC32K Ready Interrupt Enable"]
pub type OSC32KRDY_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 2 > ; # [doc = "Field `OSC8MRDY` reader - OSC8M Ready Interrupt Enable"]
pub type OSC8MRDY_R = crate :: BitReader < bool > ; # [doc = "Field `OSC8MRDY` writer - OSC8M Ready Interrupt Enable"]
pub type OSC8MRDY_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 3 > ; # [doc = "Field `DFLLRDY` reader - DFLL Ready Interrupt Enable"]
pub type DFLLRDY_R = crate :: BitReader < bool > ; # [doc = "Field `DFLLRDY` writer - DFLL Ready Interrupt Enable"]
pub type DFLLRDY_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 4 > ; # [doc = "Field `DFLLOOB` reader - DFLL Out Of Bounds Interrupt Enable"]
pub type DFLLOOB_R = crate :: BitReader < bool > ; # [doc = "Field `DFLLOOB` writer - DFLL Out Of Bounds Interrupt Enable"]
pub type DFLLOOB_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 5 > ; # [doc = "Field `DFLLLCKF` reader - DFLL Lock Fine Interrupt Enable"]
pub type DFLLLCKF_R = crate :: BitReader < bool > ; # [doc = "Field `DFLLLCKF` writer - DFLL Lock Fine Interrupt Enable"]
pub type DFLLLCKF_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 6 > ; # [doc = "Field `DFLLLCKC` reader - DFLL Lock Coarse Interrupt Enable"]
pub type DFLLLCKC_R = crate :: BitReader < bool > ; # [doc = "Field `DFLLLCKC` writer - DFLL Lock Coarse Interrupt Enable"]
pub type DFLLLCKC_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 7 > ; # [doc = "Field `DFLLRCS` reader - DFLL Reference Clock Stopped Interrupt Enable"]
pub type DFLLRCS_R = crate :: BitReader < bool > ; # [doc = "Field `DFLLRCS` writer - DFLL Reference Clock Stopped Interrupt Enable"]
pub type DFLLRCS_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 8 > ; # [doc = "Field `BOD33RDY` reader - BOD33 Ready Interrupt Enable"]
pub type BOD33RDY_R = crate :: BitReader < bool > ; # [doc = "Field `BOD33RDY` writer - BOD33 Ready Interrupt Enable"]
pub type BOD33RDY_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 9 > ; # [doc = "Field `BOD33DET` reader - BOD33 Detection Interrupt Enable"]
pub type BOD33DET_R = crate :: BitReader < bool > ; # [doc = "Field `BOD33DET` writer - BOD33 Detection Interrupt Enable"]
pub type BOD33DET_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 10 > ; # [doc = "Field `B33SRDY` reader - BOD33 Synchronization Ready Interrupt Enable"]
pub type B33SRDY_R = crate :: BitReader < bool > ; # [doc = "Field `B33SRDY` writer - BOD33 Synchronization Ready Interrupt Enable"]
pub type B33SRDY_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 11 > ; # [doc = "Field `DPLLLCKR` reader - DPLL Lock Rise Interrupt Enable"]
pub type DPLLLCKR_R = crate :: BitReader < bool > ; # [doc = "Field `DPLLLCKR` writer - DPLL Lock Rise Interrupt Enable"]
pub type DPLLLCKR_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 15 > ; # [doc = "Field `DPLLLCKF` reader - DPLL Lock Fall Interrupt Enable"]
pub type DPLLLCKF_R = crate :: BitReader < bool > ; # [doc = "Field `DPLLLCKF` writer - DPLL Lock Fall Interrupt Enable"]
pub type DPLLLCKF_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 16 > ; # [doc = "Field `DPLLLTO` reader - DPLL Lock Timeout Interrupt Enable"]
pub type DPLLLTO_R = crate :: BitReader < bool > ; # [doc = "Field `DPLLLTO` writer - DPLL Lock Timeout Interrupt Enable"]
pub type DPLLLTO_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 17 > ; impl R { # [doc = "Bit 0 - XOSC Ready Interrupt Enable"]
# [inline (always)]
pub fn xoscrdy (& self) -> XOSCRDY_R { XOSCRDY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - XOSC32K Ready Interrupt Enable"]
# [inline (always)]
pub fn xosc32krdy (& self) -> XOSC32KRDY_R { XOSC32KRDY_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - OSC32K Ready Interrupt Enable"]
# [inline (always)]
pub fn osc32krdy (& self) -> OSC32KRDY_R { OSC32KRDY_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - OSC8M Ready Interrupt Enable"]
# [inline (always)]
pub fn osc8mrdy (& self) -> OSC8MRDY_R { OSC8MRDY_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - DFLL Ready Interrupt Enable"]
# [inline (always)]
pub fn dfllrdy (& self) -> DFLLRDY_R { DFLLRDY_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - DFLL Out Of Bounds Interrupt Enable"]
# [inline (always)]
pub fn dflloob (& self) -> DFLLOOB_R { DFLLOOB_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - DFLL Lock Fine Interrupt Enable"]
# [inline (always)]
pub fn dflllckf (& self) -> DFLLLCKF_R { DFLLLCKF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - DFLL Lock Coarse Interrupt Enable"]
# [inline (always)]
pub fn dflllckc (& self) -> DFLLLCKC_R { DFLLLCKC_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - DFLL Reference Clock Stopped Interrupt Enable"]
# [inline (always)]
pub fn dfllrcs (& self) -> DFLLRCS_R { DFLLRCS_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - BOD33 Ready Interrupt Enable"]
# [inline (always)]
pub fn bod33rdy (& self) -> BOD33RDY_R { BOD33RDY_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - BOD33 Detection Interrupt Enable"]
# [inline (always)]
pub fn bod33det (& self) -> BOD33DET_R { BOD33DET_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - BOD33 Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn b33srdy (& self) -> B33SRDY_R { B33SRDY_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 15 - DPLL Lock Rise Interrupt Enable"]
# [inline (always)]
pub fn dplllckr (& self) -> DPLLLCKR_R { DPLLLCKR_R :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - DPLL Lock Fall Interrupt Enable"]
# [inline (always)]
pub fn dplllckf (& self) -> DPLLLCKF_R { DPLLLCKF_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - DPLL Lock Timeout Interrupt Enable"]
# [inline (always)]
pub fn dplllto (& self) -> DPLLLTO_R { DPLLLTO_R :: new (((self . bits >> 17) & 1) != 0) } } impl W { # [doc = "Bit 0 - XOSC Ready Interrupt Enable"]
# [inline (always)]
pub fn xoscrdy (& mut self) -> XOSCRDY_W { XOSCRDY_W :: new (self) } # [doc = "Bit 1 - XOSC32K Ready Interrupt Enable"]
# [inline (always)]
pub fn xosc32krdy (& mut self) -> XOSC32KRDY_W { XOSC32KRDY_W :: new (self) } # [doc = "Bit 2 - OSC32K Ready Interrupt Enable"]
# [inline (always)]
pub fn osc32krdy (& mut self) -> OSC32KRDY_W { OSC32KRDY_W :: new (self) } # [doc = "Bit 3 - OSC8M Ready Interrupt Enable"]
# [inline (always)]
pub fn osc8mrdy (& mut self) -> OSC8MRDY_W { OSC8MRDY_W :: new (self) } # [doc = "Bit 4 - DFLL Ready Interrupt Enable"]
# [inline (always)]
pub fn dfllrdy (& mut self) -> DFLLRDY_W { DFLLRDY_W :: new (self) } # [doc = "Bit 5 - DFLL Out Of Bounds Interrupt Enable"]
# [inline (always)]
pub fn dflloob (& mut self) -> DFLLOOB_W { DFLLOOB_W :: new (self) } # [doc = "Bit 6 - DFLL Lock Fine Interrupt Enable"]
# [inline (always)]
pub fn dflllckf (& mut self) -> DFLLLCKF_W { DFLLLCKF_W :: new (self) } # [doc = "Bit 7 - DFLL Lock Coarse Interrupt Enable"]
# [inline (always)]
pub fn dflllckc (& mut self) -> DFLLLCKC_W { DFLLLCKC_W :: new (self) } # [doc = "Bit 8 - DFLL Reference Clock Stopped Interrupt Enable"]
# [inline (always)]
pub fn dfllrcs (& mut self) -> DFLLRCS_W { DFLLRCS_W :: new (self) } # [doc = "Bit 9 - BOD33 Ready Interrupt Enable"]
# [inline (always)]
pub fn bod33rdy (& mut self) -> BOD33RDY_W { BOD33RDY_W :: new (self) } # [doc = "Bit 10 - BOD33 Detection Interrupt Enable"]
# [inline (always)]
pub fn bod33det (& mut self) -> BOD33DET_W { BOD33DET_W :: new (self) } # [doc = "Bit 11 - BOD33 Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn b33srdy (& mut self) -> B33SRDY_W { B33SRDY_W :: new (self) } # [doc = "Bit 15 - DPLL Lock Rise Interrupt Enable"]
# [inline (always)]
pub fn dplllckr (& mut self) -> DPLLLCKR_W { DPLLLCKR_W :: new (self) } # [doc = "Bit 16 - DPLL Lock Fall Interrupt Enable"]
# [inline (always)]
pub fn dplllckf (& mut self) -> DPLLLCKF_W { DPLLLCKF_W :: new (self) } # [doc = "Bit 17 - DPLL Lock Timeout Interrupt Enable"]
# [inline (always)]
pub fn dplllto (& mut self) -> DPLLLTO_W { DPLLLTO_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenset](index.html) module"]
pub struct INTENSET_SPEC ; impl crate :: RegisterSpec for INTENSET_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [intenset::R](R) reader structure"]
impl crate :: Readable for INTENSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenset::W](W) writer structure"]
impl crate :: Writable for INTENSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENSET to value 0"]
impl crate :: Resettable for INTENSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTFLAG register accessor: an alias for `Reg<INTFLAG_SPEC>`"]
pub type INTFLAG = crate :: Reg < intflag :: INTFLAG_SPEC > ; # [doc = "Interrupt Flag Status and Clear"]
pub mod intflag { # [doc = "Register `INTFLAG` reader"]
pub struct R (crate :: R < INTFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAG` writer"]
pub struct W (crate :: W < INTFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `XOSCRDY` reader - XOSC Ready"]
pub type XOSCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `XOSCRDY` writer - XOSC Ready"]
pub type XOSCRDY_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 0 > ; # [doc = "Field `XOSC32KRDY` reader - XOSC32K Ready"]
pub type XOSC32KRDY_R = crate :: BitReader < bool > ; # [doc = "Field `XOSC32KRDY` writer - XOSC32K Ready"]
pub type XOSC32KRDY_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 1 > ; # [doc = "Field `OSC32KRDY` reader - OSC32K Ready"]
pub type OSC32KRDY_R = crate :: BitReader < bool > ; # [doc = "Field `OSC32KRDY` writer - OSC32K Ready"]
pub type OSC32KRDY_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 2 > ; # [doc = "Field `OSC8MRDY` reader - OSC8M Ready"]
pub type OSC8MRDY_R = crate :: BitReader < bool > ; # [doc = "Field `OSC8MRDY` writer - OSC8M Ready"]
pub type OSC8MRDY_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 3 > ; # [doc = "Field `DFLLRDY` reader - DFLL Ready"]
pub type DFLLRDY_R = crate :: BitReader < bool > ; # [doc = "Field `DFLLRDY` writer - DFLL Ready"]
pub type DFLLRDY_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 4 > ; # [doc = "Field `DFLLOOB` reader - DFLL Out Of Bounds"]
pub type DFLLOOB_R = crate :: BitReader < bool > ; # [doc = "Field `DFLLOOB` writer - DFLL Out Of Bounds"]
pub type DFLLOOB_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 5 > ; # [doc = "Field `DFLLLCKF` reader - DFLL Lock Fine"]
pub type DFLLLCKF_R = crate :: BitReader < bool > ; # [doc = "Field `DFLLLCKF` writer - DFLL Lock Fine"]
pub type DFLLLCKF_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 6 > ; # [doc = "Field `DFLLLCKC` reader - DFLL Lock Coarse"]
pub type DFLLLCKC_R = crate :: BitReader < bool > ; # [doc = "Field `DFLLLCKC` writer - DFLL Lock Coarse"]
pub type DFLLLCKC_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 7 > ; # [doc = "Field `DFLLRCS` reader - DFLL Reference Clock Stopped"]
pub type DFLLRCS_R = crate :: BitReader < bool > ; # [doc = "Field `DFLLRCS` writer - DFLL Reference Clock Stopped"]
pub type DFLLRCS_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 8 > ; # [doc = "Field `BOD33RDY` reader - BOD33 Ready"]
pub type BOD33RDY_R = crate :: BitReader < bool > ; # [doc = "Field `BOD33RDY` writer - BOD33 Ready"]
pub type BOD33RDY_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 9 > ; # [doc = "Field `BOD33DET` reader - BOD33 Detection"]
pub type BOD33DET_R = crate :: BitReader < bool > ; # [doc = "Field `BOD33DET` writer - BOD33 Detection"]
pub type BOD33DET_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 10 > ; # [doc = "Field `B33SRDY` reader - BOD33 Synchronization Ready"]
pub type B33SRDY_R = crate :: BitReader < bool > ; # [doc = "Field `B33SRDY` writer - BOD33 Synchronization Ready"]
pub type B33SRDY_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 11 > ; # [doc = "Field `DPLLLCKR` reader - DPLL Lock Rise"]
pub type DPLLLCKR_R = crate :: BitReader < bool > ; # [doc = "Field `DPLLLCKR` writer - DPLL Lock Rise"]
pub type DPLLLCKR_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 15 > ; # [doc = "Field `DPLLLCKF` reader - DPLL Lock Fall"]
pub type DPLLLCKF_R = crate :: BitReader < bool > ; # [doc = "Field `DPLLLCKF` writer - DPLL Lock Fall"]
pub type DPLLLCKF_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 16 > ; # [doc = "Field `DPLLLTO` reader - DPLL Lock Timeout"]
pub type DPLLLTO_R = crate :: BitReader < bool > ; # [doc = "Field `DPLLLTO` writer - DPLL Lock Timeout"]
pub type DPLLLTO_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 17 > ; impl R { # [doc = "Bit 0 - XOSC Ready"]
# [inline (always)]
pub fn xoscrdy (& self) -> XOSCRDY_R { XOSCRDY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - XOSC32K Ready"]
# [inline (always)]
pub fn xosc32krdy (& self) -> XOSC32KRDY_R { XOSC32KRDY_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - OSC32K Ready"]
# [inline (always)]
pub fn osc32krdy (& self) -> OSC32KRDY_R { OSC32KRDY_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - OSC8M Ready"]
# [inline (always)]
pub fn osc8mrdy (& self) -> OSC8MRDY_R { OSC8MRDY_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - DFLL Ready"]
# [inline (always)]
pub fn dfllrdy (& self) -> DFLLRDY_R { DFLLRDY_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - DFLL Out Of Bounds"]
# [inline (always)]
pub fn dflloob (& self) -> DFLLOOB_R { DFLLOOB_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - DFLL Lock Fine"]
# [inline (always)]
pub fn dflllckf (& self) -> DFLLLCKF_R { DFLLLCKF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - DFLL Lock Coarse"]
# [inline (always)]
pub fn dflllckc (& self) -> DFLLLCKC_R { DFLLLCKC_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - DFLL Reference Clock Stopped"]
# [inline (always)]
pub fn dfllrcs (& self) -> DFLLRCS_R { DFLLRCS_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - BOD33 Ready"]
# [inline (always)]
pub fn bod33rdy (& self) -> BOD33RDY_R { BOD33RDY_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - BOD33 Detection"]
# [inline (always)]
pub fn bod33det (& self) -> BOD33DET_R { BOD33DET_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - BOD33 Synchronization Ready"]
# [inline (always)]
pub fn b33srdy (& self) -> B33SRDY_R { B33SRDY_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 15 - DPLL Lock Rise"]
# [inline (always)]
pub fn dplllckr (& self) -> DPLLLCKR_R { DPLLLCKR_R :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - DPLL Lock Fall"]
# [inline (always)]
pub fn dplllckf (& self) -> DPLLLCKF_R { DPLLLCKF_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - DPLL Lock Timeout"]
# [inline (always)]
pub fn dplllto (& self) -> DPLLLTO_R { DPLLLTO_R :: new (((self . bits >> 17) & 1) != 0) } } impl W { # [doc = "Bit 0 - XOSC Ready"]
# [inline (always)]
pub fn xoscrdy (& mut self) -> XOSCRDY_W { XOSCRDY_W :: new (self) } # [doc = "Bit 1 - XOSC32K Ready"]
# [inline (always)]
pub fn xosc32krdy (& mut self) -> XOSC32KRDY_W { XOSC32KRDY_W :: new (self) } # [doc = "Bit 2 - OSC32K Ready"]
# [inline (always)]
pub fn osc32krdy (& mut self) -> OSC32KRDY_W { OSC32KRDY_W :: new (self) } # [doc = "Bit 3 - OSC8M Ready"]
# [inline (always)]
pub fn osc8mrdy (& mut self) -> OSC8MRDY_W { OSC8MRDY_W :: new (self) } # [doc = "Bit 4 - DFLL Ready"]
# [inline (always)]
pub fn dfllrdy (& mut self) -> DFLLRDY_W { DFLLRDY_W :: new (self) } # [doc = "Bit 5 - DFLL Out Of Bounds"]
# [inline (always)]
pub fn dflloob (& mut self) -> DFLLOOB_W { DFLLOOB_W :: new (self) } # [doc = "Bit 6 - DFLL Lock Fine"]
# [inline (always)]
pub fn dflllckf (& mut self) -> DFLLLCKF_W { DFLLLCKF_W :: new (self) } # [doc = "Bit 7 - DFLL Lock Coarse"]
# [inline (always)]
pub fn dflllckc (& mut self) -> DFLLLCKC_W { DFLLLCKC_W :: new (self) } # [doc = "Bit 8 - DFLL Reference Clock Stopped"]
# [inline (always)]
pub fn dfllrcs (& mut self) -> DFLLRCS_W { DFLLRCS_W :: new (self) } # [doc = "Bit 9 - BOD33 Ready"]
# [inline (always)]
pub fn bod33rdy (& mut self) -> BOD33RDY_W { BOD33RDY_W :: new (self) } # [doc = "Bit 10 - BOD33 Detection"]
# [inline (always)]
pub fn bod33det (& mut self) -> BOD33DET_W { BOD33DET_W :: new (self) } # [doc = "Bit 11 - BOD33 Synchronization Ready"]
# [inline (always)]
pub fn b33srdy (& mut self) -> B33SRDY_W { B33SRDY_W :: new (self) } # [doc = "Bit 15 - DPLL Lock Rise"]
# [inline (always)]
pub fn dplllckr (& mut self) -> DPLLLCKR_W { DPLLLCKR_W :: new (self) } # [doc = "Bit 16 - DPLL Lock Fall"]
# [inline (always)]
pub fn dplllckf (& mut self) -> DPLLLCKF_W { DPLLLCKF_W :: new (self) } # [doc = "Bit 17 - DPLL Lock Timeout"]
# [inline (always)]
pub fn dplllto (& mut self) -> DPLLLTO_W { DPLLLTO_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflag](index.html) module"]
pub struct INTFLAG_SPEC ; impl crate :: RegisterSpec for INTFLAG_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [intflag::R](R) reader structure"]
impl crate :: Readable for INTFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflag::W](W) writer structure"]
impl crate :: Writable for INTFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTFLAG to value 0"]
impl crate :: Resettable for INTFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PCLKSR register accessor: an alias for `Reg<PCLKSR_SPEC>`"]
pub type PCLKSR = crate :: Reg < pclksr :: PCLKSR_SPEC > ; # [doc = "Power and Clocks Status"]
pub mod pclksr { # [doc = "Register `PCLKSR` reader"]
pub struct R (crate :: R < PCLKSR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PCLKSR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PCLKSR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PCLKSR_SPEC >) -> Self { R (reader) } } # [doc = "Field `XOSCRDY` reader - XOSC Ready"]
pub type XOSCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `XOSC32KRDY` reader - XOSC32K Ready"]
pub type XOSC32KRDY_R = crate :: BitReader < bool > ; # [doc = "Field `OSC32KRDY` reader - OSC32K Ready"]
pub type OSC32KRDY_R = crate :: BitReader < bool > ; # [doc = "Field `OSC8MRDY` reader - OSC8M Ready"]
pub type OSC8MRDY_R = crate :: BitReader < bool > ; # [doc = "Field `DFLLRDY` reader - DFLL Ready"]
pub type DFLLRDY_R = crate :: BitReader < bool > ; # [doc = "Field `DFLLOOB` reader - DFLL Out Of Bounds"]
pub type DFLLOOB_R = crate :: BitReader < bool > ; # [doc = "Field `DFLLLCKF` reader - DFLL Lock Fine"]
pub type DFLLLCKF_R = crate :: BitReader < bool > ; # [doc = "Field `DFLLLCKC` reader - DFLL Lock Coarse"]
pub type DFLLLCKC_R = crate :: BitReader < bool > ; # [doc = "Field `DFLLRCS` reader - DFLL Reference Clock Stopped"]
pub type DFLLRCS_R = crate :: BitReader < bool > ; # [doc = "Field `BOD33RDY` reader - BOD33 Ready"]
pub type BOD33RDY_R = crate :: BitReader < bool > ; # [doc = "Field `BOD33DET` reader - BOD33 Detection"]
pub type BOD33DET_R = crate :: BitReader < bool > ; # [doc = "Field `B33SRDY` reader - BOD33 Synchronization Ready"]
pub type B33SRDY_R = crate :: BitReader < bool > ; # [doc = "Field `DPLLLCKR` reader - DPLL Lock Rise"]
pub type DPLLLCKR_R = crate :: BitReader < bool > ; # [doc = "Field `DPLLLCKF` reader - DPLL Lock Fall"]
pub type DPLLLCKF_R = crate :: BitReader < bool > ; # [doc = "Field `DPLLLTO` reader - DPLL Lock Timeout"]
pub type DPLLLTO_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - XOSC Ready"]
# [inline (always)]
pub fn xoscrdy (& self) -> XOSCRDY_R { XOSCRDY_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - XOSC32K Ready"]
# [inline (always)]
pub fn xosc32krdy (& self) -> XOSC32KRDY_R { XOSC32KRDY_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - OSC32K Ready"]
# [inline (always)]
pub fn osc32krdy (& self) -> OSC32KRDY_R { OSC32KRDY_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - OSC8M Ready"]
# [inline (always)]
pub fn osc8mrdy (& self) -> OSC8MRDY_R { OSC8MRDY_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - DFLL Ready"]
# [inline (always)]
pub fn dfllrdy (& self) -> DFLLRDY_R { DFLLRDY_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - DFLL Out Of Bounds"]
# [inline (always)]
pub fn dflloob (& self) -> DFLLOOB_R { DFLLOOB_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - DFLL Lock Fine"]
# [inline (always)]
pub fn dflllckf (& self) -> DFLLLCKF_R { DFLLLCKF_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - DFLL Lock Coarse"]
# [inline (always)]
pub fn dflllckc (& self) -> DFLLLCKC_R { DFLLLCKC_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - DFLL Reference Clock Stopped"]
# [inline (always)]
pub fn dfllrcs (& self) -> DFLLRCS_R { DFLLRCS_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - BOD33 Ready"]
# [inline (always)]
pub fn bod33rdy (& self) -> BOD33RDY_R { BOD33RDY_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - BOD33 Detection"]
# [inline (always)]
pub fn bod33det (& self) -> BOD33DET_R { BOD33DET_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - BOD33 Synchronization Ready"]
# [inline (always)]
pub fn b33srdy (& self) -> B33SRDY_R { B33SRDY_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 15 - DPLL Lock Rise"]
# [inline (always)]
pub fn dplllckr (& self) -> DPLLLCKR_R { DPLLLCKR_R :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - DPLL Lock Fall"]
# [inline (always)]
pub fn dplllckf (& self) -> DPLLLCKF_R { DPLLLCKF_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - DPLL Lock Timeout"]
# [inline (always)]
pub fn dplllto (& self) -> DPLLLTO_R { DPLLLTO_R :: new (((self . bits >> 17) & 1) != 0) } } # [doc = "Power and Clocks Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pclksr](index.html) module"]
pub struct PCLKSR_SPEC ; impl crate :: RegisterSpec for PCLKSR_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [pclksr::R](R) reader structure"]
impl crate :: Readable for PCLKSR_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PCLKSR to value 0"]
impl crate :: Resettable for PCLKSR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "XOSC register accessor: an alias for `Reg<XOSC_SPEC>`"]
pub type XOSC = crate :: Reg < xosc :: XOSC_SPEC > ; # [doc = "External Multipurpose Crystal Oscillator (XOSC) Control"]
pub mod xosc { # [doc = "Register `XOSC` reader"]
pub struct R (crate :: R < XOSC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < XOSC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < XOSC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < XOSC_SPEC >) -> Self { R (reader) } } # [doc = "Register `XOSC` writer"]
pub struct W (crate :: W < XOSC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < XOSC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < XOSC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < XOSC_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Oscillator Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Oscillator Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u16 , XOSC_SPEC , bool , 1 > ; # [doc = "Field `XTALEN` reader - Crystal Oscillator Enable"]
pub type XTALEN_R = crate :: BitReader < bool > ; # [doc = "Field `XTALEN` writer - Crystal Oscillator Enable"]
pub type XTALEN_W < 'a > = crate :: BitWriter < 'a , u16 , XOSC_SPEC , bool , 2 > ; # [doc = "Field `RUNSTDBY` reader - Run in Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run in Standby"]
pub type RUNSTDBY_W < 'a > = crate :: BitWriter < 'a , u16 , XOSC_SPEC , bool , 6 > ; # [doc = "Field `ONDEMAND` reader - On Demand Control"]
pub type ONDEMAND_R = crate :: BitReader < bool > ; # [doc = "Field `ONDEMAND` writer - On Demand Control"]
pub type ONDEMAND_W < 'a > = crate :: BitWriter < 'a , u16 , XOSC_SPEC , bool , 7 > ; # [doc = "Oscillator Gain\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum GAIN_A { # [doc = "0: 2MHz"]
_0 = 0 , # [doc = "1: 4MHz"]
_1 = 1 , # [doc = "2: 8MHz"]
_2 = 2 , # [doc = "3: 16MHz"]
_3 = 3 , # [doc = "4: 30MHz"]
_4 = 4 , } impl From < GAIN_A > for u8 { # [inline (always)]
fn from (variant : GAIN_A) -> Self { variant as _ } } # [doc = "Field `GAIN` reader - Oscillator Gain"]
pub type GAIN_R = crate :: FieldReader < u8 , GAIN_A > ; impl GAIN_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < GAIN_A > { match self . bits { 0 => Some (GAIN_A :: _0) , 1 => Some (GAIN_A :: _1) , 2 => Some (GAIN_A :: _2) , 3 => Some (GAIN_A :: _3) , 4 => Some (GAIN_A :: _4) , _ => None , } } # [doc = "Checks if the value of the field is `_0`"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == GAIN_A :: _0 } # [doc = "Checks if the value of the field is `_1`"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == GAIN_A :: _1 } # [doc = "Checks if the value of the field is `_2`"]
# [inline (always)]
pub fn is_2 (& self) -> bool { * self == GAIN_A :: _2 } # [doc = "Checks if the value of the field is `_3`"]
# [inline (always)]
pub fn is_3 (& self) -> bool { * self == GAIN_A :: _3 } # [doc = "Checks if the value of the field is `_4`"]
# [inline (always)]
pub fn is_4 (& self) -> bool { * self == GAIN_A :: _4 } } # [doc = "Field `GAIN` writer - Oscillator Gain"]
pub type GAIN_W < 'a > = crate :: FieldWriter < 'a , u16 , XOSC_SPEC , u8 , GAIN_A , 3 , 8 > ; impl < 'a > GAIN_W < 'a > { # [doc = "2MHz"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut W { self . variant (GAIN_A :: _0) } # [doc = "4MHz"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut W { self . variant (GAIN_A :: _1) } # [doc = "8MHz"]
# [inline (always)]
pub fn _2 (self) -> & 'a mut W { self . variant (GAIN_A :: _2) } # [doc = "16MHz"]
# [inline (always)]
pub fn _3 (self) -> & 'a mut W { self . variant (GAIN_A :: _3) } # [doc = "30MHz"]
# [inline (always)]
pub fn _4 (self) -> & 'a mut W { self . variant (GAIN_A :: _4) } } # [doc = "Field `AMPGC` reader - Automatic Amplitude Gain Control"]
pub type AMPGC_R = crate :: BitReader < bool > ; # [doc = "Field `AMPGC` writer - Automatic Amplitude Gain Control"]
pub type AMPGC_W < 'a > = crate :: BitWriter < 'a , u16 , XOSC_SPEC , bool , 11 > ; # [doc = "Field `STARTUP` reader - Start-Up Time"]
pub type STARTUP_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `STARTUP` writer - Start-Up Time"]
pub type STARTUP_W < 'a > = crate :: FieldWriter < 'a , u16 , XOSC_SPEC , u8 , u8 , 4 , 12 > ; impl R { # [doc = "Bit 1 - Oscillator Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Crystal Oscillator Enable"]
# [inline (always)]
pub fn xtalen (& self) -> XTALEN_R { XTALEN_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 6 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - On Demand Control"]
# [inline (always)]
pub fn ondemand (& self) -> ONDEMAND_R { ONDEMAND_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bits 8:10 - Oscillator Gain"]
# [inline (always)]
pub fn gain (& self) -> GAIN_R { GAIN_R :: new (((self . bits >> 8) & 7) as u8) } # [doc = "Bit 11 - Automatic Amplitude Gain Control"]
# [inline (always)]
pub fn ampgc (& self) -> AMPGC_R { AMPGC_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bits 12:15 - Start-Up Time"]
# [inline (always)]
pub fn startup (& self) -> STARTUP_R { STARTUP_R :: new (((self . bits >> 12) & 0x0f) as u8) } } impl W { # [doc = "Bit 1 - Oscillator Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Bit 2 - Crystal Oscillator Enable"]
# [inline (always)]
pub fn xtalen (& mut self) -> XTALEN_W { XTALEN_W :: new (self) } # [doc = "Bit 6 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& mut self) -> RUNSTDBY_W { RUNSTDBY_W :: new (self) } # [doc = "Bit 7 - On Demand Control"]
# [inline (always)]
pub fn ondemand (& mut self) -> ONDEMAND_W { ONDEMAND_W :: new (self) } # [doc = "Bits 8:10 - Oscillator Gain"]
# [inline (always)]
pub fn gain (& mut self) -> GAIN_W { GAIN_W :: new (self) } # [doc = "Bit 11 - Automatic Amplitude Gain Control"]
# [inline (always)]
pub fn ampgc (& mut self) -> AMPGC_W { AMPGC_W :: new (self) } # [doc = "Bits 12:15 - Start-Up Time"]
# [inline (always)]
pub fn startup (& mut self) -> STARTUP_W { STARTUP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "External Multipurpose Crystal Oscillator (XOSC) Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xosc](index.html) module"]
pub struct XOSC_SPEC ; impl crate :: RegisterSpec for XOSC_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [xosc::R](R) reader structure"]
impl crate :: Readable for XOSC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [xosc::W](W) writer structure"]
impl crate :: Writable for XOSC_SPEC { type Writer = W ; } # [doc = "`reset()` method sets XOSC to value 0x80"]
impl crate :: Resettable for XOSC_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x80 } } } # [doc = "XOSC32K register accessor: an alias for `Reg<XOSC32K_SPEC>`"]
pub type XOSC32K = crate :: Reg < xosc32k :: XOSC32K_SPEC > ; # [doc = "32kHz External Crystal Oscillator (XOSC32K) Control"]
pub mod xosc32k { # [doc = "Register `XOSC32K` reader"]
pub struct R (crate :: R < XOSC32K_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < XOSC32K_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < XOSC32K_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < XOSC32K_SPEC >) -> Self { R (reader) } } # [doc = "Register `XOSC32K` writer"]
pub struct W (crate :: W < XOSC32K_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < XOSC32K_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < XOSC32K_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < XOSC32K_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Oscillator Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Oscillator Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u16 , XOSC32K_SPEC , bool , 1 > ; # [doc = "Field `XTALEN` reader - Crystal Oscillator Enable"]
pub type XTALEN_R = crate :: BitReader < bool > ; # [doc = "Field `XTALEN` writer - Crystal Oscillator Enable"]
pub type XTALEN_W < 'a > = crate :: BitWriter < 'a , u16 , XOSC32K_SPEC , bool , 2 > ; # [doc = "Field `EN32K` reader - 32kHz Output Enable"]
pub type EN32K_R = crate :: BitReader < bool > ; # [doc = "Field `EN32K` writer - 32kHz Output Enable"]
pub type EN32K_W < 'a > = crate :: BitWriter < 'a , u16 , XOSC32K_SPEC , bool , 3 > ; # [doc = "Field `EN1K` reader - 1kHz Output Enable"]
pub type EN1K_R = crate :: BitReader < bool > ; # [doc = "Field `EN1K` writer - 1kHz Output Enable"]
pub type EN1K_W < 'a > = crate :: BitWriter < 'a , u16 , XOSC32K_SPEC , bool , 4 > ; # [doc = "Field `AAMPEN` reader - Automatic Amplitude Control Enable"]
pub type AAMPEN_R = crate :: BitReader < bool > ; # [doc = "Field `AAMPEN` writer - Automatic Amplitude Control Enable"]
pub type AAMPEN_W < 'a > = crate :: BitWriter < 'a , u16 , XOSC32K_SPEC , bool , 5 > ; # [doc = "Field `RUNSTDBY` reader - Run in Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run in Standby"]
pub type RUNSTDBY_W < 'a > = crate :: BitWriter < 'a , u16 , XOSC32K_SPEC , bool , 6 > ; # [doc = "Field `ONDEMAND` reader - On Demand Control"]
pub type ONDEMAND_R = crate :: BitReader < bool > ; # [doc = "Field `ONDEMAND` writer - On Demand Control"]
pub type ONDEMAND_W < 'a > = crate :: BitWriter < 'a , u16 , XOSC32K_SPEC , bool , 7 > ; # [doc = "Field `STARTUP` reader - Oscillator Start-Up Time"]
pub type STARTUP_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `STARTUP` writer - Oscillator Start-Up Time"]
pub type STARTUP_W < 'a > = crate :: FieldWriter < 'a , u16 , XOSC32K_SPEC , u8 , u8 , 3 , 8 > ; # [doc = "Field `WRTLOCK` reader - Write Lock"]
pub type WRTLOCK_R = crate :: BitReader < bool > ; # [doc = "Field `WRTLOCK` writer - Write Lock"]
pub type WRTLOCK_W < 'a > = crate :: BitWriter < 'a , u16 , XOSC32K_SPEC , bool , 12 > ; impl R { # [doc = "Bit 1 - Oscillator Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Crystal Oscillator Enable"]
# [inline (always)]
pub fn xtalen (& self) -> XTALEN_R { XTALEN_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - 32kHz Output Enable"]
# [inline (always)]
pub fn en32k (& self) -> EN32K_R { EN32K_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - 1kHz Output Enable"]
# [inline (always)]
pub fn en1k (& self) -> EN1K_R { EN1K_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Automatic Amplitude Control Enable"]
# [inline (always)]
pub fn aampen (& self) -> AAMPEN_R { AAMPEN_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - On Demand Control"]
# [inline (always)]
pub fn ondemand (& self) -> ONDEMAND_R { ONDEMAND_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bits 8:10 - Oscillator Start-Up Time"]
# [inline (always)]
pub fn startup (& self) -> STARTUP_R { STARTUP_R :: new (((self . bits >> 8) & 7) as u8) } # [doc = "Bit 12 - Write Lock"]
# [inline (always)]
pub fn wrtlock (& self) -> WRTLOCK_R { WRTLOCK_R :: new (((self . bits >> 12) & 1) != 0) } } impl W { # [doc = "Bit 1 - Oscillator Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Bit 2 - Crystal Oscillator Enable"]
# [inline (always)]
pub fn xtalen (& mut self) -> XTALEN_W { XTALEN_W :: new (self) } # [doc = "Bit 3 - 32kHz Output Enable"]
# [inline (always)]
pub fn en32k (& mut self) -> EN32K_W { EN32K_W :: new (self) } # [doc = "Bit 4 - 1kHz Output Enable"]
# [inline (always)]
pub fn en1k (& mut self) -> EN1K_W { EN1K_W :: new (self) } # [doc = "Bit 5 - Automatic Amplitude Control Enable"]
# [inline (always)]
pub fn aampen (& mut self) -> AAMPEN_W { AAMPEN_W :: new (self) } # [doc = "Bit 6 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& mut self) -> RUNSTDBY_W { RUNSTDBY_W :: new (self) } # [doc = "Bit 7 - On Demand Control"]
# [inline (always)]
pub fn ondemand (& mut self) -> ONDEMAND_W { ONDEMAND_W :: new (self) } # [doc = "Bits 8:10 - Oscillator Start-Up Time"]
# [inline (always)]
pub fn startup (& mut self) -> STARTUP_W { STARTUP_W :: new (self) } # [doc = "Bit 12 - Write Lock"]
# [inline (always)]
pub fn wrtlock (& mut self) -> WRTLOCK_W { WRTLOCK_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "32kHz External Crystal Oscillator (XOSC32K) Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xosc32k](index.html) module"]
pub struct XOSC32K_SPEC ; impl crate :: RegisterSpec for XOSC32K_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [xosc32k::R](R) reader structure"]
impl crate :: Readable for XOSC32K_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [xosc32k::W](W) writer structure"]
impl crate :: Writable for XOSC32K_SPEC { type Writer = W ; } # [doc = "`reset()` method sets XOSC32K to value 0x80"]
impl crate :: Resettable for XOSC32K_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x80 } } } # [doc = "OSC32K register accessor: an alias for `Reg<OSC32K_SPEC>`"]
pub type OSC32K = crate :: Reg < osc32k :: OSC32K_SPEC > ; # [doc = "32kHz Internal Oscillator (OSC32K) Control"]
pub mod osc32k { # [doc = "Register `OSC32K` reader"]
pub struct R (crate :: R < OSC32K_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSC32K_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSC32K_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSC32K_SPEC >) -> Self { R (reader) } } # [doc = "Register `OSC32K` writer"]
pub struct W (crate :: W < OSC32K_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OSC32K_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OSC32K_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OSC32K_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Oscillator Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Oscillator Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u32 , OSC32K_SPEC , bool , 1 > ; # [doc = "Field `EN32K` reader - 32kHz Output Enable"]
pub type EN32K_R = crate :: BitReader < bool > ; # [doc = "Field `EN32K` writer - 32kHz Output Enable"]
pub type EN32K_W < 'a > = crate :: BitWriter < 'a , u32 , OSC32K_SPEC , bool , 2 > ; # [doc = "Field `EN1K` reader - 1kHz Output Enable"]
pub type EN1K_R = crate :: BitReader < bool > ; # [doc = "Field `EN1K` writer - 1kHz Output Enable"]
pub type EN1K_W < 'a > = crate :: BitWriter < 'a , u32 , OSC32K_SPEC , bool , 3 > ; # [doc = "Field `RUNSTDBY` reader - Run in Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run in Standby"]
pub type RUNSTDBY_W < 'a > = crate :: BitWriter < 'a , u32 , OSC32K_SPEC , bool , 6 > ; # [doc = "Field `ONDEMAND` reader - On Demand Control"]
pub type ONDEMAND_R = crate :: BitReader < bool > ; # [doc = "Field `ONDEMAND` writer - On Demand Control"]
pub type ONDEMAND_W < 'a > = crate :: BitWriter < 'a , u32 , OSC32K_SPEC , bool , 7 > ; # [doc = "Field `STARTUP` reader - Oscillator Start-Up Time"]
pub type STARTUP_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `STARTUP` writer - Oscillator Start-Up Time"]
pub type STARTUP_W < 'a > = crate :: FieldWriter < 'a , u32 , OSC32K_SPEC , u8 , u8 , 3 , 8 > ; # [doc = "Field `WRTLOCK` reader - Write Lock"]
pub type WRTLOCK_R = crate :: BitReader < bool > ; # [doc = "Field `WRTLOCK` writer - Write Lock"]
pub type WRTLOCK_W < 'a > = crate :: BitWriter < 'a , u32 , OSC32K_SPEC , bool , 12 > ; # [doc = "Field `CALIB` reader - Oscillator Calibration"]
pub type CALIB_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CALIB` writer - Oscillator Calibration"]
pub type CALIB_W < 'a > = crate :: FieldWriter < 'a , u32 , OSC32K_SPEC , u8 , u8 , 7 , 16 > ; impl R { # [doc = "Bit 1 - Oscillator Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - 32kHz Output Enable"]
# [inline (always)]
pub fn en32k (& self) -> EN32K_R { EN32K_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - 1kHz Output Enable"]
# [inline (always)]
pub fn en1k (& self) -> EN1K_R { EN1K_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 6 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - On Demand Control"]
# [inline (always)]
pub fn ondemand (& self) -> ONDEMAND_R { ONDEMAND_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bits 8:10 - Oscillator Start-Up Time"]
# [inline (always)]
pub fn startup (& self) -> STARTUP_R { STARTUP_R :: new (((self . bits >> 8) & 7) as u8) } # [doc = "Bit 12 - Write Lock"]
# [inline (always)]
pub fn wrtlock (& self) -> WRTLOCK_R { WRTLOCK_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bits 16:22 - Oscillator Calibration"]
# [inline (always)]
pub fn calib (& self) -> CALIB_R { CALIB_R :: new (((self . bits >> 16) & 0x7f) as u8) } } impl W { # [doc = "Bit 1 - Oscillator Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Bit 2 - 32kHz Output Enable"]
# [inline (always)]
pub fn en32k (& mut self) -> EN32K_W { EN32K_W :: new (self) } # [doc = "Bit 3 - 1kHz Output Enable"]
# [inline (always)]
pub fn en1k (& mut self) -> EN1K_W { EN1K_W :: new (self) } # [doc = "Bit 6 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& mut self) -> RUNSTDBY_W { RUNSTDBY_W :: new (self) } # [doc = "Bit 7 - On Demand Control"]
# [inline (always)]
pub fn ondemand (& mut self) -> ONDEMAND_W { ONDEMAND_W :: new (self) } # [doc = "Bits 8:10 - Oscillator Start-Up Time"]
# [inline (always)]
pub fn startup (& mut self) -> STARTUP_W { STARTUP_W :: new (self) } # [doc = "Bit 12 - Write Lock"]
# [inline (always)]
pub fn wrtlock (& mut self) -> WRTLOCK_W { WRTLOCK_W :: new (self) } # [doc = "Bits 16:22 - Oscillator Calibration"]
# [inline (always)]
pub fn calib (& mut self) -> CALIB_W { CALIB_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "32kHz Internal Oscillator (OSC32K) Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osc32k](index.html) module"]
pub struct OSC32K_SPEC ; impl crate :: RegisterSpec for OSC32K_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [osc32k::R](R) reader structure"]
impl crate :: Readable for OSC32K_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [osc32k::W](W) writer structure"]
impl crate :: Writable for OSC32K_SPEC { type Writer = W ; } # [doc = "`reset()` method sets OSC32K to value 0x003f_0080"]
impl crate :: Resettable for OSC32K_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x003f_0080 } } } # [doc = "OSCULP32K register accessor: an alias for `Reg<OSCULP32K_SPEC>`"]
pub type OSCULP32K = crate :: Reg < osculp32k :: OSCULP32K_SPEC > ; # [doc = "32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control"]
pub mod osculp32k { # [doc = "Register `OSCULP32K` reader"]
pub struct R (crate :: R < OSCULP32K_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSCULP32K_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSCULP32K_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSCULP32K_SPEC >) -> Self { R (reader) } } # [doc = "Register `OSCULP32K` writer"]
pub struct W (crate :: W < OSCULP32K_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OSCULP32K_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OSCULP32K_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OSCULP32K_SPEC >) -> Self { W (writer) } } # [doc = "Field `CALIB` reader - Oscillator Calibration"]
pub type CALIB_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CALIB` writer - Oscillator Calibration"]
pub type CALIB_W < 'a > = crate :: FieldWriter < 'a , u8 , OSCULP32K_SPEC , u8 , u8 , 5 , 0 > ; # [doc = "Field `WRTLOCK` reader - Write Lock"]
pub type WRTLOCK_R = crate :: BitReader < bool > ; # [doc = "Field `WRTLOCK` writer - Write Lock"]
pub type WRTLOCK_W < 'a > = crate :: BitWriter < 'a , u8 , OSCULP32K_SPEC , bool , 7 > ; impl R { # [doc = "Bits 0:4 - Oscillator Calibration"]
# [inline (always)]
pub fn calib (& self) -> CALIB_R { CALIB_R :: new ((self . bits & 0x1f) as u8) } # [doc = "Bit 7 - Write Lock"]
# [inline (always)]
pub fn wrtlock (& self) -> WRTLOCK_R { WRTLOCK_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:4 - Oscillator Calibration"]
# [inline (always)]
pub fn calib (& mut self) -> CALIB_W { CALIB_W :: new (self) } # [doc = "Bit 7 - Write Lock"]
# [inline (always)]
pub fn wrtlock (& mut self) -> WRTLOCK_W { WRTLOCK_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osculp32k](index.html) module"]
pub struct OSCULP32K_SPEC ; impl crate :: RegisterSpec for OSCULP32K_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [osculp32k::R](R) reader structure"]
impl crate :: Readable for OSCULP32K_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [osculp32k::W](W) writer structure"]
impl crate :: Writable for OSCULP32K_SPEC { type Writer = W ; } # [doc = "`reset()` method sets OSCULP32K to value 0x1f"]
impl crate :: Resettable for OSCULP32K_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x1f } } } # [doc = "OSC8M register accessor: an alias for `Reg<OSC8M_SPEC>`"]
pub type OSC8M = crate :: Reg < osc8m :: OSC8M_SPEC > ; # [doc = "8MHz Internal Oscillator (OSC8M) Control"]
pub mod osc8m { # [doc = "Register `OSC8M` reader"]
pub struct R (crate :: R < OSC8M_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < OSC8M_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < OSC8M_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < OSC8M_SPEC >) -> Self { R (reader) } } # [doc = "Register `OSC8M` writer"]
pub struct W (crate :: W < OSC8M_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < OSC8M_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < OSC8M_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < OSC8M_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Oscillator Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Oscillator Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u32 , OSC8M_SPEC , bool , 1 > ; # [doc = "Field `RUNSTDBY` reader - Run in Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run in Standby"]
pub type RUNSTDBY_W < 'a > = crate :: BitWriter < 'a , u32 , OSC8M_SPEC , bool , 6 > ; # [doc = "Field `ONDEMAND` reader - On Demand Control"]
pub type ONDEMAND_R = crate :: BitReader < bool > ; # [doc = "Field `ONDEMAND` writer - On Demand Control"]
pub type ONDEMAND_W < 'a > = crate :: BitWriter < 'a , u32 , OSC8M_SPEC , bool , 7 > ; # [doc = "Oscillator Prescaler\n\nValue on reset: 3"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum PRESC_A { # [doc = "0: 1"]
_0 = 0 , # [doc = "1: 2"]
_1 = 1 , # [doc = "2: 4"]
_2 = 2 , # [doc = "3: 8"]
_3 = 3 , } impl From < PRESC_A > for u8 { # [inline (always)]
fn from (variant : PRESC_A) -> Self { variant as _ } } # [doc = "Field `PRESC` reader - Oscillator Prescaler"]
pub type PRESC_R = crate :: FieldReader < u8 , PRESC_A > ; impl PRESC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PRESC_A { match self . bits { 0 => PRESC_A :: _0 , 1 => PRESC_A :: _1 , 2 => PRESC_A :: _2 , 3 => PRESC_A :: _3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_0`"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == PRESC_A :: _0 } # [doc = "Checks if the value of the field is `_1`"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == PRESC_A :: _1 } # [doc = "Checks if the value of the field is `_2`"]
# [inline (always)]
pub fn is_2 (& self) -> bool { * self == PRESC_A :: _2 } # [doc = "Checks if the value of the field is `_3`"]
# [inline (always)]
pub fn is_3 (& self) -> bool { * self == PRESC_A :: _3 } } # [doc = "Field `PRESC` writer - Oscillator Prescaler"]
pub type PRESC_W < 'a > = crate :: FieldWriterSafe < 'a , u32 , OSC8M_SPEC , u8 , PRESC_A , 2 , 8 > ; impl < 'a > PRESC_W < 'a > { # [doc = "1"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut W { self . variant (PRESC_A :: _0) } # [doc = "2"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut W { self . variant (PRESC_A :: _1) } # [doc = "4"]
# [inline (always)]
pub fn _2 (self) -> & 'a mut W { self . variant (PRESC_A :: _2) } # [doc = "8"]
# [inline (always)]
pub fn _3 (self) -> & 'a mut W { self . variant (PRESC_A :: _3) } } # [doc = "Field `CALIB` reader - Oscillator Calibration"]
pub type CALIB_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `CALIB` writer - Oscillator Calibration"]
pub type CALIB_W < 'a > = crate :: FieldWriter < 'a , u32 , OSC8M_SPEC , u16 , u16 , 12 , 16 > ; # [doc = "Oscillator Frequency Range\n\nValue on reset: 2"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum FRANGE_A { # [doc = "0: 4 to 6MHz"]
_0 = 0 , # [doc = "1: 6 to 8MHz"]
_1 = 1 , # [doc = "2: 8 to 11MHz"]
_2 = 2 , # [doc = "3: 11 to 15MHz"]
_3 = 3 , } impl From < FRANGE_A > for u8 { # [inline (always)]
fn from (variant : FRANGE_A) -> Self { variant as _ } } # [doc = "Field `FRANGE` reader - Oscillator Frequency Range"]
pub type FRANGE_R = crate :: FieldReader < u8 , FRANGE_A > ; impl FRANGE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> FRANGE_A { match self . bits { 0 => FRANGE_A :: _0 , 1 => FRANGE_A :: _1 , 2 => FRANGE_A :: _2 , 3 => FRANGE_A :: _3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `_0`"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == FRANGE_A :: _0 } # [doc = "Checks if the value of the field is `_1`"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == FRANGE_A :: _1 } # [doc = "Checks if the value of the field is `_2`"]
# [inline (always)]
pub fn is_2 (& self) -> bool { * self == FRANGE_A :: _2 } # [doc = "Checks if the value of the field is `_3`"]
# [inline (always)]
pub fn is_3 (& self) -> bool { * self == FRANGE_A :: _3 } } # [doc = "Field `FRANGE` writer - Oscillator Frequency Range"]
pub type FRANGE_W < 'a > = crate :: FieldWriterSafe < 'a , u32 , OSC8M_SPEC , u8 , FRANGE_A , 2 , 30 > ; impl < 'a > FRANGE_W < 'a > { # [doc = "4 to 6MHz"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut W { self . variant (FRANGE_A :: _0) } # [doc = "6 to 8MHz"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut W { self . variant (FRANGE_A :: _1) } # [doc = "8 to 11MHz"]
# [inline (always)]
pub fn _2 (self) -> & 'a mut W { self . variant (FRANGE_A :: _2) } # [doc = "11 to 15MHz"]
# [inline (always)]
pub fn _3 (self) -> & 'a mut W { self . variant (FRANGE_A :: _3) } } impl R { # [doc = "Bit 1 - Oscillator Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 6 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - On Demand Control"]
# [inline (always)]
pub fn ondemand (& self) -> ONDEMAND_R { ONDEMAND_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bits 8:9 - Oscillator Prescaler"]
# [inline (always)]
pub fn presc (& self) -> PRESC_R { PRESC_R :: new (((self . bits >> 8) & 3) as u8) } # [doc = "Bits 16:27 - Oscillator Calibration"]
# [inline (always)]
pub fn calib (& self) -> CALIB_R { CALIB_R :: new (((self . bits >> 16) & 0x0fff) as u16) } # [doc = "Bits 30:31 - Oscillator Frequency Range"]
# [inline (always)]
pub fn frange (& self) -> FRANGE_R { FRANGE_R :: new (((self . bits >> 30) & 3) as u8) } } impl W { # [doc = "Bit 1 - Oscillator Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Bit 6 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& mut self) -> RUNSTDBY_W { RUNSTDBY_W :: new (self) } # [doc = "Bit 7 - On Demand Control"]
# [inline (always)]
pub fn ondemand (& mut self) -> ONDEMAND_W { ONDEMAND_W :: new (self) } # [doc = "Bits 8:9 - Oscillator Prescaler"]
# [inline (always)]
pub fn presc (& mut self) -> PRESC_W { PRESC_W :: new (self) } # [doc = "Bits 16:27 - Oscillator Calibration"]
# [inline (always)]
pub fn calib (& mut self) -> CALIB_W { CALIB_W :: new (self) } # [doc = "Bits 30:31 - Oscillator Frequency Range"]
# [inline (always)]
pub fn frange (& mut self) -> FRANGE_W { FRANGE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "8MHz Internal Oscillator (OSC8M) Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [osc8m](index.html) module"]
pub struct OSC8M_SPEC ; impl crate :: RegisterSpec for OSC8M_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [osc8m::R](R) reader structure"]
impl crate :: Readable for OSC8M_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [osc8m::W](W) writer structure"]
impl crate :: Writable for OSC8M_SPEC { type Writer = W ; } # [doc = "`reset()` method sets OSC8M to value 0x8707_0382"]
impl crate :: Resettable for OSC8M_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x8707_0382 } } } # [doc = "DFLLCTRL register accessor: an alias for `Reg<DFLLCTRL_SPEC>`"]
pub type DFLLCTRL = crate :: Reg < dfllctrl :: DFLLCTRL_SPEC > ; # [doc = "DFLL48M Control"]
pub mod dfllctrl { # [doc = "Register `DFLLCTRL` reader"]
pub struct R (crate :: R < DFLLCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DFLLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DFLLCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DFLLCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DFLLCTRL` writer"]
pub struct W (crate :: W < DFLLCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DFLLCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DFLLCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DFLLCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - DFLL Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - DFLL Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u16 , DFLLCTRL_SPEC , bool , 1 > ; # [doc = "Field `MODE` reader - Operating Mode Selection"]
pub type MODE_R = crate :: BitReader < bool > ; # [doc = "Field `MODE` writer - Operating Mode Selection"]
pub type MODE_W < 'a > = crate :: BitWriter < 'a , u16 , DFLLCTRL_SPEC , bool , 2 > ; # [doc = "Field `STABLE` reader - Stable DFLL Frequency"]
pub type STABLE_R = crate :: BitReader < bool > ; # [doc = "Field `STABLE` writer - Stable DFLL Frequency"]
pub type STABLE_W < 'a > = crate :: BitWriter < 'a , u16 , DFLLCTRL_SPEC , bool , 3 > ; # [doc = "Field `LLAW` reader - Lose Lock After Wake"]
pub type LLAW_R = crate :: BitReader < bool > ; # [doc = "Field `LLAW` writer - Lose Lock After Wake"]
pub type LLAW_W < 'a > = crate :: BitWriter < 'a , u16 , DFLLCTRL_SPEC , bool , 4 > ; # [doc = "Field `USBCRM` reader - USB Clock Recovery Mode"]
pub type USBCRM_R = crate :: BitReader < bool > ; # [doc = "Field `USBCRM` writer - USB Clock Recovery Mode"]
pub type USBCRM_W < 'a > = crate :: BitWriter < 'a , u16 , DFLLCTRL_SPEC , bool , 5 > ; # [doc = "Field `RUNSTDBY` reader - Run in Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run in Standby"]
pub type RUNSTDBY_W < 'a > = crate :: BitWriter < 'a , u16 , DFLLCTRL_SPEC , bool , 6 > ; # [doc = "Field `ONDEMAND` reader - On Demand Control"]
pub type ONDEMAND_R = crate :: BitReader < bool > ; # [doc = "Field `ONDEMAND` writer - On Demand Control"]
pub type ONDEMAND_W < 'a > = crate :: BitWriter < 'a , u16 , DFLLCTRL_SPEC , bool , 7 > ; # [doc = "Field `CCDIS` reader - Chill Cycle Disable"]
pub type CCDIS_R = crate :: BitReader < bool > ; # [doc = "Field `CCDIS` writer - Chill Cycle Disable"]
pub type CCDIS_W < 'a > = crate :: BitWriter < 'a , u16 , DFLLCTRL_SPEC , bool , 8 > ; # [doc = "Field `QLDIS` reader - Quick Lock Disable"]
pub type QLDIS_R = crate :: BitReader < bool > ; # [doc = "Field `QLDIS` writer - Quick Lock Disable"]
pub type QLDIS_W < 'a > = crate :: BitWriter < 'a , u16 , DFLLCTRL_SPEC , bool , 9 > ; # [doc = "Field `BPLCKC` reader - Bypass Coarse Lock"]
pub type BPLCKC_R = crate :: BitReader < bool > ; # [doc = "Field `BPLCKC` writer - Bypass Coarse Lock"]
pub type BPLCKC_W < 'a > = crate :: BitWriter < 'a , u16 , DFLLCTRL_SPEC , bool , 10 > ; # [doc = "Field `WAITLOCK` reader - Wait Lock"]
pub type WAITLOCK_R = crate :: BitReader < bool > ; # [doc = "Field `WAITLOCK` writer - Wait Lock"]
pub type WAITLOCK_W < 'a > = crate :: BitWriter < 'a , u16 , DFLLCTRL_SPEC , bool , 11 > ; impl R { # [doc = "Bit 1 - DFLL Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Operating Mode Selection"]
# [inline (always)]
pub fn mode (& self) -> MODE_R { MODE_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Stable DFLL Frequency"]
# [inline (always)]
pub fn stable (& self) -> STABLE_R { STABLE_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Lose Lock After Wake"]
# [inline (always)]
pub fn llaw (& self) -> LLAW_R { LLAW_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - USB Clock Recovery Mode"]
# [inline (always)]
pub fn usbcrm (& self) -> USBCRM_R { USBCRM_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - On Demand Control"]
# [inline (always)]
pub fn ondemand (& self) -> ONDEMAND_R { ONDEMAND_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Chill Cycle Disable"]
# [inline (always)]
pub fn ccdis (& self) -> CCDIS_R { CCDIS_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Quick Lock Disable"]
# [inline (always)]
pub fn qldis (& self) -> QLDIS_R { QLDIS_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Bypass Coarse Lock"]
# [inline (always)]
pub fn bplckc (& self) -> BPLCKC_R { BPLCKC_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Wait Lock"]
# [inline (always)]
pub fn waitlock (& self) -> WAITLOCK_R { WAITLOCK_R :: new (((self . bits >> 11) & 1) != 0) } } impl W { # [doc = "Bit 1 - DFLL Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Bit 2 - Operating Mode Selection"]
# [inline (always)]
pub fn mode (& mut self) -> MODE_W { MODE_W :: new (self) } # [doc = "Bit 3 - Stable DFLL Frequency"]
# [inline (always)]
pub fn stable (& mut self) -> STABLE_W { STABLE_W :: new (self) } # [doc = "Bit 4 - Lose Lock After Wake"]
# [inline (always)]
pub fn llaw (& mut self) -> LLAW_W { LLAW_W :: new (self) } # [doc = "Bit 5 - USB Clock Recovery Mode"]
# [inline (always)]
pub fn usbcrm (& mut self) -> USBCRM_W { USBCRM_W :: new (self) } # [doc = "Bit 6 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& mut self) -> RUNSTDBY_W { RUNSTDBY_W :: new (self) } # [doc = "Bit 7 - On Demand Control"]
# [inline (always)]
pub fn ondemand (& mut self) -> ONDEMAND_W { ONDEMAND_W :: new (self) } # [doc = "Bit 8 - Chill Cycle Disable"]
# [inline (always)]
pub fn ccdis (& mut self) -> CCDIS_W { CCDIS_W :: new (self) } # [doc = "Bit 9 - Quick Lock Disable"]
# [inline (always)]
pub fn qldis (& mut self) -> QLDIS_W { QLDIS_W :: new (self) } # [doc = "Bit 10 - Bypass Coarse Lock"]
# [inline (always)]
pub fn bplckc (& mut self) -> BPLCKC_W { BPLCKC_W :: new (self) } # [doc = "Bit 11 - Wait Lock"]
# [inline (always)]
pub fn waitlock (& mut self) -> WAITLOCK_W { WAITLOCK_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "DFLL48M Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dfllctrl](index.html) module"]
pub struct DFLLCTRL_SPEC ; impl crate :: RegisterSpec for DFLLCTRL_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [dfllctrl::R](R) reader structure"]
impl crate :: Readable for DFLLCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dfllctrl::W](W) writer structure"]
impl crate :: Writable for DFLLCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DFLLCTRL to value 0x80"]
impl crate :: Resettable for DFLLCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x80 } } } # [doc = "DFLLVAL register accessor: an alias for `Reg<DFLLVAL_SPEC>`"]
pub type DFLLVAL = crate :: Reg < dfllval :: DFLLVAL_SPEC > ; # [doc = "DFLL48M Value"]
pub mod dfllval { # [doc = "Register `DFLLVAL` reader"]
pub struct R (crate :: R < DFLLVAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DFLLVAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DFLLVAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DFLLVAL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DFLLVAL` writer"]
pub struct W (crate :: W < DFLLVAL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DFLLVAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DFLLVAL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DFLLVAL_SPEC >) -> Self { W (writer) } } # [doc = "Field `FINE` reader - Fine Value"]
pub type FINE_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `FINE` writer - Fine Value"]
pub type FINE_W < 'a > = crate :: FieldWriter < 'a , u32 , DFLLVAL_SPEC , u16 , u16 , 10 , 0 > ; # [doc = "Field `COARSE` reader - Coarse Value"]
pub type COARSE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `COARSE` writer - Coarse Value"]
pub type COARSE_W < 'a > = crate :: FieldWriter < 'a , u32 , DFLLVAL_SPEC , u8 , u8 , 6 , 10 > ; # [doc = "Field `DIFF` reader - Multiplication Ratio Difference"]
pub type DIFF_R = crate :: FieldReader < u16 , u16 > ; impl R { # [doc = "Bits 0:9 - Fine Value"]
# [inline (always)]
pub fn fine (& self) -> FINE_R { FINE_R :: new ((self . bits & 0x03ff) as u16) } # [doc = "Bits 10:15 - Coarse Value"]
# [inline (always)]
pub fn coarse (& self) -> COARSE_R { COARSE_R :: new (((self . bits >> 10) & 0x3f) as u8) } # [doc = "Bits 16:31 - Multiplication Ratio Difference"]
# [inline (always)]
pub fn diff (& self) -> DIFF_R { DIFF_R :: new (((self . bits >> 16) & 0xffff) as u16) } } impl W { # [doc = "Bits 0:9 - Fine Value"]
# [inline (always)]
pub fn fine (& mut self) -> FINE_W { FINE_W :: new (self) } # [doc = "Bits 10:15 - Coarse Value"]
# [inline (always)]
pub fn coarse (& mut self) -> COARSE_W { COARSE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "DFLL48M Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dfllval](index.html) module"]
pub struct DFLLVAL_SPEC ; impl crate :: RegisterSpec for DFLLVAL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [dfllval::R](R) reader structure"]
impl crate :: Readable for DFLLVAL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dfllval::W](W) writer structure"]
impl crate :: Writable for DFLLVAL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DFLLVAL to value 0"]
impl crate :: Resettable for DFLLVAL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DFLLMUL register accessor: an alias for `Reg<DFLLMUL_SPEC>`"]
pub type DFLLMUL = crate :: Reg < dfllmul :: DFLLMUL_SPEC > ; # [doc = "DFLL48M Multiplier"]
pub mod dfllmul { # [doc = "Register `DFLLMUL` reader"]
pub struct R (crate :: R < DFLLMUL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DFLLMUL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DFLLMUL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DFLLMUL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DFLLMUL` writer"]
pub struct W (crate :: W < DFLLMUL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DFLLMUL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DFLLMUL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DFLLMUL_SPEC >) -> Self { W (writer) } } # [doc = "Field `MUL` reader - DFLL Multiply Factor"]
pub type MUL_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `MUL` writer - DFLL Multiply Factor"]
pub type MUL_W < 'a > = crate :: FieldWriter < 'a , u32 , DFLLMUL_SPEC , u16 , u16 , 16 , 0 > ; # [doc = "Field `FSTEP` reader - Fine Maximum Step"]
pub type FSTEP_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `FSTEP` writer - Fine Maximum Step"]
pub type FSTEP_W < 'a > = crate :: FieldWriter < 'a , u32 , DFLLMUL_SPEC , u16 , u16 , 10 , 16 > ; # [doc = "Field `CSTEP` reader - Coarse Maximum Step"]
pub type CSTEP_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CSTEP` writer - Coarse Maximum Step"]
pub type CSTEP_W < 'a > = crate :: FieldWriter < 'a , u32 , DFLLMUL_SPEC , u8 , u8 , 6 , 26 > ; impl R { # [doc = "Bits 0:15 - DFLL Multiply Factor"]
# [inline (always)]
pub fn mul (& self) -> MUL_R { MUL_R :: new ((self . bits & 0xffff) as u16) } # [doc = "Bits 16:25 - Fine Maximum Step"]
# [inline (always)]
pub fn fstep (& self) -> FSTEP_R { FSTEP_R :: new (((self . bits >> 16) & 0x03ff) as u16) } # [doc = "Bits 26:31 - Coarse Maximum Step"]
# [inline (always)]
pub fn cstep (& self) -> CSTEP_R { CSTEP_R :: new (((self . bits >> 26) & 0x3f) as u8) } } impl W { # [doc = "Bits 0:15 - DFLL Multiply Factor"]
# [inline (always)]
pub fn mul (& mut self) -> MUL_W { MUL_W :: new (self) } # [doc = "Bits 16:25 - Fine Maximum Step"]
# [inline (always)]
pub fn fstep (& mut self) -> FSTEP_W { FSTEP_W :: new (self) } # [doc = "Bits 26:31 - Coarse Maximum Step"]
# [inline (always)]
pub fn cstep (& mut self) -> CSTEP_W { CSTEP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "DFLL48M Multiplier\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dfllmul](index.html) module"]
pub struct DFLLMUL_SPEC ; impl crate :: RegisterSpec for DFLLMUL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [dfllmul::R](R) reader structure"]
impl crate :: Readable for DFLLMUL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dfllmul::W](W) writer structure"]
impl crate :: Writable for DFLLMUL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DFLLMUL to value 0"]
impl crate :: Resettable for DFLLMUL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DFLLSYNC register accessor: an alias for `Reg<DFLLSYNC_SPEC>`"]
pub type DFLLSYNC = crate :: Reg < dfllsync :: DFLLSYNC_SPEC > ; # [doc = "DFLL48M Synchronization"]
pub mod dfllsync { # [doc = "Register `DFLLSYNC` reader"]
pub struct R (crate :: R < DFLLSYNC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DFLLSYNC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DFLLSYNC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DFLLSYNC_SPEC >) -> Self { R (reader) } } # [doc = "Register `DFLLSYNC` writer"]
pub struct W (crate :: W < DFLLSYNC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DFLLSYNC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DFLLSYNC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DFLLSYNC_SPEC >) -> Self { W (writer) } } # [doc = "Field `READREQ` writer - Read Request"]
pub type READREQ_W < 'a > = crate :: BitWriter < 'a , u8 , DFLLSYNC_SPEC , bool , 7 > ; impl W { # [doc = "Bit 7 - Read Request"]
# [inline (always)]
pub fn readreq (& mut self) -> READREQ_W { READREQ_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "DFLL48M Synchronization\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dfllsync](index.html) module"]
pub struct DFLLSYNC_SPEC ; impl crate :: RegisterSpec for DFLLSYNC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dfllsync::R](R) reader structure"]
impl crate :: Readable for DFLLSYNC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dfllsync::W](W) writer structure"]
impl crate :: Writable for DFLLSYNC_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DFLLSYNC to value 0"]
impl crate :: Resettable for DFLLSYNC_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "BOD33 register accessor: an alias for `Reg<BOD33_SPEC>`"]
pub type BOD33 = crate :: Reg < bod33 :: BOD33_SPEC > ; # [doc = "3.3V Brown-Out Detector (BOD33) Control"]
pub mod bod33 { # [doc = "Register `BOD33` reader"]
pub struct R (crate :: R < BOD33_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BOD33_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BOD33_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BOD33_SPEC >) -> Self { R (reader) } } # [doc = "Register `BOD33` writer"]
pub struct W (crate :: W < BOD33_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BOD33_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BOD33_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BOD33_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u32 , BOD33_SPEC , bool , 1 > ; # [doc = "Field `HYST` reader - Hysteresis"]
pub type HYST_R = crate :: BitReader < bool > ; # [doc = "Field `HYST` writer - Hysteresis"]
pub type HYST_W < 'a > = crate :: BitWriter < 'a , u32 , BOD33_SPEC , bool , 2 > ; # [doc = "BOD33 Action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum ACTION_A { # [doc = "0: No action"]
NONE = 0 , # [doc = "1: The BOD33 generates a reset"]
RESET = 1 , # [doc = "2: The BOD33 generates an interrupt"]
INTERRUPT = 2 , } impl From < ACTION_A > for u8 { # [inline (always)]
fn from (variant : ACTION_A) -> Self { variant as _ } } # [doc = "Field `ACTION` reader - BOD33 Action"]
pub type ACTION_R = crate :: FieldReader < u8 , ACTION_A > ; impl ACTION_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < ACTION_A > { match self . bits { 0 => Some (ACTION_A :: NONE) , 1 => Some (ACTION_A :: RESET) , 2 => Some (ACTION_A :: INTERRUPT) , _ => None , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == ACTION_A :: NONE } # [doc = "Checks if the value of the field is `RESET`"]
# [inline (always)]
pub fn is_reset (& self) -> bool { * self == ACTION_A :: RESET } # [doc = "Checks if the value of the field is `INTERRUPT`"]
# [inline (always)]
pub fn is_interrupt (& self) -> bool { * self == ACTION_A :: INTERRUPT } } # [doc = "Field `ACTION` writer - BOD33 Action"]
pub type ACTION_W < 'a > = crate :: FieldWriter < 'a , u32 , BOD33_SPEC , u8 , ACTION_A , 2 , 3 > ; impl < 'a > ACTION_W < 'a > { # [doc = "No action"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (ACTION_A :: NONE) } # [doc = "The BOD33 generates a reset"]
# [inline (always)]
pub fn reset (self) -> & 'a mut W { self . variant (ACTION_A :: RESET) } # [doc = "The BOD33 generates an interrupt"]
# [inline (always)]
pub fn interrupt (self) -> & 'a mut W { self . variant (ACTION_A :: INTERRUPT) } } # [doc = "Field `RUNSTDBY` reader - Run in Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run in Standby"]
pub type RUNSTDBY_W < 'a > = crate :: BitWriter < 'a , u32 , BOD33_SPEC , bool , 6 > ; # [doc = "Field `MODE` reader - Operation Mode"]
pub type MODE_R = crate :: BitReader < bool > ; # [doc = "Field `MODE` writer - Operation Mode"]
pub type MODE_W < 'a > = crate :: BitWriter < 'a , u32 , BOD33_SPEC , bool , 8 > ; # [doc = "Field `CEN` reader - Clock Enable"]
pub type CEN_R = crate :: BitReader < bool > ; # [doc = "Field `CEN` writer - Clock Enable"]
pub type CEN_W < 'a > = crate :: BitWriter < 'a , u32 , BOD33_SPEC , bool , 9 > ; # [doc = "Prescaler Select\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum PSEL_A { # [doc = "0: Divide clock by 2"]
DIV2 = 0 , # [doc = "1: Divide clock by 4"]
DIV4 = 1 , # [doc = "2: Divide clock by 8"]
DIV8 = 2 , # [doc = "3: Divide clock by 16"]
DIV16 = 3 , # [doc = "4: Divide clock by 32"]
DIV32 = 4 , # [doc = "5: Divide clock by 64"]
DIV64 = 5 , # [doc = "6: Divide clock by 128"]
DIV128 = 6 , # [doc = "7: Divide clock by 256"]
DIV256 = 7 , # [doc = "8: Divide clock by 512"]
DIV512 = 8 , # [doc = "9: Divide clock by 1024"]
DIV1K = 9 , # [doc = "10: Divide clock by 2048"]
DIV2K = 10 , # [doc = "11: Divide clock by 4096"]
DIV4K = 11 , # [doc = "12: Divide clock by 8192"]
DIV8K = 12 , # [doc = "13: Divide clock by 16384"]
DIV16K = 13 , # [doc = "14: Divide clock by 32768"]
DIV32K = 14 , # [doc = "15: Divide clock by 65536"]
DIV64K = 15 , } impl From < PSEL_A > for u8 { # [inline (always)]
fn from (variant : PSEL_A) -> Self { variant as _ } } # [doc = "Field `PSEL` reader - Prescaler Select"]
pub type PSEL_R = crate :: FieldReader < u8 , PSEL_A > ; impl PSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PSEL_A { match self . bits { 0 => PSEL_A :: DIV2 , 1 => PSEL_A :: DIV4 , 2 => PSEL_A :: DIV8 , 3 => PSEL_A :: DIV16 , 4 => PSEL_A :: DIV32 , 5 => PSEL_A :: DIV64 , 6 => PSEL_A :: DIV128 , 7 => PSEL_A :: DIV256 , 8 => PSEL_A :: DIV512 , 9 => PSEL_A :: DIV1K , 10 => PSEL_A :: DIV2K , 11 => PSEL_A :: DIV4K , 12 => PSEL_A :: DIV8K , 13 => PSEL_A :: DIV16K , 14 => PSEL_A :: DIV32K , 15 => PSEL_A :: DIV64K , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == PSEL_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == PSEL_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == PSEL_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == PSEL_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV32`"]
# [inline (always)]
pub fn is_div32 (& self) -> bool { * self == PSEL_A :: DIV32 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == PSEL_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV128`"]
# [inline (always)]
pub fn is_div128 (& self) -> bool { * self == PSEL_A :: DIV128 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == PSEL_A :: DIV256 } # [doc = "Checks if the value of the field is `DIV512`"]
# [inline (always)]
pub fn is_div512 (& self) -> bool { * self == PSEL_A :: DIV512 } # [doc = "Checks if the value of the field is `DIV1K`"]
# [inline (always)]
pub fn is_div1k (& self) -> bool { * self == PSEL_A :: DIV1K } # [doc = "Checks if the value of the field is `DIV2K`"]
# [inline (always)]
pub fn is_div2k (& self) -> bool { * self == PSEL_A :: DIV2K } # [doc = "Checks if the value of the field is `DIV4K`"]
# [inline (always)]
pub fn is_div4k (& self) -> bool { * self == PSEL_A :: DIV4K } # [doc = "Checks if the value of the field is `DIV8K`"]
# [inline (always)]
pub fn is_div8k (& self) -> bool { * self == PSEL_A :: DIV8K } # [doc = "Checks if the value of the field is `DIV16K`"]
# [inline (always)]
pub fn is_div16k (& self) -> bool { * self == PSEL_A :: DIV16K } # [doc = "Checks if the value of the field is `DIV32K`"]
# [inline (always)]
pub fn is_div32k (& self) -> bool { * self == PSEL_A :: DIV32K } # [doc = "Checks if the value of the field is `DIV64K`"]
# [inline (always)]
pub fn is_div64k (& self) -> bool { * self == PSEL_A :: DIV64K } } # [doc = "Field `PSEL` writer - Prescaler Select"]
pub type PSEL_W < 'a > = crate :: FieldWriterSafe < 'a , u32 , BOD33_SPEC , u8 , PSEL_A , 4 , 12 > ; impl < 'a > PSEL_W < 'a > { # [doc = "Divide clock by 2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (PSEL_A :: DIV2) } # [doc = "Divide clock by 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (PSEL_A :: DIV4) } # [doc = "Divide clock by 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (PSEL_A :: DIV8) } # [doc = "Divide clock by 16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (PSEL_A :: DIV16) } # [doc = "Divide clock by 32"]
# [inline (always)]
pub fn div32 (self) -> & 'a mut W { self . variant (PSEL_A :: DIV32) } # [doc = "Divide clock by 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (PSEL_A :: DIV64) } # [doc = "Divide clock by 128"]
# [inline (always)]
pub fn div128 (self) -> & 'a mut W { self . variant (PSEL_A :: DIV128) } # [doc = "Divide clock by 256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (PSEL_A :: DIV256) } # [doc = "Divide clock by 512"]
# [inline (always)]
pub fn div512 (self) -> & 'a mut W { self . variant (PSEL_A :: DIV512) } # [doc = "Divide clock by 1024"]
# [inline (always)]
pub fn div1k (self) -> & 'a mut W { self . variant (PSEL_A :: DIV1K) } # [doc = "Divide clock by 2048"]
# [inline (always)]
pub fn div2k (self) -> & 'a mut W { self . variant (PSEL_A :: DIV2K) } # [doc = "Divide clock by 4096"]
# [inline (always)]
pub fn div4k (self) -> & 'a mut W { self . variant (PSEL_A :: DIV4K) } # [doc = "Divide clock by 8192"]
# [inline (always)]
pub fn div8k (self) -> & 'a mut W { self . variant (PSEL_A :: DIV8K) } # [doc = "Divide clock by 16384"]
# [inline (always)]
pub fn div16k (self) -> & 'a mut W { self . variant (PSEL_A :: DIV16K) } # [doc = "Divide clock by 32768"]
# [inline (always)]
pub fn div32k (self) -> & 'a mut W { self . variant (PSEL_A :: DIV32K) } # [doc = "Divide clock by 65536"]
# [inline (always)]
pub fn div64k (self) -> & 'a mut W { self . variant (PSEL_A :: DIV64K) } } # [doc = "Field `LEVEL` reader - BOD33 Threshold Level"]
pub type LEVEL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `LEVEL` writer - BOD33 Threshold Level"]
pub type LEVEL_W < 'a > = crate :: FieldWriter < 'a , u32 , BOD33_SPEC , u8 , u8 , 6 , 16 > ; impl R { # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Hysteresis"]
# [inline (always)]
pub fn hyst (& self) -> HYST_R { HYST_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 3:4 - BOD33 Action"]
# [inline (always)]
pub fn action (& self) -> ACTION_R { ACTION_R :: new (((self . bits >> 3) & 3) as u8) } # [doc = "Bit 6 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 8 - Operation Mode"]
# [inline (always)]
pub fn mode (& self) -> MODE_R { MODE_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Clock Enable"]
# [inline (always)]
pub fn cen (& self) -> CEN_R { CEN_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bits 12:15 - Prescaler Select"]
# [inline (always)]
pub fn psel (& self) -> PSEL_R { PSEL_R :: new (((self . bits >> 12) & 0x0f) as u8) } # [doc = "Bits 16:21 - BOD33 Threshold Level"]
# [inline (always)]
pub fn level (& self) -> LEVEL_R { LEVEL_R :: new (((self . bits >> 16) & 0x3f) as u8) } } impl W { # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Bit 2 - Hysteresis"]
# [inline (always)]
pub fn hyst (& mut self) -> HYST_W { HYST_W :: new (self) } # [doc = "Bits 3:4 - BOD33 Action"]
# [inline (always)]
pub fn action (& mut self) -> ACTION_W { ACTION_W :: new (self) } # [doc = "Bit 6 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& mut self) -> RUNSTDBY_W { RUNSTDBY_W :: new (self) } # [doc = "Bit 8 - Operation Mode"]
# [inline (always)]
pub fn mode (& mut self) -> MODE_W { MODE_W :: new (self) } # [doc = "Bit 9 - Clock Enable"]
# [inline (always)]
pub fn cen (& mut self) -> CEN_W { CEN_W :: new (self) } # [doc = "Bits 12:15 - Prescaler Select"]
# [inline (always)]
pub fn psel (& mut self) -> PSEL_W { PSEL_W :: new (self) } # [doc = "Bits 16:21 - BOD33 Threshold Level"]
# [inline (always)]
pub fn level (& mut self) -> LEVEL_W { LEVEL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "3.3V Brown-Out Detector (BOD33) Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [bod33](index.html) module"]
pub struct BOD33_SPEC ; impl crate :: RegisterSpec for BOD33_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [bod33::R](R) reader structure"]
impl crate :: Readable for BOD33_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [bod33::W](W) writer structure"]
impl crate :: Writable for BOD33_SPEC { type Writer = W ; } # [doc = "`reset()` method sets BOD33 to value 0"]
impl crate :: Resettable for BOD33_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "VREG register accessor: an alias for `Reg<VREG_SPEC>`"]
pub type VREG = crate :: Reg < vreg :: VREG_SPEC > ; # [doc = "Voltage Regulator System (VREG) Control"]
pub mod vreg { # [doc = "Register `VREG` reader"]
pub struct R (crate :: R < VREG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < VREG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < VREG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < VREG_SPEC >) -> Self { R (reader) } } # [doc = "Register `VREG` writer"]
pub struct W (crate :: W < VREG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < VREG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < VREG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < VREG_SPEC >) -> Self { W (writer) } } # [doc = "Field `RUNSTDBY` reader - Run in Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run in Standby"]
pub type RUNSTDBY_W < 'a > = crate :: BitWriter < 'a , u16 , VREG_SPEC , bool , 6 > ; # [doc = "Field `FORCELDO` reader - Force LDO Voltage Regulator"]
pub type FORCELDO_R = crate :: BitReader < bool > ; # [doc = "Field `FORCELDO` writer - Force LDO Voltage Regulator"]
pub type FORCELDO_W < 'a > = crate :: BitWriter < 'a , u16 , VREG_SPEC , bool , 13 > ; impl R { # [doc = "Bit 6 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 13 - Force LDO Voltage Regulator"]
# [inline (always)]
pub fn forceldo (& self) -> FORCELDO_R { FORCELDO_R :: new (((self . bits >> 13) & 1) != 0) } } impl W { # [doc = "Bit 6 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& mut self) -> RUNSTDBY_W { RUNSTDBY_W :: new (self) } # [doc = "Bit 13 - Force LDO Voltage Regulator"]
# [inline (always)]
pub fn forceldo (& mut self) -> FORCELDO_W { FORCELDO_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Voltage Regulator System (VREG) Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [vreg](index.html) module"]
pub struct VREG_SPEC ; impl crate :: RegisterSpec for VREG_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [vreg::R](R) reader structure"]
impl crate :: Readable for VREG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [vreg::W](W) writer structure"]
impl crate :: Writable for VREG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets VREG to value 0"]
impl crate :: Resettable for VREG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "VREF register accessor: an alias for `Reg<VREF_SPEC>`"]
pub type VREF = crate :: Reg < vref :: VREF_SPEC > ; # [doc = "Voltage References System (VREF) Control"]
pub mod vref { # [doc = "Register `VREF` reader"]
pub struct R (crate :: R < VREF_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < VREF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < VREF_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < VREF_SPEC >) -> Self { R (reader) } } # [doc = "Register `VREF` writer"]
pub struct W (crate :: W < VREF_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < VREF_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < VREF_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < VREF_SPEC >) -> Self { W (writer) } } # [doc = "Field `TSEN` reader - Temperature Sensor Enable"]
pub type TSEN_R = crate :: BitReader < bool > ; # [doc = "Field `TSEN` writer - Temperature Sensor Enable"]
pub type TSEN_W < 'a > = crate :: BitWriter < 'a , u32 , VREF_SPEC , bool , 1 > ; # [doc = "Field `BGOUTEN` reader - Bandgap Output Enable"]
pub type BGOUTEN_R = crate :: BitReader < bool > ; # [doc = "Field `BGOUTEN` writer - Bandgap Output Enable"]
pub type BGOUTEN_W < 'a > = crate :: BitWriter < 'a , u32 , VREF_SPEC , bool , 2 > ; # [doc = "Field `CALIB` reader - Bandgap Voltage Generator Calibration"]
pub type CALIB_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `CALIB` writer - Bandgap Voltage Generator Calibration"]
pub type CALIB_W < 'a > = crate :: FieldWriter < 'a , u32 , VREF_SPEC , u16 , u16 , 11 , 16 > ; impl R { # [doc = "Bit 1 - Temperature Sensor Enable"]
# [inline (always)]
pub fn tsen (& self) -> TSEN_R { TSEN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Bandgap Output Enable"]
# [inline (always)]
pub fn bgouten (& self) -> BGOUTEN_R { BGOUTEN_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 16:26 - Bandgap Voltage Generator Calibration"]
# [inline (always)]
pub fn calib (& self) -> CALIB_R { CALIB_R :: new (((self . bits >> 16) & 0x07ff) as u16) } } impl W { # [doc = "Bit 1 - Temperature Sensor Enable"]
# [inline (always)]
pub fn tsen (& mut self) -> TSEN_W { TSEN_W :: new (self) } # [doc = "Bit 2 - Bandgap Output Enable"]
# [inline (always)]
pub fn bgouten (& mut self) -> BGOUTEN_W { BGOUTEN_W :: new (self) } # [doc = "Bits 16:26 - Bandgap Voltage Generator Calibration"]
# [inline (always)]
pub fn calib (& mut self) -> CALIB_W { CALIB_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Voltage References System (VREF) Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [vref](index.html) module"]
pub struct VREF_SPEC ; impl crate :: RegisterSpec for VREF_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [vref::R](R) reader structure"]
impl crate :: Readable for VREF_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [vref::W](W) writer structure"]
impl crate :: Writable for VREF_SPEC { type Writer = W ; } # [doc = "`reset()` method sets VREF to value 0"]
impl crate :: Resettable for VREF_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DPLLCTRLA register accessor: an alias for `Reg<DPLLCTRLA_SPEC>`"]
pub type DPLLCTRLA = crate :: Reg < dpllctrla :: DPLLCTRLA_SPEC > ; # [doc = "DPLL Control A"]
pub mod dpllctrla { # [doc = "Register `DPLLCTRLA` reader"]
pub struct R (crate :: R < DPLLCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DPLLCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DPLLCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DPLLCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `DPLLCTRLA` writer"]
pub struct W (crate :: W < DPLLCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DPLLCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DPLLCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DPLLCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - DPLL Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - DPLL Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u8 , DPLLCTRLA_SPEC , bool , 1 > ; # [doc = "Field `RUNSTDBY` reader - Run in Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run in Standby"]
pub type RUNSTDBY_W < 'a > = crate :: BitWriter < 'a , u8 , DPLLCTRLA_SPEC , bool , 6 > ; # [doc = "Field `ONDEMAND` reader - On Demand Clock Activation"]
pub type ONDEMAND_R = crate :: BitReader < bool > ; # [doc = "Field `ONDEMAND` writer - On Demand Clock Activation"]
pub type ONDEMAND_W < 'a > = crate :: BitWriter < 'a , u8 , DPLLCTRLA_SPEC , bool , 7 > ; impl R { # [doc = "Bit 1 - DPLL Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 6 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - On Demand Clock Activation"]
# [inline (always)]
pub fn ondemand (& self) -> ONDEMAND_R { ONDEMAND_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 1 - DPLL Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Bit 6 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& mut self) -> RUNSTDBY_W { RUNSTDBY_W :: new (self) } # [doc = "Bit 7 - On Demand Clock Activation"]
# [inline (always)]
pub fn ondemand (& mut self) -> ONDEMAND_W { ONDEMAND_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "DPLL Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dpllctrla](index.html) module"]
pub struct DPLLCTRLA_SPEC ; impl crate :: RegisterSpec for DPLLCTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dpllctrla::R](R) reader structure"]
impl crate :: Readable for DPLLCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dpllctrla::W](W) writer structure"]
impl crate :: Writable for DPLLCTRLA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DPLLCTRLA to value 0x80"]
impl crate :: Resettable for DPLLCTRLA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x80 } } } # [doc = "DPLLRATIO register accessor: an alias for `Reg<DPLLRATIO_SPEC>`"]
pub type DPLLRATIO = crate :: Reg < dpllratio :: DPLLRATIO_SPEC > ; # [doc = "DPLL Ratio Control"]
pub mod dpllratio { # [doc = "Register `DPLLRATIO` reader"]
pub struct R (crate :: R < DPLLRATIO_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DPLLRATIO_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DPLLRATIO_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DPLLRATIO_SPEC >) -> Self { R (reader) } } # [doc = "Register `DPLLRATIO` writer"]
pub struct W (crate :: W < DPLLRATIO_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DPLLRATIO_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DPLLRATIO_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DPLLRATIO_SPEC >) -> Self { W (writer) } } # [doc = "Field `LDR` reader - Loop Divider Ratio"]
pub type LDR_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `LDR` writer - Loop Divider Ratio"]
pub type LDR_W < 'a > = crate :: FieldWriter < 'a , u32 , DPLLRATIO_SPEC , u16 , u16 , 12 , 0 > ; # [doc = "Field `LDRFRAC` reader - Loop Divider Ratio Fractional Part"]
pub type LDRFRAC_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `LDRFRAC` writer - Loop Divider Ratio Fractional Part"]
pub type LDRFRAC_W < 'a > = crate :: FieldWriter < 'a , u32 , DPLLRATIO_SPEC , u8 , u8 , 4 , 16 > ; impl R { # [doc = "Bits 0:11 - Loop Divider Ratio"]
# [inline (always)]
pub fn ldr (& self) -> LDR_R { LDR_R :: new ((self . bits & 0x0fff) as u16) } # [doc = "Bits 16:19 - Loop Divider Ratio Fractional Part"]
# [inline (always)]
pub fn ldrfrac (& self) -> LDRFRAC_R { LDRFRAC_R :: new (((self . bits >> 16) & 0x0f) as u8) } } impl W { # [doc = "Bits 0:11 - Loop Divider Ratio"]
# [inline (always)]
pub fn ldr (& mut self) -> LDR_W { LDR_W :: new (self) } # [doc = "Bits 16:19 - Loop Divider Ratio Fractional Part"]
# [inline (always)]
pub fn ldrfrac (& mut self) -> LDRFRAC_W { LDRFRAC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "DPLL Ratio Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dpllratio](index.html) module"]
pub struct DPLLRATIO_SPEC ; impl crate :: RegisterSpec for DPLLRATIO_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [dpllratio::R](R) reader structure"]
impl crate :: Readable for DPLLRATIO_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dpllratio::W](W) writer structure"]
impl crate :: Writable for DPLLRATIO_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DPLLRATIO to value 0"]
impl crate :: Resettable for DPLLRATIO_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DPLLCTRLB register accessor: an alias for `Reg<DPLLCTRLB_SPEC>`"]
pub type DPLLCTRLB = crate :: Reg < dpllctrlb :: DPLLCTRLB_SPEC > ; # [doc = "DPLL Control B"]
pub mod dpllctrlb { # [doc = "Register `DPLLCTRLB` reader"]
pub struct R (crate :: R < DPLLCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DPLLCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DPLLCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DPLLCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `DPLLCTRLB` writer"]
pub struct W (crate :: W < DPLLCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DPLLCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DPLLCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DPLLCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Proportional Integral Filter Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum FILTER_A { # [doc = "0: Default filter mode"]
DEFAULT = 0 , # [doc = "1: Low bandwidth filter"]
LBFILT = 1 , # [doc = "2: High bandwidth filter"]
HBFILT = 2 , # [doc = "3: High damping filter"]
HDFILT = 3 , } impl From < FILTER_A > for u8 { # [inline (always)]
fn from (variant : FILTER_A) -> Self { variant as _ } } # [doc = "Field `FILTER` reader - Proportional Integral Filter Selection"]
pub type FILTER_R = crate :: FieldReader < u8 , FILTER_A > ; impl FILTER_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> FILTER_A { match self . bits { 0 => FILTER_A :: DEFAULT , 1 => FILTER_A :: LBFILT , 2 => FILTER_A :: HBFILT , 3 => FILTER_A :: HDFILT , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DEFAULT`"]
# [inline (always)]
pub fn is_default (& self) -> bool { * self == FILTER_A :: DEFAULT } # [doc = "Checks if the value of the field is `LBFILT`"]
# [inline (always)]
pub fn is_lbfilt (& self) -> bool { * self == FILTER_A :: LBFILT } # [doc = "Checks if the value of the field is `HBFILT`"]
# [inline (always)]
pub fn is_hbfilt (& self) -> bool { * self == FILTER_A :: HBFILT } # [doc = "Checks if the value of the field is `HDFILT`"]
# [inline (always)]
pub fn is_hdfilt (& self) -> bool { * self == FILTER_A :: HDFILT } } # [doc = "Field `FILTER` writer - Proportional Integral Filter Selection"]
pub type FILTER_W < 'a > = crate :: FieldWriterSafe < 'a , u32 , DPLLCTRLB_SPEC , u8 , FILTER_A , 2 , 0 > ; impl < 'a > FILTER_W < 'a > { # [doc = "Default filter mode"]
# [inline (always)]
pub fn default (self) -> & 'a mut W { self . variant (FILTER_A :: DEFAULT) } # [doc = "Low bandwidth filter"]
# [inline (always)]
pub fn lbfilt (self) -> & 'a mut W { self . variant (FILTER_A :: LBFILT) } # [doc = "High bandwidth filter"]
# [inline (always)]
pub fn hbfilt (self) -> & 'a mut W { self . variant (FILTER_A :: HBFILT) } # [doc = "High damping filter"]
# [inline (always)]
pub fn hdfilt (self) -> & 'a mut W { self . variant (FILTER_A :: HDFILT) } } # [doc = "Field `LPEN` reader - Low-Power Enable"]
pub type LPEN_R = crate :: BitReader < bool > ; # [doc = "Field `LPEN` writer - Low-Power Enable"]
pub type LPEN_W < 'a > = crate :: BitWriter < 'a , u32 , DPLLCTRLB_SPEC , bool , 2 > ; # [doc = "Field `WUF` reader - Wake Up Fast"]
pub type WUF_R = crate :: BitReader < bool > ; # [doc = "Field `WUF` writer - Wake Up Fast"]
pub type WUF_W < 'a > = crate :: BitWriter < 'a , u32 , DPLLCTRLB_SPEC , bool , 3 > ; # [doc = "Reference Clock Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum REFCLK_A { # [doc = "0: CLK_DPLL_REF0 clock reference"]
REF0 = 0 , # [doc = "1: CLK_DPLL_REF1 clock reference"]
REF1 = 1 , # [doc = "2: GCLK_DPLL clock reference"]
GCLK = 2 , } impl From < REFCLK_A > for u8 { # [inline (always)]
fn from (variant : REFCLK_A) -> Self { variant as _ } } # [doc = "Field `REFCLK` reader - Reference Clock Selection"]
pub type REFCLK_R = crate :: FieldReader < u8 , REFCLK_A > ; impl REFCLK_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < REFCLK_A > { match self . bits { 0 => Some (REFCLK_A :: REF0) , 1 => Some (REFCLK_A :: REF1) , 2 => Some (REFCLK_A :: GCLK) , _ => None , } } # [doc = "Checks if the value of the field is `REF0`"]
# [inline (always)]
pub fn is_ref0 (& self) -> bool { * self == REFCLK_A :: REF0 } # [doc = "Checks if the value of the field is `REF1`"]
# [inline (always)]
pub fn is_ref1 (& self) -> bool { * self == REFCLK_A :: REF1 } # [doc = "Checks if the value of the field is `GCLK`"]
# [inline (always)]
pub fn is_gclk (& self) -> bool { * self == REFCLK_A :: GCLK } } # [doc = "Field `REFCLK` writer - Reference Clock Selection"]
pub type REFCLK_W < 'a > = crate :: FieldWriter < 'a , u32 , DPLLCTRLB_SPEC , u8 , REFCLK_A , 2 , 4 > ; impl < 'a > REFCLK_W < 'a > { # [doc = "CLK_DPLL_REF0 clock reference"]
# [inline (always)]
pub fn ref0 (self) -> & 'a mut W { self . variant (REFCLK_A :: REF0) } # [doc = "CLK_DPLL_REF1 clock reference"]
# [inline (always)]
pub fn ref1 (self) -> & 'a mut W { self . variant (REFCLK_A :: REF1) } # [doc = "GCLK_DPLL clock reference"]
# [inline (always)]
pub fn gclk (self) -> & 'a mut W { self . variant (REFCLK_A :: GCLK) } } # [doc = "Lock Time\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum LTIME_A { # [doc = "0: No time-out"]
DEFAULT = 0 , # [doc = "4: Time-out if no lock within 8 ms"]
_8MS = 4 , # [doc = "5: Time-out if no lock within 9 ms"]
_9MS = 5 , # [doc = "6: Time-out if no lock within 10 ms"]
_10MS = 6 , # [doc = "7: Time-out if no lock within 11 ms"]
_11MS = 7 , } impl From < LTIME_A > for u8 { # [inline (always)]
fn from (variant : LTIME_A) -> Self { variant as _ } } # [doc = "Field `LTIME` reader - Lock Time"]
pub type LTIME_R = crate :: FieldReader < u8 , LTIME_A > ; impl LTIME_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < LTIME_A > { match self . bits { 0 => Some (LTIME_A :: DEFAULT) , 4 => Some (LTIME_A :: _8MS) , 5 => Some (LTIME_A :: _9MS) , 6 => Some (LTIME_A :: _10MS) , 7 => Some (LTIME_A :: _11MS) , _ => None , } } # [doc = "Checks if the value of the field is `DEFAULT`"]
# [inline (always)]
pub fn is_default (& self) -> bool { * self == LTIME_A :: DEFAULT } # [doc = "Checks if the value of the field is `_8MS`"]
# [inline (always)]
pub fn is_8ms (& self) -> bool { * self == LTIME_A :: _8MS } # [doc = "Checks if the value of the field is `_9MS`"]
# [inline (always)]
pub fn is_9ms (& self) -> bool { * self == LTIME_A :: _9MS } # [doc = "Checks if the value of the field is `_10MS`"]
# [inline (always)]
pub fn is_10ms (& self) -> bool { * self == LTIME_A :: _10MS } # [doc = "Checks if the value of the field is `_11MS`"]
# [inline (always)]
pub fn is_11ms (& self) -> bool { * self == LTIME_A :: _11MS } } # [doc = "Field `LTIME` writer - Lock Time"]
pub type LTIME_W < 'a > = crate :: FieldWriter < 'a , u32 , DPLLCTRLB_SPEC , u8 , LTIME_A , 3 , 8 > ; impl < 'a > LTIME_W < 'a > { # [doc = "No time-out"]
# [inline (always)]
pub fn default (self) -> & 'a mut W { self . variant (LTIME_A :: DEFAULT) } # [doc = "Time-out if no lock within 8 ms"]
# [inline (always)]
pub fn _8ms (self) -> & 'a mut W { self . variant (LTIME_A :: _8MS) } # [doc = "Time-out if no lock within 9 ms"]
# [inline (always)]
pub fn _9ms (self) -> & 'a mut W { self . variant (LTIME_A :: _9MS) } # [doc = "Time-out if no lock within 10 ms"]
# [inline (always)]
pub fn _10ms (self) -> & 'a mut W { self . variant (LTIME_A :: _10MS) } # [doc = "Time-out if no lock within 11 ms"]
# [inline (always)]
pub fn _11ms (self) -> & 'a mut W { self . variant (LTIME_A :: _11MS) } } # [doc = "Field `LBYPASS` reader - Lock Bypass"]
pub type LBYPASS_R = crate :: BitReader < bool > ; # [doc = "Field `LBYPASS` writer - Lock Bypass"]
pub type LBYPASS_W < 'a > = crate :: BitWriter < 'a , u32 , DPLLCTRLB_SPEC , bool , 12 > ; # [doc = "Field `DIV` reader - Clock Divider"]
pub type DIV_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `DIV` writer - Clock Divider"]
pub type DIV_W < 'a > = crate :: FieldWriter < 'a , u32 , DPLLCTRLB_SPEC , u16 , u16 , 11 , 16 > ; impl R { # [doc = "Bits 0:1 - Proportional Integral Filter Selection"]
# [inline (always)]
pub fn filter (& self) -> FILTER_R { FILTER_R :: new ((self . bits & 3) as u8) } # [doc = "Bit 2 - Low-Power Enable"]
# [inline (always)]
pub fn lpen (& self) -> LPEN_R { LPEN_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Wake Up Fast"]
# [inline (always)]
pub fn wuf (& self) -> WUF_R { WUF_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:5 - Reference Clock Selection"]
# [inline (always)]
pub fn refclk (& self) -> REFCLK_R { REFCLK_R :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bits 8:10 - Lock Time"]
# [inline (always)]
pub fn ltime (& self) -> LTIME_R { LTIME_R :: new (((self . bits >> 8) & 7) as u8) } # [doc = "Bit 12 - Lock Bypass"]
# [inline (always)]
pub fn lbypass (& self) -> LBYPASS_R { LBYPASS_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bits 16:26 - Clock Divider"]
# [inline (always)]
pub fn div (& self) -> DIV_R { DIV_R :: new (((self . bits >> 16) & 0x07ff) as u16) } } impl W { # [doc = "Bits 0:1 - Proportional Integral Filter Selection"]
# [inline (always)]
pub fn filter (& mut self) -> FILTER_W { FILTER_W :: new (self) } # [doc = "Bit 2 - Low-Power Enable"]
# [inline (always)]
pub fn lpen (& mut self) -> LPEN_W { LPEN_W :: new (self) } # [doc = "Bit 3 - Wake Up Fast"]
# [inline (always)]
pub fn wuf (& mut self) -> WUF_W { WUF_W :: new (self) } # [doc = "Bits 4:5 - Reference Clock Selection"]
# [inline (always)]
pub fn refclk (& mut self) -> REFCLK_W { REFCLK_W :: new (self) } # [doc = "Bits 8:10 - Lock Time"]
# [inline (always)]
pub fn ltime (& mut self) -> LTIME_W { LTIME_W :: new (self) } # [doc = "Bit 12 - Lock Bypass"]
# [inline (always)]
pub fn lbypass (& mut self) -> LBYPASS_W { LBYPASS_W :: new (self) } # [doc = "Bits 16:26 - Clock Divider"]
# [inline (always)]
pub fn div (& mut self) -> DIV_W { DIV_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "DPLL Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dpllctrlb](index.html) module"]
pub struct DPLLCTRLB_SPEC ; impl crate :: RegisterSpec for DPLLCTRLB_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [dpllctrlb::R](R) reader structure"]
impl crate :: Readable for DPLLCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dpllctrlb::W](W) writer structure"]
impl crate :: Writable for DPLLCTRLB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DPLLCTRLB to value 0"]
impl crate :: Resettable for DPLLCTRLB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DPLLSTATUS register accessor: an alias for `Reg<DPLLSTATUS_SPEC>`"]
pub type DPLLSTATUS = crate :: Reg < dpllstatus :: DPLLSTATUS_SPEC > ; # [doc = "DPLL Status"]
pub mod dpllstatus { # [doc = "Register `DPLLSTATUS` reader"]
pub struct R (crate :: R < DPLLSTATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DPLLSTATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DPLLSTATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DPLLSTATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `LOCK` reader - DPLL Lock Status"]
pub type LOCK_R = crate :: BitReader < bool > ; # [doc = "Field `CLKRDY` reader - Output Clock Ready"]
pub type CLKRDY_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` reader - DPLL Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `DIV` reader - Divider Enable"]
pub type DIV_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - DPLL Lock Status"]
# [inline (always)]
pub fn lock (& self) -> LOCK_R { LOCK_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Output Clock Ready"]
# [inline (always)]
pub fn clkrdy (& self) -> CLKRDY_R { CLKRDY_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - DPLL Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Divider Enable"]
# [inline (always)]
pub fn div (& self) -> DIV_R { DIV_R :: new (((self . bits >> 3) & 1) != 0) } } # [doc = "DPLL Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dpllstatus](index.html) module"]
pub struct DPLLSTATUS_SPEC ; impl crate :: RegisterSpec for DPLLSTATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dpllstatus::R](R) reader structure"]
impl crate :: Readable for DPLLSTATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets DPLLSTATUS to value 0"]
impl crate :: Resettable for DPLLSTATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "Basic Timer Counter 3"]
pub struct TC3 { _marker : PhantomData < * const () > } unsafe impl Send for TC3 { } impl TC3 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tc3 :: RegisterBlock = 0x4200_2c00 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tc3 :: RegisterBlock { Self :: PTR } } impl Deref for TC3 { type Target = tc3 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TC3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TC3") . finish () } } # [doc = "Basic Timer Counter 3"]
pub mod tc3 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { _reserved_0_count8 : [u8 ; 0x20]
, } impl RegisterBlock { # [doc = "0x00..0x20 - 32-bit Counter Mode"]
# [inline (always)]
pub fn count32 (& self) -> & COUNT32 { unsafe { & * (((self as * const Self) as * const u8) . add (0usize) as * const COUNT32) } } # [doc = "0x00..0x1c - 16-bit Counter Mode"]
# [inline (always)]
pub fn count16 (& self) -> & COUNT16 { unsafe { & * (((self as * const Self) as * const u8) . add (0usize) as * const COUNT16) } } # [doc = "0x00..0x1a - 8-bit Counter Mode"]
# [inline (always)]
pub fn count8 (& self) -> & COUNT8 { unsafe { & * (((self as * const Self) as * const u8) . add (0usize) as * const COUNT8) } } } # [doc = r"Register block"]
# [repr (C)]
pub struct COUNT8 { # [doc = "0x00 - Control A"]
pub ctrla : crate :: Reg < self :: count8 :: ctrla :: CTRLA_SPEC > , # [doc = "0x02 - Read Request"]
pub readreq : crate :: Reg < self :: count8 :: readreq :: READREQ_SPEC > , # [doc = "0x04 - Control B Clear"]
pub ctrlbclr : crate :: Reg < self :: count8 :: ctrlbclr :: CTRLBCLR_SPEC > , # [doc = "0x05 - Control B Set"]
pub ctrlbset : crate :: Reg < self :: count8 :: ctrlbset :: CTRLBSET_SPEC > , # [doc = "0x06 - Control C"]
pub ctrlc : crate :: Reg < self :: count8 :: ctrlc :: CTRLC_SPEC > , _reserved5 : [u8 ; 0x01]
, # [doc = "0x08 - Debug Control"]
pub dbgctrl : crate :: Reg < self :: count8 :: dbgctrl :: DBGCTRL_SPEC > , _reserved6 : [u8 ; 0x01]
, # [doc = "0x0a - Event Control"]
pub evctrl : crate :: Reg < self :: count8 :: evctrl :: EVCTRL_SPEC > , # [doc = "0x0c - Interrupt Enable Clear"]
pub intenclr : crate :: Reg < self :: count8 :: intenclr :: INTENCLR_SPEC > , # [doc = "0x0d - Interrupt Enable Set"]
pub intenset : crate :: Reg < self :: count8 :: intenset :: INTENSET_SPEC > , # [doc = "0x0e - Interrupt Flag Status and Clear"]
pub intflag : crate :: Reg < self :: count8 :: intflag :: INTFLAG_SPEC > , # [doc = "0x0f - Status"]
pub status : crate :: Reg < self :: count8 :: status :: STATUS_SPEC > , # [doc = "0x10 - COUNT8 Counter Value"]
pub count : crate :: Reg < self :: count8 :: count :: COUNT_SPEC > , _reserved12 : [u8 ; 0x03]
, # [doc = "0x14 - COUNT8 Period Value"]
pub per : crate :: Reg < self :: count8 :: per :: PER_SPEC > , _reserved13 : [u8 ; 0x03]
, # [doc = "0x18 - COUNT8 Compare/Capture"]
pub cc : [crate :: Reg < self :: count8 :: cc :: CC_SPEC > ; 2]
, } # [doc = r"Register block"]
# [doc = "8-bit Counter Mode"]
pub mod count8 { # [doc = "CTRLA register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWRST` writer - Software Reset"]
pub type SWRST_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLA_SPEC , bool , 0 > ; # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLA_SPEC , bool , 1 > ; # [doc = "TC Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum MODE_A { # [doc = "0: Counter in 16-bit mode"]
COUNT16 = 0 , # [doc = "1: Counter in 8-bit mode"]
COUNT8 = 1 , # [doc = "2: Counter in 32-bit mode"]
COUNT32 = 2 , } impl From < MODE_A > for u8 { # [inline (always)]
fn from (variant : MODE_A) -> Self { variant as _ } } # [doc = "Field `MODE` reader - TC Mode"]
pub type MODE_R = crate :: FieldReader < u8 , MODE_A > ; impl MODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < MODE_A > { match self . bits { 0 => Some (MODE_A :: COUNT16) , 1 => Some (MODE_A :: COUNT8) , 2 => Some (MODE_A :: COUNT32) , _ => None , } } # [doc = "Checks if the value of the field is `COUNT16`"]
# [inline (always)]
pub fn is_count16 (& self) -> bool { * self == MODE_A :: COUNT16 } # [doc = "Checks if the value of the field is `COUNT8`"]
# [inline (always)]
pub fn is_count8 (& self) -> bool { * self == MODE_A :: COUNT8 } # [doc = "Checks if the value of the field is `COUNT32`"]
# [inline (always)]
pub fn is_count32 (& self) -> bool { * self == MODE_A :: COUNT32 } } # [doc = "Field `MODE` writer - TC Mode"]
pub type MODE_W < 'a > = crate :: FieldWriter < 'a , u16 , CTRLA_SPEC , u8 , MODE_A , 2 , 2 > ; impl < 'a > MODE_W < 'a > { # [doc = "Counter in 16-bit mode"]
# [inline (always)]
pub fn count16 (self) -> & 'a mut W { self . variant (MODE_A :: COUNT16) } # [doc = "Counter in 8-bit mode"]
# [inline (always)]
pub fn count8 (self) -> & 'a mut W { self . variant (MODE_A :: COUNT8) } # [doc = "Counter in 32-bit mode"]
# [inline (always)]
pub fn count32 (self) -> & 'a mut W { self . variant (MODE_A :: COUNT32) } } # [doc = "Waveform Generation Operation\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum WAVEGEN_A { # [doc = "0: `0`"]
NFRQ = 0 , # [doc = "1: `1`"]
MFRQ = 1 , # [doc = "2: `10`"]
NPWM = 2 , # [doc = "3: `11`"]
MPWM = 3 , } impl From < WAVEGEN_A > for u8 { # [inline (always)]
fn from (variant : WAVEGEN_A) -> Self { variant as _ } } # [doc = "Field `WAVEGEN` reader - Waveform Generation Operation"]
pub type WAVEGEN_R = crate :: FieldReader < u8 , WAVEGEN_A > ; impl WAVEGEN_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> WAVEGEN_A { match self . bits { 0 => WAVEGEN_A :: NFRQ , 1 => WAVEGEN_A :: MFRQ , 2 => WAVEGEN_A :: NPWM , 3 => WAVEGEN_A :: MPWM , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NFRQ`"]
# [inline (always)]
pub fn is_nfrq (& self) -> bool { * self == WAVEGEN_A :: NFRQ } # [doc = "Checks if the value of the field is `MFRQ`"]
# [inline (always)]
pub fn is_mfrq (& self) -> bool { * self == WAVEGEN_A :: MFRQ } # [doc = "Checks if the value of the field is `NPWM`"]
# [inline (always)]
pub fn is_npwm (& self) -> bool { * self == WAVEGEN_A :: NPWM } # [doc = "Checks if the value of the field is `MPWM`"]
# [inline (always)]
pub fn is_mpwm (& self) -> bool { * self == WAVEGEN_A :: MPWM } } # [doc = "Field `WAVEGEN` writer - Waveform Generation Operation"]
pub type WAVEGEN_W < 'a > = crate :: FieldWriterSafe < 'a , u16 , CTRLA_SPEC , u8 , WAVEGEN_A , 2 , 5 > ; impl < 'a > WAVEGEN_W < 'a > { # [doc = "`0`"]
# [inline (always)]
pub fn nfrq (self) -> & 'a mut W { self . variant (WAVEGEN_A :: NFRQ) } # [doc = "`1`"]
# [inline (always)]
pub fn mfrq (self) -> & 'a mut W { self . variant (WAVEGEN_A :: MFRQ) } # [doc = "`10`"]
# [inline (always)]
pub fn npwm (self) -> & 'a mut W { self . variant (WAVEGEN_A :: NPWM) } # [doc = "`11`"]
# [inline (always)]
pub fn mpwm (self) -> & 'a mut W { self . variant (WAVEGEN_A :: MPWM) } } # [doc = "Prescaler\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum PRESCALER_A { # [doc = "0: Prescaler: GCLK_TC"]
DIV1 = 0 , # [doc = "1: Prescaler: GCLK_TC/2"]
DIV2 = 1 , # [doc = "2: Prescaler: GCLK_TC/4"]
DIV4 = 2 , # [doc = "3: Prescaler: GCLK_TC/8"]
DIV8 = 3 , # [doc = "4: Prescaler: GCLK_TC/16"]
DIV16 = 4 , # [doc = "5: Prescaler: GCLK_TC/64"]
DIV64 = 5 , # [doc = "6: Prescaler: GCLK_TC/256"]
DIV256 = 6 , # [doc = "7: Prescaler: GCLK_TC/1024"]
DIV1024 = 7 , } impl From < PRESCALER_A > for u8 { # [inline (always)]
fn from (variant : PRESCALER_A) -> Self { variant as _ } } # [doc = "Field `PRESCALER` reader - Prescaler"]
pub type PRESCALER_R = crate :: FieldReader < u8 , PRESCALER_A > ; impl PRESCALER_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PRESCALER_A { match self . bits { 0 => PRESCALER_A :: DIV1 , 1 => PRESCALER_A :: DIV2 , 2 => PRESCALER_A :: DIV4 , 3 => PRESCALER_A :: DIV8 , 4 => PRESCALER_A :: DIV16 , 5 => PRESCALER_A :: DIV64 , 6 => PRESCALER_A :: DIV256 , 7 => PRESCALER_A :: DIV1024 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == PRESCALER_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == PRESCALER_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == PRESCALER_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == PRESCALER_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == PRESCALER_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == PRESCALER_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == PRESCALER_A :: DIV256 } # [doc = "Checks if the value of the field is `DIV1024`"]
# [inline (always)]
pub fn is_div1024 (& self) -> bool { * self == PRESCALER_A :: DIV1024 } } # [doc = "Field `PRESCALER` writer - Prescaler"]
pub type PRESCALER_W < 'a > = crate :: FieldWriterSafe < 'a , u16 , CTRLA_SPEC , u8 , PRESCALER_A , 3 , 8 > ; impl < 'a > PRESCALER_W < 'a > { # [doc = "Prescaler: GCLK_TC"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV1) } # [doc = "Prescaler: GCLK_TC/2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV2) } # [doc = "Prescaler: GCLK_TC/4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV4) } # [doc = "Prescaler: GCLK_TC/8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV8) } # [doc = "Prescaler: GCLK_TC/16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV16) } # [doc = "Prescaler: GCLK_TC/64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV64) } # [doc = "Prescaler: GCLK_TC/256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV256) } # [doc = "Prescaler: GCLK_TC/1024"]
# [inline (always)]
pub fn div1024 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV1024) } } # [doc = "Field `RUNSTDBY` reader - Run in Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run in Standby"]
pub type RUNSTDBY_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLA_SPEC , bool , 11 > ; # [doc = "Prescaler and Counter Synchronization\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum PRESCSYNC_A { # [doc = "0: Reload or reset the counter on next generic clock"]
GCLK = 0 , # [doc = "1: Reload or reset the counter on next prescaler clock"]
PRESC = 1 , # [doc = "2: Reload or reset the counter on next generic clock. Reset the prescaler counter"]
RESYNC = 2 , } impl From < PRESCSYNC_A > for u8 { # [inline (always)]
fn from (variant : PRESCSYNC_A) -> Self { variant as _ } } # [doc = "Field `PRESCSYNC` reader - Prescaler and Counter Synchronization"]
pub type PRESCSYNC_R = crate :: FieldReader < u8 , PRESCSYNC_A > ; impl PRESCSYNC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PRESCSYNC_A > { match self . bits { 0 => Some (PRESCSYNC_A :: GCLK) , 1 => Some (PRESCSYNC_A :: PRESC) , 2 => Some (PRESCSYNC_A :: RESYNC) , _ => None , } } # [doc = "Checks if the value of the field is `GCLK`"]
# [inline (always)]
pub fn is_gclk (& self) -> bool { * self == PRESCSYNC_A :: GCLK } # [doc = "Checks if the value of the field is `PRESC`"]
# [inline (always)]
pub fn is_presc (& self) -> bool { * self == PRESCSYNC_A :: PRESC } # [doc = "Checks if the value of the field is `RESYNC`"]
# [inline (always)]
pub fn is_resync (& self) -> bool { * self == PRESCSYNC_A :: RESYNC } } # [doc = "Field `PRESCSYNC` writer - Prescaler and Counter Synchronization"]
pub type PRESCSYNC_W < 'a > = crate :: FieldWriter < 'a , u16 , CTRLA_SPEC , u8 , PRESCSYNC_A , 2 , 12 > ; impl < 'a > PRESCSYNC_W < 'a > { # [doc = "Reload or reset the counter on next generic clock"]
# [inline (always)]
pub fn gclk (self) -> & 'a mut W { self . variant (PRESCSYNC_A :: GCLK) } # [doc = "Reload or reset the counter on next prescaler clock"]
# [inline (always)]
pub fn presc (self) -> & 'a mut W { self . variant (PRESCSYNC_A :: PRESC) } # [doc = "Reload or reset the counter on next generic clock. Reset the prescaler counter"]
# [inline (always)]
pub fn resync (self) -> & 'a mut W { self . variant (PRESCSYNC_A :: RESYNC) } } impl R { # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - TC Mode"]
# [inline (always)]
pub fn mode (& self) -> MODE_R { MODE_R :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bits 5:6 - Waveform Generation Operation"]
# [inline (always)]
pub fn wavegen (& self) -> WAVEGEN_R { WAVEGEN_R :: new (((self . bits >> 5) & 3) as u8) } # [doc = "Bits 8:10 - Prescaler"]
# [inline (always)]
pub fn prescaler (& self) -> PRESCALER_R { PRESCALER_R :: new (((self . bits >> 8) & 7) as u8) } # [doc = "Bit 11 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bits 12:13 - Prescaler and Counter Synchronization"]
# [inline (always)]
pub fn prescsync (& self) -> PRESCSYNC_R { PRESCSYNC_R :: new (((self . bits >> 12) & 3) as u8) } } impl W { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& mut self) -> SWRST_W { SWRST_W :: new (self) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Bits 2:3 - TC Mode"]
# [inline (always)]
pub fn mode (& mut self) -> MODE_W { MODE_W :: new (self) } # [doc = "Bits 5:6 - Waveform Generation Operation"]
# [inline (always)]
pub fn wavegen (& mut self) -> WAVEGEN_W { WAVEGEN_W :: new (self) } # [doc = "Bits 8:10 - Prescaler"]
# [inline (always)]
pub fn prescaler (& mut self) -> PRESCALER_W { PRESCALER_W :: new (self) } # [doc = "Bit 11 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& mut self) -> RUNSTDBY_W { RUNSTDBY_W :: new (self) } # [doc = "Bits 12:13 - Prescaler and Counter Synchronization"]
# [inline (always)]
pub fn prescsync (& mut self) -> PRESCSYNC_W { PRESCSYNC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "READREQ register accessor: an alias for `Reg<READREQ_SPEC>`"]
pub type READREQ = crate :: Reg < readreq :: READREQ_SPEC > ; # [doc = "Read Request"]
pub mod readreq { # [doc = "Register `READREQ` reader"]
pub struct R (crate :: R < READREQ_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < READREQ_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < READREQ_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < READREQ_SPEC >) -> Self { R (reader) } } # [doc = "Register `READREQ` writer"]
pub struct W (crate :: W < READREQ_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < READREQ_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < READREQ_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < READREQ_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADDR` reader - Address"]
pub type ADDR_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `ADDR` writer - Address"]
pub type ADDR_W < 'a > = crate :: FieldWriter < 'a , u16 , READREQ_SPEC , u8 , u8 , 5 , 0 > ; # [doc = "Field `RCONT` reader - Read Continuously"]
pub type RCONT_R = crate :: BitReader < bool > ; # [doc = "Field `RCONT` writer - Read Continuously"]
pub type RCONT_W < 'a > = crate :: BitWriter < 'a , u16 , READREQ_SPEC , bool , 14 > ; # [doc = "Field `RREQ` reader - Read Request"]
pub type RREQ_R = crate :: BitReader < bool > ; # [doc = "Field `RREQ` writer - Read Request"]
pub type RREQ_W < 'a > = crate :: BitWriter < 'a , u16 , READREQ_SPEC , bool , 15 > ; impl R { # [doc = "Bits 0:4 - Address"]
# [inline (always)]
pub fn addr (& self) -> ADDR_R { ADDR_R :: new ((self . bits & 0x1f) as u8) } # [doc = "Bit 14 - Read Continuously"]
# [inline (always)]
pub fn rcont (& self) -> RCONT_R { RCONT_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Read Request"]
# [inline (always)]
pub fn rreq (& self) -> RREQ_R { RREQ_R :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bits 0:4 - Address"]
# [inline (always)]
pub fn addr (& mut self) -> ADDR_W { ADDR_W :: new (self) } # [doc = "Bit 14 - Read Continuously"]
# [inline (always)]
pub fn rcont (& mut self) -> RCONT_W { RCONT_W :: new (self) } # [doc = "Bit 15 - Read Request"]
# [inline (always)]
pub fn rreq (& mut self) -> RREQ_W { RREQ_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Read Request\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [readreq](index.html) module"]
pub struct READREQ_SPEC ; impl crate :: RegisterSpec for READREQ_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [readreq::R](R) reader structure"]
impl crate :: Readable for READREQ_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [readreq::W](W) writer structure"]
impl crate :: Writable for READREQ_SPEC { type Writer = W ; } # [doc = "`reset()` method sets READREQ to value 0"]
impl crate :: Resettable for READREQ_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CTRLBCLR register accessor: an alias for `Reg<CTRLBCLR_SPEC>`"]
pub type CTRLBCLR = crate :: Reg < ctrlbclr :: CTRLBCLR_SPEC > ; # [doc = "Control B Clear"]
pub mod ctrlbclr { # [doc = "Register `CTRLBCLR` reader"]
pub struct R (crate :: R < CTRLBCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLBCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLBCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLBCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLBCLR` writer"]
pub struct W (crate :: W < CTRLBCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLBCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLBCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLBCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Counter Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` writer - Counter Direction"]
pub type DIR_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLBCLR_SPEC , bool , 0 > ; # [doc = "Field `ONESHOT` reader - One-Shot"]
pub type ONESHOT_R = crate :: BitReader < bool > ; # [doc = "Field `ONESHOT` writer - One-Shot"]
pub type ONESHOT_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLBCLR_SPEC , bool , 2 > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No action"]
NONE = 0 , # [doc = "1: Force a start, restart or retrigger"]
RETRIGGER = 1 , # [doc = "2: Force a stop"]
STOP = 2 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CMD_A > { match self . bits { 0 => Some (CMD_A :: NONE) , 1 => Some (CMD_A :: RETRIGGER) , 2 => Some (CMD_A :: STOP) , _ => None , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == CMD_A :: NONE } # [doc = "Checks if the value of the field is `RETRIGGER`"]
# [inline (always)]
pub fn is_retrigger (& self) -> bool { * self == CMD_A :: RETRIGGER } # [doc = "Checks if the value of the field is `STOP`"]
# [inline (always)]
pub fn is_stop (& self) -> bool { * self == CMD_A :: STOP } } # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a > = crate :: FieldWriter < 'a , u8 , CTRLBCLR_SPEC , u8 , CMD_A , 2 , 6 > ; impl < 'a > CMD_W < 'a > { # [doc = "No action"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (CMD_A :: NONE) } # [doc = "Force a start, restart or retrigger"]
# [inline (always)]
pub fn retrigger (self) -> & 'a mut W { self . variant (CMD_A :: RETRIGGER) } # [doc = "Force a stop"]
# [inline (always)]
pub fn stop (self) -> & 'a mut W { self . variant (CMD_A :: STOP) } } impl R { # [doc = "Bit 0 - Counter Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - One-Shot"]
# [inline (always)]
pub fn oneshot (& self) -> ONESHOT_R { ONESHOT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 6:7 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new (((self . bits >> 6) & 3) as u8) } } impl W { # [doc = "Bit 0 - Counter Direction"]
# [inline (always)]
pub fn dir (& mut self) -> DIR_W { DIR_W :: new (self) } # [doc = "Bit 2 - One-Shot"]
# [inline (always)]
pub fn oneshot (& mut self) -> ONESHOT_W { ONESHOT_W :: new (self) } # [doc = "Bits 6:7 - Command"]
# [inline (always)]
pub fn cmd (& mut self) -> CMD_W { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlbclr](index.html) module"]
pub struct CTRLBCLR_SPEC ; impl crate :: RegisterSpec for CTRLBCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlbclr::R](R) reader structure"]
impl crate :: Readable for CTRLBCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlbclr::W](W) writer structure"]
impl crate :: Writable for CTRLBCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLBCLR to value 0x02"]
impl crate :: Resettable for CTRLBCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x02 } } } # [doc = "CTRLBSET register accessor: an alias for `Reg<CTRLBSET_SPEC>`"]
pub type CTRLBSET = crate :: Reg < ctrlbset :: CTRLBSET_SPEC > ; # [doc = "Control B Set"]
pub mod ctrlbset { # [doc = "Register `CTRLBSET` reader"]
pub struct R (crate :: R < CTRLBSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLBSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLBSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLBSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLBSET` writer"]
pub struct W (crate :: W < CTRLBSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLBSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLBSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLBSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Counter Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` writer - Counter Direction"]
pub type DIR_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLBSET_SPEC , bool , 0 > ; # [doc = "Field `ONESHOT` reader - One-Shot"]
pub type ONESHOT_R = crate :: BitReader < bool > ; # [doc = "Field `ONESHOT` writer - One-Shot"]
pub type ONESHOT_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLBSET_SPEC , bool , 2 > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No action"]
NONE = 0 , # [doc = "1: Force a start, restart or retrigger"]
RETRIGGER = 1 , # [doc = "2: Force a stop"]
STOP = 2 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CMD_A > { match self . bits { 0 => Some (CMD_A :: NONE) , 1 => Some (CMD_A :: RETRIGGER) , 2 => Some (CMD_A :: STOP) , _ => None , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == CMD_A :: NONE } # [doc = "Checks if the value of the field is `RETRIGGER`"]
# [inline (always)]
pub fn is_retrigger (& self) -> bool { * self == CMD_A :: RETRIGGER } # [doc = "Checks if the value of the field is `STOP`"]
# [inline (always)]
pub fn is_stop (& self) -> bool { * self == CMD_A :: STOP } } # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a > = crate :: FieldWriter < 'a , u8 , CTRLBSET_SPEC , u8 , CMD_A , 2 , 6 > ; impl < 'a > CMD_W < 'a > { # [doc = "No action"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (CMD_A :: NONE) } # [doc = "Force a start, restart or retrigger"]
# [inline (always)]
pub fn retrigger (self) -> & 'a mut W { self . variant (CMD_A :: RETRIGGER) } # [doc = "Force a stop"]
# [inline (always)]
pub fn stop (self) -> & 'a mut W { self . variant (CMD_A :: STOP) } } impl R { # [doc = "Bit 0 - Counter Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - One-Shot"]
# [inline (always)]
pub fn oneshot (& self) -> ONESHOT_R { ONESHOT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 6:7 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new (((self . bits >> 6) & 3) as u8) } } impl W { # [doc = "Bit 0 - Counter Direction"]
# [inline (always)]
pub fn dir (& mut self) -> DIR_W { DIR_W :: new (self) } # [doc = "Bit 2 - One-Shot"]
# [inline (always)]
pub fn oneshot (& mut self) -> ONESHOT_W { ONESHOT_W :: new (self) } # [doc = "Bits 6:7 - Command"]
# [inline (always)]
pub fn cmd (& mut self) -> CMD_W { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlbset](index.html) module"]
pub struct CTRLBSET_SPEC ; impl crate :: RegisterSpec for CTRLBSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlbset::R](R) reader structure"]
impl crate :: Readable for CTRLBSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlbset::W](W) writer structure"]
impl crate :: Writable for CTRLBSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLBSET to value 0"]
impl crate :: Resettable for CTRLBSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CTRLC register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `INVEN0` reader - Output Waveform 0 Invert Enable"]
pub type INVEN0_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN0` writer - Output Waveform 0 Invert Enable"]
pub type INVEN0_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , 0 > ; # [doc = "Field `INVEN1` reader - Output Waveform 1 Invert Enable"]
pub type INVEN1_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN1` writer - Output Waveform 1 Invert Enable"]
pub type INVEN1_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , 1 > ; # [doc = "Field `CPTEN0` reader - Capture Channel 0 Enable"]
pub type CPTEN0_R = crate :: BitReader < bool > ; # [doc = "Field `CPTEN0` writer - Capture Channel 0 Enable"]
pub type CPTEN0_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , 4 > ; # [doc = "Field `CPTEN1` reader - Capture Channel 1 Enable"]
pub type CPTEN1_R = crate :: BitReader < bool > ; # [doc = "Field `CPTEN1` writer - Capture Channel 1 Enable"]
pub type CPTEN1_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , 5 > ; impl R { # [doc = "Bit 0 - Output Waveform 0 Invert Enable"]
# [inline (always)]
pub fn inven0 (& self) -> INVEN0_R { INVEN0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Output Waveform 1 Invert Enable"]
# [inline (always)]
pub fn inven1 (& self) -> INVEN1_R { INVEN1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - Capture Channel 0 Enable"]
# [inline (always)]
pub fn cpten0 (& self) -> CPTEN0_R { CPTEN0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Capture Channel 1 Enable"]
# [inline (always)]
pub fn cpten1 (& self) -> CPTEN1_R { CPTEN1_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Output Waveform 0 Invert Enable"]
# [inline (always)]
pub fn inven0 (& mut self) -> INVEN0_W { INVEN0_W :: new (self) } # [doc = "Bit 1 - Output Waveform 1 Invert Enable"]
# [inline (always)]
pub fn inven1 (& mut self) -> INVEN1_W { INVEN1_W :: new (self) } # [doc = "Bit 4 - Capture Channel 0 Enable"]
# [inline (always)]
pub fn cpten0 (& mut self) -> CPTEN0_W { CPTEN0_W :: new (self) } # [doc = "Bit 5 - Capture Channel 1 Enable"]
# [inline (always)]
pub fn cpten1 (& mut self) -> CPTEN1_W { CPTEN1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DBGCTRL register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Debug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Debug Run Mode"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Debug Run Mode"]
pub type DBGRUN_W < 'a > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , 0 > ; impl R { # [doc = "Bit 0 - Debug Run Mode"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug Run Mode"]
# [inline (always)]
pub fn dbgrun (& mut self) -> DBGRUN_W { DBGRUN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "EVCTRL register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "Event Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Event Action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum EVACT_A { # [doc = "0: Event action disabled"]
OFF = 0 , # [doc = "1: Start, restart or retrigger TC on event"]
RETRIGGER = 1 , # [doc = "2: Count on event"]
COUNT = 2 , # [doc = "3: Start TC on event"]
START = 3 , # [doc = "5: Period captured in CC0, pulse width in CC1"]
PPW = 5 , # [doc = "6: Period captured in CC1, pulse width in CC0"]
PWP = 6 , } impl From < EVACT_A > for u8 { # [inline (always)]
fn from (variant : EVACT_A) -> Self { variant as _ } } # [doc = "Field `EVACT` reader - Event Action"]
pub type EVACT_R = crate :: FieldReader < u8 , EVACT_A > ; impl EVACT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < EVACT_A > { match self . bits { 0 => Some (EVACT_A :: OFF) , 1 => Some (EVACT_A :: RETRIGGER) , 2 => Some (EVACT_A :: COUNT) , 3 => Some (EVACT_A :: START) , 5 => Some (EVACT_A :: PPW) , 6 => Some (EVACT_A :: PWP) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == EVACT_A :: OFF } # [doc = "Checks if the value of the field is `RETRIGGER`"]
# [inline (always)]
pub fn is_retrigger (& self) -> bool { * self == EVACT_A :: RETRIGGER } # [doc = "Checks if the value of the field is `COUNT`"]
# [inline (always)]
pub fn is_count (& self) -> bool { * self == EVACT_A :: COUNT } # [doc = "Checks if the value of the field is `START`"]
# [inline (always)]
pub fn is_start (& self) -> bool { * self == EVACT_A :: START } # [doc = "Checks if the value of the field is `PPW`"]
# [inline (always)]
pub fn is_ppw (& self) -> bool { * self == EVACT_A :: PPW } # [doc = "Checks if the value of the field is `PWP`"]
# [inline (always)]
pub fn is_pwp (& self) -> bool { * self == EVACT_A :: PWP } } # [doc = "Field `EVACT` writer - Event Action"]
pub type EVACT_W < 'a > = crate :: FieldWriter < 'a , u16 , EVCTRL_SPEC , u8 , EVACT_A , 3 , 0 > ; impl < 'a > EVACT_W < 'a > { # [doc = "Event action disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (EVACT_A :: OFF) } # [doc = "Start, restart or retrigger TC on event"]
# [inline (always)]
pub fn retrigger (self) -> & 'a mut W { self . variant (EVACT_A :: RETRIGGER) } # [doc = "Count on event"]
# [inline (always)]
pub fn count (self) -> & 'a mut W { self . variant (EVACT_A :: COUNT) } # [doc = "Start TC on event"]
# [inline (always)]
pub fn start (self) -> & 'a mut W { self . variant (EVACT_A :: START) } # [doc = "Period captured in CC0, pulse width in CC1"]
# [inline (always)]
pub fn ppw (self) -> & 'a mut W { self . variant (EVACT_A :: PPW) } # [doc = "Period captured in CC1, pulse width in CC0"]
# [inline (always)]
pub fn pwp (self) -> & 'a mut W { self . variant (EVACT_A :: PWP) } } # [doc = "Field `TCINV` reader - TC Inverted Event Input"]
pub type TCINV_R = crate :: BitReader < bool > ; # [doc = "Field `TCINV` writer - TC Inverted Event Input"]
pub type TCINV_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 4 > ; # [doc = "Field `TCEI` reader - TC Event Input"]
pub type TCEI_R = crate :: BitReader < bool > ; # [doc = "Field `TCEI` writer - TC Event Input"]
pub type TCEI_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 5 > ; # [doc = "Field `OVFEO` reader - Overflow/Underflow Event Output Enable"]
pub type OVFEO_R = crate :: BitReader < bool > ; # [doc = "Field `OVFEO` writer - Overflow/Underflow Event Output Enable"]
pub type OVFEO_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 8 > ; # [doc = "Field `MCEO0` reader - Match or Capture Channel 0 Event Output Enable"]
pub type MCEO0_R = crate :: BitReader < bool > ; # [doc = "Field `MCEO0` writer - Match or Capture Channel 0 Event Output Enable"]
pub type MCEO0_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 12 > ; # [doc = "Field `MCEO1` reader - Match or Capture Channel 1 Event Output Enable"]
pub type MCEO1_R = crate :: BitReader < bool > ; # [doc = "Field `MCEO1` writer - Match or Capture Channel 1 Event Output Enable"]
pub type MCEO1_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 13 > ; impl R { # [doc = "Bits 0:2 - Event Action"]
# [inline (always)]
pub fn evact (& self) -> EVACT_R { EVACT_R :: new ((self . bits & 7) as u8) } # [doc = "Bit 4 - TC Inverted Event Input"]
# [inline (always)]
pub fn tcinv (& self) -> TCINV_R { TCINV_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - TC Event Input"]
# [inline (always)]
pub fn tcei (& self) -> TCEI_R { TCEI_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 8 - Overflow/Underflow Event Output Enable"]
# [inline (always)]
pub fn ovfeo (& self) -> OVFEO_R { OVFEO_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 12 - Match or Capture Channel 0 Event Output Enable"]
# [inline (always)]
pub fn mceo0 (& self) -> MCEO0_R { MCEO0_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Match or Capture Channel 1 Event Output Enable"]
# [inline (always)]
pub fn mceo1 (& self) -> MCEO1_R { MCEO1_R :: new (((self . bits >> 13) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Event Action"]
# [inline (always)]
pub fn evact (& mut self) -> EVACT_W { EVACT_W :: new (self) } # [doc = "Bit 4 - TC Inverted Event Input"]
# [inline (always)]
pub fn tcinv (& mut self) -> TCINV_W { TCINV_W :: new (self) } # [doc = "Bit 5 - TC Event Input"]
# [inline (always)]
pub fn tcei (& mut self) -> TCEI_W { TCEI_W :: new (self) } # [doc = "Bit 8 - Overflow/Underflow Event Output Enable"]
# [inline (always)]
pub fn ovfeo (& mut self) -> OVFEO_W { OVFEO_W :: new (self) } # [doc = "Bit 12 - Match or Capture Channel 0 Event Output Enable"]
# [inline (always)]
pub fn mceo0 (& mut self) -> MCEO0_W { MCEO0_W :: new (self) } # [doc = "Bit 13 - Match or Capture Channel 1 Event Output Enable"]
# [inline (always)]
pub fn mceo1 (& mut self) -> MCEO1_W { MCEO1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENCLR register accessor: an alias for `Reg<INTENCLR_SPEC>`"]
pub type INTENCLR = crate :: Reg < intenclr :: INTENCLR_SPEC > ; # [doc = "Interrupt Enable Clear"]
pub mod intenclr { # [doc = "Register `INTENCLR` reader"]
pub struct R (crate :: R < INTENCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENCLR` writer"]
pub struct W (crate :: W < INTENCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVF` reader - Overflow Interrupt Enable"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow Interrupt Enable"]
pub type OVF_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 0 > ; # [doc = "Field `ERR` reader - Error Interrupt Enable"]
pub type ERR_R = crate :: BitReader < bool > ; # [doc = "Field `ERR` writer - Error Interrupt Enable"]
pub type ERR_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 1 > ; # [doc = "Field `SYNCRDY` reader - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCRDY` writer - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 3 > ; # [doc = "Field `MC0` reader - Match or Capture Channel 0 Interrupt Enable"]
pub type MC0_R = crate :: BitReader < bool > ; # [doc = "Field `MC0` writer - Match or Capture Channel 0 Interrupt Enable"]
pub type MC0_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 4 > ; # [doc = "Field `MC1` reader - Match or Capture Channel 1 Interrupt Enable"]
pub type MC1_R = crate :: BitReader < bool > ; # [doc = "Field `MC1` writer - Match or Capture Channel 1 Interrupt Enable"]
pub type MC1_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 5 > ; impl R { # [doc = "Bit 0 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Error Interrupt Enable"]
# [inline (always)]
pub fn err (& self) -> ERR_R { ERR_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& self) -> SYNCRDY_R { SYNCRDY_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Match or Capture Channel 0 Interrupt Enable"]
# [inline (always)]
pub fn mc0 (& self) -> MC0_R { MC0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Match or Capture Channel 1 Interrupt Enable"]
# [inline (always)]
pub fn mc1 (& self) -> MC1_R { MC1_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& mut self) -> OVF_W { OVF_W :: new (self) } # [doc = "Bit 1 - Error Interrupt Enable"]
# [inline (always)]
pub fn err (& mut self) -> ERR_W { ERR_W :: new (self) } # [doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& mut self) -> SYNCRDY_W { SYNCRDY_W :: new (self) } # [doc = "Bit 4 - Match or Capture Channel 0 Interrupt Enable"]
# [inline (always)]
pub fn mc0 (& mut self) -> MC0_W { MC0_W :: new (self) } # [doc = "Bit 5 - Match or Capture Channel 1 Interrupt Enable"]
# [inline (always)]
pub fn mc1 (& mut self) -> MC1_W { MC1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenclr](index.html) module"]
pub struct INTENCLR_SPEC ; impl crate :: RegisterSpec for INTENCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenclr::R](R) reader structure"]
impl crate :: Readable for INTENCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenclr::W](W) writer structure"]
impl crate :: Writable for INTENCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENCLR to value 0"]
impl crate :: Resettable for INTENCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENSET register accessor: an alias for `Reg<INTENSET_SPEC>`"]
pub type INTENSET = crate :: Reg < intenset :: INTENSET_SPEC > ; # [doc = "Interrupt Enable Set"]
pub mod intenset { # [doc = "Register `INTENSET` reader"]
pub struct R (crate :: R < INTENSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENSET` writer"]
pub struct W (crate :: W < INTENSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVF` reader - Overflow Interrupt Enable"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow Interrupt Enable"]
pub type OVF_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 0 > ; # [doc = "Field `ERR` reader - Error Interrupt Enable"]
pub type ERR_R = crate :: BitReader < bool > ; # [doc = "Field `ERR` writer - Error Interrupt Enable"]
pub type ERR_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 1 > ; # [doc = "Field `SYNCRDY` reader - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCRDY` writer - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 3 > ; # [doc = "Field `MC0` reader - Match or Capture Channel 0 Interrupt Enable"]
pub type MC0_R = crate :: BitReader < bool > ; # [doc = "Field `MC0` writer - Match or Capture Channel 0 Interrupt Enable"]
pub type MC0_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 4 > ; # [doc = "Field `MC1` reader - Match or Capture Channel 1 Interrupt Enable"]
pub type MC1_R = crate :: BitReader < bool > ; # [doc = "Field `MC1` writer - Match or Capture Channel 1 Interrupt Enable"]
pub type MC1_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 5 > ; impl R { # [doc = "Bit 0 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Error Interrupt Enable"]
# [inline (always)]
pub fn err (& self) -> ERR_R { ERR_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& self) -> SYNCRDY_R { SYNCRDY_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Match or Capture Channel 0 Interrupt Enable"]
# [inline (always)]
pub fn mc0 (& self) -> MC0_R { MC0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Match or Capture Channel 1 Interrupt Enable"]
# [inline (always)]
pub fn mc1 (& self) -> MC1_R { MC1_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& mut self) -> OVF_W { OVF_W :: new (self) } # [doc = "Bit 1 - Error Interrupt Enable"]
# [inline (always)]
pub fn err (& mut self) -> ERR_W { ERR_W :: new (self) } # [doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& mut self) -> SYNCRDY_W { SYNCRDY_W :: new (self) } # [doc = "Bit 4 - Match or Capture Channel 0 Interrupt Enable"]
# [inline (always)]
pub fn mc0 (& mut self) -> MC0_W { MC0_W :: new (self) } # [doc = "Bit 5 - Match or Capture Channel 1 Interrupt Enable"]
# [inline (always)]
pub fn mc1 (& mut self) -> MC1_W { MC1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenset](index.html) module"]
pub struct INTENSET_SPEC ; impl crate :: RegisterSpec for INTENSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenset::R](R) reader structure"]
impl crate :: Readable for INTENSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenset::W](W) writer structure"]
impl crate :: Writable for INTENSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENSET to value 0"]
impl crate :: Resettable for INTENSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTFLAG register accessor: an alias for `Reg<INTFLAG_SPEC>`"]
pub type INTFLAG = crate :: Reg < intflag :: INTFLAG_SPEC > ; # [doc = "Interrupt Flag Status and Clear"]
pub mod intflag { # [doc = "Register `INTFLAG` reader"]
pub struct R (crate :: R < INTFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAG` writer"]
pub struct W (crate :: W < INTFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVF` reader - Overflow"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow"]
pub type OVF_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 0 > ; # [doc = "Field `ERR` reader - Error"]
pub type ERR_R = crate :: BitReader < bool > ; # [doc = "Field `ERR` writer - Error"]
pub type ERR_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 1 > ; # [doc = "Field `SYNCRDY` reader - Synchronization Ready"]
pub type SYNCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCRDY` writer - Synchronization Ready"]
pub type SYNCRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 3 > ; # [doc = "Field `MC0` reader - Match or Capture Channel 0"]
pub type MC0_R = crate :: BitReader < bool > ; # [doc = "Field `MC0` writer - Match or Capture Channel 0"]
pub type MC0_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 4 > ; # [doc = "Field `MC1` reader - Match or Capture Channel 1"]
pub type MC1_R = crate :: BitReader < bool > ; # [doc = "Field `MC1` writer - Match or Capture Channel 1"]
pub type MC1_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 5 > ; impl R { # [doc = "Bit 0 - Overflow"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Error"]
# [inline (always)]
pub fn err (& self) -> ERR_R { ERR_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 3 - Synchronization Ready"]
# [inline (always)]
pub fn syncrdy (& self) -> SYNCRDY_R { SYNCRDY_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Match or Capture Channel 0"]
# [inline (always)]
pub fn mc0 (& self) -> MC0_R { MC0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Match or Capture Channel 1"]
# [inline (always)]
pub fn mc1 (& self) -> MC1_R { MC1_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow"]
# [inline (always)]
pub fn ovf (& mut self) -> OVF_W { OVF_W :: new (self) } # [doc = "Bit 1 - Error"]
# [inline (always)]
pub fn err (& mut self) -> ERR_W { ERR_W :: new (self) } # [doc = "Bit 3 - Synchronization Ready"]
# [inline (always)]
pub fn syncrdy (& mut self) -> SYNCRDY_W { SYNCRDY_W :: new (self) } # [doc = "Bit 4 - Match or Capture Channel 0"]
# [inline (always)]
pub fn mc0 (& mut self) -> MC0_W { MC0_W :: new (self) } # [doc = "Bit 5 - Match or Capture Channel 1"]
# [inline (always)]
pub fn mc1 (& mut self) -> MC1_W { MC1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflag](index.html) module"]
pub struct INTFLAG_SPEC ; impl crate :: RegisterSpec for INTFLAG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflag::R](R) reader structure"]
impl crate :: Readable for INTFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflag::W](W) writer structure"]
impl crate :: Writable for INTFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTFLAG to value 0"]
impl crate :: Resettable for INTFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATUS register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `STOP` reader - Stop"]
pub type STOP_R = crate :: BitReader < bool > ; # [doc = "Field `SLAVE` reader - Slave"]
pub type SLAVE_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCBUSY` reader - Synchronization Busy"]
pub type SYNCBUSY_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 3 - Stop"]
# [inline (always)]
pub fn stop (& self) -> STOP_R { STOP_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Slave"]
# [inline (always)]
pub fn slave (& self) -> SLAVE_R { SLAVE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 7 - Synchronization Busy"]
# [inline (always)]
pub fn syncbusy (& self) -> SYNCBUSY_R { SYNCBUSY_R :: new (((self . bits >> 7) & 1) != 0) } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATUS to value 0x08"]
impl crate :: Resettable for STATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x08 } } } # [doc = "COUNT register accessor: an alias for `Reg<COUNT_SPEC>`"]
pub type COUNT = crate :: Reg < count :: COUNT_SPEC > ; # [doc = "COUNT8 Counter Value"]
pub mod count { # [doc = "Register `COUNT` reader"]
pub struct R (crate :: R < COUNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < COUNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < COUNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < COUNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `COUNT` writer"]
pub struct W (crate :: W < COUNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < COUNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < COUNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < COUNT_SPEC >) -> Self { W (writer) } } # [doc = "Field `COUNT` reader - Counter Value"]
pub type COUNT_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `COUNT` writer - Counter Value"]
pub type COUNT_W < 'a > = crate :: FieldWriter < 'a , u8 , COUNT_SPEC , u8 , u8 , 8 , 0 > ; impl R { # [doc = "Bits 0:7 - Counter Value"]
# [inline (always)]
pub fn count (& self) -> COUNT_R { COUNT_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Counter Value"]
# [inline (always)]
pub fn count (& mut self) -> COUNT_W { COUNT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "COUNT8 Counter Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [count](index.html) module"]
pub struct COUNT_SPEC ; impl crate :: RegisterSpec for COUNT_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [count::R](R) reader structure"]
impl crate :: Readable for COUNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [count::W](W) writer structure"]
impl crate :: Writable for COUNT_SPEC { type Writer = W ; } # [doc = "`reset()` method sets COUNT to value 0"]
impl crate :: Resettable for COUNT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PER register accessor: an alias for `Reg<PER_SPEC>`"]
pub type PER = crate :: Reg < per :: PER_SPEC > ; # [doc = "COUNT8 Period Value"]
pub mod per { # [doc = "Register `PER` reader"]
pub struct R (crate :: R < PER_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PER_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PER_SPEC >) -> Self { R (reader) } } # [doc = "Register `PER` writer"]
pub struct W (crate :: W < PER_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PER_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PER_SPEC >) -> Self { W (writer) } } # [doc = "Field `PER` reader - Period Value"]
pub type PER_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `PER` writer - Period Value"]
pub type PER_W < 'a > = crate :: FieldWriter < 'a , u8 , PER_SPEC , u8 , u8 , 8 , 0 > ; impl R { # [doc = "Bits 0:7 - Period Value"]
# [inline (always)]
pub fn per (& self) -> PER_R { PER_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Period Value"]
# [inline (always)]
pub fn per (& mut self) -> PER_W { PER_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "COUNT8 Period Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [per](index.html) module"]
pub struct PER_SPEC ; impl crate :: RegisterSpec for PER_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [per::R](R) reader structure"]
impl crate :: Readable for PER_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [per::W](W) writer structure"]
impl crate :: Writable for PER_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PER to value 0xff"]
impl crate :: Resettable for PER_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0xff } } } # [doc = "CC register accessor: an alias for `Reg<CC_SPEC>`"]
pub type CC = crate :: Reg < cc :: CC_SPEC > ; # [doc = "COUNT8 Compare/Capture"]
pub mod cc { # [doc = "Register `CC%s` reader"]
pub struct R (crate :: R < CC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CC%s` writer"]
pub struct W (crate :: W < CC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CC_SPEC >) -> Self { W (writer) } } # [doc = "Field `CC` reader - Compare/Capture Value"]
pub type CC_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `CC` writer - Compare/Capture Value"]
pub type CC_W < 'a > = crate :: FieldWriter < 'a , u8 , CC_SPEC , u8 , u8 , 8 , 0 > ; impl R { # [doc = "Bits 0:7 - Compare/Capture Value"]
# [inline (always)]
pub fn cc (& self) -> CC_R { CC_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Compare/Capture Value"]
# [inline (always)]
pub fn cc (& mut self) -> CC_W { CC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "COUNT8 Compare/Capture\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cc](index.html) module"]
pub struct CC_SPEC ; impl crate :: RegisterSpec for CC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [cc::R](R) reader structure"]
impl crate :: Readable for CC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cc::W](W) writer structure"]
impl crate :: Writable for CC_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CC%s to value 0"]
impl crate :: Resettable for CC_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = r"Register block"]
# [repr (C)]
pub struct COUNT16 { # [doc = "0x00 - Control A"]
pub ctrla : crate :: Reg < self :: count16 :: ctrla :: CTRLA_SPEC > , # [doc = "0x02 - Read Request"]
pub readreq : crate :: Reg < self :: count16 :: readreq :: READREQ_SPEC > , # [doc = "0x04 - Control B Clear"]
pub ctrlbclr : crate :: Reg < self :: count16 :: ctrlbclr :: CTRLBCLR_SPEC > , # [doc = "0x05 - Control B Set"]
pub ctrlbset : crate :: Reg < self :: count16 :: ctrlbset :: CTRLBSET_SPEC > , # [doc = "0x06 - Control C"]
pub ctrlc : crate :: Reg < self :: count16 :: ctrlc :: CTRLC_SPEC > , _reserved5 : [u8 ; 0x01]
, # [doc = "0x08 - Debug Control"]
pub dbgctrl : crate :: Reg < self :: count16 :: dbgctrl :: DBGCTRL_SPEC > , _reserved6 : [u8 ; 0x01]
, # [doc = "0x0a - Event Control"]
pub evctrl : crate :: Reg < self :: count16 :: evctrl :: EVCTRL_SPEC > , # [doc = "0x0c - Interrupt Enable Clear"]
pub intenclr : crate :: Reg < self :: count16 :: intenclr :: INTENCLR_SPEC > , # [doc = "0x0d - Interrupt Enable Set"]
pub intenset : crate :: Reg < self :: count16 :: intenset :: INTENSET_SPEC > , # [doc = "0x0e - Interrupt Flag Status and Clear"]
pub intflag : crate :: Reg < self :: count16 :: intflag :: INTFLAG_SPEC > , # [doc = "0x0f - Status"]
pub status : crate :: Reg < self :: count16 :: status :: STATUS_SPEC > , # [doc = "0x10 - COUNT16 Counter Value"]
pub count : crate :: Reg < self :: count16 :: count :: COUNT_SPEC > , _reserved12 : [u8 ; 0x06]
, # [doc = "0x18 - COUNT16 Compare/Capture"]
pub cc : [crate :: Reg < self :: count16 :: cc :: CC_SPEC > ; 2]
, } # [doc = r"Register block"]
# [doc = "16-bit Counter Mode"]
pub mod count16 { # [doc = "CTRLA register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWRST` writer - Software Reset"]
pub type SWRST_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLA_SPEC , bool , 0 > ; # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLA_SPEC , bool , 1 > ; # [doc = "TC Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum MODE_A { # [doc = "0: Counter in 16-bit mode"]
COUNT16 = 0 , # [doc = "1: Counter in 8-bit mode"]
COUNT8 = 1 , # [doc = "2: Counter in 32-bit mode"]
COUNT32 = 2 , } impl From < MODE_A > for u8 { # [inline (always)]
fn from (variant : MODE_A) -> Self { variant as _ } } # [doc = "Field `MODE` reader - TC Mode"]
pub type MODE_R = crate :: FieldReader < u8 , MODE_A > ; impl MODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < MODE_A > { match self . bits { 0 => Some (MODE_A :: COUNT16) , 1 => Some (MODE_A :: COUNT8) , 2 => Some (MODE_A :: COUNT32) , _ => None , } } # [doc = "Checks if the value of the field is `COUNT16`"]
# [inline (always)]
pub fn is_count16 (& self) -> bool { * self == MODE_A :: COUNT16 } # [doc = "Checks if the value of the field is `COUNT8`"]
# [inline (always)]
pub fn is_count8 (& self) -> bool { * self == MODE_A :: COUNT8 } # [doc = "Checks if the value of the field is `COUNT32`"]
# [inline (always)]
pub fn is_count32 (& self) -> bool { * self == MODE_A :: COUNT32 } } # [doc = "Field `MODE` writer - TC Mode"]
pub type MODE_W < 'a > = crate :: FieldWriter < 'a , u16 , CTRLA_SPEC , u8 , MODE_A , 2 , 2 > ; impl < 'a > MODE_W < 'a > { # [doc = "Counter in 16-bit mode"]
# [inline (always)]
pub fn count16 (self) -> & 'a mut W { self . variant (MODE_A :: COUNT16) } # [doc = "Counter in 8-bit mode"]
# [inline (always)]
pub fn count8 (self) -> & 'a mut W { self . variant (MODE_A :: COUNT8) } # [doc = "Counter in 32-bit mode"]
# [inline (always)]
pub fn count32 (self) -> & 'a mut W { self . variant (MODE_A :: COUNT32) } } # [doc = "Waveform Generation Operation\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum WAVEGEN_A { # [doc = "0: `0`"]
NFRQ = 0 , # [doc = "1: `1`"]
MFRQ = 1 , # [doc = "2: `10`"]
NPWM = 2 , # [doc = "3: `11`"]
MPWM = 3 , } impl From < WAVEGEN_A > for u8 { # [inline (always)]
fn from (variant : WAVEGEN_A) -> Self { variant as _ } } # [doc = "Field `WAVEGEN` reader - Waveform Generation Operation"]
pub type WAVEGEN_R = crate :: FieldReader < u8 , WAVEGEN_A > ; impl WAVEGEN_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> WAVEGEN_A { match self . bits { 0 => WAVEGEN_A :: NFRQ , 1 => WAVEGEN_A :: MFRQ , 2 => WAVEGEN_A :: NPWM , 3 => WAVEGEN_A :: MPWM , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NFRQ`"]
# [inline (always)]
pub fn is_nfrq (& self) -> bool { * self == WAVEGEN_A :: NFRQ } # [doc = "Checks if the value of the field is `MFRQ`"]
# [inline (always)]
pub fn is_mfrq (& self) -> bool { * self == WAVEGEN_A :: MFRQ } # [doc = "Checks if the value of the field is `NPWM`"]
# [inline (always)]
pub fn is_npwm (& self) -> bool { * self == WAVEGEN_A :: NPWM } # [doc = "Checks if the value of the field is `MPWM`"]
# [inline (always)]
pub fn is_mpwm (& self) -> bool { * self == WAVEGEN_A :: MPWM } } # [doc = "Field `WAVEGEN` writer - Waveform Generation Operation"]
pub type WAVEGEN_W < 'a > = crate :: FieldWriterSafe < 'a , u16 , CTRLA_SPEC , u8 , WAVEGEN_A , 2 , 5 > ; impl < 'a > WAVEGEN_W < 'a > { # [doc = "`0`"]
# [inline (always)]
pub fn nfrq (self) -> & 'a mut W { self . variant (WAVEGEN_A :: NFRQ) } # [doc = "`1`"]
# [inline (always)]
pub fn mfrq (self) -> & 'a mut W { self . variant (WAVEGEN_A :: MFRQ) } # [doc = "`10`"]
# [inline (always)]
pub fn npwm (self) -> & 'a mut W { self . variant (WAVEGEN_A :: NPWM) } # [doc = "`11`"]
# [inline (always)]
pub fn mpwm (self) -> & 'a mut W { self . variant (WAVEGEN_A :: MPWM) } } # [doc = "Prescaler\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum PRESCALER_A { # [doc = "0: Prescaler: GCLK_TC"]
DIV1 = 0 , # [doc = "1: Prescaler: GCLK_TC/2"]
DIV2 = 1 , # [doc = "2: Prescaler: GCLK_TC/4"]
DIV4 = 2 , # [doc = "3: Prescaler: GCLK_TC/8"]
DIV8 = 3 , # [doc = "4: Prescaler: GCLK_TC/16"]
DIV16 = 4 , # [doc = "5: Prescaler: GCLK_TC/64"]
DIV64 = 5 , # [doc = "6: Prescaler: GCLK_TC/256"]
DIV256 = 6 , # [doc = "7: Prescaler: GCLK_TC/1024"]
DIV1024 = 7 , } impl From < PRESCALER_A > for u8 { # [inline (always)]
fn from (variant : PRESCALER_A) -> Self { variant as _ } } # [doc = "Field `PRESCALER` reader - Prescaler"]
pub type PRESCALER_R = crate :: FieldReader < u8 , PRESCALER_A > ; impl PRESCALER_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PRESCALER_A { match self . bits { 0 => PRESCALER_A :: DIV1 , 1 => PRESCALER_A :: DIV2 , 2 => PRESCALER_A :: DIV4 , 3 => PRESCALER_A :: DIV8 , 4 => PRESCALER_A :: DIV16 , 5 => PRESCALER_A :: DIV64 , 6 => PRESCALER_A :: DIV256 , 7 => PRESCALER_A :: DIV1024 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == PRESCALER_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == PRESCALER_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == PRESCALER_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == PRESCALER_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == PRESCALER_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == PRESCALER_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == PRESCALER_A :: DIV256 } # [doc = "Checks if the value of the field is `DIV1024`"]
# [inline (always)]
pub fn is_div1024 (& self) -> bool { * self == PRESCALER_A :: DIV1024 } } # [doc = "Field `PRESCALER` writer - Prescaler"]
pub type PRESCALER_W < 'a > = crate :: FieldWriterSafe < 'a , u16 , CTRLA_SPEC , u8 , PRESCALER_A , 3 , 8 > ; impl < 'a > PRESCALER_W < 'a > { # [doc = "Prescaler: GCLK_TC"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV1) } # [doc = "Prescaler: GCLK_TC/2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV2) } # [doc = "Prescaler: GCLK_TC/4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV4) } # [doc = "Prescaler: GCLK_TC/8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV8) } # [doc = "Prescaler: GCLK_TC/16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV16) } # [doc = "Prescaler: GCLK_TC/64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV64) } # [doc = "Prescaler: GCLK_TC/256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV256) } # [doc = "Prescaler: GCLK_TC/1024"]
# [inline (always)]
pub fn div1024 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV1024) } } # [doc = "Field `RUNSTDBY` reader - Run in Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run in Standby"]
pub type RUNSTDBY_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLA_SPEC , bool , 11 > ; # [doc = "Prescaler and Counter Synchronization\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum PRESCSYNC_A { # [doc = "0: Reload or reset the counter on next generic clock"]
GCLK = 0 , # [doc = "1: Reload or reset the counter on next prescaler clock"]
PRESC = 1 , # [doc = "2: Reload or reset the counter on next generic clock. Reset the prescaler counter"]
RESYNC = 2 , } impl From < PRESCSYNC_A > for u8 { # [inline (always)]
fn from (variant : PRESCSYNC_A) -> Self { variant as _ } } # [doc = "Field `PRESCSYNC` reader - Prescaler and Counter Synchronization"]
pub type PRESCSYNC_R = crate :: FieldReader < u8 , PRESCSYNC_A > ; impl PRESCSYNC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PRESCSYNC_A > { match self . bits { 0 => Some (PRESCSYNC_A :: GCLK) , 1 => Some (PRESCSYNC_A :: PRESC) , 2 => Some (PRESCSYNC_A :: RESYNC) , _ => None , } } # [doc = "Checks if the value of the field is `GCLK`"]
# [inline (always)]
pub fn is_gclk (& self) -> bool { * self == PRESCSYNC_A :: GCLK } # [doc = "Checks if the value of the field is `PRESC`"]
# [inline (always)]
pub fn is_presc (& self) -> bool { * self == PRESCSYNC_A :: PRESC } # [doc = "Checks if the value of the field is `RESYNC`"]
# [inline (always)]
pub fn is_resync (& self) -> bool { * self == PRESCSYNC_A :: RESYNC } } # [doc = "Field `PRESCSYNC` writer - Prescaler and Counter Synchronization"]
pub type PRESCSYNC_W < 'a > = crate :: FieldWriter < 'a , u16 , CTRLA_SPEC , u8 , PRESCSYNC_A , 2 , 12 > ; impl < 'a > PRESCSYNC_W < 'a > { # [doc = "Reload or reset the counter on next generic clock"]
# [inline (always)]
pub fn gclk (self) -> & 'a mut W { self . variant (PRESCSYNC_A :: GCLK) } # [doc = "Reload or reset the counter on next prescaler clock"]
# [inline (always)]
pub fn presc (self) -> & 'a mut W { self . variant (PRESCSYNC_A :: PRESC) } # [doc = "Reload or reset the counter on next generic clock. Reset the prescaler counter"]
# [inline (always)]
pub fn resync (self) -> & 'a mut W { self . variant (PRESCSYNC_A :: RESYNC) } } impl R { # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - TC Mode"]
# [inline (always)]
pub fn mode (& self) -> MODE_R { MODE_R :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bits 5:6 - Waveform Generation Operation"]
# [inline (always)]
pub fn wavegen (& self) -> WAVEGEN_R { WAVEGEN_R :: new (((self . bits >> 5) & 3) as u8) } # [doc = "Bits 8:10 - Prescaler"]
# [inline (always)]
pub fn prescaler (& self) -> PRESCALER_R { PRESCALER_R :: new (((self . bits >> 8) & 7) as u8) } # [doc = "Bit 11 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bits 12:13 - Prescaler and Counter Synchronization"]
# [inline (always)]
pub fn prescsync (& self) -> PRESCSYNC_R { PRESCSYNC_R :: new (((self . bits >> 12) & 3) as u8) } } impl W { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& mut self) -> SWRST_W { SWRST_W :: new (self) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Bits 2:3 - TC Mode"]
# [inline (always)]
pub fn mode (& mut self) -> MODE_W { MODE_W :: new (self) } # [doc = "Bits 5:6 - Waveform Generation Operation"]
# [inline (always)]
pub fn wavegen (& mut self) -> WAVEGEN_W { WAVEGEN_W :: new (self) } # [doc = "Bits 8:10 - Prescaler"]
# [inline (always)]
pub fn prescaler (& mut self) -> PRESCALER_W { PRESCALER_W :: new (self) } # [doc = "Bit 11 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& mut self) -> RUNSTDBY_W { RUNSTDBY_W :: new (self) } # [doc = "Bits 12:13 - Prescaler and Counter Synchronization"]
# [inline (always)]
pub fn prescsync (& mut self) -> PRESCSYNC_W { PRESCSYNC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "READREQ register accessor: an alias for `Reg<READREQ_SPEC>`"]
pub type READREQ = crate :: Reg < readreq :: READREQ_SPEC > ; # [doc = "Read Request"]
pub mod readreq { # [doc = "Register `READREQ` reader"]
pub struct R (crate :: R < READREQ_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < READREQ_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < READREQ_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < READREQ_SPEC >) -> Self { R (reader) } } # [doc = "Register `READREQ` writer"]
pub struct W (crate :: W < READREQ_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < READREQ_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < READREQ_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < READREQ_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADDR` reader - Address"]
pub type ADDR_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `ADDR` writer - Address"]
pub type ADDR_W < 'a > = crate :: FieldWriter < 'a , u16 , READREQ_SPEC , u8 , u8 , 5 , 0 > ; # [doc = "Field `RCONT` reader - Read Continuously"]
pub type RCONT_R = crate :: BitReader < bool > ; # [doc = "Field `RCONT` writer - Read Continuously"]
pub type RCONT_W < 'a > = crate :: BitWriter < 'a , u16 , READREQ_SPEC , bool , 14 > ; # [doc = "Field `RREQ` reader - Read Request"]
pub type RREQ_R = crate :: BitReader < bool > ; # [doc = "Field `RREQ` writer - Read Request"]
pub type RREQ_W < 'a > = crate :: BitWriter < 'a , u16 , READREQ_SPEC , bool , 15 > ; impl R { # [doc = "Bits 0:4 - Address"]
# [inline (always)]
pub fn addr (& self) -> ADDR_R { ADDR_R :: new ((self . bits & 0x1f) as u8) } # [doc = "Bit 14 - Read Continuously"]
# [inline (always)]
pub fn rcont (& self) -> RCONT_R { RCONT_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Read Request"]
# [inline (always)]
pub fn rreq (& self) -> RREQ_R { RREQ_R :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bits 0:4 - Address"]
# [inline (always)]
pub fn addr (& mut self) -> ADDR_W { ADDR_W :: new (self) } # [doc = "Bit 14 - Read Continuously"]
# [inline (always)]
pub fn rcont (& mut self) -> RCONT_W { RCONT_W :: new (self) } # [doc = "Bit 15 - Read Request"]
# [inline (always)]
pub fn rreq (& mut self) -> RREQ_W { RREQ_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Read Request\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [readreq](index.html) module"]
pub struct READREQ_SPEC ; impl crate :: RegisterSpec for READREQ_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [readreq::R](R) reader structure"]
impl crate :: Readable for READREQ_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [readreq::W](W) writer structure"]
impl crate :: Writable for READREQ_SPEC { type Writer = W ; } # [doc = "`reset()` method sets READREQ to value 0"]
impl crate :: Resettable for READREQ_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CTRLBCLR register accessor: an alias for `Reg<CTRLBCLR_SPEC>`"]
pub type CTRLBCLR = crate :: Reg < ctrlbclr :: CTRLBCLR_SPEC > ; # [doc = "Control B Clear"]
pub mod ctrlbclr { # [doc = "Register `CTRLBCLR` reader"]
pub struct R (crate :: R < CTRLBCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLBCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLBCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLBCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLBCLR` writer"]
pub struct W (crate :: W < CTRLBCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLBCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLBCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLBCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Counter Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` writer - Counter Direction"]
pub type DIR_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLBCLR_SPEC , bool , 0 > ; # [doc = "Field `ONESHOT` reader - One-Shot"]
pub type ONESHOT_R = crate :: BitReader < bool > ; # [doc = "Field `ONESHOT` writer - One-Shot"]
pub type ONESHOT_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLBCLR_SPEC , bool , 2 > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No action"]
NONE = 0 , # [doc = "1: Force a start, restart or retrigger"]
RETRIGGER = 1 , # [doc = "2: Force a stop"]
STOP = 2 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CMD_A > { match self . bits { 0 => Some (CMD_A :: NONE) , 1 => Some (CMD_A :: RETRIGGER) , 2 => Some (CMD_A :: STOP) , _ => None , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == CMD_A :: NONE } # [doc = "Checks if the value of the field is `RETRIGGER`"]
# [inline (always)]
pub fn is_retrigger (& self) -> bool { * self == CMD_A :: RETRIGGER } # [doc = "Checks if the value of the field is `STOP`"]
# [inline (always)]
pub fn is_stop (& self) -> bool { * self == CMD_A :: STOP } } # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a > = crate :: FieldWriter < 'a , u8 , CTRLBCLR_SPEC , u8 , CMD_A , 2 , 6 > ; impl < 'a > CMD_W < 'a > { # [doc = "No action"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (CMD_A :: NONE) } # [doc = "Force a start, restart or retrigger"]
# [inline (always)]
pub fn retrigger (self) -> & 'a mut W { self . variant (CMD_A :: RETRIGGER) } # [doc = "Force a stop"]
# [inline (always)]
pub fn stop (self) -> & 'a mut W { self . variant (CMD_A :: STOP) } } impl R { # [doc = "Bit 0 - Counter Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - One-Shot"]
# [inline (always)]
pub fn oneshot (& self) -> ONESHOT_R { ONESHOT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 6:7 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new (((self . bits >> 6) & 3) as u8) } } impl W { # [doc = "Bit 0 - Counter Direction"]
# [inline (always)]
pub fn dir (& mut self) -> DIR_W { DIR_W :: new (self) } # [doc = "Bit 2 - One-Shot"]
# [inline (always)]
pub fn oneshot (& mut self) -> ONESHOT_W { ONESHOT_W :: new (self) } # [doc = "Bits 6:7 - Command"]
# [inline (always)]
pub fn cmd (& mut self) -> CMD_W { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlbclr](index.html) module"]
pub struct CTRLBCLR_SPEC ; impl crate :: RegisterSpec for CTRLBCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlbclr::R](R) reader structure"]
impl crate :: Readable for CTRLBCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlbclr::W](W) writer structure"]
impl crate :: Writable for CTRLBCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLBCLR to value 0x02"]
impl crate :: Resettable for CTRLBCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x02 } } } # [doc = "CTRLBSET register accessor: an alias for `Reg<CTRLBSET_SPEC>`"]
pub type CTRLBSET = crate :: Reg < ctrlbset :: CTRLBSET_SPEC > ; # [doc = "Control B Set"]
pub mod ctrlbset { # [doc = "Register `CTRLBSET` reader"]
pub struct R (crate :: R < CTRLBSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLBSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLBSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLBSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLBSET` writer"]
pub struct W (crate :: W < CTRLBSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLBSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLBSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLBSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Counter Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` writer - Counter Direction"]
pub type DIR_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLBSET_SPEC , bool , 0 > ; # [doc = "Field `ONESHOT` reader - One-Shot"]
pub type ONESHOT_R = crate :: BitReader < bool > ; # [doc = "Field `ONESHOT` writer - One-Shot"]
pub type ONESHOT_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLBSET_SPEC , bool , 2 > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No action"]
NONE = 0 , # [doc = "1: Force a start, restart or retrigger"]
RETRIGGER = 1 , # [doc = "2: Force a stop"]
STOP = 2 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CMD_A > { match self . bits { 0 => Some (CMD_A :: NONE) , 1 => Some (CMD_A :: RETRIGGER) , 2 => Some (CMD_A :: STOP) , _ => None , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == CMD_A :: NONE } # [doc = "Checks if the value of the field is `RETRIGGER`"]
# [inline (always)]
pub fn is_retrigger (& self) -> bool { * self == CMD_A :: RETRIGGER } # [doc = "Checks if the value of the field is `STOP`"]
# [inline (always)]
pub fn is_stop (& self) -> bool { * self == CMD_A :: STOP } } # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a > = crate :: FieldWriter < 'a , u8 , CTRLBSET_SPEC , u8 , CMD_A , 2 , 6 > ; impl < 'a > CMD_W < 'a > { # [doc = "No action"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (CMD_A :: NONE) } # [doc = "Force a start, restart or retrigger"]
# [inline (always)]
pub fn retrigger (self) -> & 'a mut W { self . variant (CMD_A :: RETRIGGER) } # [doc = "Force a stop"]
# [inline (always)]
pub fn stop (self) -> & 'a mut W { self . variant (CMD_A :: STOP) } } impl R { # [doc = "Bit 0 - Counter Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - One-Shot"]
# [inline (always)]
pub fn oneshot (& self) -> ONESHOT_R { ONESHOT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 6:7 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new (((self . bits >> 6) & 3) as u8) } } impl W { # [doc = "Bit 0 - Counter Direction"]
# [inline (always)]
pub fn dir (& mut self) -> DIR_W { DIR_W :: new (self) } # [doc = "Bit 2 - One-Shot"]
# [inline (always)]
pub fn oneshot (& mut self) -> ONESHOT_W { ONESHOT_W :: new (self) } # [doc = "Bits 6:7 - Command"]
# [inline (always)]
pub fn cmd (& mut self) -> CMD_W { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlbset](index.html) module"]
pub struct CTRLBSET_SPEC ; impl crate :: RegisterSpec for CTRLBSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlbset::R](R) reader structure"]
impl crate :: Readable for CTRLBSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlbset::W](W) writer structure"]
impl crate :: Writable for CTRLBSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLBSET to value 0"]
impl crate :: Resettable for CTRLBSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CTRLC register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `INVEN0` reader - Output Waveform 0 Invert Enable"]
pub type INVEN0_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN0` writer - Output Waveform 0 Invert Enable"]
pub type INVEN0_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , 0 > ; # [doc = "Field `INVEN1` reader - Output Waveform 1 Invert Enable"]
pub type INVEN1_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN1` writer - Output Waveform 1 Invert Enable"]
pub type INVEN1_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , 1 > ; # [doc = "Field `CPTEN0` reader - Capture Channel 0 Enable"]
pub type CPTEN0_R = crate :: BitReader < bool > ; # [doc = "Field `CPTEN0` writer - Capture Channel 0 Enable"]
pub type CPTEN0_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , 4 > ; # [doc = "Field `CPTEN1` reader - Capture Channel 1 Enable"]
pub type CPTEN1_R = crate :: BitReader < bool > ; # [doc = "Field `CPTEN1` writer - Capture Channel 1 Enable"]
pub type CPTEN1_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , 5 > ; impl R { # [doc = "Bit 0 - Output Waveform 0 Invert Enable"]
# [inline (always)]
pub fn inven0 (& self) -> INVEN0_R { INVEN0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Output Waveform 1 Invert Enable"]
# [inline (always)]
pub fn inven1 (& self) -> INVEN1_R { INVEN1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - Capture Channel 0 Enable"]
# [inline (always)]
pub fn cpten0 (& self) -> CPTEN0_R { CPTEN0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Capture Channel 1 Enable"]
# [inline (always)]
pub fn cpten1 (& self) -> CPTEN1_R { CPTEN1_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Output Waveform 0 Invert Enable"]
# [inline (always)]
pub fn inven0 (& mut self) -> INVEN0_W { INVEN0_W :: new (self) } # [doc = "Bit 1 - Output Waveform 1 Invert Enable"]
# [inline (always)]
pub fn inven1 (& mut self) -> INVEN1_W { INVEN1_W :: new (self) } # [doc = "Bit 4 - Capture Channel 0 Enable"]
# [inline (always)]
pub fn cpten0 (& mut self) -> CPTEN0_W { CPTEN0_W :: new (self) } # [doc = "Bit 5 - Capture Channel 1 Enable"]
# [inline (always)]
pub fn cpten1 (& mut self) -> CPTEN1_W { CPTEN1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DBGCTRL register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Debug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Debug Run Mode"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Debug Run Mode"]
pub type DBGRUN_W < 'a > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , 0 > ; impl R { # [doc = "Bit 0 - Debug Run Mode"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug Run Mode"]
# [inline (always)]
pub fn dbgrun (& mut self) -> DBGRUN_W { DBGRUN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "EVCTRL register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "Event Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Event Action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum EVACT_A { # [doc = "0: Event action disabled"]
OFF = 0 , # [doc = "1: Start, restart or retrigger TC on event"]
RETRIGGER = 1 , # [doc = "2: Count on event"]
COUNT = 2 , # [doc = "3: Start TC on event"]
START = 3 , # [doc = "5: Period captured in CC0, pulse width in CC1"]
PPW = 5 , # [doc = "6: Period captured in CC1, pulse width in CC0"]
PWP = 6 , } impl From < EVACT_A > for u8 { # [inline (always)]
fn from (variant : EVACT_A) -> Self { variant as _ } } # [doc = "Field `EVACT` reader - Event Action"]
pub type EVACT_R = crate :: FieldReader < u8 , EVACT_A > ; impl EVACT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < EVACT_A > { match self . bits { 0 => Some (EVACT_A :: OFF) , 1 => Some (EVACT_A :: RETRIGGER) , 2 => Some (EVACT_A :: COUNT) , 3 => Some (EVACT_A :: START) , 5 => Some (EVACT_A :: PPW) , 6 => Some (EVACT_A :: PWP) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == EVACT_A :: OFF } # [doc = "Checks if the value of the field is `RETRIGGER`"]
# [inline (always)]
pub fn is_retrigger (& self) -> bool { * self == EVACT_A :: RETRIGGER } # [doc = "Checks if the value of the field is `COUNT`"]
# [inline (always)]
pub fn is_count (& self) -> bool { * self == EVACT_A :: COUNT } # [doc = "Checks if the value of the field is `START`"]
# [inline (always)]
pub fn is_start (& self) -> bool { * self == EVACT_A :: START } # [doc = "Checks if the value of the field is `PPW`"]
# [inline (always)]
pub fn is_ppw (& self) -> bool { * self == EVACT_A :: PPW } # [doc = "Checks if the value of the field is `PWP`"]
# [inline (always)]
pub fn is_pwp (& self) -> bool { * self == EVACT_A :: PWP } } # [doc = "Field `EVACT` writer - Event Action"]
pub type EVACT_W < 'a > = crate :: FieldWriter < 'a , u16 , EVCTRL_SPEC , u8 , EVACT_A , 3 , 0 > ; impl < 'a > EVACT_W < 'a > { # [doc = "Event action disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (EVACT_A :: OFF) } # [doc = "Start, restart or retrigger TC on event"]
# [inline (always)]
pub fn retrigger (self) -> & 'a mut W { self . variant (EVACT_A :: RETRIGGER) } # [doc = "Count on event"]
# [inline (always)]
pub fn count (self) -> & 'a mut W { self . variant (EVACT_A :: COUNT) } # [doc = "Start TC on event"]
# [inline (always)]
pub fn start (self) -> & 'a mut W { self . variant (EVACT_A :: START) } # [doc = "Period captured in CC0, pulse width in CC1"]
# [inline (always)]
pub fn ppw (self) -> & 'a mut W { self . variant (EVACT_A :: PPW) } # [doc = "Period captured in CC1, pulse width in CC0"]
# [inline (always)]
pub fn pwp (self) -> & 'a mut W { self . variant (EVACT_A :: PWP) } } # [doc = "Field `TCINV` reader - TC Inverted Event Input"]
pub type TCINV_R = crate :: BitReader < bool > ; # [doc = "Field `TCINV` writer - TC Inverted Event Input"]
pub type TCINV_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 4 > ; # [doc = "Field `TCEI` reader - TC Event Input"]
pub type TCEI_R = crate :: BitReader < bool > ; # [doc = "Field `TCEI` writer - TC Event Input"]
pub type TCEI_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 5 > ; # [doc = "Field `OVFEO` reader - Overflow/Underflow Event Output Enable"]
pub type OVFEO_R = crate :: BitReader < bool > ; # [doc = "Field `OVFEO` writer - Overflow/Underflow Event Output Enable"]
pub type OVFEO_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 8 > ; # [doc = "Field `MCEO0` reader - Match or Capture Channel 0 Event Output Enable"]
pub type MCEO0_R = crate :: BitReader < bool > ; # [doc = "Field `MCEO0` writer - Match or Capture Channel 0 Event Output Enable"]
pub type MCEO0_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 12 > ; # [doc = "Field `MCEO1` reader - Match or Capture Channel 1 Event Output Enable"]
pub type MCEO1_R = crate :: BitReader < bool > ; # [doc = "Field `MCEO1` writer - Match or Capture Channel 1 Event Output Enable"]
pub type MCEO1_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 13 > ; impl R { # [doc = "Bits 0:2 - Event Action"]
# [inline (always)]
pub fn evact (& self) -> EVACT_R { EVACT_R :: new ((self . bits & 7) as u8) } # [doc = "Bit 4 - TC Inverted Event Input"]
# [inline (always)]
pub fn tcinv (& self) -> TCINV_R { TCINV_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - TC Event Input"]
# [inline (always)]
pub fn tcei (& self) -> TCEI_R { TCEI_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 8 - Overflow/Underflow Event Output Enable"]
# [inline (always)]
pub fn ovfeo (& self) -> OVFEO_R { OVFEO_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 12 - Match or Capture Channel 0 Event Output Enable"]
# [inline (always)]
pub fn mceo0 (& self) -> MCEO0_R { MCEO0_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Match or Capture Channel 1 Event Output Enable"]
# [inline (always)]
pub fn mceo1 (& self) -> MCEO1_R { MCEO1_R :: new (((self . bits >> 13) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Event Action"]
# [inline (always)]
pub fn evact (& mut self) -> EVACT_W { EVACT_W :: new (self) } # [doc = "Bit 4 - TC Inverted Event Input"]
# [inline (always)]
pub fn tcinv (& mut self) -> TCINV_W { TCINV_W :: new (self) } # [doc = "Bit 5 - TC Event Input"]
# [inline (always)]
pub fn tcei (& mut self) -> TCEI_W { TCEI_W :: new (self) } # [doc = "Bit 8 - Overflow/Underflow Event Output Enable"]
# [inline (always)]
pub fn ovfeo (& mut self) -> OVFEO_W { OVFEO_W :: new (self) } # [doc = "Bit 12 - Match or Capture Channel 0 Event Output Enable"]
# [inline (always)]
pub fn mceo0 (& mut self) -> MCEO0_W { MCEO0_W :: new (self) } # [doc = "Bit 13 - Match or Capture Channel 1 Event Output Enable"]
# [inline (always)]
pub fn mceo1 (& mut self) -> MCEO1_W { MCEO1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENCLR register accessor: an alias for `Reg<INTENCLR_SPEC>`"]
pub type INTENCLR = crate :: Reg < intenclr :: INTENCLR_SPEC > ; # [doc = "Interrupt Enable Clear"]
pub mod intenclr { # [doc = "Register `INTENCLR` reader"]
pub struct R (crate :: R < INTENCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENCLR` writer"]
pub struct W (crate :: W < INTENCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVF` reader - Overflow Interrupt Enable"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow Interrupt Enable"]
pub type OVF_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 0 > ; # [doc = "Field `ERR` reader - Error Interrupt Enable"]
pub type ERR_R = crate :: BitReader < bool > ; # [doc = "Field `ERR` writer - Error Interrupt Enable"]
pub type ERR_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 1 > ; # [doc = "Field `SYNCRDY` reader - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCRDY` writer - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 3 > ; # [doc = "Field `MC0` reader - Match or Capture Channel 0 Interrupt Enable"]
pub type MC0_R = crate :: BitReader < bool > ; # [doc = "Field `MC0` writer - Match or Capture Channel 0 Interrupt Enable"]
pub type MC0_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 4 > ; # [doc = "Field `MC1` reader - Match or Capture Channel 1 Interrupt Enable"]
pub type MC1_R = crate :: BitReader < bool > ; # [doc = "Field `MC1` writer - Match or Capture Channel 1 Interrupt Enable"]
pub type MC1_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 5 > ; impl R { # [doc = "Bit 0 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Error Interrupt Enable"]
# [inline (always)]
pub fn err (& self) -> ERR_R { ERR_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& self) -> SYNCRDY_R { SYNCRDY_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Match or Capture Channel 0 Interrupt Enable"]
# [inline (always)]
pub fn mc0 (& self) -> MC0_R { MC0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Match or Capture Channel 1 Interrupt Enable"]
# [inline (always)]
pub fn mc1 (& self) -> MC1_R { MC1_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& mut self) -> OVF_W { OVF_W :: new (self) } # [doc = "Bit 1 - Error Interrupt Enable"]
# [inline (always)]
pub fn err (& mut self) -> ERR_W { ERR_W :: new (self) } # [doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& mut self) -> SYNCRDY_W { SYNCRDY_W :: new (self) } # [doc = "Bit 4 - Match or Capture Channel 0 Interrupt Enable"]
# [inline (always)]
pub fn mc0 (& mut self) -> MC0_W { MC0_W :: new (self) } # [doc = "Bit 5 - Match or Capture Channel 1 Interrupt Enable"]
# [inline (always)]
pub fn mc1 (& mut self) -> MC1_W { MC1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenclr](index.html) module"]
pub struct INTENCLR_SPEC ; impl crate :: RegisterSpec for INTENCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenclr::R](R) reader structure"]
impl crate :: Readable for INTENCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenclr::W](W) writer structure"]
impl crate :: Writable for INTENCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENCLR to value 0"]
impl crate :: Resettable for INTENCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENSET register accessor: an alias for `Reg<INTENSET_SPEC>`"]
pub type INTENSET = crate :: Reg < intenset :: INTENSET_SPEC > ; # [doc = "Interrupt Enable Set"]
pub mod intenset { # [doc = "Register `INTENSET` reader"]
pub struct R (crate :: R < INTENSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENSET` writer"]
pub struct W (crate :: W < INTENSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVF` reader - Overflow Interrupt Enable"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow Interrupt Enable"]
pub type OVF_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 0 > ; # [doc = "Field `ERR` reader - Error Interrupt Enable"]
pub type ERR_R = crate :: BitReader < bool > ; # [doc = "Field `ERR` writer - Error Interrupt Enable"]
pub type ERR_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 1 > ; # [doc = "Field `SYNCRDY` reader - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCRDY` writer - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 3 > ; # [doc = "Field `MC0` reader - Match or Capture Channel 0 Interrupt Enable"]
pub type MC0_R = crate :: BitReader < bool > ; # [doc = "Field `MC0` writer - Match or Capture Channel 0 Interrupt Enable"]
pub type MC0_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 4 > ; # [doc = "Field `MC1` reader - Match or Capture Channel 1 Interrupt Enable"]
pub type MC1_R = crate :: BitReader < bool > ; # [doc = "Field `MC1` writer - Match or Capture Channel 1 Interrupt Enable"]
pub type MC1_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 5 > ; impl R { # [doc = "Bit 0 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Error Interrupt Enable"]
# [inline (always)]
pub fn err (& self) -> ERR_R { ERR_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& self) -> SYNCRDY_R { SYNCRDY_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Match or Capture Channel 0 Interrupt Enable"]
# [inline (always)]
pub fn mc0 (& self) -> MC0_R { MC0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Match or Capture Channel 1 Interrupt Enable"]
# [inline (always)]
pub fn mc1 (& self) -> MC1_R { MC1_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& mut self) -> OVF_W { OVF_W :: new (self) } # [doc = "Bit 1 - Error Interrupt Enable"]
# [inline (always)]
pub fn err (& mut self) -> ERR_W { ERR_W :: new (self) } # [doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& mut self) -> SYNCRDY_W { SYNCRDY_W :: new (self) } # [doc = "Bit 4 - Match or Capture Channel 0 Interrupt Enable"]
# [inline (always)]
pub fn mc0 (& mut self) -> MC0_W { MC0_W :: new (self) } # [doc = "Bit 5 - Match or Capture Channel 1 Interrupt Enable"]
# [inline (always)]
pub fn mc1 (& mut self) -> MC1_W { MC1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenset](index.html) module"]
pub struct INTENSET_SPEC ; impl crate :: RegisterSpec for INTENSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenset::R](R) reader structure"]
impl crate :: Readable for INTENSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenset::W](W) writer structure"]
impl crate :: Writable for INTENSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENSET to value 0"]
impl crate :: Resettable for INTENSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTFLAG register accessor: an alias for `Reg<INTFLAG_SPEC>`"]
pub type INTFLAG = crate :: Reg < intflag :: INTFLAG_SPEC > ; # [doc = "Interrupt Flag Status and Clear"]
pub mod intflag { # [doc = "Register `INTFLAG` reader"]
pub struct R (crate :: R < INTFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAG` writer"]
pub struct W (crate :: W < INTFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVF` reader - Overflow"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow"]
pub type OVF_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 0 > ; # [doc = "Field `ERR` reader - Error"]
pub type ERR_R = crate :: BitReader < bool > ; # [doc = "Field `ERR` writer - Error"]
pub type ERR_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 1 > ; # [doc = "Field `SYNCRDY` reader - Synchronization Ready"]
pub type SYNCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCRDY` writer - Synchronization Ready"]
pub type SYNCRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 3 > ; # [doc = "Field `MC0` reader - Match or Capture Channel 0"]
pub type MC0_R = crate :: BitReader < bool > ; # [doc = "Field `MC0` writer - Match or Capture Channel 0"]
pub type MC0_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 4 > ; # [doc = "Field `MC1` reader - Match or Capture Channel 1"]
pub type MC1_R = crate :: BitReader < bool > ; # [doc = "Field `MC1` writer - Match or Capture Channel 1"]
pub type MC1_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 5 > ; impl R { # [doc = "Bit 0 - Overflow"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Error"]
# [inline (always)]
pub fn err (& self) -> ERR_R { ERR_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 3 - Synchronization Ready"]
# [inline (always)]
pub fn syncrdy (& self) -> SYNCRDY_R { SYNCRDY_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Match or Capture Channel 0"]
# [inline (always)]
pub fn mc0 (& self) -> MC0_R { MC0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Match or Capture Channel 1"]
# [inline (always)]
pub fn mc1 (& self) -> MC1_R { MC1_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow"]
# [inline (always)]
pub fn ovf (& mut self) -> OVF_W { OVF_W :: new (self) } # [doc = "Bit 1 - Error"]
# [inline (always)]
pub fn err (& mut self) -> ERR_W { ERR_W :: new (self) } # [doc = "Bit 3 - Synchronization Ready"]
# [inline (always)]
pub fn syncrdy (& mut self) -> SYNCRDY_W { SYNCRDY_W :: new (self) } # [doc = "Bit 4 - Match or Capture Channel 0"]
# [inline (always)]
pub fn mc0 (& mut self) -> MC0_W { MC0_W :: new (self) } # [doc = "Bit 5 - Match or Capture Channel 1"]
# [inline (always)]
pub fn mc1 (& mut self) -> MC1_W { MC1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflag](index.html) module"]
pub struct INTFLAG_SPEC ; impl crate :: RegisterSpec for INTFLAG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflag::R](R) reader structure"]
impl crate :: Readable for INTFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflag::W](W) writer structure"]
impl crate :: Writable for INTFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTFLAG to value 0"]
impl crate :: Resettable for INTFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATUS register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `STOP` reader - Stop"]
pub type STOP_R = crate :: BitReader < bool > ; # [doc = "Field `SLAVE` reader - Slave"]
pub type SLAVE_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCBUSY` reader - Synchronization Busy"]
pub type SYNCBUSY_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 3 - Stop"]
# [inline (always)]
pub fn stop (& self) -> STOP_R { STOP_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Slave"]
# [inline (always)]
pub fn slave (& self) -> SLAVE_R { SLAVE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 7 - Synchronization Busy"]
# [inline (always)]
pub fn syncbusy (& self) -> SYNCBUSY_R { SYNCBUSY_R :: new (((self . bits >> 7) & 1) != 0) } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATUS to value 0x08"]
impl crate :: Resettable for STATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x08 } } } # [doc = "COUNT register accessor: an alias for `Reg<COUNT_SPEC>`"]
pub type COUNT = crate :: Reg < count :: COUNT_SPEC > ; # [doc = "COUNT16 Counter Value"]
pub mod count { # [doc = "Register `COUNT` reader"]
pub struct R (crate :: R < COUNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < COUNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < COUNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < COUNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `COUNT` writer"]
pub struct W (crate :: W < COUNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < COUNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < COUNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < COUNT_SPEC >) -> Self { W (writer) } } # [doc = "Field `COUNT` reader - Count Value"]
pub type COUNT_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `COUNT` writer - Count Value"]
pub type COUNT_W < 'a > = crate :: FieldWriter < 'a , u16 , COUNT_SPEC , u16 , u16 , 16 , 0 > ; impl R { # [doc = "Bits 0:15 - Count Value"]
# [inline (always)]
pub fn count (& self) -> COUNT_R { COUNT_R :: new (self . bits) } } impl W { # [doc = "Bits 0:15 - Count Value"]
# [inline (always)]
pub fn count (& mut self) -> COUNT_W { COUNT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "COUNT16 Counter Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [count](index.html) module"]
pub struct COUNT_SPEC ; impl crate :: RegisterSpec for COUNT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [count::R](R) reader structure"]
impl crate :: Readable for COUNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [count::W](W) writer structure"]
impl crate :: Writable for COUNT_SPEC { type Writer = W ; } # [doc = "`reset()` method sets COUNT to value 0"]
impl crate :: Resettable for COUNT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CC register accessor: an alias for `Reg<CC_SPEC>`"]
pub type CC = crate :: Reg < cc :: CC_SPEC > ; # [doc = "COUNT16 Compare/Capture"]
pub mod cc { # [doc = "Register `CC%s` reader"]
pub struct R (crate :: R < CC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CC%s` writer"]
pub struct W (crate :: W < CC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CC_SPEC >) -> Self { W (writer) } } # [doc = "Field `CC` reader - Compare/Capture Value"]
pub type CC_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `CC` writer - Compare/Capture Value"]
pub type CC_W < 'a > = crate :: FieldWriter < 'a , u16 , CC_SPEC , u16 , u16 , 16 , 0 > ; impl R { # [doc = "Bits 0:15 - Compare/Capture Value"]
# [inline (always)]
pub fn cc (& self) -> CC_R { CC_R :: new (self . bits) } } impl W { # [doc = "Bits 0:15 - Compare/Capture Value"]
# [inline (always)]
pub fn cc (& mut self) -> CC_W { CC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "COUNT16 Compare/Capture\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cc](index.html) module"]
pub struct CC_SPEC ; impl crate :: RegisterSpec for CC_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [cc::R](R) reader structure"]
impl crate :: Readable for CC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cc::W](W) writer structure"]
impl crate :: Writable for CC_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CC%s to value 0"]
impl crate :: Resettable for CC_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = r"Register block"]
# [repr (C)]
pub struct COUNT32 { # [doc = "0x00 - Control A"]
pub ctrla : crate :: Reg < self :: count32 :: ctrla :: CTRLA_SPEC > , # [doc = "0x02 - Read Request"]
pub readreq : crate :: Reg < self :: count32 :: readreq :: READREQ_SPEC > , # [doc = "0x04 - Control B Clear"]
pub ctrlbclr : crate :: Reg < self :: count32 :: ctrlbclr :: CTRLBCLR_SPEC > , # [doc = "0x05 - Control B Set"]
pub ctrlbset : crate :: Reg < self :: count32 :: ctrlbset :: CTRLBSET_SPEC > , # [doc = "0x06 - Control C"]
pub ctrlc : crate :: Reg < self :: count32 :: ctrlc :: CTRLC_SPEC > , _reserved5 : [u8 ; 0x01]
, # [doc = "0x08 - Debug Control"]
pub dbgctrl : crate :: Reg < self :: count32 :: dbgctrl :: DBGCTRL_SPEC > , _reserved6 : [u8 ; 0x01]
, # [doc = "0x0a - Event Control"]
pub evctrl : crate :: Reg < self :: count32 :: evctrl :: EVCTRL_SPEC > , # [doc = "0x0c - Interrupt Enable Clear"]
pub intenclr : crate :: Reg < self :: count32 :: intenclr :: INTENCLR_SPEC > , # [doc = "0x0d - Interrupt Enable Set"]
pub intenset : crate :: Reg < self :: count32 :: intenset :: INTENSET_SPEC > , # [doc = "0x0e - Interrupt Flag Status and Clear"]
pub intflag : crate :: Reg < self :: count32 :: intflag :: INTFLAG_SPEC > , # [doc = "0x0f - Status"]
pub status : crate :: Reg < self :: count32 :: status :: STATUS_SPEC > , # [doc = "0x10 - COUNT32 Counter Value"]
pub count : crate :: Reg < self :: count32 :: count :: COUNT_SPEC > , _reserved12 : [u8 ; 0x04]
, # [doc = "0x18..0x20 - COUNT32 Compare/Capture"]
pub cc : [crate :: Reg < self :: count32 :: cc :: CC_SPEC > ; 2]
, } # [doc = r"Register block"]
# [doc = "32-bit Counter Mode"]
pub mod count32 { # [doc = "CTRLA register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWRST` writer - Software Reset"]
pub type SWRST_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLA_SPEC , bool , 0 > ; # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLA_SPEC , bool , 1 > ; # [doc = "TC Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum MODE_A { # [doc = "0: Counter in 16-bit mode"]
COUNT16 = 0 , # [doc = "1: Counter in 8-bit mode"]
COUNT8 = 1 , # [doc = "2: Counter in 32-bit mode"]
COUNT32 = 2 , } impl From < MODE_A > for u8 { # [inline (always)]
fn from (variant : MODE_A) -> Self { variant as _ } } # [doc = "Field `MODE` reader - TC Mode"]
pub type MODE_R = crate :: FieldReader < u8 , MODE_A > ; impl MODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < MODE_A > { match self . bits { 0 => Some (MODE_A :: COUNT16) , 1 => Some (MODE_A :: COUNT8) , 2 => Some (MODE_A :: COUNT32) , _ => None , } } # [doc = "Checks if the value of the field is `COUNT16`"]
# [inline (always)]
pub fn is_count16 (& self) -> bool { * self == MODE_A :: COUNT16 } # [doc = "Checks if the value of the field is `COUNT8`"]
# [inline (always)]
pub fn is_count8 (& self) -> bool { * self == MODE_A :: COUNT8 } # [doc = "Checks if the value of the field is `COUNT32`"]
# [inline (always)]
pub fn is_count32 (& self) -> bool { * self == MODE_A :: COUNT32 } } # [doc = "Field `MODE` writer - TC Mode"]
pub type MODE_W < 'a > = crate :: FieldWriter < 'a , u16 , CTRLA_SPEC , u8 , MODE_A , 2 , 2 > ; impl < 'a > MODE_W < 'a > { # [doc = "Counter in 16-bit mode"]
# [inline (always)]
pub fn count16 (self) -> & 'a mut W { self . variant (MODE_A :: COUNT16) } # [doc = "Counter in 8-bit mode"]
# [inline (always)]
pub fn count8 (self) -> & 'a mut W { self . variant (MODE_A :: COUNT8) } # [doc = "Counter in 32-bit mode"]
# [inline (always)]
pub fn count32 (self) -> & 'a mut W { self . variant (MODE_A :: COUNT32) } } # [doc = "Waveform Generation Operation\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum WAVEGEN_A { # [doc = "0: `0`"]
NFRQ = 0 , # [doc = "1: `1`"]
MFRQ = 1 , # [doc = "2: `10`"]
NPWM = 2 , # [doc = "3: `11`"]
MPWM = 3 , } impl From < WAVEGEN_A > for u8 { # [inline (always)]
fn from (variant : WAVEGEN_A) -> Self { variant as _ } } # [doc = "Field `WAVEGEN` reader - Waveform Generation Operation"]
pub type WAVEGEN_R = crate :: FieldReader < u8 , WAVEGEN_A > ; impl WAVEGEN_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> WAVEGEN_A { match self . bits { 0 => WAVEGEN_A :: NFRQ , 1 => WAVEGEN_A :: MFRQ , 2 => WAVEGEN_A :: NPWM , 3 => WAVEGEN_A :: MPWM , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NFRQ`"]
# [inline (always)]
pub fn is_nfrq (& self) -> bool { * self == WAVEGEN_A :: NFRQ } # [doc = "Checks if the value of the field is `MFRQ`"]
# [inline (always)]
pub fn is_mfrq (& self) -> bool { * self == WAVEGEN_A :: MFRQ } # [doc = "Checks if the value of the field is `NPWM`"]
# [inline (always)]
pub fn is_npwm (& self) -> bool { * self == WAVEGEN_A :: NPWM } # [doc = "Checks if the value of the field is `MPWM`"]
# [inline (always)]
pub fn is_mpwm (& self) -> bool { * self == WAVEGEN_A :: MPWM } } # [doc = "Field `WAVEGEN` writer - Waveform Generation Operation"]
pub type WAVEGEN_W < 'a > = crate :: FieldWriterSafe < 'a , u16 , CTRLA_SPEC , u8 , WAVEGEN_A , 2 , 5 > ; impl < 'a > WAVEGEN_W < 'a > { # [doc = "`0`"]
# [inline (always)]
pub fn nfrq (self) -> & 'a mut W { self . variant (WAVEGEN_A :: NFRQ) } # [doc = "`1`"]
# [inline (always)]
pub fn mfrq (self) -> & 'a mut W { self . variant (WAVEGEN_A :: MFRQ) } # [doc = "`10`"]
# [inline (always)]
pub fn npwm (self) -> & 'a mut W { self . variant (WAVEGEN_A :: NPWM) } # [doc = "`11`"]
# [inline (always)]
pub fn mpwm (self) -> & 'a mut W { self . variant (WAVEGEN_A :: MPWM) } } # [doc = "Prescaler\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum PRESCALER_A { # [doc = "0: Prescaler: GCLK_TC"]
DIV1 = 0 , # [doc = "1: Prescaler: GCLK_TC/2"]
DIV2 = 1 , # [doc = "2: Prescaler: GCLK_TC/4"]
DIV4 = 2 , # [doc = "3: Prescaler: GCLK_TC/8"]
DIV8 = 3 , # [doc = "4: Prescaler: GCLK_TC/16"]
DIV16 = 4 , # [doc = "5: Prescaler: GCLK_TC/64"]
DIV64 = 5 , # [doc = "6: Prescaler: GCLK_TC/256"]
DIV256 = 6 , # [doc = "7: Prescaler: GCLK_TC/1024"]
DIV1024 = 7 , } impl From < PRESCALER_A > for u8 { # [inline (always)]
fn from (variant : PRESCALER_A) -> Self { variant as _ } } # [doc = "Field `PRESCALER` reader - Prescaler"]
pub type PRESCALER_R = crate :: FieldReader < u8 , PRESCALER_A > ; impl PRESCALER_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PRESCALER_A { match self . bits { 0 => PRESCALER_A :: DIV1 , 1 => PRESCALER_A :: DIV2 , 2 => PRESCALER_A :: DIV4 , 3 => PRESCALER_A :: DIV8 , 4 => PRESCALER_A :: DIV16 , 5 => PRESCALER_A :: DIV64 , 6 => PRESCALER_A :: DIV256 , 7 => PRESCALER_A :: DIV1024 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == PRESCALER_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == PRESCALER_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == PRESCALER_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == PRESCALER_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == PRESCALER_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == PRESCALER_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == PRESCALER_A :: DIV256 } # [doc = "Checks if the value of the field is `DIV1024`"]
# [inline (always)]
pub fn is_div1024 (& self) -> bool { * self == PRESCALER_A :: DIV1024 } } # [doc = "Field `PRESCALER` writer - Prescaler"]
pub type PRESCALER_W < 'a > = crate :: FieldWriterSafe < 'a , u16 , CTRLA_SPEC , u8 , PRESCALER_A , 3 , 8 > ; impl < 'a > PRESCALER_W < 'a > { # [doc = "Prescaler: GCLK_TC"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV1) } # [doc = "Prescaler: GCLK_TC/2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV2) } # [doc = "Prescaler: GCLK_TC/4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV4) } # [doc = "Prescaler: GCLK_TC/8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV8) } # [doc = "Prescaler: GCLK_TC/16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV16) } # [doc = "Prescaler: GCLK_TC/64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV64) } # [doc = "Prescaler: GCLK_TC/256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV256) } # [doc = "Prescaler: GCLK_TC/1024"]
# [inline (always)]
pub fn div1024 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV1024) } } # [doc = "Field `RUNSTDBY` reader - Run in Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run in Standby"]
pub type RUNSTDBY_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLA_SPEC , bool , 11 > ; # [doc = "Prescaler and Counter Synchronization\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum PRESCSYNC_A { # [doc = "0: Reload or reset the counter on next generic clock"]
GCLK = 0 , # [doc = "1: Reload or reset the counter on next prescaler clock"]
PRESC = 1 , # [doc = "2: Reload or reset the counter on next generic clock. Reset the prescaler counter"]
RESYNC = 2 , } impl From < PRESCSYNC_A > for u8 { # [inline (always)]
fn from (variant : PRESCSYNC_A) -> Self { variant as _ } } # [doc = "Field `PRESCSYNC` reader - Prescaler and Counter Synchronization"]
pub type PRESCSYNC_R = crate :: FieldReader < u8 , PRESCSYNC_A > ; impl PRESCSYNC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PRESCSYNC_A > { match self . bits { 0 => Some (PRESCSYNC_A :: GCLK) , 1 => Some (PRESCSYNC_A :: PRESC) , 2 => Some (PRESCSYNC_A :: RESYNC) , _ => None , } } # [doc = "Checks if the value of the field is `GCLK`"]
# [inline (always)]
pub fn is_gclk (& self) -> bool { * self == PRESCSYNC_A :: GCLK } # [doc = "Checks if the value of the field is `PRESC`"]
# [inline (always)]
pub fn is_presc (& self) -> bool { * self == PRESCSYNC_A :: PRESC } # [doc = "Checks if the value of the field is `RESYNC`"]
# [inline (always)]
pub fn is_resync (& self) -> bool { * self == PRESCSYNC_A :: RESYNC } } # [doc = "Field `PRESCSYNC` writer - Prescaler and Counter Synchronization"]
pub type PRESCSYNC_W < 'a > = crate :: FieldWriter < 'a , u16 , CTRLA_SPEC , u8 , PRESCSYNC_A , 2 , 12 > ; impl < 'a > PRESCSYNC_W < 'a > { # [doc = "Reload or reset the counter on next generic clock"]
# [inline (always)]
pub fn gclk (self) -> & 'a mut W { self . variant (PRESCSYNC_A :: GCLK) } # [doc = "Reload or reset the counter on next prescaler clock"]
# [inline (always)]
pub fn presc (self) -> & 'a mut W { self . variant (PRESCSYNC_A :: PRESC) } # [doc = "Reload or reset the counter on next generic clock. Reset the prescaler counter"]
# [inline (always)]
pub fn resync (self) -> & 'a mut W { self . variant (PRESCSYNC_A :: RESYNC) } } impl R { # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - TC Mode"]
# [inline (always)]
pub fn mode (& self) -> MODE_R { MODE_R :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bits 5:6 - Waveform Generation Operation"]
# [inline (always)]
pub fn wavegen (& self) -> WAVEGEN_R { WAVEGEN_R :: new (((self . bits >> 5) & 3) as u8) } # [doc = "Bits 8:10 - Prescaler"]
# [inline (always)]
pub fn prescaler (& self) -> PRESCALER_R { PRESCALER_R :: new (((self . bits >> 8) & 7) as u8) } # [doc = "Bit 11 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bits 12:13 - Prescaler and Counter Synchronization"]
# [inline (always)]
pub fn prescsync (& self) -> PRESCSYNC_R { PRESCSYNC_R :: new (((self . bits >> 12) & 3) as u8) } } impl W { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& mut self) -> SWRST_W { SWRST_W :: new (self) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Bits 2:3 - TC Mode"]
# [inline (always)]
pub fn mode (& mut self) -> MODE_W { MODE_W :: new (self) } # [doc = "Bits 5:6 - Waveform Generation Operation"]
# [inline (always)]
pub fn wavegen (& mut self) -> WAVEGEN_W { WAVEGEN_W :: new (self) } # [doc = "Bits 8:10 - Prescaler"]
# [inline (always)]
pub fn prescaler (& mut self) -> PRESCALER_W { PRESCALER_W :: new (self) } # [doc = "Bit 11 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& mut self) -> RUNSTDBY_W { RUNSTDBY_W :: new (self) } # [doc = "Bits 12:13 - Prescaler and Counter Synchronization"]
# [inline (always)]
pub fn prescsync (& mut self) -> PRESCSYNC_W { PRESCSYNC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "READREQ register accessor: an alias for `Reg<READREQ_SPEC>`"]
pub type READREQ = crate :: Reg < readreq :: READREQ_SPEC > ; # [doc = "Read Request"]
pub mod readreq { # [doc = "Register `READREQ` reader"]
pub struct R (crate :: R < READREQ_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < READREQ_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < READREQ_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < READREQ_SPEC >) -> Self { R (reader) } } # [doc = "Register `READREQ` writer"]
pub struct W (crate :: W < READREQ_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < READREQ_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < READREQ_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < READREQ_SPEC >) -> Self { W (writer) } } # [doc = "Field `ADDR` reader - Address"]
pub type ADDR_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `ADDR` writer - Address"]
pub type ADDR_W < 'a > = crate :: FieldWriter < 'a , u16 , READREQ_SPEC , u8 , u8 , 5 , 0 > ; # [doc = "Field `RCONT` reader - Read Continuously"]
pub type RCONT_R = crate :: BitReader < bool > ; # [doc = "Field `RCONT` writer - Read Continuously"]
pub type RCONT_W < 'a > = crate :: BitWriter < 'a , u16 , READREQ_SPEC , bool , 14 > ; # [doc = "Field `RREQ` reader - Read Request"]
pub type RREQ_R = crate :: BitReader < bool > ; # [doc = "Field `RREQ` writer - Read Request"]
pub type RREQ_W < 'a > = crate :: BitWriter < 'a , u16 , READREQ_SPEC , bool , 15 > ; impl R { # [doc = "Bits 0:4 - Address"]
# [inline (always)]
pub fn addr (& self) -> ADDR_R { ADDR_R :: new ((self . bits & 0x1f) as u8) } # [doc = "Bit 14 - Read Continuously"]
# [inline (always)]
pub fn rcont (& self) -> RCONT_R { RCONT_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Read Request"]
# [inline (always)]
pub fn rreq (& self) -> RREQ_R { RREQ_R :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bits 0:4 - Address"]
# [inline (always)]
pub fn addr (& mut self) -> ADDR_W { ADDR_W :: new (self) } # [doc = "Bit 14 - Read Continuously"]
# [inline (always)]
pub fn rcont (& mut self) -> RCONT_W { RCONT_W :: new (self) } # [doc = "Bit 15 - Read Request"]
# [inline (always)]
pub fn rreq (& mut self) -> RREQ_W { RREQ_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Read Request\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [readreq](index.html) module"]
pub struct READREQ_SPEC ; impl crate :: RegisterSpec for READREQ_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [readreq::R](R) reader structure"]
impl crate :: Readable for READREQ_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [readreq::W](W) writer structure"]
impl crate :: Writable for READREQ_SPEC { type Writer = W ; } # [doc = "`reset()` method sets READREQ to value 0"]
impl crate :: Resettable for READREQ_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CTRLBCLR register accessor: an alias for `Reg<CTRLBCLR_SPEC>`"]
pub type CTRLBCLR = crate :: Reg < ctrlbclr :: CTRLBCLR_SPEC > ; # [doc = "Control B Clear"]
pub mod ctrlbclr { # [doc = "Register `CTRLBCLR` reader"]
pub struct R (crate :: R < CTRLBCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLBCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLBCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLBCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLBCLR` writer"]
pub struct W (crate :: W < CTRLBCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLBCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLBCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLBCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Counter Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` writer - Counter Direction"]
pub type DIR_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLBCLR_SPEC , bool , 0 > ; # [doc = "Field `ONESHOT` reader - One-Shot"]
pub type ONESHOT_R = crate :: BitReader < bool > ; # [doc = "Field `ONESHOT` writer - One-Shot"]
pub type ONESHOT_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLBCLR_SPEC , bool , 2 > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No action"]
NONE = 0 , # [doc = "1: Force a start, restart or retrigger"]
RETRIGGER = 1 , # [doc = "2: Force a stop"]
STOP = 2 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CMD_A > { match self . bits { 0 => Some (CMD_A :: NONE) , 1 => Some (CMD_A :: RETRIGGER) , 2 => Some (CMD_A :: STOP) , _ => None , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == CMD_A :: NONE } # [doc = "Checks if the value of the field is `RETRIGGER`"]
# [inline (always)]
pub fn is_retrigger (& self) -> bool { * self == CMD_A :: RETRIGGER } # [doc = "Checks if the value of the field is `STOP`"]
# [inline (always)]
pub fn is_stop (& self) -> bool { * self == CMD_A :: STOP } } # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a > = crate :: FieldWriter < 'a , u8 , CTRLBCLR_SPEC , u8 , CMD_A , 2 , 6 > ; impl < 'a > CMD_W < 'a > { # [doc = "No action"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (CMD_A :: NONE) } # [doc = "Force a start, restart or retrigger"]
# [inline (always)]
pub fn retrigger (self) -> & 'a mut W { self . variant (CMD_A :: RETRIGGER) } # [doc = "Force a stop"]
# [inline (always)]
pub fn stop (self) -> & 'a mut W { self . variant (CMD_A :: STOP) } } impl R { # [doc = "Bit 0 - Counter Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - One-Shot"]
# [inline (always)]
pub fn oneshot (& self) -> ONESHOT_R { ONESHOT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 6:7 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new (((self . bits >> 6) & 3) as u8) } } impl W { # [doc = "Bit 0 - Counter Direction"]
# [inline (always)]
pub fn dir (& mut self) -> DIR_W { DIR_W :: new (self) } # [doc = "Bit 2 - One-Shot"]
# [inline (always)]
pub fn oneshot (& mut self) -> ONESHOT_W { ONESHOT_W :: new (self) } # [doc = "Bits 6:7 - Command"]
# [inline (always)]
pub fn cmd (& mut self) -> CMD_W { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlbclr](index.html) module"]
pub struct CTRLBCLR_SPEC ; impl crate :: RegisterSpec for CTRLBCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlbclr::R](R) reader structure"]
impl crate :: Readable for CTRLBCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlbclr::W](W) writer structure"]
impl crate :: Writable for CTRLBCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLBCLR to value 0x02"]
impl crate :: Resettable for CTRLBCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x02 } } } # [doc = "CTRLBSET register accessor: an alias for `Reg<CTRLBSET_SPEC>`"]
pub type CTRLBSET = crate :: Reg < ctrlbset :: CTRLBSET_SPEC > ; # [doc = "Control B Set"]
pub mod ctrlbset { # [doc = "Register `CTRLBSET` reader"]
pub struct R (crate :: R < CTRLBSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLBSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLBSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLBSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLBSET` writer"]
pub struct W (crate :: W < CTRLBSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLBSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLBSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLBSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Counter Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` writer - Counter Direction"]
pub type DIR_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLBSET_SPEC , bool , 0 > ; # [doc = "Field `ONESHOT` reader - One-Shot"]
pub type ONESHOT_R = crate :: BitReader < bool > ; # [doc = "Field `ONESHOT` writer - One-Shot"]
pub type ONESHOT_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLBSET_SPEC , bool , 2 > ; # [doc = "Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No action"]
NONE = 0 , # [doc = "1: Force a start, restart or retrigger"]
RETRIGGER = 1 , # [doc = "2: Force a stop"]
STOP = 2 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } # [doc = "Field `CMD` reader - Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CMD_A > { match self . bits { 0 => Some (CMD_A :: NONE) , 1 => Some (CMD_A :: RETRIGGER) , 2 => Some (CMD_A :: STOP) , _ => None , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == CMD_A :: NONE } # [doc = "Checks if the value of the field is `RETRIGGER`"]
# [inline (always)]
pub fn is_retrigger (& self) -> bool { * self == CMD_A :: RETRIGGER } # [doc = "Checks if the value of the field is `STOP`"]
# [inline (always)]
pub fn is_stop (& self) -> bool { * self == CMD_A :: STOP } } # [doc = "Field `CMD` writer - Command"]
pub type CMD_W < 'a > = crate :: FieldWriter < 'a , u8 , CTRLBSET_SPEC , u8 , CMD_A , 2 , 6 > ; impl < 'a > CMD_W < 'a > { # [doc = "No action"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (CMD_A :: NONE) } # [doc = "Force a start, restart or retrigger"]
# [inline (always)]
pub fn retrigger (self) -> & 'a mut W { self . variant (CMD_A :: RETRIGGER) } # [doc = "Force a stop"]
# [inline (always)]
pub fn stop (self) -> & 'a mut W { self . variant (CMD_A :: STOP) } } impl R { # [doc = "Bit 0 - Counter Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - One-Shot"]
# [inline (always)]
pub fn oneshot (& self) -> ONESHOT_R { ONESHOT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 6:7 - Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new (((self . bits >> 6) & 3) as u8) } } impl W { # [doc = "Bit 0 - Counter Direction"]
# [inline (always)]
pub fn dir (& mut self) -> DIR_W { DIR_W :: new (self) } # [doc = "Bit 2 - One-Shot"]
# [inline (always)]
pub fn oneshot (& mut self) -> ONESHOT_W { ONESHOT_W :: new (self) } # [doc = "Bits 6:7 - Command"]
# [inline (always)]
pub fn cmd (& mut self) -> CMD_W { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlbset](index.html) module"]
pub struct CTRLBSET_SPEC ; impl crate :: RegisterSpec for CTRLBSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlbset::R](R) reader structure"]
impl crate :: Readable for CTRLBSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlbset::W](W) writer structure"]
impl crate :: Writable for CTRLBSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLBSET to value 0"]
impl crate :: Resettable for CTRLBSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CTRLC register accessor: an alias for `Reg<CTRLC_SPEC>`"]
pub type CTRLC = crate :: Reg < ctrlc :: CTRLC_SPEC > ; # [doc = "Control C"]
pub mod ctrlc { # [doc = "Register `CTRLC` reader"]
pub struct R (crate :: R < CTRLC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLC` writer"]
pub struct W (crate :: W < CTRLC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLC_SPEC >) -> Self { W (writer) } } # [doc = "Field `INVEN0` reader - Output Waveform 0 Invert Enable"]
pub type INVEN0_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN0` writer - Output Waveform 0 Invert Enable"]
pub type INVEN0_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , 0 > ; # [doc = "Field `INVEN1` reader - Output Waveform 1 Invert Enable"]
pub type INVEN1_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN1` writer - Output Waveform 1 Invert Enable"]
pub type INVEN1_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , 1 > ; # [doc = "Field `CPTEN0` reader - Capture Channel 0 Enable"]
pub type CPTEN0_R = crate :: BitReader < bool > ; # [doc = "Field `CPTEN0` writer - Capture Channel 0 Enable"]
pub type CPTEN0_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , 4 > ; # [doc = "Field `CPTEN1` reader - Capture Channel 1 Enable"]
pub type CPTEN1_R = crate :: BitReader < bool > ; # [doc = "Field `CPTEN1` writer - Capture Channel 1 Enable"]
pub type CPTEN1_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLC_SPEC , bool , 5 > ; impl R { # [doc = "Bit 0 - Output Waveform 0 Invert Enable"]
# [inline (always)]
pub fn inven0 (& self) -> INVEN0_R { INVEN0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Output Waveform 1 Invert Enable"]
# [inline (always)]
pub fn inven1 (& self) -> INVEN1_R { INVEN1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - Capture Channel 0 Enable"]
# [inline (always)]
pub fn cpten0 (& self) -> CPTEN0_R { CPTEN0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Capture Channel 1 Enable"]
# [inline (always)]
pub fn cpten1 (& self) -> CPTEN1_R { CPTEN1_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Output Waveform 0 Invert Enable"]
# [inline (always)]
pub fn inven0 (& mut self) -> INVEN0_W { INVEN0_W :: new (self) } # [doc = "Bit 1 - Output Waveform 1 Invert Enable"]
# [inline (always)]
pub fn inven1 (& mut self) -> INVEN1_W { INVEN1_W :: new (self) } # [doc = "Bit 4 - Capture Channel 0 Enable"]
# [inline (always)]
pub fn cpten0 (& mut self) -> CPTEN0_W { CPTEN0_W :: new (self) } # [doc = "Bit 5 - Capture Channel 1 Enable"]
# [inline (always)]
pub fn cpten1 (& mut self) -> CPTEN1_W { CPTEN1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control C\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlc](index.html) module"]
pub struct CTRLC_SPEC ; impl crate :: RegisterSpec for CTRLC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlc::R](R) reader structure"]
impl crate :: Readable for CTRLC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlc::W](W) writer structure"]
impl crate :: Writable for CTRLC_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLC to value 0"]
impl crate :: Resettable for CTRLC_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DBGCTRL register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Debug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Debug Run Mode"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Debug Run Mode"]
pub type DBGRUN_W < 'a > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , 0 > ; impl R { # [doc = "Bit 0 - Debug Run Mode"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug Run Mode"]
# [inline (always)]
pub fn dbgrun (& mut self) -> DBGRUN_W { DBGRUN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "EVCTRL register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "Event Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Event Action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum EVACT_A { # [doc = "0: Event action disabled"]
OFF = 0 , # [doc = "1: Start, restart or retrigger TC on event"]
RETRIGGER = 1 , # [doc = "2: Count on event"]
COUNT = 2 , # [doc = "3: Start TC on event"]
START = 3 , # [doc = "5: Period captured in CC0, pulse width in CC1"]
PPW = 5 , # [doc = "6: Period captured in CC1, pulse width in CC0"]
PWP = 6 , } impl From < EVACT_A > for u8 { # [inline (always)]
fn from (variant : EVACT_A) -> Self { variant as _ } } # [doc = "Field `EVACT` reader - Event Action"]
pub type EVACT_R = crate :: FieldReader < u8 , EVACT_A > ; impl EVACT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < EVACT_A > { match self . bits { 0 => Some (EVACT_A :: OFF) , 1 => Some (EVACT_A :: RETRIGGER) , 2 => Some (EVACT_A :: COUNT) , 3 => Some (EVACT_A :: START) , 5 => Some (EVACT_A :: PPW) , 6 => Some (EVACT_A :: PWP) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == EVACT_A :: OFF } # [doc = "Checks if the value of the field is `RETRIGGER`"]
# [inline (always)]
pub fn is_retrigger (& self) -> bool { * self == EVACT_A :: RETRIGGER } # [doc = "Checks if the value of the field is `COUNT`"]
# [inline (always)]
pub fn is_count (& self) -> bool { * self == EVACT_A :: COUNT } # [doc = "Checks if the value of the field is `START`"]
# [inline (always)]
pub fn is_start (& self) -> bool { * self == EVACT_A :: START } # [doc = "Checks if the value of the field is `PPW`"]
# [inline (always)]
pub fn is_ppw (& self) -> bool { * self == EVACT_A :: PPW } # [doc = "Checks if the value of the field is `PWP`"]
# [inline (always)]
pub fn is_pwp (& self) -> bool { * self == EVACT_A :: PWP } } # [doc = "Field `EVACT` writer - Event Action"]
pub type EVACT_W < 'a > = crate :: FieldWriter < 'a , u16 , EVCTRL_SPEC , u8 , EVACT_A , 3 , 0 > ; impl < 'a > EVACT_W < 'a > { # [doc = "Event action disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (EVACT_A :: OFF) } # [doc = "Start, restart or retrigger TC on event"]
# [inline (always)]
pub fn retrigger (self) -> & 'a mut W { self . variant (EVACT_A :: RETRIGGER) } # [doc = "Count on event"]
# [inline (always)]
pub fn count (self) -> & 'a mut W { self . variant (EVACT_A :: COUNT) } # [doc = "Start TC on event"]
# [inline (always)]
pub fn start (self) -> & 'a mut W { self . variant (EVACT_A :: START) } # [doc = "Period captured in CC0, pulse width in CC1"]
# [inline (always)]
pub fn ppw (self) -> & 'a mut W { self . variant (EVACT_A :: PPW) } # [doc = "Period captured in CC1, pulse width in CC0"]
# [inline (always)]
pub fn pwp (self) -> & 'a mut W { self . variant (EVACT_A :: PWP) } } # [doc = "Field `TCINV` reader - TC Inverted Event Input"]
pub type TCINV_R = crate :: BitReader < bool > ; # [doc = "Field `TCINV` writer - TC Inverted Event Input"]
pub type TCINV_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 4 > ; # [doc = "Field `TCEI` reader - TC Event Input"]
pub type TCEI_R = crate :: BitReader < bool > ; # [doc = "Field `TCEI` writer - TC Event Input"]
pub type TCEI_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 5 > ; # [doc = "Field `OVFEO` reader - Overflow/Underflow Event Output Enable"]
pub type OVFEO_R = crate :: BitReader < bool > ; # [doc = "Field `OVFEO` writer - Overflow/Underflow Event Output Enable"]
pub type OVFEO_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 8 > ; # [doc = "Field `MCEO0` reader - Match or Capture Channel 0 Event Output Enable"]
pub type MCEO0_R = crate :: BitReader < bool > ; # [doc = "Field `MCEO0` writer - Match or Capture Channel 0 Event Output Enable"]
pub type MCEO0_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 12 > ; # [doc = "Field `MCEO1` reader - Match or Capture Channel 1 Event Output Enable"]
pub type MCEO1_R = crate :: BitReader < bool > ; # [doc = "Field `MCEO1` writer - Match or Capture Channel 1 Event Output Enable"]
pub type MCEO1_W < 'a > = crate :: BitWriter < 'a , u16 , EVCTRL_SPEC , bool , 13 > ; impl R { # [doc = "Bits 0:2 - Event Action"]
# [inline (always)]
pub fn evact (& self) -> EVACT_R { EVACT_R :: new ((self . bits & 7) as u8) } # [doc = "Bit 4 - TC Inverted Event Input"]
# [inline (always)]
pub fn tcinv (& self) -> TCINV_R { TCINV_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - TC Event Input"]
# [inline (always)]
pub fn tcei (& self) -> TCEI_R { TCEI_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 8 - Overflow/Underflow Event Output Enable"]
# [inline (always)]
pub fn ovfeo (& self) -> OVFEO_R { OVFEO_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 12 - Match or Capture Channel 0 Event Output Enable"]
# [inline (always)]
pub fn mceo0 (& self) -> MCEO0_R { MCEO0_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Match or Capture Channel 1 Event Output Enable"]
# [inline (always)]
pub fn mceo1 (& self) -> MCEO1_R { MCEO1_R :: new (((self . bits >> 13) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Event Action"]
# [inline (always)]
pub fn evact (& mut self) -> EVACT_W { EVACT_W :: new (self) } # [doc = "Bit 4 - TC Inverted Event Input"]
# [inline (always)]
pub fn tcinv (& mut self) -> TCINV_W { TCINV_W :: new (self) } # [doc = "Bit 5 - TC Event Input"]
# [inline (always)]
pub fn tcei (& mut self) -> TCEI_W { TCEI_W :: new (self) } # [doc = "Bit 8 - Overflow/Underflow Event Output Enable"]
# [inline (always)]
pub fn ovfeo (& mut self) -> OVFEO_W { OVFEO_W :: new (self) } # [doc = "Bit 12 - Match or Capture Channel 0 Event Output Enable"]
# [inline (always)]
pub fn mceo0 (& mut self) -> MCEO0_W { MCEO0_W :: new (self) } # [doc = "Bit 13 - Match or Capture Channel 1 Event Output Enable"]
# [inline (always)]
pub fn mceo1 (& mut self) -> MCEO1_W { MCEO1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENCLR register accessor: an alias for `Reg<INTENCLR_SPEC>`"]
pub type INTENCLR = crate :: Reg < intenclr :: INTENCLR_SPEC > ; # [doc = "Interrupt Enable Clear"]
pub mod intenclr { # [doc = "Register `INTENCLR` reader"]
pub struct R (crate :: R < INTENCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENCLR` writer"]
pub struct W (crate :: W < INTENCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVF` reader - Overflow Interrupt Enable"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow Interrupt Enable"]
pub type OVF_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 0 > ; # [doc = "Field `ERR` reader - Error Interrupt Enable"]
pub type ERR_R = crate :: BitReader < bool > ; # [doc = "Field `ERR` writer - Error Interrupt Enable"]
pub type ERR_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 1 > ; # [doc = "Field `SYNCRDY` reader - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCRDY` writer - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 3 > ; # [doc = "Field `MC0` reader - Match or Capture Channel 0 Interrupt Enable"]
pub type MC0_R = crate :: BitReader < bool > ; # [doc = "Field `MC0` writer - Match or Capture Channel 0 Interrupt Enable"]
pub type MC0_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 4 > ; # [doc = "Field `MC1` reader - Match or Capture Channel 1 Interrupt Enable"]
pub type MC1_R = crate :: BitReader < bool > ; # [doc = "Field `MC1` writer - Match or Capture Channel 1 Interrupt Enable"]
pub type MC1_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 5 > ; impl R { # [doc = "Bit 0 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Error Interrupt Enable"]
# [inline (always)]
pub fn err (& self) -> ERR_R { ERR_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& self) -> SYNCRDY_R { SYNCRDY_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Match or Capture Channel 0 Interrupt Enable"]
# [inline (always)]
pub fn mc0 (& self) -> MC0_R { MC0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Match or Capture Channel 1 Interrupt Enable"]
# [inline (always)]
pub fn mc1 (& self) -> MC1_R { MC1_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& mut self) -> OVF_W { OVF_W :: new (self) } # [doc = "Bit 1 - Error Interrupt Enable"]
# [inline (always)]
pub fn err (& mut self) -> ERR_W { ERR_W :: new (self) } # [doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& mut self) -> SYNCRDY_W { SYNCRDY_W :: new (self) } # [doc = "Bit 4 - Match or Capture Channel 0 Interrupt Enable"]
# [inline (always)]
pub fn mc0 (& mut self) -> MC0_W { MC0_W :: new (self) } # [doc = "Bit 5 - Match or Capture Channel 1 Interrupt Enable"]
# [inline (always)]
pub fn mc1 (& mut self) -> MC1_W { MC1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenclr](index.html) module"]
pub struct INTENCLR_SPEC ; impl crate :: RegisterSpec for INTENCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenclr::R](R) reader structure"]
impl crate :: Readable for INTENCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenclr::W](W) writer structure"]
impl crate :: Writable for INTENCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENCLR to value 0"]
impl crate :: Resettable for INTENCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENSET register accessor: an alias for `Reg<INTENSET_SPEC>`"]
pub type INTENSET = crate :: Reg < intenset :: INTENSET_SPEC > ; # [doc = "Interrupt Enable Set"]
pub mod intenset { # [doc = "Register `INTENSET` reader"]
pub struct R (crate :: R < INTENSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENSET` writer"]
pub struct W (crate :: W < INTENSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVF` reader - Overflow Interrupt Enable"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow Interrupt Enable"]
pub type OVF_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 0 > ; # [doc = "Field `ERR` reader - Error Interrupt Enable"]
pub type ERR_R = crate :: BitReader < bool > ; # [doc = "Field `ERR` writer - Error Interrupt Enable"]
pub type ERR_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 1 > ; # [doc = "Field `SYNCRDY` reader - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCRDY` writer - Synchronization Ready Interrupt Enable"]
pub type SYNCRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 3 > ; # [doc = "Field `MC0` reader - Match or Capture Channel 0 Interrupt Enable"]
pub type MC0_R = crate :: BitReader < bool > ; # [doc = "Field `MC0` writer - Match or Capture Channel 0 Interrupt Enable"]
pub type MC0_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 4 > ; # [doc = "Field `MC1` reader - Match or Capture Channel 1 Interrupt Enable"]
pub type MC1_R = crate :: BitReader < bool > ; # [doc = "Field `MC1` writer - Match or Capture Channel 1 Interrupt Enable"]
pub type MC1_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 5 > ; impl R { # [doc = "Bit 0 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Error Interrupt Enable"]
# [inline (always)]
pub fn err (& self) -> ERR_R { ERR_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& self) -> SYNCRDY_R { SYNCRDY_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Match or Capture Channel 0 Interrupt Enable"]
# [inline (always)]
pub fn mc0 (& self) -> MC0_R { MC0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Match or Capture Channel 1 Interrupt Enable"]
# [inline (always)]
pub fn mc1 (& self) -> MC1_R { MC1_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& mut self) -> OVF_W { OVF_W :: new (self) } # [doc = "Bit 1 - Error Interrupt Enable"]
# [inline (always)]
pub fn err (& mut self) -> ERR_W { ERR_W :: new (self) } # [doc = "Bit 3 - Synchronization Ready Interrupt Enable"]
# [inline (always)]
pub fn syncrdy (& mut self) -> SYNCRDY_W { SYNCRDY_W :: new (self) } # [doc = "Bit 4 - Match or Capture Channel 0 Interrupt Enable"]
# [inline (always)]
pub fn mc0 (& mut self) -> MC0_W { MC0_W :: new (self) } # [doc = "Bit 5 - Match or Capture Channel 1 Interrupt Enable"]
# [inline (always)]
pub fn mc1 (& mut self) -> MC1_W { MC1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenset](index.html) module"]
pub struct INTENSET_SPEC ; impl crate :: RegisterSpec for INTENSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenset::R](R) reader structure"]
impl crate :: Readable for INTENSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenset::W](W) writer structure"]
impl crate :: Writable for INTENSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENSET to value 0"]
impl crate :: Resettable for INTENSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTFLAG register accessor: an alias for `Reg<INTFLAG_SPEC>`"]
pub type INTFLAG = crate :: Reg < intflag :: INTFLAG_SPEC > ; # [doc = "Interrupt Flag Status and Clear"]
pub mod intflag { # [doc = "Register `INTFLAG` reader"]
pub struct R (crate :: R < INTFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAG` writer"]
pub struct W (crate :: W < INTFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVF` reader - Overflow"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow"]
pub type OVF_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 0 > ; # [doc = "Field `ERR` reader - Error"]
pub type ERR_R = crate :: BitReader < bool > ; # [doc = "Field `ERR` writer - Error"]
pub type ERR_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 1 > ; # [doc = "Field `SYNCRDY` reader - Synchronization Ready"]
pub type SYNCRDY_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCRDY` writer - Synchronization Ready"]
pub type SYNCRDY_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 3 > ; # [doc = "Field `MC0` reader - Match or Capture Channel 0"]
pub type MC0_R = crate :: BitReader < bool > ; # [doc = "Field `MC0` writer - Match or Capture Channel 0"]
pub type MC0_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 4 > ; # [doc = "Field `MC1` reader - Match or Capture Channel 1"]
pub type MC1_R = crate :: BitReader < bool > ; # [doc = "Field `MC1` writer - Match or Capture Channel 1"]
pub type MC1_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 5 > ; impl R { # [doc = "Bit 0 - Overflow"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Error"]
# [inline (always)]
pub fn err (& self) -> ERR_R { ERR_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 3 - Synchronization Ready"]
# [inline (always)]
pub fn syncrdy (& self) -> SYNCRDY_R { SYNCRDY_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Match or Capture Channel 0"]
# [inline (always)]
pub fn mc0 (& self) -> MC0_R { MC0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Match or Capture Channel 1"]
# [inline (always)]
pub fn mc1 (& self) -> MC1_R { MC1_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow"]
# [inline (always)]
pub fn ovf (& mut self) -> OVF_W { OVF_W :: new (self) } # [doc = "Bit 1 - Error"]
# [inline (always)]
pub fn err (& mut self) -> ERR_W { ERR_W :: new (self) } # [doc = "Bit 3 - Synchronization Ready"]
# [inline (always)]
pub fn syncrdy (& mut self) -> SYNCRDY_W { SYNCRDY_W :: new (self) } # [doc = "Bit 4 - Match or Capture Channel 0"]
# [inline (always)]
pub fn mc0 (& mut self) -> MC0_W { MC0_W :: new (self) } # [doc = "Bit 5 - Match or Capture Channel 1"]
# [inline (always)]
pub fn mc1 (& mut self) -> MC1_W { MC1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflag](index.html) module"]
pub struct INTFLAG_SPEC ; impl crate :: RegisterSpec for INTFLAG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflag::R](R) reader structure"]
impl crate :: Readable for INTFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflag::W](W) writer structure"]
impl crate :: Writable for INTFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTFLAG to value 0"]
impl crate :: Resettable for INTFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATUS register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `STOP` reader - Stop"]
pub type STOP_R = crate :: BitReader < bool > ; # [doc = "Field `SLAVE` reader - Slave"]
pub type SLAVE_R = crate :: BitReader < bool > ; # [doc = "Field `SYNCBUSY` reader - Synchronization Busy"]
pub type SYNCBUSY_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 3 - Stop"]
# [inline (always)]
pub fn stop (& self) -> STOP_R { STOP_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Slave"]
# [inline (always)]
pub fn slave (& self) -> SLAVE_R { SLAVE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 7 - Synchronization Busy"]
# [inline (always)]
pub fn syncbusy (& self) -> SYNCBUSY_R { SYNCBUSY_R :: new (((self . bits >> 7) & 1) != 0) } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATUS to value 0x08"]
impl crate :: Resettable for STATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x08 } } } # [doc = "COUNT register accessor: an alias for `Reg<COUNT_SPEC>`"]
pub type COUNT = crate :: Reg < count :: COUNT_SPEC > ; # [doc = "COUNT32 Counter Value"]
pub mod count { # [doc = "Register `COUNT` reader"]
pub struct R (crate :: R < COUNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < COUNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < COUNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < COUNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `COUNT` writer"]
pub struct W (crate :: W < COUNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < COUNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < COUNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < COUNT_SPEC >) -> Self { W (writer) } } # [doc = "Field `COUNT` reader - Count Value"]
pub type COUNT_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `COUNT` writer - Count Value"]
pub type COUNT_W < 'a > = crate :: FieldWriter < 'a , u32 , COUNT_SPEC , u32 , u32 , 32 , 0 > ; impl R { # [doc = "Bits 0:31 - Count Value"]
# [inline (always)]
pub fn count (& self) -> COUNT_R { COUNT_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Count Value"]
# [inline (always)]
pub fn count (& mut self) -> COUNT_W { COUNT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "COUNT32 Counter Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [count](index.html) module"]
pub struct COUNT_SPEC ; impl crate :: RegisterSpec for COUNT_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [count::R](R) reader structure"]
impl crate :: Readable for COUNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [count::W](W) writer structure"]
impl crate :: Writable for COUNT_SPEC { type Writer = W ; } # [doc = "`reset()` method sets COUNT to value 0"]
impl crate :: Resettable for COUNT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CC register accessor: an alias for `Reg<CC_SPEC>`"]
pub type CC = crate :: Reg < cc :: CC_SPEC > ; # [doc = "COUNT32 Compare/Capture"]
pub mod cc { # [doc = "Register `CC%s` reader"]
pub struct R (crate :: R < CC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CC%s` writer"]
pub struct W (crate :: W < CC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CC_SPEC >) -> Self { W (writer) } } # [doc = "Field `CC` reader - Compare/Capture Value"]
pub type CC_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `CC` writer - Compare/Capture Value"]
pub type CC_W < 'a > = crate :: FieldWriter < 'a , u32 , CC_SPEC , u32 , u32 , 32 , 0 > ; impl R { # [doc = "Bits 0:31 - Compare/Capture Value"]
# [inline (always)]
pub fn cc (& self) -> CC_R { CC_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Compare/Capture Value"]
# [inline (always)]
pub fn cc (& mut self) -> CC_W { CC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "COUNT32 Compare/Capture\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cc](index.html) module"]
pub struct CC_SPEC ; impl crate :: RegisterSpec for CC_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [cc::R](R) reader structure"]
impl crate :: Readable for CC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cc::W](W) writer structure"]
impl crate :: Writable for CC_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CC%s to value 0"]
impl crate :: Resettable for CC_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } } # [doc = "Basic Timer Counter 4"]
pub struct TC4 { _marker : PhantomData < * const () > } unsafe impl Send for TC4 { } impl TC4 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tc3 :: RegisterBlock = 0x4200_3000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tc3 :: RegisterBlock { Self :: PTR } } impl Deref for TC4 { type Target = tc3 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TC4 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TC4") . finish () } } # [doc = "Basic Timer Counter 4"]
pub use tc3 as tc4 ; # [doc = "Basic Timer Counter 5"]
pub struct TC5 { _marker : PhantomData < * const () > } unsafe impl Send for TC5 { } impl TC5 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tc3 :: RegisterBlock = 0x4200_3400 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tc3 :: RegisterBlock { Self :: PTR } } impl Deref for TC5 { type Target = tc3 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TC5 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TC5") . finish () } } # [doc = "Basic Timer Counter 5"]
pub use tc3 as tc5 ; # [doc = "Basic Timer Counter 6"]
pub struct TC6 { _marker : PhantomData < * const () > } unsafe impl Send for TC6 { } impl TC6 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tc3 :: RegisterBlock = 0x4200_3800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tc3 :: RegisterBlock { Self :: PTR } } impl Deref for TC6 { type Target = tc3 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TC6 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TC6") . finish () } } # [doc = "Basic Timer Counter 6"]
pub use tc3 as tc6 ; # [doc = "Basic Timer Counter 7"]
pub struct TC7 { _marker : PhantomData < * const () > } unsafe impl Send for TC7 { } impl TC7 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tc3 :: RegisterBlock = 0x4200_3c00 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tc3 :: RegisterBlock { Self :: PTR } } impl Deref for TC7 { type Target = tc3 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TC7 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TC7") . finish () } } # [doc = "Basic Timer Counter 7"]
pub use tc3 as tc7 ; # [doc = "Timer Counter Control 0"]
pub struct TCC0 { _marker : PhantomData < * const () > } unsafe impl Send for TCC0 { } impl TCC0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tcc0 :: RegisterBlock = 0x4200_2000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tcc0 :: RegisterBlock { Self :: PTR } } impl Deref for TCC0 { type Target = tcc0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TCC0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TCC0") . finish () } } # [doc = "Timer Counter Control 0"]
pub mod tcc0 { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control A"]
pub ctrla : crate :: Reg < ctrla :: CTRLA_SPEC > , # [doc = "0x04 - Control B Clear"]
pub ctrlbclr : crate :: Reg < ctrlbclr :: CTRLBCLR_SPEC > , # [doc = "0x05 - Control B Set"]
pub ctrlbset : crate :: Reg < ctrlbset :: CTRLBSET_SPEC > , _reserved3 : [u8 ; 0x02]
, # [doc = "0x08 - Synchronization Busy"]
pub syncbusy : crate :: Reg < syncbusy :: SYNCBUSY_SPEC > , # [doc = "0x0c - Recoverable Fault A Configuration"]
pub fctrla : crate :: Reg < fctrla :: FCTRLA_SPEC > , # [doc = "0x10 - Recoverable Fault B Configuration"]
pub fctrlb : crate :: Reg < fctrlb :: FCTRLB_SPEC > , # [doc = "0x14 - Waveform Extension Configuration"]
pub wexctrl : crate :: Reg < wexctrl :: WEXCTRL_SPEC > , # [doc = "0x18 - Driver Control"]
pub drvctrl : crate :: Reg < drvctrl :: DRVCTRL_SPEC > , _reserved8 : [u8 ; 0x02]
, # [doc = "0x1e - Debug Control"]
pub dbgctrl : crate :: Reg < dbgctrl :: DBGCTRL_SPEC > , _reserved9 : [u8 ; 0x01]
, # [doc = "0x20 - Event Control"]
pub evctrl : crate :: Reg < evctrl :: EVCTRL_SPEC > , # [doc = "0x24 - Interrupt Enable Clear"]
pub intenclr : crate :: Reg < intenclr :: INTENCLR_SPEC > , # [doc = "0x28 - Interrupt Enable Set"]
pub intenset : crate :: Reg < intenset :: INTENSET_SPEC > , # [doc = "0x2c - Interrupt Flag Status and Clear"]
pub intflag : crate :: Reg < intflag :: INTFLAG_SPEC > , # [doc = "0x30 - Status"]
pub status : crate :: Reg < status :: STATUS_SPEC > , _reserved_14_count : [u8 ; 0x04]
, # [doc = "0x38 - Pattern"]
pub patt : crate :: Reg < patt :: PATT_SPEC > , _reserved16 : [u8 ; 0x02]
, # [doc = "0x3c - Waveform Control"]
pub wave : crate :: Reg < wave :: WAVE_SPEC > , _reserved_17_per : [u8 ; 0x04]
, _reserved_18_cc : [u8 ; 0x10]
, _reserved19 : [u8 ; 0x10]
, # [doc = "0x64 - Pattern Buffer"]
pub pattb : crate :: Reg < pattb :: PATTB_SPEC > , _reserved20 : [u8 ; 0x02]
, # [doc = "0x68 - Waveform Control Buffer"]
pub waveb : crate :: Reg < waveb :: WAVEB_SPEC > , _reserved_21_perb : [u8 ; 0x04]
, _reserved_22_ccb : [u8 ; 0x10]
, } impl RegisterBlock { # [doc = "0x34 - Count"]
# [inline (always)]
pub fn count_dith6 (& self) -> & crate :: Reg < count_dith6 :: COUNT_DITH6_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (52usize) as * const crate :: Reg < count_dith6 :: COUNT_DITH6_SPEC >) } } # [doc = "0x34 - Count"]
# [inline (always)]
pub fn count_dith5 (& self) -> & crate :: Reg < count_dith5 :: COUNT_DITH5_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (52usize) as * const crate :: Reg < count_dith5 :: COUNT_DITH5_SPEC >) } } # [doc = "0x34 - Count"]
# [inline (always)]
pub fn count_dith4 (& self) -> & crate :: Reg < count_dith4 :: COUNT_DITH4_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (52usize) as * const crate :: Reg < count_dith4 :: COUNT_DITH4_SPEC >) } } # [doc = "0x34 - Count"]
# [inline (always)]
pub fn count (& self) -> & crate :: Reg < count :: COUNT_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (52usize) as * const crate :: Reg < count :: COUNT_SPEC >) } } # [doc = "0x40 - Period"]
# [inline (always)]
pub fn per_dith6 (& self) -> & crate :: Reg < per_dith6 :: PER_DITH6_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (64usize) as * const crate :: Reg < per_dith6 :: PER_DITH6_SPEC >) } } # [doc = "0x40 - Period"]
# [inline (always)]
pub fn per_dith5 (& self) -> & crate :: Reg < per_dith5 :: PER_DITH5_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (64usize) as * const crate :: Reg < per_dith5 :: PER_DITH5_SPEC >) } } # [doc = "0x40 - Period"]
# [inline (always)]
pub fn per_dith4 (& self) -> & crate :: Reg < per_dith4 :: PER_DITH4_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (64usize) as * const crate :: Reg < per_dith4 :: PER_DITH4_SPEC >) } } # [doc = "0x40 - Period"]
# [inline (always)]
pub fn per (& self) -> & crate :: Reg < per :: PER_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (64usize) as * const crate :: Reg < per :: PER_SPEC >) } } # [doc = "0x44..0x54 - Compare and Capture"]
# [inline (always)]
pub fn cc_dith6 (& self) -> & [crate :: Reg < cc_dith6 :: CC_DITH6_SPEC > ; 4]
{ unsafe { & * (((self as * const Self) as * const u8) . add (68usize) as * const [crate :: Reg < cc_dith6 :: CC_DITH6_SPEC > ; 4]) } } # [doc = "0x44..0x54 - Compare and Capture"]
# [inline (always)]
pub fn cc_dith5 (& self) -> & [crate :: Reg < cc_dith5 :: CC_DITH5_SPEC > ; 4]
{ unsafe { & * (((self as * const Self) as * const u8) . add (68usize) as * const [crate :: Reg < cc_dith5 :: CC_DITH5_SPEC > ; 4]) } } # [doc = "0x44..0x54 - Compare and Capture"]
# [inline (always)]
pub fn cc_dith4 (& self) -> & [crate :: Reg < cc_dith4 :: CC_DITH4_SPEC > ; 4]
{ unsafe { & * (((self as * const Self) as * const u8) . add (68usize) as * const [crate :: Reg < cc_dith4 :: CC_DITH4_SPEC > ; 4]) } } # [doc = "0x44..0x54 - Compare and Capture"]
# [inline (always)]
pub fn cc (& self) -> & [crate :: Reg < cc :: CC_SPEC > ; 4]
{ unsafe { & * (((self as * const Self) as * const u8) . add (68usize) as * const [crate :: Reg < cc :: CC_SPEC > ; 4]) } } # [doc = "0x6c - Period Buffer"]
# [inline (always)]
pub fn perb_dith6 (& self) -> & crate :: Reg < perb_dith6 :: PERB_DITH6_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (108usize) as * const crate :: Reg < perb_dith6 :: PERB_DITH6_SPEC >) } } # [doc = "0x6c - Period Buffer"]
# [inline (always)]
pub fn perb_dith5 (& self) -> & crate :: Reg < perb_dith5 :: PERB_DITH5_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (108usize) as * const crate :: Reg < perb_dith5 :: PERB_DITH5_SPEC >) } } # [doc = "0x6c - Period Buffer"]
# [inline (always)]
pub fn perb_dith4 (& self) -> & crate :: Reg < perb_dith4 :: PERB_DITH4_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (108usize) as * const crate :: Reg < perb_dith4 :: PERB_DITH4_SPEC >) } } # [doc = "0x6c - Period Buffer"]
# [inline (always)]
pub fn perb (& self) -> & crate :: Reg < perb :: PERB_SPEC > { unsafe { & * (((self as * const Self) as * const u8) . add (108usize) as * const crate :: Reg < perb :: PERB_SPEC >) } } # [doc = "0x70..0x80 - Compare and Capture Buffer"]
# [inline (always)]
pub fn ccb_dith6 (& self) -> & [crate :: Reg < ccb_dith6 :: CCB_DITH6_SPEC > ; 4]
{ unsafe { & * (((self as * const Self) as * const u8) . add (112usize) as * const [crate :: Reg < ccb_dith6 :: CCB_DITH6_SPEC > ; 4]) } } # [doc = "0x70..0x80 - Compare and Capture Buffer"]
# [inline (always)]
pub fn ccb_dith5 (& self) -> & [crate :: Reg < ccb_dith5 :: CCB_DITH5_SPEC > ; 4]
{ unsafe { & * (((self as * const Self) as * const u8) . add (112usize) as * const [crate :: Reg < ccb_dith5 :: CCB_DITH5_SPEC > ; 4]) } } # [doc = "0x70..0x80 - Compare and Capture Buffer"]
# [inline (always)]
pub fn ccb_dith4 (& self) -> & [crate :: Reg < ccb_dith4 :: CCB_DITH4_SPEC > ; 4]
{ unsafe { & * (((self as * const Self) as * const u8) . add (112usize) as * const [crate :: Reg < ccb_dith4 :: CCB_DITH4_SPEC > ; 4]) } } # [doc = "0x70..0x80 - Compare and Capture Buffer"]
# [inline (always)]
pub fn ccb (& self) -> & [crate :: Reg < ccb :: CCB_SPEC > ; 4]
{ unsafe { & * (((self as * const Self) as * const u8) . add (112usize) as * const [crate :: Reg < ccb :: CCB_SPEC > ; 4]) } } } # [doc = "CTRLA register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWRST` reader - Software Reset"]
pub type SWRST_R = crate :: BitReader < bool > ; # [doc = "Field `SWRST` writer - Software Reset"]
pub type SWRST_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 0 > ; # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 1 > ; # [doc = "Enhanced Resolution\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum RESOLUTION_A { # [doc = "0: Dithering is disabled"]
NONE = 0 , # [doc = "1: Dithering is done every 16 PWM frames"]
DITH4 = 1 , # [doc = "2: Dithering is done every 32 PWM frames"]
DITH5 = 2 , # [doc = "3: Dithering is done every 64 PWM frames"]
DITH6 = 3 , } impl From < RESOLUTION_A > for u8 { # [inline (always)]
fn from (variant : RESOLUTION_A) -> Self { variant as _ } } # [doc = "Field `RESOLUTION` reader - Enhanced Resolution"]
pub type RESOLUTION_R = crate :: FieldReader < u8 , RESOLUTION_A > ; impl RESOLUTION_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> RESOLUTION_A { match self . bits { 0 => RESOLUTION_A :: NONE , 1 => RESOLUTION_A :: DITH4 , 2 => RESOLUTION_A :: DITH5 , 3 => RESOLUTION_A :: DITH6 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == RESOLUTION_A :: NONE } # [doc = "Checks if the value of the field is `DITH4`"]
# [inline (always)]
pub fn is_dith4 (& self) -> bool { * self == RESOLUTION_A :: DITH4 } # [doc = "Checks if the value of the field is `DITH5`"]
# [inline (always)]
pub fn is_dith5 (& self) -> bool { * self == RESOLUTION_A :: DITH5 } # [doc = "Checks if the value of the field is `DITH6`"]
# [inline (always)]
pub fn is_dith6 (& self) -> bool { * self == RESOLUTION_A :: DITH6 } } # [doc = "Field `RESOLUTION` writer - Enhanced Resolution"]
pub type RESOLUTION_W < 'a > = crate :: FieldWriterSafe < 'a , u32 , CTRLA_SPEC , u8 , RESOLUTION_A , 2 , 5 > ; impl < 'a > RESOLUTION_W < 'a > { # [doc = "Dithering is disabled"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (RESOLUTION_A :: NONE) } # [doc = "Dithering is done every 16 PWM frames"]
# [inline (always)]
pub fn dith4 (self) -> & 'a mut W { self . variant (RESOLUTION_A :: DITH4) } # [doc = "Dithering is done every 32 PWM frames"]
# [inline (always)]
pub fn dith5 (self) -> & 'a mut W { self . variant (RESOLUTION_A :: DITH5) } # [doc = "Dithering is done every 64 PWM frames"]
# [inline (always)]
pub fn dith6 (self) -> & 'a mut W { self . variant (RESOLUTION_A :: DITH6) } } # [doc = "Prescaler\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum PRESCALER_A { # [doc = "0: No division"]
DIV1 = 0 , # [doc = "1: Divide by 2"]
DIV2 = 1 , # [doc = "2: Divide by 4"]
DIV4 = 2 , # [doc = "3: Divide by 8"]
DIV8 = 3 , # [doc = "4: Divide by 16"]
DIV16 = 4 , # [doc = "5: Divide by 64"]
DIV64 = 5 , # [doc = "6: Divide by 256"]
DIV256 = 6 , # [doc = "7: Divide by 1024"]
DIV1024 = 7 , } impl From < PRESCALER_A > for u8 { # [inline (always)]
fn from (variant : PRESCALER_A) -> Self { variant as _ } } # [doc = "Field `PRESCALER` reader - Prescaler"]
pub type PRESCALER_R = crate :: FieldReader < u8 , PRESCALER_A > ; impl PRESCALER_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> PRESCALER_A { match self . bits { 0 => PRESCALER_A :: DIV1 , 1 => PRESCALER_A :: DIV2 , 2 => PRESCALER_A :: DIV4 , 3 => PRESCALER_A :: DIV8 , 4 => PRESCALER_A :: DIV16 , 5 => PRESCALER_A :: DIV64 , 6 => PRESCALER_A :: DIV256 , 7 => PRESCALER_A :: DIV1024 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DIV1`"]
# [inline (always)]
pub fn is_div1 (& self) -> bool { * self == PRESCALER_A :: DIV1 } # [doc = "Checks if the value of the field is `DIV2`"]
# [inline (always)]
pub fn is_div2 (& self) -> bool { * self == PRESCALER_A :: DIV2 } # [doc = "Checks if the value of the field is `DIV4`"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == PRESCALER_A :: DIV4 } # [doc = "Checks if the value of the field is `DIV8`"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == PRESCALER_A :: DIV8 } # [doc = "Checks if the value of the field is `DIV16`"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == PRESCALER_A :: DIV16 } # [doc = "Checks if the value of the field is `DIV64`"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == PRESCALER_A :: DIV64 } # [doc = "Checks if the value of the field is `DIV256`"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == PRESCALER_A :: DIV256 } # [doc = "Checks if the value of the field is `DIV1024`"]
# [inline (always)]
pub fn is_div1024 (& self) -> bool { * self == PRESCALER_A :: DIV1024 } } # [doc = "Field `PRESCALER` writer - Prescaler"]
pub type PRESCALER_W < 'a > = crate :: FieldWriterSafe < 'a , u32 , CTRLA_SPEC , u8 , PRESCALER_A , 3 , 8 > ; impl < 'a > PRESCALER_W < 'a > { # [doc = "No division"]
# [inline (always)]
pub fn div1 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV1) } # [doc = "Divide by 2"]
# [inline (always)]
pub fn div2 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV2) } # [doc = "Divide by 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV4) } # [doc = "Divide by 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV8) } # [doc = "Divide by 16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV16) } # [doc = "Divide by 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV64) } # [doc = "Divide by 256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV256) } # [doc = "Divide by 1024"]
# [inline (always)]
pub fn div1024 (self) -> & 'a mut W { self . variant (PRESCALER_A :: DIV1024) } } # [doc = "Field `RUNSTDBY` reader - Run in Standby"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run in Standby"]
pub type RUNSTDBY_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 11 > ; # [doc = "Prescaler and Counter Synchronization Selection\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum PRESCSYNC_A { # [doc = "0: Reload or reset counter on next GCLK"]
GCLK = 0 , # [doc = "1: Reload or reset counter on next prescaler clock"]
PRESC = 1 , # [doc = "2: Reload or reset counter on next GCLK and reset prescaler counter"]
RESYNC = 2 , } impl From < PRESCSYNC_A > for u8 { # [inline (always)]
fn from (variant : PRESCSYNC_A) -> Self { variant as _ } } # [doc = "Field `PRESCSYNC` reader - Prescaler and Counter Synchronization Selection"]
pub type PRESCSYNC_R = crate :: FieldReader < u8 , PRESCSYNC_A > ; impl PRESCSYNC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PRESCSYNC_A > { match self . bits { 0 => Some (PRESCSYNC_A :: GCLK) , 1 => Some (PRESCSYNC_A :: PRESC) , 2 => Some (PRESCSYNC_A :: RESYNC) , _ => None , } } # [doc = "Checks if the value of the field is `GCLK`"]
# [inline (always)]
pub fn is_gclk (& self) -> bool { * self == PRESCSYNC_A :: GCLK } # [doc = "Checks if the value of the field is `PRESC`"]
# [inline (always)]
pub fn is_presc (& self) -> bool { * self == PRESCSYNC_A :: PRESC } # [doc = "Checks if the value of the field is `RESYNC`"]
# [inline (always)]
pub fn is_resync (& self) -> bool { * self == PRESCSYNC_A :: RESYNC } } # [doc = "Field `PRESCSYNC` writer - Prescaler and Counter Synchronization Selection"]
pub type PRESCSYNC_W < 'a > = crate :: FieldWriter < 'a , u32 , CTRLA_SPEC , u8 , PRESCSYNC_A , 2 , 12 > ; impl < 'a > PRESCSYNC_W < 'a > { # [doc = "Reload or reset counter on next GCLK"]
# [inline (always)]
pub fn gclk (self) -> & 'a mut W { self . variant (PRESCSYNC_A :: GCLK) } # [doc = "Reload or reset counter on next prescaler clock"]
# [inline (always)]
pub fn presc (self) -> & 'a mut W { self . variant (PRESCSYNC_A :: PRESC) } # [doc = "Reload or reset counter on next GCLK and reset prescaler counter"]
# [inline (always)]
pub fn resync (self) -> & 'a mut W { self . variant (PRESCSYNC_A :: RESYNC) } } # [doc = "Field `ALOCK` reader - Auto Lock"]
pub type ALOCK_R = crate :: BitReader < bool > ; # [doc = "Field `ALOCK` writer - Auto Lock"]
pub type ALOCK_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 14 > ; # [doc = "Field `CPTEN0` reader - Capture Channel 0 Enable"]
pub type CPTEN0_R = crate :: BitReader < bool > ; # [doc = "Field `CPTEN0` writer - Capture Channel 0 Enable"]
pub type CPTEN0_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 24 > ; # [doc = "Field `CPTEN1` reader - Capture Channel 1 Enable"]
pub type CPTEN1_R = crate :: BitReader < bool > ; # [doc = "Field `CPTEN1` writer - Capture Channel 1 Enable"]
pub type CPTEN1_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 25 > ; # [doc = "Field `CPTEN2` reader - Capture Channel 2 Enable"]
pub type CPTEN2_R = crate :: BitReader < bool > ; # [doc = "Field `CPTEN2` writer - Capture Channel 2 Enable"]
pub type CPTEN2_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 26 > ; # [doc = "Field `CPTEN3` reader - Capture Channel 3 Enable"]
pub type CPTEN3_R = crate :: BitReader < bool > ; # [doc = "Field `CPTEN3` writer - Capture Channel 3 Enable"]
pub type CPTEN3_W < 'a > = crate :: BitWriter < 'a , u32 , CTRLA_SPEC , bool , 27 > ; impl R { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& self) -> SWRST_R { SWRST_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 5:6 - Enhanced Resolution"]
# [inline (always)]
pub fn resolution (& self) -> RESOLUTION_R { RESOLUTION_R :: new (((self . bits >> 5) & 3) as u8) } # [doc = "Bits 8:10 - Prescaler"]
# [inline (always)]
pub fn prescaler (& self) -> PRESCALER_R { PRESCALER_R :: new (((self . bits >> 8) & 7) as u8) } # [doc = "Bit 11 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bits 12:13 - Prescaler and Counter Synchronization Selection"]
# [inline (always)]
pub fn prescsync (& self) -> PRESCSYNC_R { PRESCSYNC_R :: new (((self . bits >> 12) & 3) as u8) } # [doc = "Bit 14 - Auto Lock"]
# [inline (always)]
pub fn alock (& self) -> ALOCK_R { ALOCK_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 24 - Capture Channel 0 Enable"]
# [inline (always)]
pub fn cpten0 (& self) -> CPTEN0_R { CPTEN0_R :: new (((self . bits >> 24) & 1) != 0) } # [doc = "Bit 25 - Capture Channel 1 Enable"]
# [inline (always)]
pub fn cpten1 (& self) -> CPTEN1_R { CPTEN1_R :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - Capture Channel 2 Enable"]
# [inline (always)]
pub fn cpten2 (& self) -> CPTEN2_R { CPTEN2_R :: new (((self . bits >> 26) & 1) != 0) } # [doc = "Bit 27 - Capture Channel 3 Enable"]
# [inline (always)]
pub fn cpten3 (& self) -> CPTEN3_R { CPTEN3_R :: new (((self . bits >> 27) & 1) != 0) } } impl W { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& mut self) -> SWRST_W { SWRST_W :: new (self) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Bits 5:6 - Enhanced Resolution"]
# [inline (always)]
pub fn resolution (& mut self) -> RESOLUTION_W { RESOLUTION_W :: new (self) } # [doc = "Bits 8:10 - Prescaler"]
# [inline (always)]
pub fn prescaler (& mut self) -> PRESCALER_W { PRESCALER_W :: new (self) } # [doc = "Bit 11 - Run in Standby"]
# [inline (always)]
pub fn runstdby (& mut self) -> RUNSTDBY_W { RUNSTDBY_W :: new (self) } # [doc = "Bits 12:13 - Prescaler and Counter Synchronization Selection"]
# [inline (always)]
pub fn prescsync (& mut self) -> PRESCSYNC_W { PRESCSYNC_W :: new (self) } # [doc = "Bit 14 - Auto Lock"]
# [inline (always)]
pub fn alock (& mut self) -> ALOCK_W { ALOCK_W :: new (self) } # [doc = "Bit 24 - Capture Channel 0 Enable"]
# [inline (always)]
pub fn cpten0 (& mut self) -> CPTEN0_W { CPTEN0_W :: new (self) } # [doc = "Bit 25 - Capture Channel 1 Enable"]
# [inline (always)]
pub fn cpten1 (& mut self) -> CPTEN1_W { CPTEN1_W :: new (self) } # [doc = "Bit 26 - Capture Channel 2 Enable"]
# [inline (always)]
pub fn cpten2 (& mut self) -> CPTEN2_W { CPTEN2_W :: new (self) } # [doc = "Bit 27 - Capture Channel 3 Enable"]
# [inline (always)]
pub fn cpten3 (& mut self) -> CPTEN3_W { CPTEN3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CTRLBCLR register accessor: an alias for `Reg<CTRLBCLR_SPEC>`"]
pub type CTRLBCLR = crate :: Reg < ctrlbclr :: CTRLBCLR_SPEC > ; # [doc = "Control B Clear"]
pub mod ctrlbclr { # [doc = "Register `CTRLBCLR` reader"]
pub struct R (crate :: R < CTRLBCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLBCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLBCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLBCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLBCLR` writer"]
pub struct W (crate :: W < CTRLBCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLBCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLBCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLBCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Counter Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` writer - Counter Direction"]
pub type DIR_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLBCLR_SPEC , bool , 0 > ; # [doc = "Field `LUPD` reader - Lock Update"]
pub type LUPD_R = crate :: BitReader < bool > ; # [doc = "Field `LUPD` writer - Lock Update"]
pub type LUPD_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLBCLR_SPEC , bool , 1 > ; # [doc = "Field `ONESHOT` reader - One-Shot"]
pub type ONESHOT_R = crate :: BitReader < bool > ; # [doc = "Field `ONESHOT` writer - One-Shot"]
pub type ONESHOT_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLBCLR_SPEC , bool , 2 > ; # [doc = "Ramp Index Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum IDXCMD_A { # [doc = "0: Command disabled: Index toggles between cycles A and B"]
DISABLE = 0 , # [doc = "1: Set index: cycle B will be forced in the next cycle"]
SET = 1 , # [doc = "2: Clear index: cycle A will be forced in the next cycle"]
CLEAR = 2 , # [doc = "3: Hold index: the next cycle will be the same as the current cycle"]
HOLD = 3 , } impl From < IDXCMD_A > for u8 { # [inline (always)]
fn from (variant : IDXCMD_A) -> Self { variant as _ } } # [doc = "Field `IDXCMD` reader - Ramp Index Command"]
pub type IDXCMD_R = crate :: FieldReader < u8 , IDXCMD_A > ; impl IDXCMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> IDXCMD_A { match self . bits { 0 => IDXCMD_A :: DISABLE , 1 => IDXCMD_A :: SET , 2 => IDXCMD_A :: CLEAR , 3 => IDXCMD_A :: HOLD , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DISABLE`"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == IDXCMD_A :: DISABLE } # [doc = "Checks if the value of the field is `SET`"]
# [inline (always)]
pub fn is_set (& self) -> bool { * self == IDXCMD_A :: SET } # [doc = "Checks if the value of the field is `CLEAR`"]
# [inline (always)]
pub fn is_clear (& self) -> bool { * self == IDXCMD_A :: CLEAR } # [doc = "Checks if the value of the field is `HOLD`"]
# [inline (always)]
pub fn is_hold (& self) -> bool { * self == IDXCMD_A :: HOLD } } # [doc = "Field `IDXCMD` writer - Ramp Index Command"]
pub type IDXCMD_W < 'a > = crate :: FieldWriterSafe < 'a , u8 , CTRLBCLR_SPEC , u8 , IDXCMD_A , 2 , 3 > ; impl < 'a > IDXCMD_W < 'a > { # [doc = "Command disabled: Index toggles between cycles A and B"]
# [inline (always)]
pub fn disable (self) -> & 'a mut W { self . variant (IDXCMD_A :: DISABLE) } # [doc = "Set index: cycle B will be forced in the next cycle"]
# [inline (always)]
pub fn set (self) -> & 'a mut W { self . variant (IDXCMD_A :: SET) } # [doc = "Clear index: cycle A will be forced in the next cycle"]
# [inline (always)]
pub fn clear (self) -> & 'a mut W { self . variant (IDXCMD_A :: CLEAR) } # [doc = "Hold index: the next cycle will be the same as the current cycle"]
# [inline (always)]
pub fn hold (self) -> & 'a mut W { self . variant (IDXCMD_A :: HOLD) } } # [doc = "TCC Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No action"]
NONE = 0 , # [doc = "1: Clear start, restart or retrigger"]
RETRIGGER = 1 , # [doc = "2: Force stop"]
STOP = 2 , # [doc = "3: Force update of double buffered registers"]
UPDATE = 3 , # [doc = "4: Force COUNT read synchronization"]
READSYNC = 4 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } # [doc = "Field `CMD` reader - TCC Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CMD_A > { match self . bits { 0 => Some (CMD_A :: NONE) , 1 => Some (CMD_A :: RETRIGGER) , 2 => Some (CMD_A :: STOP) , 3 => Some (CMD_A :: UPDATE) , 4 => Some (CMD_A :: READSYNC) , _ => None , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == CMD_A :: NONE } # [doc = "Checks if the value of the field is `RETRIGGER`"]
# [inline (always)]
pub fn is_retrigger (& self) -> bool { * self == CMD_A :: RETRIGGER } # [doc = "Checks if the value of the field is `STOP`"]
# [inline (always)]
pub fn is_stop (& self) -> bool { * self == CMD_A :: STOP } # [doc = "Checks if the value of the field is `UPDATE`"]
# [inline (always)]
pub fn is_update (& self) -> bool { * self == CMD_A :: UPDATE } # [doc = "Checks if the value of the field is `READSYNC`"]
# [inline (always)]
pub fn is_readsync (& self) -> bool { * self == CMD_A :: READSYNC } } # [doc = "Field `CMD` writer - TCC Command"]
pub type CMD_W < 'a > = crate :: FieldWriter < 'a , u8 , CTRLBCLR_SPEC , u8 , CMD_A , 3 , 5 > ; impl < 'a > CMD_W < 'a > { # [doc = "No action"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (CMD_A :: NONE) } # [doc = "Clear start, restart or retrigger"]
# [inline (always)]
pub fn retrigger (self) -> & 'a mut W { self . variant (CMD_A :: RETRIGGER) } # [doc = "Force stop"]
# [inline (always)]
pub fn stop (self) -> & 'a mut W { self . variant (CMD_A :: STOP) } # [doc = "Force update of double buffered registers"]
# [inline (always)]
pub fn update (self) -> & 'a mut W { self . variant (CMD_A :: UPDATE) } # [doc = "Force COUNT read synchronization"]
# [inline (always)]
pub fn readsync (self) -> & 'a mut W { self . variant (CMD_A :: READSYNC) } } impl R { # [doc = "Bit 0 - Counter Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
pub fn lupd (& self) -> LUPD_R { LUPD_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - One-Shot"]
# [inline (always)]
pub fn oneshot (& self) -> ONESHOT_R { ONESHOT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 3:4 - Ramp Index Command"]
# [inline (always)]
pub fn idxcmd (& self) -> IDXCMD_R { IDXCMD_R :: new (((self . bits >> 3) & 3) as u8) } # [doc = "Bits 5:7 - TCC Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new (((self . bits >> 5) & 7) as u8) } } impl W { # [doc = "Bit 0 - Counter Direction"]
# [inline (always)]
pub fn dir (& mut self) -> DIR_W { DIR_W :: new (self) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
pub fn lupd (& mut self) -> LUPD_W { LUPD_W :: new (self) } # [doc = "Bit 2 - One-Shot"]
# [inline (always)]
pub fn oneshot (& mut self) -> ONESHOT_W { ONESHOT_W :: new (self) } # [doc = "Bits 3:4 - Ramp Index Command"]
# [inline (always)]
pub fn idxcmd (& mut self) -> IDXCMD_W { IDXCMD_W :: new (self) } # [doc = "Bits 5:7 - TCC Command"]
# [inline (always)]
pub fn cmd (& mut self) -> CMD_W { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlbclr](index.html) module"]
pub struct CTRLBCLR_SPEC ; impl crate :: RegisterSpec for CTRLBCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlbclr::R](R) reader structure"]
impl crate :: Readable for CTRLBCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlbclr::W](W) writer structure"]
impl crate :: Writable for CTRLBCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLBCLR to value 0"]
impl crate :: Resettable for CTRLBCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CTRLBSET register accessor: an alias for `Reg<CTRLBSET_SPEC>`"]
pub type CTRLBSET = crate :: Reg < ctrlbset :: CTRLBSET_SPEC > ; # [doc = "Control B Set"]
pub mod ctrlbset { # [doc = "Register `CTRLBSET` reader"]
pub struct R (crate :: R < CTRLBSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLBSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLBSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLBSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLBSET` writer"]
pub struct W (crate :: W < CTRLBSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLBSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLBSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLBSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `DIR` reader - Counter Direction"]
pub type DIR_R = crate :: BitReader < bool > ; # [doc = "Field `DIR` writer - Counter Direction"]
pub type DIR_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLBSET_SPEC , bool , 0 > ; # [doc = "Field `LUPD` reader - Lock Update"]
pub type LUPD_R = crate :: BitReader < bool > ; # [doc = "Field `LUPD` writer - Lock Update"]
pub type LUPD_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLBSET_SPEC , bool , 1 > ; # [doc = "Field `ONESHOT` reader - One-Shot"]
pub type ONESHOT_R = crate :: BitReader < bool > ; # [doc = "Field `ONESHOT` writer - One-Shot"]
pub type ONESHOT_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLBSET_SPEC , bool , 2 > ; # [doc = "Ramp Index Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum IDXCMD_A { # [doc = "0: Command disabled: Index toggles between cycles A and B"]
DISABLE = 0 , # [doc = "1: Set index: cycle B will be forced in the next cycle"]
SET = 1 , # [doc = "2: Clear index: cycle A will be forced in the next cycle"]
CLEAR = 2 , # [doc = "3: Hold index: the next cycle will be the same as the current cycle"]
HOLD = 3 , } impl From < IDXCMD_A > for u8 { # [inline (always)]
fn from (variant : IDXCMD_A) -> Self { variant as _ } } # [doc = "Field `IDXCMD` reader - Ramp Index Command"]
pub type IDXCMD_R = crate :: FieldReader < u8 , IDXCMD_A > ; impl IDXCMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> IDXCMD_A { match self . bits { 0 => IDXCMD_A :: DISABLE , 1 => IDXCMD_A :: SET , 2 => IDXCMD_A :: CLEAR , 3 => IDXCMD_A :: HOLD , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DISABLE`"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == IDXCMD_A :: DISABLE } # [doc = "Checks if the value of the field is `SET`"]
# [inline (always)]
pub fn is_set (& self) -> bool { * self == IDXCMD_A :: SET } # [doc = "Checks if the value of the field is `CLEAR`"]
# [inline (always)]
pub fn is_clear (& self) -> bool { * self == IDXCMD_A :: CLEAR } # [doc = "Checks if the value of the field is `HOLD`"]
# [inline (always)]
pub fn is_hold (& self) -> bool { * self == IDXCMD_A :: HOLD } } # [doc = "Field `IDXCMD` writer - Ramp Index Command"]
pub type IDXCMD_W < 'a > = crate :: FieldWriterSafe < 'a , u8 , CTRLBSET_SPEC , u8 , IDXCMD_A , 2 , 3 > ; impl < 'a > IDXCMD_W < 'a > { # [doc = "Command disabled: Index toggles between cycles A and B"]
# [inline (always)]
pub fn disable (self) -> & 'a mut W { self . variant (IDXCMD_A :: DISABLE) } # [doc = "Set index: cycle B will be forced in the next cycle"]
# [inline (always)]
pub fn set (self) -> & 'a mut W { self . variant (IDXCMD_A :: SET) } # [doc = "Clear index: cycle A will be forced in the next cycle"]
# [inline (always)]
pub fn clear (self) -> & 'a mut W { self . variant (IDXCMD_A :: CLEAR) } # [doc = "Hold index: the next cycle will be the same as the current cycle"]
# [inline (always)]
pub fn hold (self) -> & 'a mut W { self . variant (IDXCMD_A :: HOLD) } } # [doc = "TCC Command\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CMD_A { # [doc = "0: No action"]
NONE = 0 , # [doc = "1: Clear start, restart or retrigger"]
RETRIGGER = 1 , # [doc = "2: Force stop"]
STOP = 2 , # [doc = "3: Force update of double buffered registers"]
UPDATE = 3 , # [doc = "4: Force COUNT read synchronization"]
READSYNC = 4 , } impl From < CMD_A > for u8 { # [inline (always)]
fn from (variant : CMD_A) -> Self { variant as _ } } # [doc = "Field `CMD` reader - TCC Command"]
pub type CMD_R = crate :: FieldReader < u8 , CMD_A > ; impl CMD_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CMD_A > { match self . bits { 0 => Some (CMD_A :: NONE) , 1 => Some (CMD_A :: RETRIGGER) , 2 => Some (CMD_A :: STOP) , 3 => Some (CMD_A :: UPDATE) , 4 => Some (CMD_A :: READSYNC) , _ => None , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == CMD_A :: NONE } # [doc = "Checks if the value of the field is `RETRIGGER`"]
# [inline (always)]
pub fn is_retrigger (& self) -> bool { * self == CMD_A :: RETRIGGER } # [doc = "Checks if the value of the field is `STOP`"]
# [inline (always)]
pub fn is_stop (& self) -> bool { * self == CMD_A :: STOP } # [doc = "Checks if the value of the field is `UPDATE`"]
# [inline (always)]
pub fn is_update (& self) -> bool { * self == CMD_A :: UPDATE } # [doc = "Checks if the value of the field is `READSYNC`"]
# [inline (always)]
pub fn is_readsync (& self) -> bool { * self == CMD_A :: READSYNC } } # [doc = "Field `CMD` writer - TCC Command"]
pub type CMD_W < 'a > = crate :: FieldWriter < 'a , u8 , CTRLBSET_SPEC , u8 , CMD_A , 3 , 5 > ; impl < 'a > CMD_W < 'a > { # [doc = "No action"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (CMD_A :: NONE) } # [doc = "Clear start, restart or retrigger"]
# [inline (always)]
pub fn retrigger (self) -> & 'a mut W { self . variant (CMD_A :: RETRIGGER) } # [doc = "Force stop"]
# [inline (always)]
pub fn stop (self) -> & 'a mut W { self . variant (CMD_A :: STOP) } # [doc = "Force update of double buffered registers"]
# [inline (always)]
pub fn update (self) -> & 'a mut W { self . variant (CMD_A :: UPDATE) } # [doc = "Force COUNT read synchronization"]
# [inline (always)]
pub fn readsync (self) -> & 'a mut W { self . variant (CMD_A :: READSYNC) } } impl R { # [doc = "Bit 0 - Counter Direction"]
# [inline (always)]
pub fn dir (& self) -> DIR_R { DIR_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
pub fn lupd (& self) -> LUPD_R { LUPD_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - One-Shot"]
# [inline (always)]
pub fn oneshot (& self) -> ONESHOT_R { ONESHOT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 3:4 - Ramp Index Command"]
# [inline (always)]
pub fn idxcmd (& self) -> IDXCMD_R { IDXCMD_R :: new (((self . bits >> 3) & 3) as u8) } # [doc = "Bits 5:7 - TCC Command"]
# [inline (always)]
pub fn cmd (& self) -> CMD_R { CMD_R :: new (((self . bits >> 5) & 7) as u8) } } impl W { # [doc = "Bit 0 - Counter Direction"]
# [inline (always)]
pub fn dir (& mut self) -> DIR_W { DIR_W :: new (self) } # [doc = "Bit 1 - Lock Update"]
# [inline (always)]
pub fn lupd (& mut self) -> LUPD_W { LUPD_W :: new (self) } # [doc = "Bit 2 - One-Shot"]
# [inline (always)]
pub fn oneshot (& mut self) -> ONESHOT_W { ONESHOT_W :: new (self) } # [doc = "Bits 3:4 - Ramp Index Command"]
# [inline (always)]
pub fn idxcmd (& mut self) -> IDXCMD_W { IDXCMD_W :: new (self) } # [doc = "Bits 5:7 - TCC Command"]
# [inline (always)]
pub fn cmd (& mut self) -> CMD_W { CMD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control B Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlbset](index.html) module"]
pub struct CTRLBSET_SPEC ; impl crate :: RegisterSpec for CTRLBSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrlbset::R](R) reader structure"]
impl crate :: Readable for CTRLBSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlbset::W](W) writer structure"]
impl crate :: Writable for CTRLBSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLBSET to value 0"]
impl crate :: Resettable for CTRLBSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYNCBUSY register accessor: an alias for `Reg<SYNCBUSY_SPEC>`"]
pub type SYNCBUSY = crate :: Reg < syncbusy :: SYNCBUSY_SPEC > ; # [doc = "Synchronization Busy"]
pub mod syncbusy { # [doc = "Register `SYNCBUSY` reader"]
pub struct R (crate :: R < SYNCBUSY_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYNCBUSY_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYNCBUSY_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYNCBUSY_SPEC >) -> Self { R (reader) } } # [doc = "Field `SWRST` reader - Swrst Busy"]
pub type SWRST_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` reader - Enable Busy"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `CTRLB` reader - Ctrlb Busy"]
pub type CTRLB_R = crate :: BitReader < bool > ; # [doc = "Field `STATUS` reader - Status Busy"]
pub type STATUS_R = crate :: BitReader < bool > ; # [doc = "Field `COUNT` reader - Count Busy"]
pub type COUNT_R = crate :: BitReader < bool > ; # [doc = "Field `PATT` reader - Pattern Busy"]
pub type PATT_R = crate :: BitReader < bool > ; # [doc = "Field `WAVE` reader - Wave Busy"]
pub type WAVE_R = crate :: BitReader < bool > ; # [doc = "Field `PER` reader - Period busy"]
pub type PER_R = crate :: BitReader < bool > ; # [doc = "Field `CC0` reader - Compare Channel 0 Busy"]
pub type CC0_R = crate :: BitReader < bool > ; # [doc = "Field `CC1` reader - Compare Channel 1 Busy"]
pub type CC1_R = crate :: BitReader < bool > ; # [doc = "Field `CC2` reader - Compare Channel 2 Busy"]
pub type CC2_R = crate :: BitReader < bool > ; # [doc = "Field `CC3` reader - Compare Channel 3 Busy"]
pub type CC3_R = crate :: BitReader < bool > ; # [doc = "Field `PATTB` reader - Pattern Buffer Busy"]
pub type PATTB_R = crate :: BitReader < bool > ; # [doc = "Field `WAVEB` reader - Wave Buffer Busy"]
pub type WAVEB_R = crate :: BitReader < bool > ; # [doc = "Field `PERB` reader - Period Buffer Busy"]
pub type PERB_R = crate :: BitReader < bool > ; # [doc = "Field `CCB0` reader - Compare Channel Buffer 0 Busy"]
pub type CCB0_R = crate :: BitReader < bool > ; # [doc = "Field `CCB1` reader - Compare Channel Buffer 1 Busy"]
pub type CCB1_R = crate :: BitReader < bool > ; # [doc = "Field `CCB2` reader - Compare Channel Buffer 2 Busy"]
pub type CCB2_R = crate :: BitReader < bool > ; # [doc = "Field `CCB3` reader - Compare Channel Buffer 3 Busy"]
pub type CCB3_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Swrst Busy"]
# [inline (always)]
pub fn swrst (& self) -> SWRST_R { SWRST_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Enable Busy"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Ctrlb Busy"]
# [inline (always)]
pub fn ctrlb (& self) -> CTRLB_R { CTRLB_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Status Busy"]
# [inline (always)]
pub fn status (& self) -> STATUS_R { STATUS_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Count Busy"]
# [inline (always)]
pub fn count (& self) -> COUNT_R { COUNT_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pattern Busy"]
# [inline (always)]
pub fn patt (& self) -> PATT_R { PATT_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Wave Busy"]
# [inline (always)]
pub fn wave (& self) -> WAVE_R { WAVE_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Period busy"]
# [inline (always)]
pub fn per (& self) -> PER_R { PER_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Compare Channel 0 Busy"]
# [inline (always)]
pub fn cc0 (& self) -> CC0_R { CC0_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Compare Channel 1 Busy"]
# [inline (always)]
pub fn cc1 (& self) -> CC1_R { CC1_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Compare Channel 2 Busy"]
# [inline (always)]
pub fn cc2 (& self) -> CC2_R { CC2_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Compare Channel 3 Busy"]
# [inline (always)]
pub fn cc3 (& self) -> CC3_R { CC3_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 16 - Pattern Buffer Busy"]
# [inline (always)]
pub fn pattb (& self) -> PATTB_R { PATTB_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Wave Buffer Busy"]
# [inline (always)]
pub fn waveb (& self) -> WAVEB_R { WAVEB_R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Period Buffer Busy"]
# [inline (always)]
pub fn perb (& self) -> PERB_R { PERB_R :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Compare Channel Buffer 0 Busy"]
# [inline (always)]
pub fn ccb0 (& self) -> CCB0_R { CCB0_R :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 20 - Compare Channel Buffer 1 Busy"]
# [inline (always)]
pub fn ccb1 (& self) -> CCB1_R { CCB1_R :: new (((self . bits >> 20) & 1) != 0) } # [doc = "Bit 21 - Compare Channel Buffer 2 Busy"]
# [inline (always)]
pub fn ccb2 (& self) -> CCB2_R { CCB2_R :: new (((self . bits >> 21) & 1) != 0) } # [doc = "Bit 22 - Compare Channel Buffer 3 Busy"]
# [inline (always)]
pub fn ccb3 (& self) -> CCB3_R { CCB3_R :: new (((self . bits >> 22) & 1) != 0) } } # [doc = "Synchronization Busy\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [syncbusy](index.html) module"]
pub struct SYNCBUSY_SPEC ; impl crate :: RegisterSpec for SYNCBUSY_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [syncbusy::R](R) reader structure"]
impl crate :: Readable for SYNCBUSY_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SYNCBUSY to value 0"]
impl crate :: Resettable for SYNCBUSY_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "FCTRLA register accessor: an alias for `Reg<FCTRLA_SPEC>`"]
pub type FCTRLA = crate :: Reg < fctrla :: FCTRLA_SPEC > ; # [doc = "Recoverable Fault A Configuration"]
pub mod fctrla { # [doc = "Register `FCTRLA` reader"]
pub struct R (crate :: R < FCTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < FCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < FCTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < FCTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `FCTRLA` writer"]
pub struct W (crate :: W < FCTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < FCTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < FCTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < FCTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Fault A Source\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum SRC_A { # [doc = "0: Fault input disabled"]
DISABLE = 0 , # [doc = "1: MCEx (x=0,1) event input"]
ENABLE = 1 , # [doc = "2: Inverted MCEx (x=0,1) event input"]
INVERT = 2 , # [doc = "3: Alternate fault (A or B) state at the end of the previous period"]
ALTFAULT = 3 , } impl From < SRC_A > for u8 { # [inline (always)]
fn from (variant : SRC_A) -> Self { variant as _ } } # [doc = "Field `SRC` reader - Fault A Source"]
pub type SRC_R = crate :: FieldReader < u8 , SRC_A > ; impl SRC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SRC_A { match self . bits { 0 => SRC_A :: DISABLE , 1 => SRC_A :: ENABLE , 2 => SRC_A :: INVERT , 3 => SRC_A :: ALTFAULT , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DISABLE`"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == SRC_A :: DISABLE } # [doc = "Checks if the value of the field is `ENABLE`"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == SRC_A :: ENABLE } # [doc = "Checks if the value of the field is `INVERT`"]
# [inline (always)]
pub fn is_invert (& self) -> bool { * self == SRC_A :: INVERT } # [doc = "Checks if the value of the field is `ALTFAULT`"]
# [inline (always)]
pub fn is_altfault (& self) -> bool { * self == SRC_A :: ALTFAULT } } # [doc = "Field `SRC` writer - Fault A Source"]
pub type SRC_W < 'a > = crate :: FieldWriterSafe < 'a , u32 , FCTRLA_SPEC , u8 , SRC_A , 2 , 0 > ; impl < 'a > SRC_W < 'a > { # [doc = "Fault input disabled"]
# [inline (always)]
pub fn disable (self) -> & 'a mut W { self . variant (SRC_A :: DISABLE) } # [doc = "MCEx (x=0,1) event input"]
# [inline (always)]
pub fn enable (self) -> & 'a mut W { self . variant (SRC_A :: ENABLE) } # [doc = "Inverted MCEx (x=0,1) event input"]
# [inline (always)]
pub fn invert (self) -> & 'a mut W { self . variant (SRC_A :: INVERT) } # [doc = "Alternate fault (A or B) state at the end of the previous period"]
# [inline (always)]
pub fn altfault (self) -> & 'a mut W { self . variant (SRC_A :: ALTFAULT) } } # [doc = "Field `KEEP` reader - Fault A Keeper"]
pub type KEEP_R = crate :: BitReader < bool > ; # [doc = "Field `KEEP` writer - Fault A Keeper"]
pub type KEEP_W < 'a > = crate :: BitWriter < 'a , u32 , FCTRLA_SPEC , bool , 3 > ; # [doc = "Field `QUAL` reader - Fault A Qualification"]
pub type QUAL_R = crate :: BitReader < bool > ; # [doc = "Field `QUAL` writer - Fault A Qualification"]
pub type QUAL_W < 'a > = crate :: BitWriter < 'a , u32 , FCTRLA_SPEC , bool , 4 > ; # [doc = "Fault A Blanking Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum BLANK_A { # [doc = "0: No blanking applied"]
NONE = 0 , # [doc = "1: Blanking applied from rising edge of the output waveform"]
RISE = 1 , # [doc = "2: Blanking applied from falling edge of the output waveform"]
FALL = 2 , # [doc = "3: Blanking applied from each toggle of the output waveform"]
BOTH = 3 , } impl From < BLANK_A > for u8 { # [inline (always)]
fn from (variant : BLANK_A) -> Self { variant as _ } } # [doc = "Field `BLANK` reader - Fault A Blanking Mode"]
pub type BLANK_R = crate :: FieldReader < u8 , BLANK_A > ; impl BLANK_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> BLANK_A { match self . bits { 0 => BLANK_A :: NONE , 1 => BLANK_A :: RISE , 2 => BLANK_A :: FALL , 3 => BLANK_A :: BOTH , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == BLANK_A :: NONE } # [doc = "Checks if the value of the field is `RISE`"]
# [inline (always)]
pub fn is_rise (& self) -> bool { * self == BLANK_A :: RISE } # [doc = "Checks if the value of the field is `FALL`"]
# [inline (always)]
pub fn is_fall (& self) -> bool { * self == BLANK_A :: FALL } # [doc = "Checks if the value of the field is `BOTH`"]
# [inline (always)]
pub fn is_both (& self) -> bool { * self == BLANK_A :: BOTH } } # [doc = "Field `BLANK` writer - Fault A Blanking Mode"]
pub type BLANK_W < 'a > = crate :: FieldWriterSafe < 'a , u32 , FCTRLA_SPEC , u8 , BLANK_A , 2 , 5 > ; impl < 'a > BLANK_W < 'a > { # [doc = "No blanking applied"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (BLANK_A :: NONE) } # [doc = "Blanking applied from rising edge of the output waveform"]
# [inline (always)]
pub fn rise (self) -> & 'a mut W { self . variant (BLANK_A :: RISE) } # [doc = "Blanking applied from falling edge of the output waveform"]
# [inline (always)]
pub fn fall (self) -> & 'a mut W { self . variant (BLANK_A :: FALL) } # [doc = "Blanking applied from each toggle of the output waveform"]
# [inline (always)]
pub fn both (self) -> & 'a mut W { self . variant (BLANK_A :: BOTH) } } # [doc = "Field `RESTART` reader - Fault A Restart"]
pub type RESTART_R = crate :: BitReader < bool > ; # [doc = "Field `RESTART` writer - Fault A Restart"]
pub type RESTART_W < 'a > = crate :: BitWriter < 'a , u32 , FCTRLA_SPEC , bool , 7 > ; # [doc = "Fault A Halt Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum HALT_A { # [doc = "0: Halt action disabled"]
DISABLE = 0 , # [doc = "1: Hardware halt action"]
HW = 1 , # [doc = "2: Software halt action"]
SW = 2 , # [doc = "3: Non-recoverable fault"]
NR = 3 , } impl From < HALT_A > for u8 { # [inline (always)]
fn from (variant : HALT_A) -> Self { variant as _ } } # [doc = "Field `HALT` reader - Fault A Halt Mode"]
pub type HALT_R = crate :: FieldReader < u8 , HALT_A > ; impl HALT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> HALT_A { match self . bits { 0 => HALT_A :: DISABLE , 1 => HALT_A :: HW , 2 => HALT_A :: SW , 3 => HALT_A :: NR , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DISABLE`"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == HALT_A :: DISABLE } # [doc = "Checks if the value of the field is `HW`"]
# [inline (always)]
pub fn is_hw (& self) -> bool { * self == HALT_A :: HW } # [doc = "Checks if the value of the field is `SW`"]
# [inline (always)]
pub fn is_sw (& self) -> bool { * self == HALT_A :: SW } # [doc = "Checks if the value of the field is `NR`"]
# [inline (always)]
pub fn is_nr (& self) -> bool { * self == HALT_A :: NR } } # [doc = "Field `HALT` writer - Fault A Halt Mode"]
pub type HALT_W < 'a > = crate :: FieldWriterSafe < 'a , u32 , FCTRLA_SPEC , u8 , HALT_A , 2 , 8 > ; impl < 'a > HALT_W < 'a > { # [doc = "Halt action disabled"]
# [inline (always)]
pub fn disable (self) -> & 'a mut W { self . variant (HALT_A :: DISABLE) } # [doc = "Hardware halt action"]
# [inline (always)]
pub fn hw (self) -> & 'a mut W { self . variant (HALT_A :: HW) } # [doc = "Software halt action"]
# [inline (always)]
pub fn sw (self) -> & 'a mut W { self . variant (HALT_A :: SW) } # [doc = "Non-recoverable fault"]
# [inline (always)]
pub fn nr (self) -> & 'a mut W { self . variant (HALT_A :: NR) } } # [doc = "Fault A Capture Channel\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CHSEL_A { # [doc = "0: Capture value stored in channel 0"]
CC0 = 0 , # [doc = "1: Capture value stored in channel 1"]
CC1 = 1 , # [doc = "2: Capture value stored in channel 2"]
CC2 = 2 , # [doc = "3: Capture value stored in channel 3"]
CC3 = 3 , } impl From < CHSEL_A > for u8 { # [inline (always)]
fn from (variant : CHSEL_A) -> Self { variant as _ } } # [doc = "Field `CHSEL` reader - Fault A Capture Channel"]
pub type CHSEL_R = crate :: FieldReader < u8 , CHSEL_A > ; impl CHSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CHSEL_A { match self . bits { 0 => CHSEL_A :: CC0 , 1 => CHSEL_A :: CC1 , 2 => CHSEL_A :: CC2 , 3 => CHSEL_A :: CC3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `CC0`"]
# [inline (always)]
pub fn is_cc0 (& self) -> bool { * self == CHSEL_A :: CC0 } # [doc = "Checks if the value of the field is `CC1`"]
# [inline (always)]
pub fn is_cc1 (& self) -> bool { * self == CHSEL_A :: CC1 } # [doc = "Checks if the value of the field is `CC2`"]
# [inline (always)]
pub fn is_cc2 (& self) -> bool { * self == CHSEL_A :: CC2 } # [doc = "Checks if the value of the field is `CC3`"]
# [inline (always)]
pub fn is_cc3 (& self) -> bool { * self == CHSEL_A :: CC3 } } # [doc = "Field `CHSEL` writer - Fault A Capture Channel"]
pub type CHSEL_W < 'a > = crate :: FieldWriterSafe < 'a , u32 , FCTRLA_SPEC , u8 , CHSEL_A , 2 , 10 > ; impl < 'a > CHSEL_W < 'a > { # [doc = "Capture value stored in channel 0"]
# [inline (always)]
pub fn cc0 (self) -> & 'a mut W { self . variant (CHSEL_A :: CC0) } # [doc = "Capture value stored in channel 1"]
# [inline (always)]
pub fn cc1 (self) -> & 'a mut W { self . variant (CHSEL_A :: CC1) } # [doc = "Capture value stored in channel 2"]
# [inline (always)]
pub fn cc2 (self) -> & 'a mut W { self . variant (CHSEL_A :: CC2) } # [doc = "Capture value stored in channel 3"]
# [inline (always)]
pub fn cc3 (self) -> & 'a mut W { self . variant (CHSEL_A :: CC3) } } # [doc = "Fault A Capture Action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CAPTURE_A { # [doc = "0: No capture"]
DISABLE = 0 , # [doc = "1: Capture on fault"]
CAPT = 1 , # [doc = "2: Minimum capture"]
CAPTMIN = 2 , # [doc = "3: Maximum capture"]
CAPTMAX = 3 , # [doc = "4: Minimum local detection"]
LOCMIN = 4 , # [doc = "5: Maximum local detection"]
LOCMAX = 5 , # [doc = "6: Minimum and maximum local detection"]
DERIV0 = 6 , } impl From < CAPTURE_A > for u8 { # [inline (always)]
fn from (variant : CAPTURE_A) -> Self { variant as _ } } # [doc = "Field `CAPTURE` reader - Fault A Capture Action"]
pub type CAPTURE_R = crate :: FieldReader < u8 , CAPTURE_A > ; impl CAPTURE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CAPTURE_A > { match self . bits { 0 => Some (CAPTURE_A :: DISABLE) , 1 => Some (CAPTURE_A :: CAPT) , 2 => Some (CAPTURE_A :: CAPTMIN) , 3 => Some (CAPTURE_A :: CAPTMAX) , 4 => Some (CAPTURE_A :: LOCMIN) , 5 => Some (CAPTURE_A :: LOCMAX) , 6 => Some (CAPTURE_A :: DERIV0) , _ => None , } } # [doc = "Checks if the value of the field is `DISABLE`"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == CAPTURE_A :: DISABLE } # [doc = "Checks if the value of the field is `CAPT`"]
# [inline (always)]
pub fn is_capt (& self) -> bool { * self == CAPTURE_A :: CAPT } # [doc = "Checks if the value of the field is `CAPTMIN`"]
# [inline (always)]
pub fn is_captmin (& self) -> bool { * self == CAPTURE_A :: CAPTMIN } # [doc = "Checks if the value of the field is `CAPTMAX`"]
# [inline (always)]
pub fn is_captmax (& self) -> bool { * self == CAPTURE_A :: CAPTMAX } # [doc = "Checks if the value of the field is `LOCMIN`"]
# [inline (always)]
pub fn is_locmin (& self) -> bool { * self == CAPTURE_A :: LOCMIN } # [doc = "Checks if the value of the field is `LOCMAX`"]
# [inline (always)]
pub fn is_locmax (& self) -> bool { * self == CAPTURE_A :: LOCMAX } # [doc = "Checks if the value of the field is `DERIV0`"]
# [inline (always)]
pub fn is_deriv0 (& self) -> bool { * self == CAPTURE_A :: DERIV0 } } # [doc = "Field `CAPTURE` writer - Fault A Capture Action"]
pub type CAPTURE_W < 'a > = crate :: FieldWriter < 'a , u32 , FCTRLA_SPEC , u8 , CAPTURE_A , 3 , 12 > ; impl < 'a > CAPTURE_W < 'a > { # [doc = "No capture"]
# [inline (always)]
pub fn disable (self) -> & 'a mut W { self . variant (CAPTURE_A :: DISABLE) } # [doc = "Capture on fault"]
# [inline (always)]
pub fn capt (self) -> & 'a mut W { self . variant (CAPTURE_A :: CAPT) } # [doc = "Minimum capture"]
# [inline (always)]
pub fn captmin (self) -> & 'a mut W { self . variant (CAPTURE_A :: CAPTMIN) } # [doc = "Maximum capture"]
# [inline (always)]
pub fn captmax (self) -> & 'a mut W { self . variant (CAPTURE_A :: CAPTMAX) } # [doc = "Minimum local detection"]
# [inline (always)]
pub fn locmin (self) -> & 'a mut W { self . variant (CAPTURE_A :: LOCMIN) } # [doc = "Maximum local detection"]
# [inline (always)]
pub fn locmax (self) -> & 'a mut W { self . variant (CAPTURE_A :: LOCMAX) } # [doc = "Minimum and maximum local detection"]
# [inline (always)]
pub fn deriv0 (self) -> & 'a mut W { self . variant (CAPTURE_A :: DERIV0) } } # [doc = "Field `BLANKVAL` reader - Fault A Blanking Time"]
pub type BLANKVAL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BLANKVAL` writer - Fault A Blanking Time"]
pub type BLANKVAL_W < 'a > = crate :: FieldWriter < 'a , u32 , FCTRLA_SPEC , u8 , u8 , 8 , 16 > ; # [doc = "Field `FILTERVAL` reader - Fault A Filter Value"]
pub type FILTERVAL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `FILTERVAL` writer - Fault A Filter Value"]
pub type FILTERVAL_W < 'a > = crate :: FieldWriter < 'a , u32 , FCTRLA_SPEC , u8 , u8 , 4 , 24 > ; impl R { # [doc = "Bits 0:1 - Fault A Source"]
# [inline (always)]
pub fn src (& self) -> SRC_R { SRC_R :: new ((self . bits & 3) as u8) } # [doc = "Bit 3 - Fault A Keeper"]
# [inline (always)]
pub fn keep (& self) -> KEEP_R { KEEP_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Fault A Qualification"]
# [inline (always)]
pub fn qual (& self) -> QUAL_R { QUAL_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:6 - Fault A Blanking Mode"]
# [inline (always)]
pub fn blank (& self) -> BLANK_R { BLANK_R :: new (((self . bits >> 5) & 3) as u8) } # [doc = "Bit 7 - Fault A Restart"]
# [inline (always)]
pub fn restart (& self) -> RESTART_R { RESTART_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bits 8:9 - Fault A Halt Mode"]
# [inline (always)]
pub fn halt (& self) -> HALT_R { HALT_R :: new (((self . bits >> 8) & 3) as u8) } # [doc = "Bits 10:11 - Fault A Capture Channel"]
# [inline (always)]
pub fn chsel (& self) -> CHSEL_R { CHSEL_R :: new (((self . bits >> 10) & 3) as u8) } # [doc = "Bits 12:14 - Fault A Capture Action"]
# [inline (always)]
pub fn capture (& self) -> CAPTURE_R { CAPTURE_R :: new (((self . bits >> 12) & 7) as u8) } # [doc = "Bits 16:23 - Fault A Blanking Time"]
# [inline (always)]
pub fn blankval (& self) -> BLANKVAL_R { BLANKVAL_R :: new (((self . bits >> 16) & 0xff) as u8) } # [doc = "Bits 24:27 - Fault A Filter Value"]
# [inline (always)]
pub fn filterval (& self) -> FILTERVAL_R { FILTERVAL_R :: new (((self . bits >> 24) & 0x0f) as u8) } } impl W { # [doc = "Bits 0:1 - Fault A Source"]
# [inline (always)]
pub fn src (& mut self) -> SRC_W { SRC_W :: new (self) } # [doc = "Bit 3 - Fault A Keeper"]
# [inline (always)]
pub fn keep (& mut self) -> KEEP_W { KEEP_W :: new (self) } # [doc = "Bit 4 - Fault A Qualification"]
# [inline (always)]
pub fn qual (& mut self) -> QUAL_W { QUAL_W :: new (self) } # [doc = "Bits 5:6 - Fault A Blanking Mode"]
# [inline (always)]
pub fn blank (& mut self) -> BLANK_W { BLANK_W :: new (self) } # [doc = "Bit 7 - Fault A Restart"]
# [inline (always)]
pub fn restart (& mut self) -> RESTART_W { RESTART_W :: new (self) } # [doc = "Bits 8:9 - Fault A Halt Mode"]
# [inline (always)]
pub fn halt (& mut self) -> HALT_W { HALT_W :: new (self) } # [doc = "Bits 10:11 - Fault A Capture Channel"]
# [inline (always)]
pub fn chsel (& mut self) -> CHSEL_W { CHSEL_W :: new (self) } # [doc = "Bits 12:14 - Fault A Capture Action"]
# [inline (always)]
pub fn capture (& mut self) -> CAPTURE_W { CAPTURE_W :: new (self) } # [doc = "Bits 16:23 - Fault A Blanking Time"]
# [inline (always)]
pub fn blankval (& mut self) -> BLANKVAL_W { BLANKVAL_W :: new (self) } # [doc = "Bits 24:27 - Fault A Filter Value"]
# [inline (always)]
pub fn filterval (& mut self) -> FILTERVAL_W { FILTERVAL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Recoverable Fault A Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fctrla](index.html) module"]
pub struct FCTRLA_SPEC ; impl crate :: RegisterSpec for FCTRLA_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [fctrla::R](R) reader structure"]
impl crate :: Readable for FCTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [fctrla::W](W) writer structure"]
impl crate :: Writable for FCTRLA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets FCTRLA to value 0"]
impl crate :: Resettable for FCTRLA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "FCTRLB register accessor: an alias for `Reg<FCTRLB_SPEC>`"]
pub type FCTRLB = crate :: Reg < fctrlb :: FCTRLB_SPEC > ; # [doc = "Recoverable Fault B Configuration"]
pub mod fctrlb { # [doc = "Register `FCTRLB` reader"]
pub struct R (crate :: R < FCTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < FCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < FCTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < FCTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `FCTRLB` writer"]
pub struct W (crate :: W < FCTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < FCTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < FCTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < FCTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Fault B Source\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum SRC_A { # [doc = "0: Fault input disabled"]
DISABLE = 0 , # [doc = "1: MCEx (x=0,1) event input"]
ENABLE = 1 , # [doc = "2: Inverted MCEx (x=0,1) event input"]
INVERT = 2 , # [doc = "3: Alternate fault (A or B) state at the end of the previous period"]
ALTFAULT = 3 , } impl From < SRC_A > for u8 { # [inline (always)]
fn from (variant : SRC_A) -> Self { variant as _ } } # [doc = "Field `SRC` reader - Fault B Source"]
pub type SRC_R = crate :: FieldReader < u8 , SRC_A > ; impl SRC_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SRC_A { match self . bits { 0 => SRC_A :: DISABLE , 1 => SRC_A :: ENABLE , 2 => SRC_A :: INVERT , 3 => SRC_A :: ALTFAULT , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DISABLE`"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == SRC_A :: DISABLE } # [doc = "Checks if the value of the field is `ENABLE`"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == SRC_A :: ENABLE } # [doc = "Checks if the value of the field is `INVERT`"]
# [inline (always)]
pub fn is_invert (& self) -> bool { * self == SRC_A :: INVERT } # [doc = "Checks if the value of the field is `ALTFAULT`"]
# [inline (always)]
pub fn is_altfault (& self) -> bool { * self == SRC_A :: ALTFAULT } } # [doc = "Field `SRC` writer - Fault B Source"]
pub type SRC_W < 'a > = crate :: FieldWriterSafe < 'a , u32 , FCTRLB_SPEC , u8 , SRC_A , 2 , 0 > ; impl < 'a > SRC_W < 'a > { # [doc = "Fault input disabled"]
# [inline (always)]
pub fn disable (self) -> & 'a mut W { self . variant (SRC_A :: DISABLE) } # [doc = "MCEx (x=0,1) event input"]
# [inline (always)]
pub fn enable (self) -> & 'a mut W { self . variant (SRC_A :: ENABLE) } # [doc = "Inverted MCEx (x=0,1) event input"]
# [inline (always)]
pub fn invert (self) -> & 'a mut W { self . variant (SRC_A :: INVERT) } # [doc = "Alternate fault (A or B) state at the end of the previous period"]
# [inline (always)]
pub fn altfault (self) -> & 'a mut W { self . variant (SRC_A :: ALTFAULT) } } # [doc = "Field `KEEP` reader - Fault B Keeper"]
pub type KEEP_R = crate :: BitReader < bool > ; # [doc = "Field `KEEP` writer - Fault B Keeper"]
pub type KEEP_W < 'a > = crate :: BitWriter < 'a , u32 , FCTRLB_SPEC , bool , 3 > ; # [doc = "Field `QUAL` reader - Fault B Qualification"]
pub type QUAL_R = crate :: BitReader < bool > ; # [doc = "Field `QUAL` writer - Fault B Qualification"]
pub type QUAL_W < 'a > = crate :: BitWriter < 'a , u32 , FCTRLB_SPEC , bool , 4 > ; # [doc = "Fault B Blanking Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum BLANK_A { # [doc = "0: No blanking applied"]
NONE = 0 , # [doc = "1: Blanking applied from rising edge of the output waveform"]
RISE = 1 , # [doc = "2: Blanking applied from falling edge of the output waveform"]
FALL = 2 , # [doc = "3: Blanking applied from each toggle of the output waveform"]
BOTH = 3 , } impl From < BLANK_A > for u8 { # [inline (always)]
fn from (variant : BLANK_A) -> Self { variant as _ } } # [doc = "Field `BLANK` reader - Fault B Blanking Mode"]
pub type BLANK_R = crate :: FieldReader < u8 , BLANK_A > ; impl BLANK_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> BLANK_A { match self . bits { 0 => BLANK_A :: NONE , 1 => BLANK_A :: RISE , 2 => BLANK_A :: FALL , 3 => BLANK_A :: BOTH , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NONE`"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == BLANK_A :: NONE } # [doc = "Checks if the value of the field is `RISE`"]
# [inline (always)]
pub fn is_rise (& self) -> bool { * self == BLANK_A :: RISE } # [doc = "Checks if the value of the field is `FALL`"]
# [inline (always)]
pub fn is_fall (& self) -> bool { * self == BLANK_A :: FALL } # [doc = "Checks if the value of the field is `BOTH`"]
# [inline (always)]
pub fn is_both (& self) -> bool { * self == BLANK_A :: BOTH } } # [doc = "Field `BLANK` writer - Fault B Blanking Mode"]
pub type BLANK_W < 'a > = crate :: FieldWriterSafe < 'a , u32 , FCTRLB_SPEC , u8 , BLANK_A , 2 , 5 > ; impl < 'a > BLANK_W < 'a > { # [doc = "No blanking applied"]
# [inline (always)]
pub fn none (self) -> & 'a mut W { self . variant (BLANK_A :: NONE) } # [doc = "Blanking applied from rising edge of the output waveform"]
# [inline (always)]
pub fn rise (self) -> & 'a mut W { self . variant (BLANK_A :: RISE) } # [doc = "Blanking applied from falling edge of the output waveform"]
# [inline (always)]
pub fn fall (self) -> & 'a mut W { self . variant (BLANK_A :: FALL) } # [doc = "Blanking applied from each toggle of the output waveform"]
# [inline (always)]
pub fn both (self) -> & 'a mut W { self . variant (BLANK_A :: BOTH) } } # [doc = "Field `RESTART` reader - Fault B Restart"]
pub type RESTART_R = crate :: BitReader < bool > ; # [doc = "Field `RESTART` writer - Fault B Restart"]
pub type RESTART_W < 'a > = crate :: BitWriter < 'a , u32 , FCTRLB_SPEC , bool , 7 > ; # [doc = "Fault B Halt Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum HALT_A { # [doc = "0: Halt action disabled"]
DISABLE = 0 , # [doc = "1: Hardware halt action"]
HW = 1 , # [doc = "2: Software halt action"]
SW = 2 , # [doc = "3: Non-recoverable fault"]
NR = 3 , } impl From < HALT_A > for u8 { # [inline (always)]
fn from (variant : HALT_A) -> Self { variant as _ } } # [doc = "Field `HALT` reader - Fault B Halt Mode"]
pub type HALT_R = crate :: FieldReader < u8 , HALT_A > ; impl HALT_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> HALT_A { match self . bits { 0 => HALT_A :: DISABLE , 1 => HALT_A :: HW , 2 => HALT_A :: SW , 3 => HALT_A :: NR , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DISABLE`"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == HALT_A :: DISABLE } # [doc = "Checks if the value of the field is `HW`"]
# [inline (always)]
pub fn is_hw (& self) -> bool { * self == HALT_A :: HW } # [doc = "Checks if the value of the field is `SW`"]
# [inline (always)]
pub fn is_sw (& self) -> bool { * self == HALT_A :: SW } # [doc = "Checks if the value of the field is `NR`"]
# [inline (always)]
pub fn is_nr (& self) -> bool { * self == HALT_A :: NR } } # [doc = "Field `HALT` writer - Fault B Halt Mode"]
pub type HALT_W < 'a > = crate :: FieldWriterSafe < 'a , u32 , FCTRLB_SPEC , u8 , HALT_A , 2 , 8 > ; impl < 'a > HALT_W < 'a > { # [doc = "Halt action disabled"]
# [inline (always)]
pub fn disable (self) -> & 'a mut W { self . variant (HALT_A :: DISABLE) } # [doc = "Hardware halt action"]
# [inline (always)]
pub fn hw (self) -> & 'a mut W { self . variant (HALT_A :: HW) } # [doc = "Software halt action"]
# [inline (always)]
pub fn sw (self) -> & 'a mut W { self . variant (HALT_A :: SW) } # [doc = "Non-recoverable fault"]
# [inline (always)]
pub fn nr (self) -> & 'a mut W { self . variant (HALT_A :: NR) } } # [doc = "Fault B Capture Channel\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CHSEL_A { # [doc = "0: Capture value stored in channel 0"]
CC0 = 0 , # [doc = "1: Capture value stored in channel 1"]
CC1 = 1 , # [doc = "2: Capture value stored in channel 2"]
CC2 = 2 , # [doc = "3: Capture value stored in channel 3"]
CC3 = 3 , } impl From < CHSEL_A > for u8 { # [inline (always)]
fn from (variant : CHSEL_A) -> Self { variant as _ } } # [doc = "Field `CHSEL` reader - Fault B Capture Channel"]
pub type CHSEL_R = crate :: FieldReader < u8 , CHSEL_A > ; impl CHSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CHSEL_A { match self . bits { 0 => CHSEL_A :: CC0 , 1 => CHSEL_A :: CC1 , 2 => CHSEL_A :: CC2 , 3 => CHSEL_A :: CC3 , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `CC0`"]
# [inline (always)]
pub fn is_cc0 (& self) -> bool { * self == CHSEL_A :: CC0 } # [doc = "Checks if the value of the field is `CC1`"]
# [inline (always)]
pub fn is_cc1 (& self) -> bool { * self == CHSEL_A :: CC1 } # [doc = "Checks if the value of the field is `CC2`"]
# [inline (always)]
pub fn is_cc2 (& self) -> bool { * self == CHSEL_A :: CC2 } # [doc = "Checks if the value of the field is `CC3`"]
# [inline (always)]
pub fn is_cc3 (& self) -> bool { * self == CHSEL_A :: CC3 } } # [doc = "Field `CHSEL` writer - Fault B Capture Channel"]
pub type CHSEL_W < 'a > = crate :: FieldWriterSafe < 'a , u32 , FCTRLB_SPEC , u8 , CHSEL_A , 2 , 10 > ; impl < 'a > CHSEL_W < 'a > { # [doc = "Capture value stored in channel 0"]
# [inline (always)]
pub fn cc0 (self) -> & 'a mut W { self . variant (CHSEL_A :: CC0) } # [doc = "Capture value stored in channel 1"]
# [inline (always)]
pub fn cc1 (self) -> & 'a mut W { self . variant (CHSEL_A :: CC1) } # [doc = "Capture value stored in channel 2"]
# [inline (always)]
pub fn cc2 (self) -> & 'a mut W { self . variant (CHSEL_A :: CC2) } # [doc = "Capture value stored in channel 3"]
# [inline (always)]
pub fn cc3 (self) -> & 'a mut W { self . variant (CHSEL_A :: CC3) } } # [doc = "Fault B Capture Action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CAPTURE_A { # [doc = "0: No capture"]
DISABLE = 0 , # [doc = "1: Capture on fault"]
CAPT = 1 , # [doc = "2: Minimum capture"]
CAPTMIN = 2 , # [doc = "3: Maximum capture"]
CAPTMAX = 3 , # [doc = "4: Minimum local detection"]
LOCMIN = 4 , # [doc = "5: Maximum local detection"]
LOCMAX = 5 , # [doc = "6: Minimum and maximum local detection"]
DERIV0 = 6 , } impl From < CAPTURE_A > for u8 { # [inline (always)]
fn from (variant : CAPTURE_A) -> Self { variant as _ } } # [doc = "Field `CAPTURE` reader - Fault B Capture Action"]
pub type CAPTURE_R = crate :: FieldReader < u8 , CAPTURE_A > ; impl CAPTURE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < CAPTURE_A > { match self . bits { 0 => Some (CAPTURE_A :: DISABLE) , 1 => Some (CAPTURE_A :: CAPT) , 2 => Some (CAPTURE_A :: CAPTMIN) , 3 => Some (CAPTURE_A :: CAPTMAX) , 4 => Some (CAPTURE_A :: LOCMIN) , 5 => Some (CAPTURE_A :: LOCMAX) , 6 => Some (CAPTURE_A :: DERIV0) , _ => None , } } # [doc = "Checks if the value of the field is `DISABLE`"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == CAPTURE_A :: DISABLE } # [doc = "Checks if the value of the field is `CAPT`"]
# [inline (always)]
pub fn is_capt (& self) -> bool { * self == CAPTURE_A :: CAPT } # [doc = "Checks if the value of the field is `CAPTMIN`"]
# [inline (always)]
pub fn is_captmin (& self) -> bool { * self == CAPTURE_A :: CAPTMIN } # [doc = "Checks if the value of the field is `CAPTMAX`"]
# [inline (always)]
pub fn is_captmax (& self) -> bool { * self == CAPTURE_A :: CAPTMAX } # [doc = "Checks if the value of the field is `LOCMIN`"]
# [inline (always)]
pub fn is_locmin (& self) -> bool { * self == CAPTURE_A :: LOCMIN } # [doc = "Checks if the value of the field is `LOCMAX`"]
# [inline (always)]
pub fn is_locmax (& self) -> bool { * self == CAPTURE_A :: LOCMAX } # [doc = "Checks if the value of the field is `DERIV0`"]
# [inline (always)]
pub fn is_deriv0 (& self) -> bool { * self == CAPTURE_A :: DERIV0 } } # [doc = "Field `CAPTURE` writer - Fault B Capture Action"]
pub type CAPTURE_W < 'a > = crate :: FieldWriter < 'a , u32 , FCTRLB_SPEC , u8 , CAPTURE_A , 3 , 12 > ; impl < 'a > CAPTURE_W < 'a > { # [doc = "No capture"]
# [inline (always)]
pub fn disable (self) -> & 'a mut W { self . variant (CAPTURE_A :: DISABLE) } # [doc = "Capture on fault"]
# [inline (always)]
pub fn capt (self) -> & 'a mut W { self . variant (CAPTURE_A :: CAPT) } # [doc = "Minimum capture"]
# [inline (always)]
pub fn captmin (self) -> & 'a mut W { self . variant (CAPTURE_A :: CAPTMIN) } # [doc = "Maximum capture"]
# [inline (always)]
pub fn captmax (self) -> & 'a mut W { self . variant (CAPTURE_A :: CAPTMAX) } # [doc = "Minimum local detection"]
# [inline (always)]
pub fn locmin (self) -> & 'a mut W { self . variant (CAPTURE_A :: LOCMIN) } # [doc = "Maximum local detection"]
# [inline (always)]
pub fn locmax (self) -> & 'a mut W { self . variant (CAPTURE_A :: LOCMAX) } # [doc = "Minimum and maximum local detection"]
# [inline (always)]
pub fn deriv0 (self) -> & 'a mut W { self . variant (CAPTURE_A :: DERIV0) } } # [doc = "Field `BLANKVAL` reader - Fault B Blanking Time"]
pub type BLANKVAL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BLANKVAL` writer - Fault B Blanking Time"]
pub type BLANKVAL_W < 'a > = crate :: FieldWriter < 'a , u32 , FCTRLB_SPEC , u8 , u8 , 8 , 16 > ; # [doc = "Field `FILTERVAL` reader - Fault B Filter Value"]
pub type FILTERVAL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `FILTERVAL` writer - Fault B Filter Value"]
pub type FILTERVAL_W < 'a > = crate :: FieldWriter < 'a , u32 , FCTRLB_SPEC , u8 , u8 , 4 , 24 > ; impl R { # [doc = "Bits 0:1 - Fault B Source"]
# [inline (always)]
pub fn src (& self) -> SRC_R { SRC_R :: new ((self . bits & 3) as u8) } # [doc = "Bit 3 - Fault B Keeper"]
# [inline (always)]
pub fn keep (& self) -> KEEP_R { KEEP_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Fault B Qualification"]
# [inline (always)]
pub fn qual (& self) -> QUAL_R { QUAL_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:6 - Fault B Blanking Mode"]
# [inline (always)]
pub fn blank (& self) -> BLANK_R { BLANK_R :: new (((self . bits >> 5) & 3) as u8) } # [doc = "Bit 7 - Fault B Restart"]
# [inline (always)]
pub fn restart (& self) -> RESTART_R { RESTART_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bits 8:9 - Fault B Halt Mode"]
# [inline (always)]
pub fn halt (& self) -> HALT_R { HALT_R :: new (((self . bits >> 8) & 3) as u8) } # [doc = "Bits 10:11 - Fault B Capture Channel"]
# [inline (always)]
pub fn chsel (& self) -> CHSEL_R { CHSEL_R :: new (((self . bits >> 10) & 3) as u8) } # [doc = "Bits 12:14 - Fault B Capture Action"]
# [inline (always)]
pub fn capture (& self) -> CAPTURE_R { CAPTURE_R :: new (((self . bits >> 12) & 7) as u8) } # [doc = "Bits 16:23 - Fault B Blanking Time"]
# [inline (always)]
pub fn blankval (& self) -> BLANKVAL_R { BLANKVAL_R :: new (((self . bits >> 16) & 0xff) as u8) } # [doc = "Bits 24:27 - Fault B Filter Value"]
# [inline (always)]
pub fn filterval (& self) -> FILTERVAL_R { FILTERVAL_R :: new (((self . bits >> 24) & 0x0f) as u8) } } impl W { # [doc = "Bits 0:1 - Fault B Source"]
# [inline (always)]
pub fn src (& mut self) -> SRC_W { SRC_W :: new (self) } # [doc = "Bit 3 - Fault B Keeper"]
# [inline (always)]
pub fn keep (& mut self) -> KEEP_W { KEEP_W :: new (self) } # [doc = "Bit 4 - Fault B Qualification"]
# [inline (always)]
pub fn qual (& mut self) -> QUAL_W { QUAL_W :: new (self) } # [doc = "Bits 5:6 - Fault B Blanking Mode"]
# [inline (always)]
pub fn blank (& mut self) -> BLANK_W { BLANK_W :: new (self) } # [doc = "Bit 7 - Fault B Restart"]
# [inline (always)]
pub fn restart (& mut self) -> RESTART_W { RESTART_W :: new (self) } # [doc = "Bits 8:9 - Fault B Halt Mode"]
# [inline (always)]
pub fn halt (& mut self) -> HALT_W { HALT_W :: new (self) } # [doc = "Bits 10:11 - Fault B Capture Channel"]
# [inline (always)]
pub fn chsel (& mut self) -> CHSEL_W { CHSEL_W :: new (self) } # [doc = "Bits 12:14 - Fault B Capture Action"]
# [inline (always)]
pub fn capture (& mut self) -> CAPTURE_W { CAPTURE_W :: new (self) } # [doc = "Bits 16:23 - Fault B Blanking Time"]
# [inline (always)]
pub fn blankval (& mut self) -> BLANKVAL_W { BLANKVAL_W :: new (self) } # [doc = "Bits 24:27 - Fault B Filter Value"]
# [inline (always)]
pub fn filterval (& mut self) -> FILTERVAL_W { FILTERVAL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Recoverable Fault B Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fctrlb](index.html) module"]
pub struct FCTRLB_SPEC ; impl crate :: RegisterSpec for FCTRLB_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [fctrlb::R](R) reader structure"]
impl crate :: Readable for FCTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [fctrlb::W](W) writer structure"]
impl crate :: Writable for FCTRLB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets FCTRLB to value 0"]
impl crate :: Resettable for FCTRLB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "WEXCTRL register accessor: an alias for `Reg<WEXCTRL_SPEC>`"]
pub type WEXCTRL = crate :: Reg < wexctrl :: WEXCTRL_SPEC > ; # [doc = "Waveform Extension Configuration"]
pub mod wexctrl { # [doc = "Register `WEXCTRL` reader"]
pub struct R (crate :: R < WEXCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < WEXCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < WEXCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < WEXCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `WEXCTRL` writer"]
pub struct W (crate :: W < WEXCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < WEXCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < WEXCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < WEXCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `OTMX` reader - Output Matrix"]
pub type OTMX_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `OTMX` writer - Output Matrix"]
pub type OTMX_W < 'a > = crate :: FieldWriter < 'a , u32 , WEXCTRL_SPEC , u8 , u8 , 2 , 0 > ; # [doc = "Field `DTIEN0` reader - Dead-time Insertion Generator 0 Enable"]
pub type DTIEN0_R = crate :: BitReader < bool > ; # [doc = "Field `DTIEN0` writer - Dead-time Insertion Generator 0 Enable"]
pub type DTIEN0_W < 'a > = crate :: BitWriter < 'a , u32 , WEXCTRL_SPEC , bool , 8 > ; # [doc = "Field `DTIEN1` reader - Dead-time Insertion Generator 1 Enable"]
pub type DTIEN1_R = crate :: BitReader < bool > ; # [doc = "Field `DTIEN1` writer - Dead-time Insertion Generator 1 Enable"]
pub type DTIEN1_W < 'a > = crate :: BitWriter < 'a , u32 , WEXCTRL_SPEC , bool , 9 > ; # [doc = "Field `DTIEN2` reader - Dead-time Insertion Generator 2 Enable"]
pub type DTIEN2_R = crate :: BitReader < bool > ; # [doc = "Field `DTIEN2` writer - Dead-time Insertion Generator 2 Enable"]
pub type DTIEN2_W < 'a > = crate :: BitWriter < 'a , u32 , WEXCTRL_SPEC , bool , 10 > ; # [doc = "Field `DTIEN3` reader - Dead-time Insertion Generator 3 Enable"]
pub type DTIEN3_R = crate :: BitReader < bool > ; # [doc = "Field `DTIEN3` writer - Dead-time Insertion Generator 3 Enable"]
pub type DTIEN3_W < 'a > = crate :: BitWriter < 'a , u32 , WEXCTRL_SPEC , bool , 11 > ; # [doc = "Field `DTLS` reader - Dead-time Low Side Outputs Value"]
pub type DTLS_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DTLS` writer - Dead-time Low Side Outputs Value"]
pub type DTLS_W < 'a > = crate :: FieldWriter < 'a , u32 , WEXCTRL_SPEC , u8 , u8 , 8 , 16 > ; # [doc = "Field `DTHS` reader - Dead-time High Side Outputs Value"]
pub type DTHS_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DTHS` writer - Dead-time High Side Outputs Value"]
pub type DTHS_W < 'a > = crate :: FieldWriter < 'a , u32 , WEXCTRL_SPEC , u8 , u8 , 8 , 24 > ; impl R { # [doc = "Bits 0:1 - Output Matrix"]
# [inline (always)]
pub fn otmx (& self) -> OTMX_R { OTMX_R :: new ((self . bits & 3) as u8) } # [doc = "Bit 8 - Dead-time Insertion Generator 0 Enable"]
# [inline (always)]
pub fn dtien0 (& self) -> DTIEN0_R { DTIEN0_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Dead-time Insertion Generator 1 Enable"]
# [inline (always)]
pub fn dtien1 (& self) -> DTIEN1_R { DTIEN1_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Dead-time Insertion Generator 2 Enable"]
# [inline (always)]
pub fn dtien2 (& self) -> DTIEN2_R { DTIEN2_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Dead-time Insertion Generator 3 Enable"]
# [inline (always)]
pub fn dtien3 (& self) -> DTIEN3_R { DTIEN3_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bits 16:23 - Dead-time Low Side Outputs Value"]
# [inline (always)]
pub fn dtls (& self) -> DTLS_R { DTLS_R :: new (((self . bits >> 16) & 0xff) as u8) } # [doc = "Bits 24:31 - Dead-time High Side Outputs Value"]
# [inline (always)]
pub fn dths (& self) -> DTHS_R { DTHS_R :: new (((self . bits >> 24) & 0xff) as u8) } } impl W { # [doc = "Bits 0:1 - Output Matrix"]
# [inline (always)]
pub fn otmx (& mut self) -> OTMX_W { OTMX_W :: new (self) } # [doc = "Bit 8 - Dead-time Insertion Generator 0 Enable"]
# [inline (always)]
pub fn dtien0 (& mut self) -> DTIEN0_W { DTIEN0_W :: new (self) } # [doc = "Bit 9 - Dead-time Insertion Generator 1 Enable"]
# [inline (always)]
pub fn dtien1 (& mut self) -> DTIEN1_W { DTIEN1_W :: new (self) } # [doc = "Bit 10 - Dead-time Insertion Generator 2 Enable"]
# [inline (always)]
pub fn dtien2 (& mut self) -> DTIEN2_W { DTIEN2_W :: new (self) } # [doc = "Bit 11 - Dead-time Insertion Generator 3 Enable"]
# [inline (always)]
pub fn dtien3 (& mut self) -> DTIEN3_W { DTIEN3_W :: new (self) } # [doc = "Bits 16:23 - Dead-time Low Side Outputs Value"]
# [inline (always)]
pub fn dtls (& mut self) -> DTLS_W { DTLS_W :: new (self) } # [doc = "Bits 24:31 - Dead-time High Side Outputs Value"]
# [inline (always)]
pub fn dths (& mut self) -> DTHS_W { DTHS_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Waveform Extension Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [wexctrl](index.html) module"]
pub struct WEXCTRL_SPEC ; impl crate :: RegisterSpec for WEXCTRL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [wexctrl::R](R) reader structure"]
impl crate :: Readable for WEXCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [wexctrl::W](W) writer structure"]
impl crate :: Writable for WEXCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets WEXCTRL to value 0"]
impl crate :: Resettable for WEXCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DRVCTRL register accessor: an alias for `Reg<DRVCTRL_SPEC>`"]
pub type DRVCTRL = crate :: Reg < drvctrl :: DRVCTRL_SPEC > ; # [doc = "Driver Control"]
pub mod drvctrl { # [doc = "Register `DRVCTRL` reader"]
pub struct R (crate :: R < DRVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DRVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DRVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DRVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DRVCTRL` writer"]
pub struct W (crate :: W < DRVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DRVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DRVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DRVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `NRE0` reader - Non-Recoverable State 0 Output Enable"]
pub type NRE0_R = crate :: BitReader < bool > ; # [doc = "Field `NRE0` writer - Non-Recoverable State 0 Output Enable"]
pub type NRE0_W < 'a > = crate :: BitWriter < 'a , u32 , DRVCTRL_SPEC , bool , 0 > ; # [doc = "Field `NRE1` reader - Non-Recoverable State 1 Output Enable"]
pub type NRE1_R = crate :: BitReader < bool > ; # [doc = "Field `NRE1` writer - Non-Recoverable State 1 Output Enable"]
pub type NRE1_W < 'a > = crate :: BitWriter < 'a , u32 , DRVCTRL_SPEC , bool , 1 > ; # [doc = "Field `NRE2` reader - Non-Recoverable State 2 Output Enable"]
pub type NRE2_R = crate :: BitReader < bool > ; # [doc = "Field `NRE2` writer - Non-Recoverable State 2 Output Enable"]
pub type NRE2_W < 'a > = crate :: BitWriter < 'a , u32 , DRVCTRL_SPEC , bool , 2 > ; # [doc = "Field `NRE3` reader - Non-Recoverable State 3 Output Enable"]
pub type NRE3_R = crate :: BitReader < bool > ; # [doc = "Field `NRE3` writer - Non-Recoverable State 3 Output Enable"]
pub type NRE3_W < 'a > = crate :: BitWriter < 'a , u32 , DRVCTRL_SPEC , bool , 3 > ; # [doc = "Field `NRE4` reader - Non-Recoverable State 4 Output Enable"]
pub type NRE4_R = crate :: BitReader < bool > ; # [doc = "Field `NRE4` writer - Non-Recoverable State 4 Output Enable"]
pub type NRE4_W < 'a > = crate :: BitWriter < 'a , u32 , DRVCTRL_SPEC , bool , 4 > ; # [doc = "Field `NRE5` reader - Non-Recoverable State 5 Output Enable"]
pub type NRE5_R = crate :: BitReader < bool > ; # [doc = "Field `NRE5` writer - Non-Recoverable State 5 Output Enable"]
pub type NRE5_W < 'a > = crate :: BitWriter < 'a , u32 , DRVCTRL_SPEC , bool , 5 > ; # [doc = "Field `NRE6` reader - Non-Recoverable State 6 Output Enable"]
pub type NRE6_R = crate :: BitReader < bool > ; # [doc = "Field `NRE6` writer - Non-Recoverable State 6 Output Enable"]
pub type NRE6_W < 'a > = crate :: BitWriter < 'a , u32 , DRVCTRL_SPEC , bool , 6 > ; # [doc = "Field `NRE7` reader - Non-Recoverable State 7 Output Enable"]
pub type NRE7_R = crate :: BitReader < bool > ; # [doc = "Field `NRE7` writer - Non-Recoverable State 7 Output Enable"]
pub type NRE7_W < 'a > = crate :: BitWriter < 'a , u32 , DRVCTRL_SPEC , bool , 7 > ; # [doc = "Field `NRV0` reader - Non-Recoverable State 0 Output Value"]
pub type NRV0_R = crate :: BitReader < bool > ; # [doc = "Field `NRV0` writer - Non-Recoverable State 0 Output Value"]
pub type NRV0_W < 'a > = crate :: BitWriter < 'a , u32 , DRVCTRL_SPEC , bool , 8 > ; # [doc = "Field `NRV1` reader - Non-Recoverable State 1 Output Value"]
pub type NRV1_R = crate :: BitReader < bool > ; # [doc = "Field `NRV1` writer - Non-Recoverable State 1 Output Value"]
pub type NRV1_W < 'a > = crate :: BitWriter < 'a , u32 , DRVCTRL_SPEC , bool , 9 > ; # [doc = "Field `NRV2` reader - Non-Recoverable State 2 Output Value"]
pub type NRV2_R = crate :: BitReader < bool > ; # [doc = "Field `NRV2` writer - Non-Recoverable State 2 Output Value"]
pub type NRV2_W < 'a > = crate :: BitWriter < 'a , u32 , DRVCTRL_SPEC , bool , 10 > ; # [doc = "Field `NRV3` reader - Non-Recoverable State 3 Output Value"]
pub type NRV3_R = crate :: BitReader < bool > ; # [doc = "Field `NRV3` writer - Non-Recoverable State 3 Output Value"]
pub type NRV3_W < 'a > = crate :: BitWriter < 'a , u32 , DRVCTRL_SPEC , bool , 11 > ; # [doc = "Field `NRV4` reader - Non-Recoverable State 4 Output Value"]
pub type NRV4_R = crate :: BitReader < bool > ; # [doc = "Field `NRV4` writer - Non-Recoverable State 4 Output Value"]
pub type NRV4_W < 'a > = crate :: BitWriter < 'a , u32 , DRVCTRL_SPEC , bool , 12 > ; # [doc = "Field `NRV5` reader - Non-Recoverable State 5 Output Value"]
pub type NRV5_R = crate :: BitReader < bool > ; # [doc = "Field `NRV5` writer - Non-Recoverable State 5 Output Value"]
pub type NRV5_W < 'a > = crate :: BitWriter < 'a , u32 , DRVCTRL_SPEC , bool , 13 > ; # [doc = "Field `NRV6` reader - Non-Recoverable State 6 Output Value"]
pub type NRV6_R = crate :: BitReader < bool > ; # [doc = "Field `NRV6` writer - Non-Recoverable State 6 Output Value"]
pub type NRV6_W < 'a > = crate :: BitWriter < 'a , u32 , DRVCTRL_SPEC , bool , 14 > ; # [doc = "Field `NRV7` reader - Non-Recoverable State 7 Output Value"]
pub type NRV7_R = crate :: BitReader < bool > ; # [doc = "Field `NRV7` writer - Non-Recoverable State 7 Output Value"]
pub type NRV7_W < 'a > = crate :: BitWriter < 'a , u32 , DRVCTRL_SPEC , bool , 15 > ; # [doc = "Field `INVEN0` reader - Output Waveform 0 Inversion"]
pub type INVEN0_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN0` writer - Output Waveform 0 Inversion"]
pub type INVEN0_W < 'a > = crate :: BitWriter < 'a , u32 , DRVCTRL_SPEC , bool , 16 > ; # [doc = "Field `INVEN1` reader - Output Waveform 1 Inversion"]
pub type INVEN1_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN1` writer - Output Waveform 1 Inversion"]
pub type INVEN1_W < 'a > = crate :: BitWriter < 'a , u32 , DRVCTRL_SPEC , bool , 17 > ; # [doc = "Field `INVEN2` reader - Output Waveform 2 Inversion"]
pub type INVEN2_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN2` writer - Output Waveform 2 Inversion"]
pub type INVEN2_W < 'a > = crate :: BitWriter < 'a , u32 , DRVCTRL_SPEC , bool , 18 > ; # [doc = "Field `INVEN3` reader - Output Waveform 3 Inversion"]
pub type INVEN3_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN3` writer - Output Waveform 3 Inversion"]
pub type INVEN3_W < 'a > = crate :: BitWriter < 'a , u32 , DRVCTRL_SPEC , bool , 19 > ; # [doc = "Field `INVEN4` reader - Output Waveform 4 Inversion"]
pub type INVEN4_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN4` writer - Output Waveform 4 Inversion"]
pub type INVEN4_W < 'a > = crate :: BitWriter < 'a , u32 , DRVCTRL_SPEC , bool , 20 > ; # [doc = "Field `INVEN5` reader - Output Waveform 5 Inversion"]
pub type INVEN5_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN5` writer - Output Waveform 5 Inversion"]
pub type INVEN5_W < 'a > = crate :: BitWriter < 'a , u32 , DRVCTRL_SPEC , bool , 21 > ; # [doc = "Field `INVEN6` reader - Output Waveform 6 Inversion"]
pub type INVEN6_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN6` writer - Output Waveform 6 Inversion"]
pub type INVEN6_W < 'a > = crate :: BitWriter < 'a , u32 , DRVCTRL_SPEC , bool , 22 > ; # [doc = "Field `INVEN7` reader - Output Waveform 7 Inversion"]
pub type INVEN7_R = crate :: BitReader < bool > ; # [doc = "Field `INVEN7` writer - Output Waveform 7 Inversion"]
pub type INVEN7_W < 'a > = crate :: BitWriter < 'a , u32 , DRVCTRL_SPEC , bool , 23 > ; # [doc = "Field `FILTERVAL0` reader - Non-Recoverable Fault Input 0 Filter Value"]
pub type FILTERVAL0_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `FILTERVAL0` writer - Non-Recoverable Fault Input 0 Filter Value"]
pub type FILTERVAL0_W < 'a > = crate :: FieldWriter < 'a , u32 , DRVCTRL_SPEC , u8 , u8 , 4 , 24 > ; # [doc = "Field `FILTERVAL1` reader - Non-Recoverable Fault Input 1 Filter Value"]
pub type FILTERVAL1_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `FILTERVAL1` writer - Non-Recoverable Fault Input 1 Filter Value"]
pub type FILTERVAL1_W < 'a > = crate :: FieldWriter < 'a , u32 , DRVCTRL_SPEC , u8 , u8 , 4 , 28 > ; impl R { # [doc = "Bit 0 - Non-Recoverable State 0 Output Enable"]
# [inline (always)]
pub fn nre0 (& self) -> NRE0_R { NRE0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Non-Recoverable State 1 Output Enable"]
# [inline (always)]
pub fn nre1 (& self) -> NRE1_R { NRE1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Non-Recoverable State 2 Output Enable"]
# [inline (always)]
pub fn nre2 (& self) -> NRE2_R { NRE2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Non-Recoverable State 3 Output Enable"]
# [inline (always)]
pub fn nre3 (& self) -> NRE3_R { NRE3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Non-Recoverable State 4 Output Enable"]
# [inline (always)]
pub fn nre4 (& self) -> NRE4_R { NRE4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Non-Recoverable State 5 Output Enable"]
# [inline (always)]
pub fn nre5 (& self) -> NRE5_R { NRE5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Non-Recoverable State 6 Output Enable"]
# [inline (always)]
pub fn nre6 (& self) -> NRE6_R { NRE6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Non-Recoverable State 7 Output Enable"]
# [inline (always)]
pub fn nre7 (& self) -> NRE7_R { NRE7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Non-Recoverable State 0 Output Value"]
# [inline (always)]
pub fn nrv0 (& self) -> NRV0_R { NRV0_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Non-Recoverable State 1 Output Value"]
# [inline (always)]
pub fn nrv1 (& self) -> NRV1_R { NRV1_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Non-Recoverable State 2 Output Value"]
# [inline (always)]
pub fn nrv2 (& self) -> NRV2_R { NRV2_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Non-Recoverable State 3 Output Value"]
# [inline (always)]
pub fn nrv3 (& self) -> NRV3_R { NRV3_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Non-Recoverable State 4 Output Value"]
# [inline (always)]
pub fn nrv4 (& self) -> NRV4_R { NRV4_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Non-Recoverable State 5 Output Value"]
# [inline (always)]
pub fn nrv5 (& self) -> NRV5_R { NRV5_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Non-Recoverable State 6 Output Value"]
# [inline (always)]
pub fn nrv6 (& self) -> NRV6_R { NRV6_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Non-Recoverable State 7 Output Value"]
# [inline (always)]
pub fn nrv7 (& self) -> NRV7_R { NRV7_R :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - Output Waveform 0 Inversion"]
# [inline (always)]
pub fn inven0 (& self) -> INVEN0_R { INVEN0_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Output Waveform 1 Inversion"]
# [inline (always)]
pub fn inven1 (& self) -> INVEN1_R { INVEN1_R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Output Waveform 2 Inversion"]
# [inline (always)]
pub fn inven2 (& self) -> INVEN2_R { INVEN2_R :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Output Waveform 3 Inversion"]
# [inline (always)]
pub fn inven3 (& self) -> INVEN3_R { INVEN3_R :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 20 - Output Waveform 4 Inversion"]
# [inline (always)]
pub fn inven4 (& self) -> INVEN4_R { INVEN4_R :: new (((self . bits >> 20) & 1) != 0) } # [doc = "Bit 21 - Output Waveform 5 Inversion"]
# [inline (always)]
pub fn inven5 (& self) -> INVEN5_R { INVEN5_R :: new (((self . bits >> 21) & 1) != 0) } # [doc = "Bit 22 - Output Waveform 6 Inversion"]
# [inline (always)]
pub fn inven6 (& self) -> INVEN6_R { INVEN6_R :: new (((self . bits >> 22) & 1) != 0) } # [doc = "Bit 23 - Output Waveform 7 Inversion"]
# [inline (always)]
pub fn inven7 (& self) -> INVEN7_R { INVEN7_R :: new (((self . bits >> 23) & 1) != 0) } # [doc = "Bits 24:27 - Non-Recoverable Fault Input 0 Filter Value"]
# [inline (always)]
pub fn filterval0 (& self) -> FILTERVAL0_R { FILTERVAL0_R :: new (((self . bits >> 24) & 0x0f) as u8) } # [doc = "Bits 28:31 - Non-Recoverable Fault Input 1 Filter Value"]
# [inline (always)]
pub fn filterval1 (& self) -> FILTERVAL1_R { FILTERVAL1_R :: new (((self . bits >> 28) & 0x0f) as u8) } } impl W { # [doc = "Bit 0 - Non-Recoverable State 0 Output Enable"]
# [inline (always)]
pub fn nre0 (& mut self) -> NRE0_W { NRE0_W :: new (self) } # [doc = "Bit 1 - Non-Recoverable State 1 Output Enable"]
# [inline (always)]
pub fn nre1 (& mut self) -> NRE1_W { NRE1_W :: new (self) } # [doc = "Bit 2 - Non-Recoverable State 2 Output Enable"]
# [inline (always)]
pub fn nre2 (& mut self) -> NRE2_W { NRE2_W :: new (self) } # [doc = "Bit 3 - Non-Recoverable State 3 Output Enable"]
# [inline (always)]
pub fn nre3 (& mut self) -> NRE3_W { NRE3_W :: new (self) } # [doc = "Bit 4 - Non-Recoverable State 4 Output Enable"]
# [inline (always)]
pub fn nre4 (& mut self) -> NRE4_W { NRE4_W :: new (self) } # [doc = "Bit 5 - Non-Recoverable State 5 Output Enable"]
# [inline (always)]
pub fn nre5 (& mut self) -> NRE5_W { NRE5_W :: new (self) } # [doc = "Bit 6 - Non-Recoverable State 6 Output Enable"]
# [inline (always)]
pub fn nre6 (& mut self) -> NRE6_W { NRE6_W :: new (self) } # [doc = "Bit 7 - Non-Recoverable State 7 Output Enable"]
# [inline (always)]
pub fn nre7 (& mut self) -> NRE7_W { NRE7_W :: new (self) } # [doc = "Bit 8 - Non-Recoverable State 0 Output Value"]
# [inline (always)]
pub fn nrv0 (& mut self) -> NRV0_W { NRV0_W :: new (self) } # [doc = "Bit 9 - Non-Recoverable State 1 Output Value"]
# [inline (always)]
pub fn nrv1 (& mut self) -> NRV1_W { NRV1_W :: new (self) } # [doc = "Bit 10 - Non-Recoverable State 2 Output Value"]
# [inline (always)]
pub fn nrv2 (& mut self) -> NRV2_W { NRV2_W :: new (self) } # [doc = "Bit 11 - Non-Recoverable State 3 Output Value"]
# [inline (always)]
pub fn nrv3 (& mut self) -> NRV3_W { NRV3_W :: new (self) } # [doc = "Bit 12 - Non-Recoverable State 4 Output Value"]
# [inline (always)]
pub fn nrv4 (& mut self) -> NRV4_W { NRV4_W :: new (self) } # [doc = "Bit 13 - Non-Recoverable State 5 Output Value"]
# [inline (always)]
pub fn nrv5 (& mut self) -> NRV5_W { NRV5_W :: new (self) } # [doc = "Bit 14 - Non-Recoverable State 6 Output Value"]
# [inline (always)]
pub fn nrv6 (& mut self) -> NRV6_W { NRV6_W :: new (self) } # [doc = "Bit 15 - Non-Recoverable State 7 Output Value"]
# [inline (always)]
pub fn nrv7 (& mut self) -> NRV7_W { NRV7_W :: new (self) } # [doc = "Bit 16 - Output Waveform 0 Inversion"]
# [inline (always)]
pub fn inven0 (& mut self) -> INVEN0_W { INVEN0_W :: new (self) } # [doc = "Bit 17 - Output Waveform 1 Inversion"]
# [inline (always)]
pub fn inven1 (& mut self) -> INVEN1_W { INVEN1_W :: new (self) } # [doc = "Bit 18 - Output Waveform 2 Inversion"]
# [inline (always)]
pub fn inven2 (& mut self) -> INVEN2_W { INVEN2_W :: new (self) } # [doc = "Bit 19 - Output Waveform 3 Inversion"]
# [inline (always)]
pub fn inven3 (& mut self) -> INVEN3_W { INVEN3_W :: new (self) } # [doc = "Bit 20 - Output Waveform 4 Inversion"]
# [inline (always)]
pub fn inven4 (& mut self) -> INVEN4_W { INVEN4_W :: new (self) } # [doc = "Bit 21 - Output Waveform 5 Inversion"]
# [inline (always)]
pub fn inven5 (& mut self) -> INVEN5_W { INVEN5_W :: new (self) } # [doc = "Bit 22 - Output Waveform 6 Inversion"]
# [inline (always)]
pub fn inven6 (& mut self) -> INVEN6_W { INVEN6_W :: new (self) } # [doc = "Bit 23 - Output Waveform 7 Inversion"]
# [inline (always)]
pub fn inven7 (& mut self) -> INVEN7_W { INVEN7_W :: new (self) } # [doc = "Bits 24:27 - Non-Recoverable Fault Input 0 Filter Value"]
# [inline (always)]
pub fn filterval0 (& mut self) -> FILTERVAL0_W { FILTERVAL0_W :: new (self) } # [doc = "Bits 28:31 - Non-Recoverable Fault Input 1 Filter Value"]
# [inline (always)]
pub fn filterval1 (& mut self) -> FILTERVAL1_W { FILTERVAL1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Driver Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [drvctrl](index.html) module"]
pub struct DRVCTRL_SPEC ; impl crate :: RegisterSpec for DRVCTRL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [drvctrl::R](R) reader structure"]
impl crate :: Readable for DRVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [drvctrl::W](W) writer structure"]
impl crate :: Writable for DRVCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DRVCTRL to value 0"]
impl crate :: Resettable for DRVCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DBGCTRL register accessor: an alias for `Reg<DBGCTRL_SPEC>`"]
pub type DBGCTRL = crate :: Reg < dbgctrl :: DBGCTRL_SPEC > ; # [doc = "Debug Control"]
pub mod dbgctrl { # [doc = "Register `DBGCTRL` reader"]
pub struct R (crate :: R < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DBGCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DBGCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `DBGCTRL` writer"]
pub struct W (crate :: W < DBGCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DBGCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DBGCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DBGCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `DBGRUN` reader - Debug Running Mode"]
pub type DBGRUN_R = crate :: BitReader < bool > ; # [doc = "Field `DBGRUN` writer - Debug Running Mode"]
pub type DBGRUN_W < 'a > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , 0 > ; # [doc = "Field `FDDBD` reader - Fault Detection on Debug Break Detection"]
pub type FDDBD_R = crate :: BitReader < bool > ; # [doc = "Field `FDDBD` writer - Fault Detection on Debug Break Detection"]
pub type FDDBD_W < 'a > = crate :: BitWriter < 'a , u8 , DBGCTRL_SPEC , bool , 2 > ; impl R { # [doc = "Bit 0 - Debug Running Mode"]
# [inline (always)]
pub fn dbgrun (& self) -> DBGRUN_R { DBGRUN_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - Fault Detection on Debug Break Detection"]
# [inline (always)]
pub fn fddbd (& self) -> FDDBD_R { FDDBD_R :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Debug Running Mode"]
# [inline (always)]
pub fn dbgrun (& mut self) -> DBGRUN_W { DBGRUN_W :: new (self) } # [doc = "Bit 2 - Fault Detection on Debug Break Detection"]
# [inline (always)]
pub fn fddbd (& mut self) -> FDDBD_W { FDDBD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dbgctrl](index.html) module"]
pub struct DBGCTRL_SPEC ; impl crate :: RegisterSpec for DBGCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dbgctrl::R](R) reader structure"]
impl crate :: Readable for DBGCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dbgctrl::W](W) writer structure"]
impl crate :: Writable for DBGCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DBGCTRL to value 0"]
impl crate :: Resettable for DBGCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "EVCTRL register accessor: an alias for `Reg<EVCTRL_SPEC>`"]
pub type EVCTRL = crate :: Reg < evctrl :: EVCTRL_SPEC > ; # [doc = "Event Control"]
pub mod evctrl { # [doc = "Register `EVCTRL` reader"]
pub struct R (crate :: R < EVCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EVCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EVCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EVCTRL` writer"]
pub struct W (crate :: W < EVCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EVCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EVCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EVCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Timer/counter Input Event0 Action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum EVACT0_A { # [doc = "0: Event action disabled"]
OFF = 0 , # [doc = "1: Start, restart or re-trigger counter on event"]
RETRIGGER = 1 , # [doc = "2: Count on event"]
COUNTEV = 2 , # [doc = "3: Start counter on event"]
START = 3 , # [doc = "4: Increment counter on event"]
INC = 4 , # [doc = "5: Count on active state of asynchronous event"]
COUNT = 5 , # [doc = "7: Non-recoverable fault"]
FAULT = 7 , } impl From < EVACT0_A > for u8 { # [inline (always)]
fn from (variant : EVACT0_A) -> Self { variant as _ } } # [doc = "Field `EVACT0` reader - Timer/counter Input Event0 Action"]
pub type EVACT0_R = crate :: FieldReader < u8 , EVACT0_A > ; impl EVACT0_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < EVACT0_A > { match self . bits { 0 => Some (EVACT0_A :: OFF) , 1 => Some (EVACT0_A :: RETRIGGER) , 2 => Some (EVACT0_A :: COUNTEV) , 3 => Some (EVACT0_A :: START) , 4 => Some (EVACT0_A :: INC) , 5 => Some (EVACT0_A :: COUNT) , 7 => Some (EVACT0_A :: FAULT) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == EVACT0_A :: OFF } # [doc = "Checks if the value of the field is `RETRIGGER`"]
# [inline (always)]
pub fn is_retrigger (& self) -> bool { * self == EVACT0_A :: RETRIGGER } # [doc = "Checks if the value of the field is `COUNTEV`"]
# [inline (always)]
pub fn is_countev (& self) -> bool { * self == EVACT0_A :: COUNTEV } # [doc = "Checks if the value of the field is `START`"]
# [inline (always)]
pub fn is_start (& self) -> bool { * self == EVACT0_A :: START } # [doc = "Checks if the value of the field is `INC`"]
# [inline (always)]
pub fn is_inc (& self) -> bool { * self == EVACT0_A :: INC } # [doc = "Checks if the value of the field is `COUNT`"]
# [inline (always)]
pub fn is_count (& self) -> bool { * self == EVACT0_A :: COUNT } # [doc = "Checks if the value of the field is `FAULT`"]
# [inline (always)]
pub fn is_fault (& self) -> bool { * self == EVACT0_A :: FAULT } } # [doc = "Field `EVACT0` writer - Timer/counter Input Event0 Action"]
pub type EVACT0_W < 'a > = crate :: FieldWriter < 'a , u32 , EVCTRL_SPEC , u8 , EVACT0_A , 3 , 0 > ; impl < 'a > EVACT0_W < 'a > { # [doc = "Event action disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (EVACT0_A :: OFF) } # [doc = "Start, restart or re-trigger counter on event"]
# [inline (always)]
pub fn retrigger (self) -> & 'a mut W { self . variant (EVACT0_A :: RETRIGGER) } # [doc = "Count on event"]
# [inline (always)]
pub fn countev (self) -> & 'a mut W { self . variant (EVACT0_A :: COUNTEV) } # [doc = "Start counter on event"]
# [inline (always)]
pub fn start (self) -> & 'a mut W { self . variant (EVACT0_A :: START) } # [doc = "Increment counter on event"]
# [inline (always)]
pub fn inc (self) -> & 'a mut W { self . variant (EVACT0_A :: INC) } # [doc = "Count on active state of asynchronous event"]
# [inline (always)]
pub fn count (self) -> & 'a mut W { self . variant (EVACT0_A :: COUNT) } # [doc = "Non-recoverable fault"]
# [inline (always)]
pub fn fault (self) -> & 'a mut W { self . variant (EVACT0_A :: FAULT) } } # [doc = "Timer/counter Input Event1 Action\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum EVACT1_A { # [doc = "0: Event action disabled"]
OFF = 0 , # [doc = "1: Re-trigger counter on event"]
RETRIGGER = 1 , # [doc = "2: Direction control"]
DIR = 2 , # [doc = "3: Stop counter on event"]
STOP = 3 , # [doc = "4: Decrement counter on event"]
DEC = 4 , # [doc = "5: Period capture value in CC0 register, pulse width capture value in CC1 register"]
PPW = 5 , # [doc = "6: Period capture value in CC1 register, pulse width capture value in CC0 register"]
PWP = 6 , # [doc = "7: Non-recoverable fault"]
FAULT = 7 , } impl From < EVACT1_A > for u8 { # [inline (always)]
fn from (variant : EVACT1_A) -> Self { variant as _ } } # [doc = "Field `EVACT1` reader - Timer/counter Input Event1 Action"]
pub type EVACT1_R = crate :: FieldReader < u8 , EVACT1_A > ; impl EVACT1_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> EVACT1_A { match self . bits { 0 => EVACT1_A :: OFF , 1 => EVACT1_A :: RETRIGGER , 2 => EVACT1_A :: DIR , 3 => EVACT1_A :: STOP , 4 => EVACT1_A :: DEC , 5 => EVACT1_A :: PPW , 6 => EVACT1_A :: PWP , 7 => EVACT1_A :: FAULT , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == EVACT1_A :: OFF } # [doc = "Checks if the value of the field is `RETRIGGER`"]
# [inline (always)]
pub fn is_retrigger (& self) -> bool { * self == EVACT1_A :: RETRIGGER } # [doc = "Checks if the value of the field is `DIR`"]
# [inline (always)]
pub fn is_dir (& self) -> bool { * self == EVACT1_A :: DIR } # [doc = "Checks if the value of the field is `STOP`"]
# [inline (always)]
pub fn is_stop (& self) -> bool { * self == EVACT1_A :: STOP } # [doc = "Checks if the value of the field is `DEC`"]
# [inline (always)]
pub fn is_dec (& self) -> bool { * self == EVACT1_A :: DEC } # [doc = "Checks if the value of the field is `PPW`"]
# [inline (always)]
pub fn is_ppw (& self) -> bool { * self == EVACT1_A :: PPW } # [doc = "Checks if the value of the field is `PWP`"]
# [inline (always)]
pub fn is_pwp (& self) -> bool { * self == EVACT1_A :: PWP } # [doc = "Checks if the value of the field is `FAULT`"]
# [inline (always)]
pub fn is_fault (& self) -> bool { * self == EVACT1_A :: FAULT } } # [doc = "Field `EVACT1` writer - Timer/counter Input Event1 Action"]
pub type EVACT1_W < 'a > = crate :: FieldWriterSafe < 'a , u32 , EVCTRL_SPEC , u8 , EVACT1_A , 3 , 3 > ; impl < 'a > EVACT1_W < 'a > { # [doc = "Event action disabled"]
# [inline (always)]
pub fn off (self) -> & 'a mut W { self . variant (EVACT1_A :: OFF) } # [doc = "Re-trigger counter on event"]
# [inline (always)]
pub fn retrigger (self) -> & 'a mut W { self . variant (EVACT1_A :: RETRIGGER) } # [doc = "Direction control"]
# [inline (always)]
pub fn dir (self) -> & 'a mut W { self . variant (EVACT1_A :: DIR) } # [doc = "Stop counter on event"]
# [inline (always)]
pub fn stop (self) -> & 'a mut W { self . variant (EVACT1_A :: STOP) } # [doc = "Decrement counter on event"]
# [inline (always)]
pub fn dec (self) -> & 'a mut W { self . variant (EVACT1_A :: DEC) } # [doc = "Period capture value in CC0 register, pulse width capture value in CC1 register"]
# [inline (always)]
pub fn ppw (self) -> & 'a mut W { self . variant (EVACT1_A :: PPW) } # [doc = "Period capture value in CC1 register, pulse width capture value in CC0 register"]
# [inline (always)]
pub fn pwp (self) -> & 'a mut W { self . variant (EVACT1_A :: PWP) } # [doc = "Non-recoverable fault"]
# [inline (always)]
pub fn fault (self) -> & 'a mut W { self . variant (EVACT1_A :: FAULT) } } # [doc = "Timer/counter Output Event Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CNTSEL_A { # [doc = "0: An interrupt/event is generated when a new counter cycle starts"]
START = 0 , # [doc = "1: An interrupt/event is generated when a counter cycle ends"]
END = 1 , # [doc = "2: An interrupt/event is generated when a counter cycle ends, except for the first and last cycles"]
BETWEEN = 2 , # [doc = "3: An interrupt/event is generated when a new counter cycle starts or a counter cycle ends"]
BOUNDARY = 3 , } impl From < CNTSEL_A > for u8 { # [inline (always)]
fn from (variant : CNTSEL_A) -> Self { variant as _ } } # [doc = "Field `CNTSEL` reader - Timer/counter Output Event Mode"]
pub type CNTSEL_R = crate :: FieldReader < u8 , CNTSEL_A > ; impl CNTSEL_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CNTSEL_A { match self . bits { 0 => CNTSEL_A :: START , 1 => CNTSEL_A :: END , 2 => CNTSEL_A :: BETWEEN , 3 => CNTSEL_A :: BOUNDARY , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `START`"]
# [inline (always)]
pub fn is_start (& self) -> bool { * self == CNTSEL_A :: START } # [doc = "Checks if the value of the field is `END`"]
# [inline (always)]
pub fn is_end (& self) -> bool { * self == CNTSEL_A :: END } # [doc = "Checks if the value of the field is `BETWEEN`"]
# [inline (always)]
pub fn is_between (& self) -> bool { * self == CNTSEL_A :: BETWEEN } # [doc = "Checks if the value of the field is `BOUNDARY`"]
# [inline (always)]
pub fn is_boundary (& self) -> bool { * self == CNTSEL_A :: BOUNDARY } } # [doc = "Field `CNTSEL` writer - Timer/counter Output Event Mode"]
pub type CNTSEL_W < 'a > = crate :: FieldWriterSafe < 'a , u32 , EVCTRL_SPEC , u8 , CNTSEL_A , 2 , 6 > ; impl < 'a > CNTSEL_W < 'a > { # [doc = "An interrupt/event is generated when a new counter cycle starts"]
# [inline (always)]
pub fn start (self) -> & 'a mut W { self . variant (CNTSEL_A :: START) } # [doc = "An interrupt/event is generated when a counter cycle ends"]
# [inline (always)]
pub fn end (self) -> & 'a mut W { self . variant (CNTSEL_A :: END) } # [doc = "An interrupt/event is generated when a counter cycle ends, except for the first and last cycles"]
# [inline (always)]
pub fn between (self) -> & 'a mut W { self . variant (CNTSEL_A :: BETWEEN) } # [doc = "An interrupt/event is generated when a new counter cycle starts or a counter cycle ends"]
# [inline (always)]
pub fn boundary (self) -> & 'a mut W { self . variant (CNTSEL_A :: BOUNDARY) } } # [doc = "Field `OVFEO` reader - Overflow/Underflow Output Event Enable"]
pub type OVFEO_R = crate :: BitReader < bool > ; # [doc = "Field `OVFEO` writer - Overflow/Underflow Output Event Enable"]
pub type OVFEO_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 8 > ; # [doc = "Field `TRGEO` reader - Retrigger Output Event Enable"]
pub type TRGEO_R = crate :: BitReader < bool > ; # [doc = "Field `TRGEO` writer - Retrigger Output Event Enable"]
pub type TRGEO_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 9 > ; # [doc = "Field `CNTEO` reader - Timer/counter Output Event Enable"]
pub type CNTEO_R = crate :: BitReader < bool > ; # [doc = "Field `CNTEO` writer - Timer/counter Output Event Enable"]
pub type CNTEO_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 10 > ; # [doc = "Field `TCINV0` reader - Inverted Event 0 Input Enable"]
pub type TCINV0_R = crate :: BitReader < bool > ; # [doc = "Field `TCINV0` writer - Inverted Event 0 Input Enable"]
pub type TCINV0_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 12 > ; # [doc = "Field `TCINV1` reader - Inverted Event 1 Input Enable"]
pub type TCINV1_R = crate :: BitReader < bool > ; # [doc = "Field `TCINV1` writer - Inverted Event 1 Input Enable"]
pub type TCINV1_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 13 > ; # [doc = "Field `TCEI0` reader - Timer/counter Event 0 Input Enable"]
pub type TCEI0_R = crate :: BitReader < bool > ; # [doc = "Field `TCEI0` writer - Timer/counter Event 0 Input Enable"]
pub type TCEI0_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 14 > ; # [doc = "Field `TCEI1` reader - Timer/counter Event 1 Input Enable"]
pub type TCEI1_R = crate :: BitReader < bool > ; # [doc = "Field `TCEI1` writer - Timer/counter Event 1 Input Enable"]
pub type TCEI1_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 15 > ; # [doc = "Field `MCEI0` reader - Match or Capture Channel 0 Event Input Enable"]
pub type MCEI0_R = crate :: BitReader < bool > ; # [doc = "Field `MCEI0` writer - Match or Capture Channel 0 Event Input Enable"]
pub type MCEI0_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 16 > ; # [doc = "Field `MCEI1` reader - Match or Capture Channel 1 Event Input Enable"]
pub type MCEI1_R = crate :: BitReader < bool > ; # [doc = "Field `MCEI1` writer - Match or Capture Channel 1 Event Input Enable"]
pub type MCEI1_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 17 > ; # [doc = "Field `MCEI2` reader - Match or Capture Channel 2 Event Input Enable"]
pub type MCEI2_R = crate :: BitReader < bool > ; # [doc = "Field `MCEI2` writer - Match or Capture Channel 2 Event Input Enable"]
pub type MCEI2_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 18 > ; # [doc = "Field `MCEI3` reader - Match or Capture Channel 3 Event Input Enable"]
pub type MCEI3_R = crate :: BitReader < bool > ; # [doc = "Field `MCEI3` writer - Match or Capture Channel 3 Event Input Enable"]
pub type MCEI3_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 19 > ; # [doc = "Field `MCEO0` reader - Match or Capture Channel 0 Event Output Enable"]
pub type MCEO0_R = crate :: BitReader < bool > ; # [doc = "Field `MCEO0` writer - Match or Capture Channel 0 Event Output Enable"]
pub type MCEO0_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 24 > ; # [doc = "Field `MCEO1` reader - Match or Capture Channel 1 Event Output Enable"]
pub type MCEO1_R = crate :: BitReader < bool > ; # [doc = "Field `MCEO1` writer - Match or Capture Channel 1 Event Output Enable"]
pub type MCEO1_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 25 > ; # [doc = "Field `MCEO2` reader - Match or Capture Channel 2 Event Output Enable"]
pub type MCEO2_R = crate :: BitReader < bool > ; # [doc = "Field `MCEO2` writer - Match or Capture Channel 2 Event Output Enable"]
pub type MCEO2_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 26 > ; # [doc = "Field `MCEO3` reader - Match or Capture Channel 3 Event Output Enable"]
pub type MCEO3_R = crate :: BitReader < bool > ; # [doc = "Field `MCEO3` writer - Match or Capture Channel 3 Event Output Enable"]
pub type MCEO3_W < 'a > = crate :: BitWriter < 'a , u32 , EVCTRL_SPEC , bool , 27 > ; impl R { # [doc = "Bits 0:2 - Timer/counter Input Event0 Action"]
# [inline (always)]
pub fn evact0 (& self) -> EVACT0_R { EVACT0_R :: new ((self . bits & 7) as u8) } # [doc = "Bits 3:5 - Timer/counter Input Event1 Action"]
# [inline (always)]
pub fn evact1 (& self) -> EVACT1_R { EVACT1_R :: new (((self . bits >> 3) & 7) as u8) } # [doc = "Bits 6:7 - Timer/counter Output Event Mode"]
# [inline (always)]
pub fn cntsel (& self) -> CNTSEL_R { CNTSEL_R :: new (((self . bits >> 6) & 3) as u8) } # [doc = "Bit 8 - Overflow/Underflow Output Event Enable"]
# [inline (always)]
pub fn ovfeo (& self) -> OVFEO_R { OVFEO_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Retrigger Output Event Enable"]
# [inline (always)]
pub fn trgeo (& self) -> TRGEO_R { TRGEO_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Timer/counter Output Event Enable"]
# [inline (always)]
pub fn cnteo (& self) -> CNTEO_R { CNTEO_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 12 - Inverted Event 0 Input Enable"]
# [inline (always)]
pub fn tcinv0 (& self) -> TCINV0_R { TCINV0_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Inverted Event 1 Input Enable"]
# [inline (always)]
pub fn tcinv1 (& self) -> TCINV1_R { TCINV1_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Timer/counter Event 0 Input Enable"]
# [inline (always)]
pub fn tcei0 (& self) -> TCEI0_R { TCEI0_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Timer/counter Event 1 Input Enable"]
# [inline (always)]
pub fn tcei1 (& self) -> TCEI1_R { TCEI1_R :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - Match or Capture Channel 0 Event Input Enable"]
# [inline (always)]
pub fn mcei0 (& self) -> MCEI0_R { MCEI0_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Match or Capture Channel 1 Event Input Enable"]
# [inline (always)]
pub fn mcei1 (& self) -> MCEI1_R { MCEI1_R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Match or Capture Channel 2 Event Input Enable"]
# [inline (always)]
pub fn mcei2 (& self) -> MCEI2_R { MCEI2_R :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Match or Capture Channel 3 Event Input Enable"]
# [inline (always)]
pub fn mcei3 (& self) -> MCEI3_R { MCEI3_R :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 24 - Match or Capture Channel 0 Event Output Enable"]
# [inline (always)]
pub fn mceo0 (& self) -> MCEO0_R { MCEO0_R :: new (((self . bits >> 24) & 1) != 0) } # [doc = "Bit 25 - Match or Capture Channel 1 Event Output Enable"]
# [inline (always)]
pub fn mceo1 (& self) -> MCEO1_R { MCEO1_R :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - Match or Capture Channel 2 Event Output Enable"]
# [inline (always)]
pub fn mceo2 (& self) -> MCEO2_R { MCEO2_R :: new (((self . bits >> 26) & 1) != 0) } # [doc = "Bit 27 - Match or Capture Channel 3 Event Output Enable"]
# [inline (always)]
pub fn mceo3 (& self) -> MCEO3_R { MCEO3_R :: new (((self . bits >> 27) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Timer/counter Input Event0 Action"]
# [inline (always)]
pub fn evact0 (& mut self) -> EVACT0_W { EVACT0_W :: new (self) } # [doc = "Bits 3:5 - Timer/counter Input Event1 Action"]
# [inline (always)]
pub fn evact1 (& mut self) -> EVACT1_W { EVACT1_W :: new (self) } # [doc = "Bits 6:7 - Timer/counter Output Event Mode"]
# [inline (always)]
pub fn cntsel (& mut self) -> CNTSEL_W { CNTSEL_W :: new (self) } # [doc = "Bit 8 - Overflow/Underflow Output Event Enable"]
# [inline (always)]
pub fn ovfeo (& mut self) -> OVFEO_W { OVFEO_W :: new (self) } # [doc = "Bit 9 - Retrigger Output Event Enable"]
# [inline (always)]
pub fn trgeo (& mut self) -> TRGEO_W { TRGEO_W :: new (self) } # [doc = "Bit 10 - Timer/counter Output Event Enable"]
# [inline (always)]
pub fn cnteo (& mut self) -> CNTEO_W { CNTEO_W :: new (self) } # [doc = "Bit 12 - Inverted Event 0 Input Enable"]
# [inline (always)]
pub fn tcinv0 (& mut self) -> TCINV0_W { TCINV0_W :: new (self) } # [doc = "Bit 13 - Inverted Event 1 Input Enable"]
# [inline (always)]
pub fn tcinv1 (& mut self) -> TCINV1_W { TCINV1_W :: new (self) } # [doc = "Bit 14 - Timer/counter Event 0 Input Enable"]
# [inline (always)]
pub fn tcei0 (& mut self) -> TCEI0_W { TCEI0_W :: new (self) } # [doc = "Bit 15 - Timer/counter Event 1 Input Enable"]
# [inline (always)]
pub fn tcei1 (& mut self) -> TCEI1_W { TCEI1_W :: new (self) } # [doc = "Bit 16 - Match or Capture Channel 0 Event Input Enable"]
# [inline (always)]
pub fn mcei0 (& mut self) -> MCEI0_W { MCEI0_W :: new (self) } # [doc = "Bit 17 - Match or Capture Channel 1 Event Input Enable"]
# [inline (always)]
pub fn mcei1 (& mut self) -> MCEI1_W { MCEI1_W :: new (self) } # [doc = "Bit 18 - Match or Capture Channel 2 Event Input Enable"]
# [inline (always)]
pub fn mcei2 (& mut self) -> MCEI2_W { MCEI2_W :: new (self) } # [doc = "Bit 19 - Match or Capture Channel 3 Event Input Enable"]
# [inline (always)]
pub fn mcei3 (& mut self) -> MCEI3_W { MCEI3_W :: new (self) } # [doc = "Bit 24 - Match or Capture Channel 0 Event Output Enable"]
# [inline (always)]
pub fn mceo0 (& mut self) -> MCEO0_W { MCEO0_W :: new (self) } # [doc = "Bit 25 - Match or Capture Channel 1 Event Output Enable"]
# [inline (always)]
pub fn mceo1 (& mut self) -> MCEO1_W { MCEO1_W :: new (self) } # [doc = "Bit 26 - Match or Capture Channel 2 Event Output Enable"]
# [inline (always)]
pub fn mceo2 (& mut self) -> MCEO2_W { MCEO2_W :: new (self) } # [doc = "Bit 27 - Match or Capture Channel 3 Event Output Enable"]
# [inline (always)]
pub fn mceo3 (& mut self) -> MCEO3_W { MCEO3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [evctrl](index.html) module"]
pub struct EVCTRL_SPEC ; impl crate :: RegisterSpec for EVCTRL_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [evctrl::R](R) reader structure"]
impl crate :: Readable for EVCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [evctrl::W](W) writer structure"]
impl crate :: Writable for EVCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets EVCTRL to value 0"]
impl crate :: Resettable for EVCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENCLR register accessor: an alias for `Reg<INTENCLR_SPEC>`"]
pub type INTENCLR = crate :: Reg < intenclr :: INTENCLR_SPEC > ; # [doc = "Interrupt Enable Clear"]
pub mod intenclr { # [doc = "Register `INTENCLR` reader"]
pub struct R (crate :: R < INTENCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENCLR` writer"]
pub struct W (crate :: W < INTENCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVF` reader - Overflow Interrupt Enable"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow Interrupt Enable"]
pub type OVF_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 0 > ; # [doc = "Field `TRG` reader - Retrigger Interrupt Enable"]
pub type TRG_R = crate :: BitReader < bool > ; # [doc = "Field `TRG` writer - Retrigger Interrupt Enable"]
pub type TRG_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 1 > ; # [doc = "Field `CNT` reader - Counter Interrupt Enable"]
pub type CNT_R = crate :: BitReader < bool > ; # [doc = "Field `CNT` writer - Counter Interrupt Enable"]
pub type CNT_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 2 > ; # [doc = "Field `ERR` reader - Error Interrupt Enable"]
pub type ERR_R = crate :: BitReader < bool > ; # [doc = "Field `ERR` writer - Error Interrupt Enable"]
pub type ERR_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 3 > ; # [doc = "Field `DFS` reader - Non-Recoverable Debug Fault Interrupt Enable"]
pub type DFS_R = crate :: BitReader < bool > ; # [doc = "Field `DFS` writer - Non-Recoverable Debug Fault Interrupt Enable"]
pub type DFS_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 11 > ; # [doc = "Field `FAULTA` reader - Recoverable Fault A Interrupt Enable"]
pub type FAULTA_R = crate :: BitReader < bool > ; # [doc = "Field `FAULTA` writer - Recoverable Fault A Interrupt Enable"]
pub type FAULTA_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 12 > ; # [doc = "Field `FAULTB` reader - Recoverable Fault B Interrupt Enable"]
pub type FAULTB_R = crate :: BitReader < bool > ; # [doc = "Field `FAULTB` writer - Recoverable Fault B Interrupt Enable"]
pub type FAULTB_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 13 > ; # [doc = "Field `FAULT0` reader - Non-Recoverable Fault 0 Interrupt Enable"]
pub type FAULT0_R = crate :: BitReader < bool > ; # [doc = "Field `FAULT0` writer - Non-Recoverable Fault 0 Interrupt Enable"]
pub type FAULT0_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 14 > ; # [doc = "Field `FAULT1` reader - Non-Recoverable Fault 1 Interrupt Enable"]
pub type FAULT1_R = crate :: BitReader < bool > ; # [doc = "Field `FAULT1` writer - Non-Recoverable Fault 1 Interrupt Enable"]
pub type FAULT1_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 15 > ; # [doc = "Field `MC0` reader - Match or Capture Channel 0 Interrupt Enable"]
pub type MC0_R = crate :: BitReader < bool > ; # [doc = "Field `MC0` writer - Match or Capture Channel 0 Interrupt Enable"]
pub type MC0_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 16 > ; # [doc = "Field `MC1` reader - Match or Capture Channel 1 Interrupt Enable"]
pub type MC1_R = crate :: BitReader < bool > ; # [doc = "Field `MC1` writer - Match or Capture Channel 1 Interrupt Enable"]
pub type MC1_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 17 > ; # [doc = "Field `MC2` reader - Match or Capture Channel 2 Interrupt Enable"]
pub type MC2_R = crate :: BitReader < bool > ; # [doc = "Field `MC2` writer - Match or Capture Channel 2 Interrupt Enable"]
pub type MC2_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 18 > ; # [doc = "Field `MC3` reader - Match or Capture Channel 3 Interrupt Enable"]
pub type MC3_R = crate :: BitReader < bool > ; # [doc = "Field `MC3` writer - Match or Capture Channel 3 Interrupt Enable"]
pub type MC3_W < 'a > = crate :: BitWriter < 'a , u32 , INTENCLR_SPEC , bool , 19 > ; impl R { # [doc = "Bit 0 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Retrigger Interrupt Enable"]
# [inline (always)]
pub fn trg (& self) -> TRG_R { TRG_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Counter Interrupt Enable"]
# [inline (always)]
pub fn cnt (& self) -> CNT_R { CNT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Error Interrupt Enable"]
# [inline (always)]
pub fn err (& self) -> ERR_R { ERR_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 11 - Non-Recoverable Debug Fault Interrupt Enable"]
# [inline (always)]
pub fn dfs (& self) -> DFS_R { DFS_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Recoverable Fault A Interrupt Enable"]
# [inline (always)]
pub fn faulta (& self) -> FAULTA_R { FAULTA_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Recoverable Fault B Interrupt Enable"]
# [inline (always)]
pub fn faultb (& self) -> FAULTB_R { FAULTB_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Non-Recoverable Fault 0 Interrupt Enable"]
# [inline (always)]
pub fn fault0 (& self) -> FAULT0_R { FAULT0_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Non-Recoverable Fault 1 Interrupt Enable"]
# [inline (always)]
pub fn fault1 (& self) -> FAULT1_R { FAULT1_R :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - Match or Capture Channel 0 Interrupt Enable"]
# [inline (always)]
pub fn mc0 (& self) -> MC0_R { MC0_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Match or Capture Channel 1 Interrupt Enable"]
# [inline (always)]
pub fn mc1 (& self) -> MC1_R { MC1_R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Match or Capture Channel 2 Interrupt Enable"]
# [inline (always)]
pub fn mc2 (& self) -> MC2_R { MC2_R :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Match or Capture Channel 3 Interrupt Enable"]
# [inline (always)]
pub fn mc3 (& self) -> MC3_R { MC3_R :: new (((self . bits >> 19) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& mut self) -> OVF_W { OVF_W :: new (self) } # [doc = "Bit 1 - Retrigger Interrupt Enable"]
# [inline (always)]
pub fn trg (& mut self) -> TRG_W { TRG_W :: new (self) } # [doc = "Bit 2 - Counter Interrupt Enable"]
# [inline (always)]
pub fn cnt (& mut self) -> CNT_W { CNT_W :: new (self) } # [doc = "Bit 3 - Error Interrupt Enable"]
# [inline (always)]
pub fn err (& mut self) -> ERR_W { ERR_W :: new (self) } # [doc = "Bit 11 - Non-Recoverable Debug Fault Interrupt Enable"]
# [inline (always)]
pub fn dfs (& mut self) -> DFS_W { DFS_W :: new (self) } # [doc = "Bit 12 - Recoverable Fault A Interrupt Enable"]
# [inline (always)]
pub fn faulta (& mut self) -> FAULTA_W { FAULTA_W :: new (self) } # [doc = "Bit 13 - Recoverable Fault B Interrupt Enable"]
# [inline (always)]
pub fn faultb (& mut self) -> FAULTB_W { FAULTB_W :: new (self) } # [doc = "Bit 14 - Non-Recoverable Fault 0 Interrupt Enable"]
# [inline (always)]
pub fn fault0 (& mut self) -> FAULT0_W { FAULT0_W :: new (self) } # [doc = "Bit 15 - Non-Recoverable Fault 1 Interrupt Enable"]
# [inline (always)]
pub fn fault1 (& mut self) -> FAULT1_W { FAULT1_W :: new (self) } # [doc = "Bit 16 - Match or Capture Channel 0 Interrupt Enable"]
# [inline (always)]
pub fn mc0 (& mut self) -> MC0_W { MC0_W :: new (self) } # [doc = "Bit 17 - Match or Capture Channel 1 Interrupt Enable"]
# [inline (always)]
pub fn mc1 (& mut self) -> MC1_W { MC1_W :: new (self) } # [doc = "Bit 18 - Match or Capture Channel 2 Interrupt Enable"]
# [inline (always)]
pub fn mc2 (& mut self) -> MC2_W { MC2_W :: new (self) } # [doc = "Bit 19 - Match or Capture Channel 3 Interrupt Enable"]
# [inline (always)]
pub fn mc3 (& mut self) -> MC3_W { MC3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenclr](index.html) module"]
pub struct INTENCLR_SPEC ; impl crate :: RegisterSpec for INTENCLR_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [intenclr::R](R) reader structure"]
impl crate :: Readable for INTENCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenclr::W](W) writer structure"]
impl crate :: Writable for INTENCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENCLR to value 0"]
impl crate :: Resettable for INTENCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENSET register accessor: an alias for `Reg<INTENSET_SPEC>`"]
pub type INTENSET = crate :: Reg < intenset :: INTENSET_SPEC > ; # [doc = "Interrupt Enable Set"]
pub mod intenset { # [doc = "Register `INTENSET` reader"]
pub struct R (crate :: R < INTENSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENSET` writer"]
pub struct W (crate :: W < INTENSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVF` reader - Overflow Interrupt Enable"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow Interrupt Enable"]
pub type OVF_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 0 > ; # [doc = "Field `TRG` reader - Retrigger Interrupt Enable"]
pub type TRG_R = crate :: BitReader < bool > ; # [doc = "Field `TRG` writer - Retrigger Interrupt Enable"]
pub type TRG_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 1 > ; # [doc = "Field `CNT` reader - Counter Interrupt Enable"]
pub type CNT_R = crate :: BitReader < bool > ; # [doc = "Field `CNT` writer - Counter Interrupt Enable"]
pub type CNT_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 2 > ; # [doc = "Field `ERR` reader - Error Interrupt Enable"]
pub type ERR_R = crate :: BitReader < bool > ; # [doc = "Field `ERR` writer - Error Interrupt Enable"]
pub type ERR_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 3 > ; # [doc = "Field `DFS` reader - Non-Recoverable Debug Fault Interrupt Enable"]
pub type DFS_R = crate :: BitReader < bool > ; # [doc = "Field `DFS` writer - Non-Recoverable Debug Fault Interrupt Enable"]
pub type DFS_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 11 > ; # [doc = "Field `FAULTA` reader - Recoverable Fault A Interrupt Enable"]
pub type FAULTA_R = crate :: BitReader < bool > ; # [doc = "Field `FAULTA` writer - Recoverable Fault A Interrupt Enable"]
pub type FAULTA_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 12 > ; # [doc = "Field `FAULTB` reader - Recoverable Fault B Interrupt Enable"]
pub type FAULTB_R = crate :: BitReader < bool > ; # [doc = "Field `FAULTB` writer - Recoverable Fault B Interrupt Enable"]
pub type FAULTB_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 13 > ; # [doc = "Field `FAULT0` reader - Non-Recoverable Fault 0 Interrupt Enable"]
pub type FAULT0_R = crate :: BitReader < bool > ; # [doc = "Field `FAULT0` writer - Non-Recoverable Fault 0 Interrupt Enable"]
pub type FAULT0_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 14 > ; # [doc = "Field `FAULT1` reader - Non-Recoverable Fault 1 Interrupt Enable"]
pub type FAULT1_R = crate :: BitReader < bool > ; # [doc = "Field `FAULT1` writer - Non-Recoverable Fault 1 Interrupt Enable"]
pub type FAULT1_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 15 > ; # [doc = "Field `MC0` reader - Match or Capture Channel 0 Interrupt Enable"]
pub type MC0_R = crate :: BitReader < bool > ; # [doc = "Field `MC0` writer - Match or Capture Channel 0 Interrupt Enable"]
pub type MC0_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 16 > ; # [doc = "Field `MC1` reader - Match or Capture Channel 1 Interrupt Enable"]
pub type MC1_R = crate :: BitReader < bool > ; # [doc = "Field `MC1` writer - Match or Capture Channel 1 Interrupt Enable"]
pub type MC1_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 17 > ; # [doc = "Field `MC2` reader - Match or Capture Channel 2 Interrupt Enable"]
pub type MC2_R = crate :: BitReader < bool > ; # [doc = "Field `MC2` writer - Match or Capture Channel 2 Interrupt Enable"]
pub type MC2_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 18 > ; # [doc = "Field `MC3` reader - Match or Capture Channel 3 Interrupt Enable"]
pub type MC3_R = crate :: BitReader < bool > ; # [doc = "Field `MC3` writer - Match or Capture Channel 3 Interrupt Enable"]
pub type MC3_W < 'a > = crate :: BitWriter < 'a , u32 , INTENSET_SPEC , bool , 19 > ; impl R { # [doc = "Bit 0 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Retrigger Interrupt Enable"]
# [inline (always)]
pub fn trg (& self) -> TRG_R { TRG_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Counter Interrupt Enable"]
# [inline (always)]
pub fn cnt (& self) -> CNT_R { CNT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Error Interrupt Enable"]
# [inline (always)]
pub fn err (& self) -> ERR_R { ERR_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 11 - Non-Recoverable Debug Fault Interrupt Enable"]
# [inline (always)]
pub fn dfs (& self) -> DFS_R { DFS_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Recoverable Fault A Interrupt Enable"]
# [inline (always)]
pub fn faulta (& self) -> FAULTA_R { FAULTA_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Recoverable Fault B Interrupt Enable"]
# [inline (always)]
pub fn faultb (& self) -> FAULTB_R { FAULTB_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Non-Recoverable Fault 0 Interrupt Enable"]
# [inline (always)]
pub fn fault0 (& self) -> FAULT0_R { FAULT0_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Non-Recoverable Fault 1 Interrupt Enable"]
# [inline (always)]
pub fn fault1 (& self) -> FAULT1_R { FAULT1_R :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - Match or Capture Channel 0 Interrupt Enable"]
# [inline (always)]
pub fn mc0 (& self) -> MC0_R { MC0_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Match or Capture Channel 1 Interrupt Enable"]
# [inline (always)]
pub fn mc1 (& self) -> MC1_R { MC1_R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Match or Capture Channel 2 Interrupt Enable"]
# [inline (always)]
pub fn mc2 (& self) -> MC2_R { MC2_R :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Match or Capture Channel 3 Interrupt Enable"]
# [inline (always)]
pub fn mc3 (& self) -> MC3_R { MC3_R :: new (((self . bits >> 19) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow Interrupt Enable"]
# [inline (always)]
pub fn ovf (& mut self) -> OVF_W { OVF_W :: new (self) } # [doc = "Bit 1 - Retrigger Interrupt Enable"]
# [inline (always)]
pub fn trg (& mut self) -> TRG_W { TRG_W :: new (self) } # [doc = "Bit 2 - Counter Interrupt Enable"]
# [inline (always)]
pub fn cnt (& mut self) -> CNT_W { CNT_W :: new (self) } # [doc = "Bit 3 - Error Interrupt Enable"]
# [inline (always)]
pub fn err (& mut self) -> ERR_W { ERR_W :: new (self) } # [doc = "Bit 11 - Non-Recoverable Debug Fault Interrupt Enable"]
# [inline (always)]
pub fn dfs (& mut self) -> DFS_W { DFS_W :: new (self) } # [doc = "Bit 12 - Recoverable Fault A Interrupt Enable"]
# [inline (always)]
pub fn faulta (& mut self) -> FAULTA_W { FAULTA_W :: new (self) } # [doc = "Bit 13 - Recoverable Fault B Interrupt Enable"]
# [inline (always)]
pub fn faultb (& mut self) -> FAULTB_W { FAULTB_W :: new (self) } # [doc = "Bit 14 - Non-Recoverable Fault 0 Interrupt Enable"]
# [inline (always)]
pub fn fault0 (& mut self) -> FAULT0_W { FAULT0_W :: new (self) } # [doc = "Bit 15 - Non-Recoverable Fault 1 Interrupt Enable"]
# [inline (always)]
pub fn fault1 (& mut self) -> FAULT1_W { FAULT1_W :: new (self) } # [doc = "Bit 16 - Match or Capture Channel 0 Interrupt Enable"]
# [inline (always)]
pub fn mc0 (& mut self) -> MC0_W { MC0_W :: new (self) } # [doc = "Bit 17 - Match or Capture Channel 1 Interrupt Enable"]
# [inline (always)]
pub fn mc1 (& mut self) -> MC1_W { MC1_W :: new (self) } # [doc = "Bit 18 - Match or Capture Channel 2 Interrupt Enable"]
# [inline (always)]
pub fn mc2 (& mut self) -> MC2_W { MC2_W :: new (self) } # [doc = "Bit 19 - Match or Capture Channel 3 Interrupt Enable"]
# [inline (always)]
pub fn mc3 (& mut self) -> MC3_W { MC3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenset](index.html) module"]
pub struct INTENSET_SPEC ; impl crate :: RegisterSpec for INTENSET_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [intenset::R](R) reader structure"]
impl crate :: Readable for INTENSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenset::W](W) writer structure"]
impl crate :: Writable for INTENSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENSET to value 0"]
impl crate :: Resettable for INTENSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTFLAG register accessor: an alias for `Reg<INTFLAG_SPEC>`"]
pub type INTFLAG = crate :: Reg < intflag :: INTFLAG_SPEC > ; # [doc = "Interrupt Flag Status and Clear"]
pub mod intflag { # [doc = "Register `INTFLAG` reader"]
pub struct R (crate :: R < INTFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAG` writer"]
pub struct W (crate :: W < INTFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `OVF` reader - Overflow"]
pub type OVF_R = crate :: BitReader < bool > ; # [doc = "Field `OVF` writer - Overflow"]
pub type OVF_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 0 > ; # [doc = "Field `TRG` reader - Retrigger"]
pub type TRG_R = crate :: BitReader < bool > ; # [doc = "Field `TRG` writer - Retrigger"]
pub type TRG_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 1 > ; # [doc = "Field `CNT` reader - Counter"]
pub type CNT_R = crate :: BitReader < bool > ; # [doc = "Field `CNT` writer - Counter"]
pub type CNT_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 2 > ; # [doc = "Field `ERR` reader - Error"]
pub type ERR_R = crate :: BitReader < bool > ; # [doc = "Field `ERR` writer - Error"]
pub type ERR_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 3 > ; # [doc = "Field `DFS` reader - Non-Recoverable Debug Fault"]
pub type DFS_R = crate :: BitReader < bool > ; # [doc = "Field `DFS` writer - Non-Recoverable Debug Fault"]
pub type DFS_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 11 > ; # [doc = "Field `FAULTA` reader - Recoverable Fault A"]
pub type FAULTA_R = crate :: BitReader < bool > ; # [doc = "Field `FAULTA` writer - Recoverable Fault A"]
pub type FAULTA_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 12 > ; # [doc = "Field `FAULTB` reader - Recoverable Fault B"]
pub type FAULTB_R = crate :: BitReader < bool > ; # [doc = "Field `FAULTB` writer - Recoverable Fault B"]
pub type FAULTB_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 13 > ; # [doc = "Field `FAULT0` reader - Non-Recoverable Fault 0"]
pub type FAULT0_R = crate :: BitReader < bool > ; # [doc = "Field `FAULT0` writer - Non-Recoverable Fault 0"]
pub type FAULT0_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 14 > ; # [doc = "Field `FAULT1` reader - Non-Recoverable Fault 1"]
pub type FAULT1_R = crate :: BitReader < bool > ; # [doc = "Field `FAULT1` writer - Non-Recoverable Fault 1"]
pub type FAULT1_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 15 > ; # [doc = "Field `MC0` reader - Match or Capture 0"]
pub type MC0_R = crate :: BitReader < bool > ; # [doc = "Field `MC0` writer - Match or Capture 0"]
pub type MC0_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 16 > ; # [doc = "Field `MC1` reader - Match or Capture 1"]
pub type MC1_R = crate :: BitReader < bool > ; # [doc = "Field `MC1` writer - Match or Capture 1"]
pub type MC1_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 17 > ; # [doc = "Field `MC2` reader - Match or Capture 2"]
pub type MC2_R = crate :: BitReader < bool > ; # [doc = "Field `MC2` writer - Match or Capture 2"]
pub type MC2_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 18 > ; # [doc = "Field `MC3` reader - Match or Capture 3"]
pub type MC3_R = crate :: BitReader < bool > ; # [doc = "Field `MC3` writer - Match or Capture 3"]
pub type MC3_W < 'a > = crate :: BitWriter < 'a , u32 , INTFLAG_SPEC , bool , 19 > ; impl R { # [doc = "Bit 0 - Overflow"]
# [inline (always)]
pub fn ovf (& self) -> OVF_R { OVF_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Retrigger"]
# [inline (always)]
pub fn trg (& self) -> TRG_R { TRG_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Counter"]
# [inline (always)]
pub fn cnt (& self) -> CNT_R { CNT_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Error"]
# [inline (always)]
pub fn err (& self) -> ERR_R { ERR_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 11 - Non-Recoverable Debug Fault"]
# [inline (always)]
pub fn dfs (& self) -> DFS_R { DFS_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Recoverable Fault A"]
# [inline (always)]
pub fn faulta (& self) -> FAULTA_R { FAULTA_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Recoverable Fault B"]
# [inline (always)]
pub fn faultb (& self) -> FAULTB_R { FAULTB_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Non-Recoverable Fault 0"]
# [inline (always)]
pub fn fault0 (& self) -> FAULT0_R { FAULT0_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Non-Recoverable Fault 1"]
# [inline (always)]
pub fn fault1 (& self) -> FAULT1_R { FAULT1_R :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - Match or Capture 0"]
# [inline (always)]
pub fn mc0 (& self) -> MC0_R { MC0_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Match or Capture 1"]
# [inline (always)]
pub fn mc1 (& self) -> MC1_R { MC1_R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Match or Capture 2"]
# [inline (always)]
pub fn mc2 (& self) -> MC2_R { MC2_R :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Match or Capture 3"]
# [inline (always)]
pub fn mc3 (& self) -> MC3_R { MC3_R :: new (((self . bits >> 19) & 1) != 0) } } impl W { # [doc = "Bit 0 - Overflow"]
# [inline (always)]
pub fn ovf (& mut self) -> OVF_W { OVF_W :: new (self) } # [doc = "Bit 1 - Retrigger"]
# [inline (always)]
pub fn trg (& mut self) -> TRG_W { TRG_W :: new (self) } # [doc = "Bit 2 - Counter"]
# [inline (always)]
pub fn cnt (& mut self) -> CNT_W { CNT_W :: new (self) } # [doc = "Bit 3 - Error"]
# [inline (always)]
pub fn err (& mut self) -> ERR_W { ERR_W :: new (self) } # [doc = "Bit 11 - Non-Recoverable Debug Fault"]
# [inline (always)]
pub fn dfs (& mut self) -> DFS_W { DFS_W :: new (self) } # [doc = "Bit 12 - Recoverable Fault A"]
# [inline (always)]
pub fn faulta (& mut self) -> FAULTA_W { FAULTA_W :: new (self) } # [doc = "Bit 13 - Recoverable Fault B"]
# [inline (always)]
pub fn faultb (& mut self) -> FAULTB_W { FAULTB_W :: new (self) } # [doc = "Bit 14 - Non-Recoverable Fault 0"]
# [inline (always)]
pub fn fault0 (& mut self) -> FAULT0_W { FAULT0_W :: new (self) } # [doc = "Bit 15 - Non-Recoverable Fault 1"]
# [inline (always)]
pub fn fault1 (& mut self) -> FAULT1_W { FAULT1_W :: new (self) } # [doc = "Bit 16 - Match or Capture 0"]
# [inline (always)]
pub fn mc0 (& mut self) -> MC0_W { MC0_W :: new (self) } # [doc = "Bit 17 - Match or Capture 1"]
# [inline (always)]
pub fn mc1 (& mut self) -> MC1_W { MC1_W :: new (self) } # [doc = "Bit 18 - Match or Capture 2"]
# [inline (always)]
pub fn mc2 (& mut self) -> MC2_W { MC2_W :: new (self) } # [doc = "Bit 19 - Match or Capture 3"]
# [inline (always)]
pub fn mc3 (& mut self) -> MC3_W { MC3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflag](index.html) module"]
pub struct INTFLAG_SPEC ; impl crate :: RegisterSpec for INTFLAG_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [intflag::R](R) reader structure"]
impl crate :: Readable for INTFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflag::W](W) writer structure"]
impl crate :: Writable for INTFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTFLAG to value 0"]
impl crate :: Resettable for INTFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATUS register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `STOP` reader - Stop"]
pub type STOP_R = crate :: BitReader < bool > ; # [doc = "Field `IDX` reader - Ramp"]
pub type IDX_R = crate :: BitReader < bool > ; # [doc = "Field `DFS` reader - Non-Recoverable Debug Fault State"]
pub type DFS_R = crate :: BitReader < bool > ; # [doc = "Field `DFS` writer - Non-Recoverable Debug Fault State"]
pub type DFS_W < 'a > = crate :: BitWriter < 'a , u32 , STATUS_SPEC , bool , 3 > ; # [doc = "Field `SLAVE` reader - Slave"]
pub type SLAVE_R = crate :: BitReader < bool > ; # [doc = "Field `PATTBV` reader - Pattern Buffer Valid"]
pub type PATTBV_R = crate :: BitReader < bool > ; # [doc = "Field `PATTBV` writer - Pattern Buffer Valid"]
pub type PATTBV_W < 'a > = crate :: BitWriter < 'a , u32 , STATUS_SPEC , bool , 5 > ; # [doc = "Field `WAVEBV` reader - Wave Buffer Valid"]
pub type WAVEBV_R = crate :: BitReader < bool > ; # [doc = "Field `WAVEBV` writer - Wave Buffer Valid"]
pub type WAVEBV_W < 'a > = crate :: BitWriter < 'a , u32 , STATUS_SPEC , bool , 6 > ; # [doc = "Field `PERBV` reader - Period Buffer Valid"]
pub type PERBV_R = crate :: BitReader < bool > ; # [doc = "Field `PERBV` writer - Period Buffer Valid"]
pub type PERBV_W < 'a > = crate :: BitWriter < 'a , u32 , STATUS_SPEC , bool , 7 > ; # [doc = "Field `FAULTAIN` reader - Recoverable Fault A Input"]
pub type FAULTAIN_R = crate :: BitReader < bool > ; # [doc = "Field `FAULTBIN` reader - Recoverable Fault B Input"]
pub type FAULTBIN_R = crate :: BitReader < bool > ; # [doc = "Field `FAULT0IN` reader - Non-Recoverable Fault0 Input"]
pub type FAULT0IN_R = crate :: BitReader < bool > ; # [doc = "Field `FAULT1IN` reader - Non-Recoverable Fault1 Input"]
pub type FAULT1IN_R = crate :: BitReader < bool > ; # [doc = "Field `FAULTA` reader - Recoverable Fault A State"]
pub type FAULTA_R = crate :: BitReader < bool > ; # [doc = "Field `FAULTA` writer - Recoverable Fault A State"]
pub type FAULTA_W < 'a > = crate :: BitWriter < 'a , u32 , STATUS_SPEC , bool , 12 > ; # [doc = "Field `FAULTB` reader - Recoverable Fault B State"]
pub type FAULTB_R = crate :: BitReader < bool > ; # [doc = "Field `FAULTB` writer - Recoverable Fault B State"]
pub type FAULTB_W < 'a > = crate :: BitWriter < 'a , u32 , STATUS_SPEC , bool , 13 > ; # [doc = "Field `FAULT0` reader - Non-Recoverable Fault 0 State"]
pub type FAULT0_R = crate :: BitReader < bool > ; # [doc = "Field `FAULT0` writer - Non-Recoverable Fault 0 State"]
pub type FAULT0_W < 'a > = crate :: BitWriter < 'a , u32 , STATUS_SPEC , bool , 14 > ; # [doc = "Field `FAULT1` reader - Non-Recoverable Fault 1 State"]
pub type FAULT1_R = crate :: BitReader < bool > ; # [doc = "Field `FAULT1` writer - Non-Recoverable Fault 1 State"]
pub type FAULT1_W < 'a > = crate :: BitWriter < 'a , u32 , STATUS_SPEC , bool , 15 > ; # [doc = "Field `CCBV0` reader - Compare Channel 0 Buffer Valid"]
pub type CCBV0_R = crate :: BitReader < bool > ; # [doc = "Field `CCBV0` writer - Compare Channel 0 Buffer Valid"]
pub type CCBV0_W < 'a > = crate :: BitWriter < 'a , u32 , STATUS_SPEC , bool , 16 > ; # [doc = "Field `CCBV1` reader - Compare Channel 1 Buffer Valid"]
pub type CCBV1_R = crate :: BitReader < bool > ; # [doc = "Field `CCBV1` writer - Compare Channel 1 Buffer Valid"]
pub type CCBV1_W < 'a > = crate :: BitWriter < 'a , u32 , STATUS_SPEC , bool , 17 > ; # [doc = "Field `CCBV2` reader - Compare Channel 2 Buffer Valid"]
pub type CCBV2_R = crate :: BitReader < bool > ; # [doc = "Field `CCBV2` writer - Compare Channel 2 Buffer Valid"]
pub type CCBV2_W < 'a > = crate :: BitWriter < 'a , u32 , STATUS_SPEC , bool , 18 > ; # [doc = "Field `CCBV3` reader - Compare Channel 3 Buffer Valid"]
pub type CCBV3_R = crate :: BitReader < bool > ; # [doc = "Field `CCBV3` writer - Compare Channel 3 Buffer Valid"]
pub type CCBV3_W < 'a > = crate :: BitWriter < 'a , u32 , STATUS_SPEC , bool , 19 > ; # [doc = "Field `CMP0` reader - Compare Channel 0 Value"]
pub type CMP0_R = crate :: BitReader < bool > ; # [doc = "Field `CMP1` reader - Compare Channel 1 Value"]
pub type CMP1_R = crate :: BitReader < bool > ; # [doc = "Field `CMP2` reader - Compare Channel 2 Value"]
pub type CMP2_R = crate :: BitReader < bool > ; # [doc = "Field `CMP3` reader - Compare Channel 3 Value"]
pub type CMP3_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Stop"]
# [inline (always)]
pub fn stop (& self) -> STOP_R { STOP_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Ramp"]
# [inline (always)]
pub fn idx (& self) -> IDX_R { IDX_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 3 - Non-Recoverable Debug Fault State"]
# [inline (always)]
pub fn dfs (& self) -> DFS_R { DFS_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Slave"]
# [inline (always)]
pub fn slave (& self) -> SLAVE_R { SLAVE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pattern Buffer Valid"]
# [inline (always)]
pub fn pattbv (& self) -> PATTBV_R { PATTBV_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Wave Buffer Valid"]
# [inline (always)]
pub fn wavebv (& self) -> WAVEBV_R { WAVEBV_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Period Buffer Valid"]
# [inline (always)]
pub fn perbv (& self) -> PERBV_R { PERBV_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Recoverable Fault A Input"]
# [inline (always)]
pub fn faultain (& self) -> FAULTAIN_R { FAULTAIN_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Recoverable Fault B Input"]
# [inline (always)]
pub fn faultbin (& self) -> FAULTBIN_R { FAULTBIN_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Non-Recoverable Fault0 Input"]
# [inline (always)]
pub fn fault0in (& self) -> FAULT0IN_R { FAULT0IN_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Non-Recoverable Fault1 Input"]
# [inline (always)]
pub fn fault1in (& self) -> FAULT1IN_R { FAULT1IN_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Recoverable Fault A State"]
# [inline (always)]
pub fn faulta (& self) -> FAULTA_R { FAULTA_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Recoverable Fault B State"]
# [inline (always)]
pub fn faultb (& self) -> FAULTB_R { FAULTB_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Non-Recoverable Fault 0 State"]
# [inline (always)]
pub fn fault0 (& self) -> FAULT0_R { FAULT0_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Non-Recoverable Fault 1 State"]
# [inline (always)]
pub fn fault1 (& self) -> FAULT1_R { FAULT1_R :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - Compare Channel 0 Buffer Valid"]
# [inline (always)]
pub fn ccbv0 (& self) -> CCBV0_R { CCBV0_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Compare Channel 1 Buffer Valid"]
# [inline (always)]
pub fn ccbv1 (& self) -> CCBV1_R { CCBV1_R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Compare Channel 2 Buffer Valid"]
# [inline (always)]
pub fn ccbv2 (& self) -> CCBV2_R { CCBV2_R :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Compare Channel 3 Buffer Valid"]
# [inline (always)]
pub fn ccbv3 (& self) -> CCBV3_R { CCBV3_R :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 24 - Compare Channel 0 Value"]
# [inline (always)]
pub fn cmp0 (& self) -> CMP0_R { CMP0_R :: new (((self . bits >> 24) & 1) != 0) } # [doc = "Bit 25 - Compare Channel 1 Value"]
# [inline (always)]
pub fn cmp1 (& self) -> CMP1_R { CMP1_R :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - Compare Channel 2 Value"]
# [inline (always)]
pub fn cmp2 (& self) -> CMP2_R { CMP2_R :: new (((self . bits >> 26) & 1) != 0) } # [doc = "Bit 27 - Compare Channel 3 Value"]
# [inline (always)]
pub fn cmp3 (& self) -> CMP3_R { CMP3_R :: new (((self . bits >> 27) & 1) != 0) } } impl W { # [doc = "Bit 3 - Non-Recoverable Debug Fault State"]
# [inline (always)]
pub fn dfs (& mut self) -> DFS_W { DFS_W :: new (self) } # [doc = "Bit 5 - Pattern Buffer Valid"]
# [inline (always)]
pub fn pattbv (& mut self) -> PATTBV_W { PATTBV_W :: new (self) } # [doc = "Bit 6 - Wave Buffer Valid"]
# [inline (always)]
pub fn wavebv (& mut self) -> WAVEBV_W { WAVEBV_W :: new (self) } # [doc = "Bit 7 - Period Buffer Valid"]
# [inline (always)]
pub fn perbv (& mut self) -> PERBV_W { PERBV_W :: new (self) } # [doc = "Bit 12 - Recoverable Fault A State"]
# [inline (always)]
pub fn faulta (& mut self) -> FAULTA_W { FAULTA_W :: new (self) } # [doc = "Bit 13 - Recoverable Fault B State"]
# [inline (always)]
pub fn faultb (& mut self) -> FAULTB_W { FAULTB_W :: new (self) } # [doc = "Bit 14 - Non-Recoverable Fault 0 State"]
# [inline (always)]
pub fn fault0 (& mut self) -> FAULT0_W { FAULT0_W :: new (self) } # [doc = "Bit 15 - Non-Recoverable Fault 1 State"]
# [inline (always)]
pub fn fault1 (& mut self) -> FAULT1_W { FAULT1_W :: new (self) } # [doc = "Bit 16 - Compare Channel 0 Buffer Valid"]
# [inline (always)]
pub fn ccbv0 (& mut self) -> CCBV0_W { CCBV0_W :: new (self) } # [doc = "Bit 17 - Compare Channel 1 Buffer Valid"]
# [inline (always)]
pub fn ccbv1 (& mut self) -> CCBV1_W { CCBV1_W :: new (self) } # [doc = "Bit 18 - Compare Channel 2 Buffer Valid"]
# [inline (always)]
pub fn ccbv2 (& mut self) -> CCBV2_W { CCBV2_W :: new (self) } # [doc = "Bit 19 - Compare Channel 3 Buffer Valid"]
# [inline (always)]
pub fn ccbv3 (& mut self) -> CCBV3_W { CCBV3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; } # [doc = "`reset()` method sets STATUS to value 0x01"]
impl crate :: Resettable for STATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x01 } } } # [doc = "COUNT register accessor: an alias for `Reg<COUNT_SPEC>`"]
pub type COUNT = crate :: Reg < count :: COUNT_SPEC > ; # [doc = "Count"]
pub mod count { # [doc = "Register `COUNT` reader"]
pub struct R (crate :: R < COUNT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < COUNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < COUNT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < COUNT_SPEC >) -> Self { R (reader) } } # [doc = "Register `COUNT` writer"]
pub struct W (crate :: W < COUNT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < COUNT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < COUNT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < COUNT_SPEC >) -> Self { W (writer) } } # [doc = "Field `COUNT` reader - Counter Value"]
pub type COUNT_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `COUNT` writer - Counter Value"]
pub type COUNT_W < 'a > = crate :: FieldWriter < 'a , u32 , COUNT_SPEC , u32 , u32 , 24 , 0 > ; impl R { # [doc = "Bits 0:23 - Counter Value"]
# [inline (always)]
pub fn count (& self) -> COUNT_R { COUNT_R :: new ((self . bits & 0x00ff_ffff) as u32) } } impl W { # [doc = "Bits 0:23 - Counter Value"]
# [inline (always)]
pub fn count (& mut self) -> COUNT_W { COUNT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [count](index.html) module"]
pub struct COUNT_SPEC ; impl crate :: RegisterSpec for COUNT_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [count::R](R) reader structure"]
impl crate :: Readable for COUNT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [count::W](W) writer structure"]
impl crate :: Writable for COUNT_SPEC { type Writer = W ; } # [doc = "`reset()` method sets COUNT to value 0"]
impl crate :: Resettable for COUNT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "COUNT_DITH4 register accessor: an alias for `Reg<COUNT_DITH4_SPEC>`"]
pub type COUNT_DITH4 = crate :: Reg < count_dith4 :: COUNT_DITH4_SPEC > ; # [doc = "Count"]
pub mod count_dith4 { # [doc = "Register `COUNT_DITH4` reader"]
pub struct R (crate :: R < COUNT_DITH4_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < COUNT_DITH4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < COUNT_DITH4_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < COUNT_DITH4_SPEC >) -> Self { R (reader) } } # [doc = "Register `COUNT_DITH4` writer"]
pub struct W (crate :: W < COUNT_DITH4_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < COUNT_DITH4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < COUNT_DITH4_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < COUNT_DITH4_SPEC >) -> Self { W (writer) } } # [doc = "Field `COUNT` reader - Counter Value"]
pub type COUNT_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `COUNT` writer - Counter Value"]
pub type COUNT_W < 'a > = crate :: FieldWriter < 'a , u32 , COUNT_DITH4_SPEC , u32 , u32 , 20 , 4 > ; impl R { # [doc = "Bits 4:23 - Counter Value"]
# [inline (always)]
pub fn count (& self) -> COUNT_R { COUNT_R :: new (((self . bits >> 4) & 0x000f_ffff) as u32) } } impl W { # [doc = "Bits 4:23 - Counter Value"]
# [inline (always)]
pub fn count (& mut self) -> COUNT_W { COUNT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [count_dith4](index.html) module"]
pub struct COUNT_DITH4_SPEC ; impl crate :: RegisterSpec for COUNT_DITH4_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [count_dith4::R](R) reader structure"]
impl crate :: Readable for COUNT_DITH4_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [count_dith4::W](W) writer structure"]
impl crate :: Writable for COUNT_DITH4_SPEC { type Writer = W ; } # [doc = "`reset()` method sets COUNT_DITH4 to value 0"]
impl crate :: Resettable for COUNT_DITH4_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "COUNT_DITH5 register accessor: an alias for `Reg<COUNT_DITH5_SPEC>`"]
pub type COUNT_DITH5 = crate :: Reg < count_dith5 :: COUNT_DITH5_SPEC > ; # [doc = "Count"]
pub mod count_dith5 { # [doc = "Register `COUNT_DITH5` reader"]
pub struct R (crate :: R < COUNT_DITH5_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < COUNT_DITH5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < COUNT_DITH5_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < COUNT_DITH5_SPEC >) -> Self { R (reader) } } # [doc = "Register `COUNT_DITH5` writer"]
pub struct W (crate :: W < COUNT_DITH5_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < COUNT_DITH5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < COUNT_DITH5_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < COUNT_DITH5_SPEC >) -> Self { W (writer) } } # [doc = "Field `COUNT` reader - Counter Value"]
pub type COUNT_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `COUNT` writer - Counter Value"]
pub type COUNT_W < 'a > = crate :: FieldWriter < 'a , u32 , COUNT_DITH5_SPEC , u32 , u32 , 19 , 5 > ; impl R { # [doc = "Bits 5:23 - Counter Value"]
# [inline (always)]
pub fn count (& self) -> COUNT_R { COUNT_R :: new (((self . bits >> 5) & 0x0007_ffff) as u32) } } impl W { # [doc = "Bits 5:23 - Counter Value"]
# [inline (always)]
pub fn count (& mut self) -> COUNT_W { COUNT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [count_dith5](index.html) module"]
pub struct COUNT_DITH5_SPEC ; impl crate :: RegisterSpec for COUNT_DITH5_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [count_dith5::R](R) reader structure"]
impl crate :: Readable for COUNT_DITH5_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [count_dith5::W](W) writer structure"]
impl crate :: Writable for COUNT_DITH5_SPEC { type Writer = W ; } # [doc = "`reset()` method sets COUNT_DITH5 to value 0"]
impl crate :: Resettable for COUNT_DITH5_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "COUNT_DITH6 register accessor: an alias for `Reg<COUNT_DITH6_SPEC>`"]
pub type COUNT_DITH6 = crate :: Reg < count_dith6 :: COUNT_DITH6_SPEC > ; # [doc = "Count"]
pub mod count_dith6 { # [doc = "Register `COUNT_DITH6` reader"]
pub struct R (crate :: R < COUNT_DITH6_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < COUNT_DITH6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < COUNT_DITH6_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < COUNT_DITH6_SPEC >) -> Self { R (reader) } } # [doc = "Register `COUNT_DITH6` writer"]
pub struct W (crate :: W < COUNT_DITH6_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < COUNT_DITH6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < COUNT_DITH6_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < COUNT_DITH6_SPEC >) -> Self { W (writer) } } # [doc = "Field `COUNT` reader - Counter Value"]
pub type COUNT_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `COUNT` writer - Counter Value"]
pub type COUNT_W < 'a > = crate :: FieldWriter < 'a , u32 , COUNT_DITH6_SPEC , u32 , u32 , 18 , 6 > ; impl R { # [doc = "Bits 6:23 - Counter Value"]
# [inline (always)]
pub fn count (& self) -> COUNT_R { COUNT_R :: new (((self . bits >> 6) & 0x0003_ffff) as u32) } } impl W { # [doc = "Bits 6:23 - Counter Value"]
# [inline (always)]
pub fn count (& mut self) -> COUNT_W { COUNT_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [count_dith6](index.html) module"]
pub struct COUNT_DITH6_SPEC ; impl crate :: RegisterSpec for COUNT_DITH6_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [count_dith6::R](R) reader structure"]
impl crate :: Readable for COUNT_DITH6_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [count_dith6::W](W) writer structure"]
impl crate :: Writable for COUNT_DITH6_SPEC { type Writer = W ; } # [doc = "`reset()` method sets COUNT_DITH6 to value 0"]
impl crate :: Resettable for COUNT_DITH6_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PATT register accessor: an alias for `Reg<PATT_SPEC>`"]
pub type PATT = crate :: Reg < patt :: PATT_SPEC > ; # [doc = "Pattern"]
pub mod patt { # [doc = "Register `PATT` reader"]
pub struct R (crate :: R < PATT_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PATT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PATT_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PATT_SPEC >) -> Self { R (reader) } } # [doc = "Register `PATT` writer"]
pub struct W (crate :: W < PATT_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PATT_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PATT_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PATT_SPEC >) -> Self { W (writer) } } # [doc = "Field `PGE0` reader - Pattern Generator 0 Output Enable"]
pub type PGE0_R = crate :: BitReader < bool > ; # [doc = "Field `PGE0` writer - Pattern Generator 0 Output Enable"]
pub type PGE0_W < 'a > = crate :: BitWriter < 'a , u16 , PATT_SPEC , bool , 0 > ; # [doc = "Field `PGE1` reader - Pattern Generator 1 Output Enable"]
pub type PGE1_R = crate :: BitReader < bool > ; # [doc = "Field `PGE1` writer - Pattern Generator 1 Output Enable"]
pub type PGE1_W < 'a > = crate :: BitWriter < 'a , u16 , PATT_SPEC , bool , 1 > ; # [doc = "Field `PGE2` reader - Pattern Generator 2 Output Enable"]
pub type PGE2_R = crate :: BitReader < bool > ; # [doc = "Field `PGE2` writer - Pattern Generator 2 Output Enable"]
pub type PGE2_W < 'a > = crate :: BitWriter < 'a , u16 , PATT_SPEC , bool , 2 > ; # [doc = "Field `PGE3` reader - Pattern Generator 3 Output Enable"]
pub type PGE3_R = crate :: BitReader < bool > ; # [doc = "Field `PGE3` writer - Pattern Generator 3 Output Enable"]
pub type PGE3_W < 'a > = crate :: BitWriter < 'a , u16 , PATT_SPEC , bool , 3 > ; # [doc = "Field `PGE4` reader - Pattern Generator 4 Output Enable"]
pub type PGE4_R = crate :: BitReader < bool > ; # [doc = "Field `PGE4` writer - Pattern Generator 4 Output Enable"]
pub type PGE4_W < 'a > = crate :: BitWriter < 'a , u16 , PATT_SPEC , bool , 4 > ; # [doc = "Field `PGE5` reader - Pattern Generator 5 Output Enable"]
pub type PGE5_R = crate :: BitReader < bool > ; # [doc = "Field `PGE5` writer - Pattern Generator 5 Output Enable"]
pub type PGE5_W < 'a > = crate :: BitWriter < 'a , u16 , PATT_SPEC , bool , 5 > ; # [doc = "Field `PGE6` reader - Pattern Generator 6 Output Enable"]
pub type PGE6_R = crate :: BitReader < bool > ; # [doc = "Field `PGE6` writer - Pattern Generator 6 Output Enable"]
pub type PGE6_W < 'a > = crate :: BitWriter < 'a , u16 , PATT_SPEC , bool , 6 > ; # [doc = "Field `PGE7` reader - Pattern Generator 7 Output Enable"]
pub type PGE7_R = crate :: BitReader < bool > ; # [doc = "Field `PGE7` writer - Pattern Generator 7 Output Enable"]
pub type PGE7_W < 'a > = crate :: BitWriter < 'a , u16 , PATT_SPEC , bool , 7 > ; # [doc = "Field `PGV0` reader - Pattern Generator 0 Output Value"]
pub type PGV0_R = crate :: BitReader < bool > ; # [doc = "Field `PGV0` writer - Pattern Generator 0 Output Value"]
pub type PGV0_W < 'a > = crate :: BitWriter < 'a , u16 , PATT_SPEC , bool , 8 > ; # [doc = "Field `PGV1` reader - Pattern Generator 1 Output Value"]
pub type PGV1_R = crate :: BitReader < bool > ; # [doc = "Field `PGV1` writer - Pattern Generator 1 Output Value"]
pub type PGV1_W < 'a > = crate :: BitWriter < 'a , u16 , PATT_SPEC , bool , 9 > ; # [doc = "Field `PGV2` reader - Pattern Generator 2 Output Value"]
pub type PGV2_R = crate :: BitReader < bool > ; # [doc = "Field `PGV2` writer - Pattern Generator 2 Output Value"]
pub type PGV2_W < 'a > = crate :: BitWriter < 'a , u16 , PATT_SPEC , bool , 10 > ; # [doc = "Field `PGV3` reader - Pattern Generator 3 Output Value"]
pub type PGV3_R = crate :: BitReader < bool > ; # [doc = "Field `PGV3` writer - Pattern Generator 3 Output Value"]
pub type PGV3_W < 'a > = crate :: BitWriter < 'a , u16 , PATT_SPEC , bool , 11 > ; # [doc = "Field `PGV4` reader - Pattern Generator 4 Output Value"]
pub type PGV4_R = crate :: BitReader < bool > ; # [doc = "Field `PGV4` writer - Pattern Generator 4 Output Value"]
pub type PGV4_W < 'a > = crate :: BitWriter < 'a , u16 , PATT_SPEC , bool , 12 > ; # [doc = "Field `PGV5` reader - Pattern Generator 5 Output Value"]
pub type PGV5_R = crate :: BitReader < bool > ; # [doc = "Field `PGV5` writer - Pattern Generator 5 Output Value"]
pub type PGV5_W < 'a > = crate :: BitWriter < 'a , u16 , PATT_SPEC , bool , 13 > ; # [doc = "Field `PGV6` reader - Pattern Generator 6 Output Value"]
pub type PGV6_R = crate :: BitReader < bool > ; # [doc = "Field `PGV6` writer - Pattern Generator 6 Output Value"]
pub type PGV6_W < 'a > = crate :: BitWriter < 'a , u16 , PATT_SPEC , bool , 14 > ; # [doc = "Field `PGV7` reader - Pattern Generator 7 Output Value"]
pub type PGV7_R = crate :: BitReader < bool > ; # [doc = "Field `PGV7` writer - Pattern Generator 7 Output Value"]
pub type PGV7_W < 'a > = crate :: BitWriter < 'a , u16 , PATT_SPEC , bool , 15 > ; impl R { # [doc = "Bit 0 - Pattern Generator 0 Output Enable"]
# [inline (always)]
pub fn pge0 (& self) -> PGE0_R { PGE0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pattern Generator 1 Output Enable"]
# [inline (always)]
pub fn pge1 (& self) -> PGE1_R { PGE1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pattern Generator 2 Output Enable"]
# [inline (always)]
pub fn pge2 (& self) -> PGE2_R { PGE2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pattern Generator 3 Output Enable"]
# [inline (always)]
pub fn pge3 (& self) -> PGE3_R { PGE3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pattern Generator 4 Output Enable"]
# [inline (always)]
pub fn pge4 (& self) -> PGE4_R { PGE4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pattern Generator 5 Output Enable"]
# [inline (always)]
pub fn pge5 (& self) -> PGE5_R { PGE5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pattern Generator 6 Output Enable"]
# [inline (always)]
pub fn pge6 (& self) -> PGE6_R { PGE6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pattern Generator 7 Output Enable"]
# [inline (always)]
pub fn pge7 (& self) -> PGE7_R { PGE7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Pattern Generator 0 Output Value"]
# [inline (always)]
pub fn pgv0 (& self) -> PGV0_R { PGV0_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Pattern Generator 1 Output Value"]
# [inline (always)]
pub fn pgv1 (& self) -> PGV1_R { PGV1_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Pattern Generator 2 Output Value"]
# [inline (always)]
pub fn pgv2 (& self) -> PGV2_R { PGV2_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Pattern Generator 3 Output Value"]
# [inline (always)]
pub fn pgv3 (& self) -> PGV3_R { PGV3_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Pattern Generator 4 Output Value"]
# [inline (always)]
pub fn pgv4 (& self) -> PGV4_R { PGV4_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Pattern Generator 5 Output Value"]
# [inline (always)]
pub fn pgv5 (& self) -> PGV5_R { PGV5_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Pattern Generator 6 Output Value"]
# [inline (always)]
pub fn pgv6 (& self) -> PGV6_R { PGV6_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Pattern Generator 7 Output Value"]
# [inline (always)]
pub fn pgv7 (& self) -> PGV7_R { PGV7_R :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pattern Generator 0 Output Enable"]
# [inline (always)]
pub fn pge0 (& mut self) -> PGE0_W { PGE0_W :: new (self) } # [doc = "Bit 1 - Pattern Generator 1 Output Enable"]
# [inline (always)]
pub fn pge1 (& mut self) -> PGE1_W { PGE1_W :: new (self) } # [doc = "Bit 2 - Pattern Generator 2 Output Enable"]
# [inline (always)]
pub fn pge2 (& mut self) -> PGE2_W { PGE2_W :: new (self) } # [doc = "Bit 3 - Pattern Generator 3 Output Enable"]
# [inline (always)]
pub fn pge3 (& mut self) -> PGE3_W { PGE3_W :: new (self) } # [doc = "Bit 4 - Pattern Generator 4 Output Enable"]
# [inline (always)]
pub fn pge4 (& mut self) -> PGE4_W { PGE4_W :: new (self) } # [doc = "Bit 5 - Pattern Generator 5 Output Enable"]
# [inline (always)]
pub fn pge5 (& mut self) -> PGE5_W { PGE5_W :: new (self) } # [doc = "Bit 6 - Pattern Generator 6 Output Enable"]
# [inline (always)]
pub fn pge6 (& mut self) -> PGE6_W { PGE6_W :: new (self) } # [doc = "Bit 7 - Pattern Generator 7 Output Enable"]
# [inline (always)]
pub fn pge7 (& mut self) -> PGE7_W { PGE7_W :: new (self) } # [doc = "Bit 8 - Pattern Generator 0 Output Value"]
# [inline (always)]
pub fn pgv0 (& mut self) -> PGV0_W { PGV0_W :: new (self) } # [doc = "Bit 9 - Pattern Generator 1 Output Value"]
# [inline (always)]
pub fn pgv1 (& mut self) -> PGV1_W { PGV1_W :: new (self) } # [doc = "Bit 10 - Pattern Generator 2 Output Value"]
# [inline (always)]
pub fn pgv2 (& mut self) -> PGV2_W { PGV2_W :: new (self) } # [doc = "Bit 11 - Pattern Generator 3 Output Value"]
# [inline (always)]
pub fn pgv3 (& mut self) -> PGV3_W { PGV3_W :: new (self) } # [doc = "Bit 12 - Pattern Generator 4 Output Value"]
# [inline (always)]
pub fn pgv4 (& mut self) -> PGV4_W { PGV4_W :: new (self) } # [doc = "Bit 13 - Pattern Generator 5 Output Value"]
# [inline (always)]
pub fn pgv5 (& mut self) -> PGV5_W { PGV5_W :: new (self) } # [doc = "Bit 14 - Pattern Generator 6 Output Value"]
# [inline (always)]
pub fn pgv6 (& mut self) -> PGV6_W { PGV6_W :: new (self) } # [doc = "Bit 15 - Pattern Generator 7 Output Value"]
# [inline (always)]
pub fn pgv7 (& mut self) -> PGV7_W { PGV7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pattern\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [patt](index.html) module"]
pub struct PATT_SPEC ; impl crate :: RegisterSpec for PATT_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [patt::R](R) reader structure"]
impl crate :: Readable for PATT_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [patt::W](W) writer structure"]
impl crate :: Writable for PATT_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PATT to value 0"]
impl crate :: Resettable for PATT_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "WAVE register accessor: an alias for `Reg<WAVE_SPEC>`"]
pub type WAVE = crate :: Reg < wave :: WAVE_SPEC > ; # [doc = "Waveform Control"]
pub mod wave { # [doc = "Register `WAVE` reader"]
pub struct R (crate :: R < WAVE_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < WAVE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < WAVE_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < WAVE_SPEC >) -> Self { R (reader) } } # [doc = "Register `WAVE` writer"]
pub struct W (crate :: W < WAVE_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < WAVE_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < WAVE_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < WAVE_SPEC >) -> Self { W (writer) } } # [doc = "Waveform Generation\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum WAVEGEN_A { # [doc = "0: Normal frequency"]
NFRQ = 0 , # [doc = "1: Match frequency"]
MFRQ = 1 , # [doc = "2: Normal PWM"]
NPWM = 2 , # [doc = "4: Dual-slope critical"]
DSCRITICAL = 4 , # [doc = "5: Dual-slope with interrupt/event condition when COUNT reaches ZERO"]
DSBOTTOM = 5 , # [doc = "6: Dual-slope with interrupt/event condition when COUNT reaches ZERO or TOP"]
DSBOTH = 6 , # [doc = "7: Dual-slope with interrupt/event condition when COUNT reaches TOP"]
DSTOP = 7 , } impl From < WAVEGEN_A > for u8 { # [inline (always)]
fn from (variant : WAVEGEN_A) -> Self { variant as _ } } # [doc = "Field `WAVEGEN` reader - Waveform Generation"]
pub type WAVEGEN_R = crate :: FieldReader < u8 , WAVEGEN_A > ; impl WAVEGEN_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WAVEGEN_A > { match self . bits { 0 => Some (WAVEGEN_A :: NFRQ) , 1 => Some (WAVEGEN_A :: MFRQ) , 2 => Some (WAVEGEN_A :: NPWM) , 4 => Some (WAVEGEN_A :: DSCRITICAL) , 5 => Some (WAVEGEN_A :: DSBOTTOM) , 6 => Some (WAVEGEN_A :: DSBOTH) , 7 => Some (WAVEGEN_A :: DSTOP) , _ => None , } } # [doc = "Checks if the value of the field is `NFRQ`"]
# [inline (always)]
pub fn is_nfrq (& self) -> bool { * self == WAVEGEN_A :: NFRQ } # [doc = "Checks if the value of the field is `MFRQ`"]
# [inline (always)]
pub fn is_mfrq (& self) -> bool { * self == WAVEGEN_A :: MFRQ } # [doc = "Checks if the value of the field is `NPWM`"]
# [inline (always)]
pub fn is_npwm (& self) -> bool { * self == WAVEGEN_A :: NPWM } # [doc = "Checks if the value of the field is `DSCRITICAL`"]
# [inline (always)]
pub fn is_dscritical (& self) -> bool { * self == WAVEGEN_A :: DSCRITICAL } # [doc = "Checks if the value of the field is `DSBOTTOM`"]
# [inline (always)]
pub fn is_dsbottom (& self) -> bool { * self == WAVEGEN_A :: DSBOTTOM } # [doc = "Checks if the value of the field is `DSBOTH`"]
# [inline (always)]
pub fn is_dsboth (& self) -> bool { * self == WAVEGEN_A :: DSBOTH } # [doc = "Checks if the value of the field is `DSTOP`"]
# [inline (always)]
pub fn is_dstop (& self) -> bool { * self == WAVEGEN_A :: DSTOP } } # [doc = "Field `WAVEGEN` writer - Waveform Generation"]
pub type WAVEGEN_W < 'a > = crate :: FieldWriter < 'a , u32 , WAVE_SPEC , u8 , WAVEGEN_A , 3 , 0 > ; impl < 'a > WAVEGEN_W < 'a > { # [doc = "Normal frequency"]
# [inline (always)]
pub fn nfrq (self) -> & 'a mut W { self . variant (WAVEGEN_A :: NFRQ) } # [doc = "Match frequency"]
# [inline (always)]
pub fn mfrq (self) -> & 'a mut W { self . variant (WAVEGEN_A :: MFRQ) } # [doc = "Normal PWM"]
# [inline (always)]
pub fn npwm (self) -> & 'a mut W { self . variant (WAVEGEN_A :: NPWM) } # [doc = "Dual-slope critical"]
# [inline (always)]
pub fn dscritical (self) -> & 'a mut W { self . variant (WAVEGEN_A :: DSCRITICAL) } # [doc = "Dual-slope with interrupt/event condition when COUNT reaches ZERO"]
# [inline (always)]
pub fn dsbottom (self) -> & 'a mut W { self . variant (WAVEGEN_A :: DSBOTTOM) } # [doc = "Dual-slope with interrupt/event condition when COUNT reaches ZERO or TOP"]
# [inline (always)]
pub fn dsboth (self) -> & 'a mut W { self . variant (WAVEGEN_A :: DSBOTH) } # [doc = "Dual-slope with interrupt/event condition when COUNT reaches TOP"]
# [inline (always)]
pub fn dstop (self) -> & 'a mut W { self . variant (WAVEGEN_A :: DSTOP) } } # [doc = "Ramp Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum RAMP_A { # [doc = "0: RAMP1 operation"]
RAMP1 = 0 , # [doc = "1: Alternative RAMP2 operation"]
RAMP2A = 1 , # [doc = "2: RAMP2 operation"]
RAMP2 = 2 , } impl From < RAMP_A > for u8 { # [inline (always)]
fn from (variant : RAMP_A) -> Self { variant as _ } } # [doc = "Field `RAMP` reader - Ramp Mode"]
pub type RAMP_R = crate :: FieldReader < u8 , RAMP_A > ; impl RAMP_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < RAMP_A > { match self . bits { 0 => Some (RAMP_A :: RAMP1) , 1 => Some (RAMP_A :: RAMP2A) , 2 => Some (RAMP_A :: RAMP2) , _ => None , } } # [doc = "Checks if the value of the field is `RAMP1`"]
# [inline (always)]
pub fn is_ramp1 (& self) -> bool { * self == RAMP_A :: RAMP1 } # [doc = "Checks if the value of the field is `RAMP2A`"]
# [inline (always)]
pub fn is_ramp2a (& self) -> bool { * self == RAMP_A :: RAMP2A } # [doc = "Checks if the value of the field is `RAMP2`"]
# [inline (always)]
pub fn is_ramp2 (& self) -> bool { * self == RAMP_A :: RAMP2 } } # [doc = "Field `RAMP` writer - Ramp Mode"]
pub type RAMP_W < 'a > = crate :: FieldWriter < 'a , u32 , WAVE_SPEC , u8 , RAMP_A , 2 , 4 > ; impl < 'a > RAMP_W < 'a > { # [doc = "RAMP1 operation"]
# [inline (always)]
pub fn ramp1 (self) -> & 'a mut W { self . variant (RAMP_A :: RAMP1) } # [doc = "Alternative RAMP2 operation"]
# [inline (always)]
pub fn ramp2a (self) -> & 'a mut W { self . variant (RAMP_A :: RAMP2A) } # [doc = "RAMP2 operation"]
# [inline (always)]
pub fn ramp2 (self) -> & 'a mut W { self . variant (RAMP_A :: RAMP2) } } # [doc = "Field `CIPEREN` reader - Circular period Enable"]
pub type CIPEREN_R = crate :: BitReader < bool > ; # [doc = "Field `CIPEREN` writer - Circular period Enable"]
pub type CIPEREN_W < 'a > = crate :: BitWriter < 'a , u32 , WAVE_SPEC , bool , 7 > ; # [doc = "Field `CICCEN0` reader - Circular Channel 0 Enable"]
pub type CICCEN0_R = crate :: BitReader < bool > ; # [doc = "Field `CICCEN0` writer - Circular Channel 0 Enable"]
pub type CICCEN0_W < 'a > = crate :: BitWriter < 'a , u32 , WAVE_SPEC , bool , 8 > ; # [doc = "Field `CICCEN1` reader - Circular Channel 1 Enable"]
pub type CICCEN1_R = crate :: BitReader < bool > ; # [doc = "Field `CICCEN1` writer - Circular Channel 1 Enable"]
pub type CICCEN1_W < 'a > = crate :: BitWriter < 'a , u32 , WAVE_SPEC , bool , 9 > ; # [doc = "Field `CICCEN2` reader - Circular Channel 2 Enable"]
pub type CICCEN2_R = crate :: BitReader < bool > ; # [doc = "Field `CICCEN2` writer - Circular Channel 2 Enable"]
pub type CICCEN2_W < 'a > = crate :: BitWriter < 'a , u32 , WAVE_SPEC , bool , 10 > ; # [doc = "Field `CICCEN3` reader - Circular Channel 3 Enable"]
pub type CICCEN3_R = crate :: BitReader < bool > ; # [doc = "Field `CICCEN3` writer - Circular Channel 3 Enable"]
pub type CICCEN3_W < 'a > = crate :: BitWriter < 'a , u32 , WAVE_SPEC , bool , 11 > ; # [doc = "Field `POL0` reader - Channel 0 Polarity"]
pub type POL0_R = crate :: BitReader < bool > ; # [doc = "Field `POL0` writer - Channel 0 Polarity"]
pub type POL0_W < 'a > = crate :: BitWriter < 'a , u32 , WAVE_SPEC , bool , 16 > ; # [doc = "Field `POL1` reader - Channel 1 Polarity"]
pub type POL1_R = crate :: BitReader < bool > ; # [doc = "Field `POL1` writer - Channel 1 Polarity"]
pub type POL1_W < 'a > = crate :: BitWriter < 'a , u32 , WAVE_SPEC , bool , 17 > ; # [doc = "Field `POL2` reader - Channel 2 Polarity"]
pub type POL2_R = crate :: BitReader < bool > ; # [doc = "Field `POL2` writer - Channel 2 Polarity"]
pub type POL2_W < 'a > = crate :: BitWriter < 'a , u32 , WAVE_SPEC , bool , 18 > ; # [doc = "Field `POL3` reader - Channel 3 Polarity"]
pub type POL3_R = crate :: BitReader < bool > ; # [doc = "Field `POL3` writer - Channel 3 Polarity"]
pub type POL3_W < 'a > = crate :: BitWriter < 'a , u32 , WAVE_SPEC , bool , 19 > ; # [doc = "Field `SWAP0` reader - Swap DTI Output Pair 0"]
pub type SWAP0_R = crate :: BitReader < bool > ; # [doc = "Field `SWAP0` writer - Swap DTI Output Pair 0"]
pub type SWAP0_W < 'a > = crate :: BitWriter < 'a , u32 , WAVE_SPEC , bool , 24 > ; # [doc = "Field `SWAP1` reader - Swap DTI Output Pair 1"]
pub type SWAP1_R = crate :: BitReader < bool > ; # [doc = "Field `SWAP1` writer - Swap DTI Output Pair 1"]
pub type SWAP1_W < 'a > = crate :: BitWriter < 'a , u32 , WAVE_SPEC , bool , 25 > ; # [doc = "Field `SWAP2` reader - Swap DTI Output Pair 2"]
pub type SWAP2_R = crate :: BitReader < bool > ; # [doc = "Field `SWAP2` writer - Swap DTI Output Pair 2"]
pub type SWAP2_W < 'a > = crate :: BitWriter < 'a , u32 , WAVE_SPEC , bool , 26 > ; # [doc = "Field `SWAP3` reader - Swap DTI Output Pair 3"]
pub type SWAP3_R = crate :: BitReader < bool > ; # [doc = "Field `SWAP3` writer - Swap DTI Output Pair 3"]
pub type SWAP3_W < 'a > = crate :: BitWriter < 'a , u32 , WAVE_SPEC , bool , 27 > ; impl R { # [doc = "Bits 0:2 - Waveform Generation"]
# [inline (always)]
pub fn wavegen (& self) -> WAVEGEN_R { WAVEGEN_R :: new ((self . bits & 7) as u8) } # [doc = "Bits 4:5 - Ramp Mode"]
# [inline (always)]
pub fn ramp (& self) -> RAMP_R { RAMP_R :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bit 7 - Circular period Enable"]
# [inline (always)]
pub fn ciperen (& self) -> CIPEREN_R { CIPEREN_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Circular Channel 0 Enable"]
# [inline (always)]
pub fn ciccen0 (& self) -> CICCEN0_R { CICCEN0_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Circular Channel 1 Enable"]
# [inline (always)]
pub fn ciccen1 (& self) -> CICCEN1_R { CICCEN1_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Circular Channel 2 Enable"]
# [inline (always)]
pub fn ciccen2 (& self) -> CICCEN2_R { CICCEN2_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Circular Channel 3 Enable"]
# [inline (always)]
pub fn ciccen3 (& self) -> CICCEN3_R { CICCEN3_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 16 - Channel 0 Polarity"]
# [inline (always)]
pub fn pol0 (& self) -> POL0_R { POL0_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Channel 1 Polarity"]
# [inline (always)]
pub fn pol1 (& self) -> POL1_R { POL1_R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Channel 2 Polarity"]
# [inline (always)]
pub fn pol2 (& self) -> POL2_R { POL2_R :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Channel 3 Polarity"]
# [inline (always)]
pub fn pol3 (& self) -> POL3_R { POL3_R :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 24 - Swap DTI Output Pair 0"]
# [inline (always)]
pub fn swap0 (& self) -> SWAP0_R { SWAP0_R :: new (((self . bits >> 24) & 1) != 0) } # [doc = "Bit 25 - Swap DTI Output Pair 1"]
# [inline (always)]
pub fn swap1 (& self) -> SWAP1_R { SWAP1_R :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - Swap DTI Output Pair 2"]
# [inline (always)]
pub fn swap2 (& self) -> SWAP2_R { SWAP2_R :: new (((self . bits >> 26) & 1) != 0) } # [doc = "Bit 27 - Swap DTI Output Pair 3"]
# [inline (always)]
pub fn swap3 (& self) -> SWAP3_R { SWAP3_R :: new (((self . bits >> 27) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Waveform Generation"]
# [inline (always)]
pub fn wavegen (& mut self) -> WAVEGEN_W { WAVEGEN_W :: new (self) } # [doc = "Bits 4:5 - Ramp Mode"]
# [inline (always)]
pub fn ramp (& mut self) -> RAMP_W { RAMP_W :: new (self) } # [doc = "Bit 7 - Circular period Enable"]
# [inline (always)]
pub fn ciperen (& mut self) -> CIPEREN_W { CIPEREN_W :: new (self) } # [doc = "Bit 8 - Circular Channel 0 Enable"]
# [inline (always)]
pub fn ciccen0 (& mut self) -> CICCEN0_W { CICCEN0_W :: new (self) } # [doc = "Bit 9 - Circular Channel 1 Enable"]
# [inline (always)]
pub fn ciccen1 (& mut self) -> CICCEN1_W { CICCEN1_W :: new (self) } # [doc = "Bit 10 - Circular Channel 2 Enable"]
# [inline (always)]
pub fn ciccen2 (& mut self) -> CICCEN2_W { CICCEN2_W :: new (self) } # [doc = "Bit 11 - Circular Channel 3 Enable"]
# [inline (always)]
pub fn ciccen3 (& mut self) -> CICCEN3_W { CICCEN3_W :: new (self) } # [doc = "Bit 16 - Channel 0 Polarity"]
# [inline (always)]
pub fn pol0 (& mut self) -> POL0_W { POL0_W :: new (self) } # [doc = "Bit 17 - Channel 1 Polarity"]
# [inline (always)]
pub fn pol1 (& mut self) -> POL1_W { POL1_W :: new (self) } # [doc = "Bit 18 - Channel 2 Polarity"]
# [inline (always)]
pub fn pol2 (& mut self) -> POL2_W { POL2_W :: new (self) } # [doc = "Bit 19 - Channel 3 Polarity"]
# [inline (always)]
pub fn pol3 (& mut self) -> POL3_W { POL3_W :: new (self) } # [doc = "Bit 24 - Swap DTI Output Pair 0"]
# [inline (always)]
pub fn swap0 (& mut self) -> SWAP0_W { SWAP0_W :: new (self) } # [doc = "Bit 25 - Swap DTI Output Pair 1"]
# [inline (always)]
pub fn swap1 (& mut self) -> SWAP1_W { SWAP1_W :: new (self) } # [doc = "Bit 26 - Swap DTI Output Pair 2"]
# [inline (always)]
pub fn swap2 (& mut self) -> SWAP2_W { SWAP2_W :: new (self) } # [doc = "Bit 27 - Swap DTI Output Pair 3"]
# [inline (always)]
pub fn swap3 (& mut self) -> SWAP3_W { SWAP3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Waveform Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [wave](index.html) module"]
pub struct WAVE_SPEC ; impl crate :: RegisterSpec for WAVE_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [wave::R](R) reader structure"]
impl crate :: Readable for WAVE_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [wave::W](W) writer structure"]
impl crate :: Writable for WAVE_SPEC { type Writer = W ; } # [doc = "`reset()` method sets WAVE to value 0"]
impl crate :: Resettable for WAVE_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PER register accessor: an alias for `Reg<PER_SPEC>`"]
pub type PER = crate :: Reg < per :: PER_SPEC > ; # [doc = "Period"]
pub mod per { # [doc = "Register `PER` reader"]
pub struct R (crate :: R < PER_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PER_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PER_SPEC >) -> Self { R (reader) } } # [doc = "Register `PER` writer"]
pub struct W (crate :: W < PER_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PER_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PER_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PER_SPEC >) -> Self { W (writer) } } # [doc = "Field `PER` reader - Period Value"]
pub type PER_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `PER` writer - Period Value"]
pub type PER_W < 'a > = crate :: FieldWriter < 'a , u32 , PER_SPEC , u32 , u32 , 24 , 0 > ; impl R { # [doc = "Bits 0:23 - Period Value"]
# [inline (always)]
pub fn per (& self) -> PER_R { PER_R :: new ((self . bits & 0x00ff_ffff) as u32) } } impl W { # [doc = "Bits 0:23 - Period Value"]
# [inline (always)]
pub fn per (& mut self) -> PER_W { PER_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [per](index.html) module"]
pub struct PER_SPEC ; impl crate :: RegisterSpec for PER_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [per::R](R) reader structure"]
impl crate :: Readable for PER_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [per::W](W) writer structure"]
impl crate :: Writable for PER_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PER to value 0xffff_ffff"]
impl crate :: Resettable for PER_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0xffff_ffff } } } # [doc = "PER_DITH4 register accessor: an alias for `Reg<PER_DITH4_SPEC>`"]
pub type PER_DITH4 = crate :: Reg < per_dith4 :: PER_DITH4_SPEC > ; # [doc = "Period"]
pub mod per_dith4 { # [doc = "Register `PER_DITH4` reader"]
pub struct R (crate :: R < PER_DITH4_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PER_DITH4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PER_DITH4_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PER_DITH4_SPEC >) -> Self { R (reader) } } # [doc = "Register `PER_DITH4` writer"]
pub struct W (crate :: W < PER_DITH4_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PER_DITH4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PER_DITH4_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PER_DITH4_SPEC >) -> Self { W (writer) } } # [doc = "Field `DITHERCY` reader - Dithering Cycle Number"]
pub type DITHERCY_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DITHERCY` writer - Dithering Cycle Number"]
pub type DITHERCY_W < 'a > = crate :: FieldWriter < 'a , u32 , PER_DITH4_SPEC , u8 , u8 , 4 , 0 > ; # [doc = "Field `PER` reader - Period Value"]
pub type PER_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `PER` writer - Period Value"]
pub type PER_W < 'a > = crate :: FieldWriter < 'a , u32 , PER_DITH4_SPEC , u32 , u32 , 20 , 4 > ; impl R { # [doc = "Bits 0:3 - Dithering Cycle Number"]
# [inline (always)]
pub fn dithercy (& self) -> DITHERCY_R { DITHERCY_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bits 4:23 - Period Value"]
# [inline (always)]
pub fn per (& self) -> PER_R { PER_R :: new (((self . bits >> 4) & 0x000f_ffff) as u32) } } impl W { # [doc = "Bits 0:3 - Dithering Cycle Number"]
# [inline (always)]
pub fn dithercy (& mut self) -> DITHERCY_W { DITHERCY_W :: new (self) } # [doc = "Bits 4:23 - Period Value"]
# [inline (always)]
pub fn per (& mut self) -> PER_W { PER_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [per_dith4](index.html) module"]
pub struct PER_DITH4_SPEC ; impl crate :: RegisterSpec for PER_DITH4_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [per_dith4::R](R) reader structure"]
impl crate :: Readable for PER_DITH4_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [per_dith4::W](W) writer structure"]
impl crate :: Writable for PER_DITH4_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PER_DITH4 to value 0xffff_ffff"]
impl crate :: Resettable for PER_DITH4_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0xffff_ffff } } } # [doc = "PER_DITH5 register accessor: an alias for `Reg<PER_DITH5_SPEC>`"]
pub type PER_DITH5 = crate :: Reg < per_dith5 :: PER_DITH5_SPEC > ; # [doc = "Period"]
pub mod per_dith5 { # [doc = "Register `PER_DITH5` reader"]
pub struct R (crate :: R < PER_DITH5_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PER_DITH5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PER_DITH5_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PER_DITH5_SPEC >) -> Self { R (reader) } } # [doc = "Register `PER_DITH5` writer"]
pub struct W (crate :: W < PER_DITH5_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PER_DITH5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PER_DITH5_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PER_DITH5_SPEC >) -> Self { W (writer) } } # [doc = "Field `DITHERCY` reader - Dithering Cycle Number"]
pub type DITHERCY_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DITHERCY` writer - Dithering Cycle Number"]
pub type DITHERCY_W < 'a > = crate :: FieldWriter < 'a , u32 , PER_DITH5_SPEC , u8 , u8 , 5 , 0 > ; # [doc = "Field `PER` reader - Period Value"]
pub type PER_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `PER` writer - Period Value"]
pub type PER_W < 'a > = crate :: FieldWriter < 'a , u32 , PER_DITH5_SPEC , u32 , u32 , 19 , 5 > ; impl R { # [doc = "Bits 0:4 - Dithering Cycle Number"]
# [inline (always)]
pub fn dithercy (& self) -> DITHERCY_R { DITHERCY_R :: new ((self . bits & 0x1f) as u8) } # [doc = "Bits 5:23 - Period Value"]
# [inline (always)]
pub fn per (& self) -> PER_R { PER_R :: new (((self . bits >> 5) & 0x0007_ffff) as u32) } } impl W { # [doc = "Bits 0:4 - Dithering Cycle Number"]
# [inline (always)]
pub fn dithercy (& mut self) -> DITHERCY_W { DITHERCY_W :: new (self) } # [doc = "Bits 5:23 - Period Value"]
# [inline (always)]
pub fn per (& mut self) -> PER_W { PER_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [per_dith5](index.html) module"]
pub struct PER_DITH5_SPEC ; impl crate :: RegisterSpec for PER_DITH5_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [per_dith5::R](R) reader structure"]
impl crate :: Readable for PER_DITH5_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [per_dith5::W](W) writer structure"]
impl crate :: Writable for PER_DITH5_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PER_DITH5 to value 0xffff_ffff"]
impl crate :: Resettable for PER_DITH5_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0xffff_ffff } } } # [doc = "PER_DITH6 register accessor: an alias for `Reg<PER_DITH6_SPEC>`"]
pub type PER_DITH6 = crate :: Reg < per_dith6 :: PER_DITH6_SPEC > ; # [doc = "Period"]
pub mod per_dith6 { # [doc = "Register `PER_DITH6` reader"]
pub struct R (crate :: R < PER_DITH6_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PER_DITH6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PER_DITH6_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PER_DITH6_SPEC >) -> Self { R (reader) } } # [doc = "Register `PER_DITH6` writer"]
pub struct W (crate :: W < PER_DITH6_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PER_DITH6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PER_DITH6_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PER_DITH6_SPEC >) -> Self { W (writer) } } # [doc = "Field `DITHERCY` reader - Dithering Cycle Number"]
pub type DITHERCY_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DITHERCY` writer - Dithering Cycle Number"]
pub type DITHERCY_W < 'a > = crate :: FieldWriter < 'a , u32 , PER_DITH6_SPEC , u8 , u8 , 6 , 0 > ; # [doc = "Field `PER` reader - Period Value"]
pub type PER_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `PER` writer - Period Value"]
pub type PER_W < 'a > = crate :: FieldWriter < 'a , u32 , PER_DITH6_SPEC , u32 , u32 , 18 , 6 > ; impl R { # [doc = "Bits 0:5 - Dithering Cycle Number"]
# [inline (always)]
pub fn dithercy (& self) -> DITHERCY_R { DITHERCY_R :: new ((self . bits & 0x3f) as u8) } # [doc = "Bits 6:23 - Period Value"]
# [inline (always)]
pub fn per (& self) -> PER_R { PER_R :: new (((self . bits >> 6) & 0x0003_ffff) as u32) } } impl W { # [doc = "Bits 0:5 - Dithering Cycle Number"]
# [inline (always)]
pub fn dithercy (& mut self) -> DITHERCY_W { DITHERCY_W :: new (self) } # [doc = "Bits 6:23 - Period Value"]
# [inline (always)]
pub fn per (& mut self) -> PER_W { PER_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [per_dith6](index.html) module"]
pub struct PER_DITH6_SPEC ; impl crate :: RegisterSpec for PER_DITH6_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [per_dith6::R](R) reader structure"]
impl crate :: Readable for PER_DITH6_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [per_dith6::W](W) writer structure"]
impl crate :: Writable for PER_DITH6_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PER_DITH6 to value 0xffff_ffff"]
impl crate :: Resettable for PER_DITH6_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0xffff_ffff } } } # [doc = "CC register accessor: an alias for `Reg<CC_SPEC>`"]
pub type CC = crate :: Reg < cc :: CC_SPEC > ; # [doc = "Compare and Capture"]
pub mod cc { # [doc = "Register `CC%s` reader"]
pub struct R (crate :: R < CC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CC_SPEC >) -> Self { R (reader) } } # [doc = "Register `CC%s` writer"]
pub struct W (crate :: W < CC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CC_SPEC >) -> Self { W (writer) } } # [doc = "Field `CC` reader - Channel Compare/Capture Value"]
pub type CC_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `CC` writer - Channel Compare/Capture Value"]
pub type CC_W < 'a > = crate :: FieldWriter < 'a , u32 , CC_SPEC , u32 , u32 , 24 , 0 > ; impl R { # [doc = "Bits 0:23 - Channel Compare/Capture Value"]
# [inline (always)]
pub fn cc (& self) -> CC_R { CC_R :: new ((self . bits & 0x00ff_ffff) as u32) } } impl W { # [doc = "Bits 0:23 - Channel Compare/Capture Value"]
# [inline (always)]
pub fn cc (& mut self) -> CC_W { CC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Compare and Capture\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cc](index.html) module"]
pub struct CC_SPEC ; impl crate :: RegisterSpec for CC_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [cc::R](R) reader structure"]
impl crate :: Readable for CC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cc::W](W) writer structure"]
impl crate :: Writable for CC_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CC%s to value 0"]
impl crate :: Resettable for CC_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CC_DITH4 register accessor: an alias for `Reg<CC_DITH4_SPEC>`"]
pub type CC_DITH4 = crate :: Reg < cc_dith4 :: CC_DITH4_SPEC > ; # [doc = "Compare and Capture"]
pub mod cc_dith4 { # [doc = "Register `CC%s_DITH4` reader"]
pub struct R (crate :: R < CC_DITH4_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CC_DITH4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CC_DITH4_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CC_DITH4_SPEC >) -> Self { R (reader) } } # [doc = "Register `CC%s_DITH4` writer"]
pub struct W (crate :: W < CC_DITH4_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CC_DITH4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CC_DITH4_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CC_DITH4_SPEC >) -> Self { W (writer) } } # [doc = "Field `DITHERCY` reader - Dithering Cycle Number"]
pub type DITHERCY_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DITHERCY` writer - Dithering Cycle Number"]
pub type DITHERCY_W < 'a > = crate :: FieldWriter < 'a , u32 , CC_DITH4_SPEC , u8 , u8 , 4 , 0 > ; # [doc = "Field `CC` reader - Channel Compare/Capture Value"]
pub type CC_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `CC` writer - Channel Compare/Capture Value"]
pub type CC_W < 'a > = crate :: FieldWriter < 'a , u32 , CC_DITH4_SPEC , u32 , u32 , 20 , 4 > ; impl R { # [doc = "Bits 0:3 - Dithering Cycle Number"]
# [inline (always)]
pub fn dithercy (& self) -> DITHERCY_R { DITHERCY_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bits 4:23 - Channel Compare/Capture Value"]
# [inline (always)]
pub fn cc (& self) -> CC_R { CC_R :: new (((self . bits >> 4) & 0x000f_ffff) as u32) } } impl W { # [doc = "Bits 0:3 - Dithering Cycle Number"]
# [inline (always)]
pub fn dithercy (& mut self) -> DITHERCY_W { DITHERCY_W :: new (self) } # [doc = "Bits 4:23 - Channel Compare/Capture Value"]
# [inline (always)]
pub fn cc (& mut self) -> CC_W { CC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Compare and Capture\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cc_dith4](index.html) module"]
pub struct CC_DITH4_SPEC ; impl crate :: RegisterSpec for CC_DITH4_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [cc_dith4::R](R) reader structure"]
impl crate :: Readable for CC_DITH4_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cc_dith4::W](W) writer structure"]
impl crate :: Writable for CC_DITH4_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CC%s_DITH4 to value 0"]
impl crate :: Resettable for CC_DITH4_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CC_DITH5 register accessor: an alias for `Reg<CC_DITH5_SPEC>`"]
pub type CC_DITH5 = crate :: Reg < cc_dith5 :: CC_DITH5_SPEC > ; # [doc = "Compare and Capture"]
pub mod cc_dith5 { # [doc = "Register `CC%s_DITH5` reader"]
pub struct R (crate :: R < CC_DITH5_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CC_DITH5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CC_DITH5_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CC_DITH5_SPEC >) -> Self { R (reader) } } # [doc = "Register `CC%s_DITH5` writer"]
pub struct W (crate :: W < CC_DITH5_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CC_DITH5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CC_DITH5_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CC_DITH5_SPEC >) -> Self { W (writer) } } # [doc = "Field `DITHERCY` reader - Dithering Cycle Number"]
pub type DITHERCY_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DITHERCY` writer - Dithering Cycle Number"]
pub type DITHERCY_W < 'a > = crate :: FieldWriter < 'a , u32 , CC_DITH5_SPEC , u8 , u8 , 5 , 0 > ; # [doc = "Field `CC` reader - Channel Compare/Capture Value"]
pub type CC_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `CC` writer - Channel Compare/Capture Value"]
pub type CC_W < 'a > = crate :: FieldWriter < 'a , u32 , CC_DITH5_SPEC , u32 , u32 , 19 , 5 > ; impl R { # [doc = "Bits 0:4 - Dithering Cycle Number"]
# [inline (always)]
pub fn dithercy (& self) -> DITHERCY_R { DITHERCY_R :: new ((self . bits & 0x1f) as u8) } # [doc = "Bits 5:23 - Channel Compare/Capture Value"]
# [inline (always)]
pub fn cc (& self) -> CC_R { CC_R :: new (((self . bits >> 5) & 0x0007_ffff) as u32) } } impl W { # [doc = "Bits 0:4 - Dithering Cycle Number"]
# [inline (always)]
pub fn dithercy (& mut self) -> DITHERCY_W { DITHERCY_W :: new (self) } # [doc = "Bits 5:23 - Channel Compare/Capture Value"]
# [inline (always)]
pub fn cc (& mut self) -> CC_W { CC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Compare and Capture\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cc_dith5](index.html) module"]
pub struct CC_DITH5_SPEC ; impl crate :: RegisterSpec for CC_DITH5_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [cc_dith5::R](R) reader structure"]
impl crate :: Readable for CC_DITH5_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cc_dith5::W](W) writer structure"]
impl crate :: Writable for CC_DITH5_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CC%s_DITH5 to value 0"]
impl crate :: Resettable for CC_DITH5_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CC_DITH6 register accessor: an alias for `Reg<CC_DITH6_SPEC>`"]
pub type CC_DITH6 = crate :: Reg < cc_dith6 :: CC_DITH6_SPEC > ; # [doc = "Compare and Capture"]
pub mod cc_dith6 { # [doc = "Register `CC%s_DITH6` reader"]
pub struct R (crate :: R < CC_DITH6_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CC_DITH6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CC_DITH6_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CC_DITH6_SPEC >) -> Self { R (reader) } } # [doc = "Register `CC%s_DITH6` writer"]
pub struct W (crate :: W < CC_DITH6_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CC_DITH6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CC_DITH6_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CC_DITH6_SPEC >) -> Self { W (writer) } } # [doc = "Field `DITHERCY` reader - Dithering Cycle Number"]
pub type DITHERCY_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DITHERCY` writer - Dithering Cycle Number"]
pub type DITHERCY_W < 'a > = crate :: FieldWriter < 'a , u32 , CC_DITH6_SPEC , u8 , u8 , 6 , 0 > ; # [doc = "Field `CC` reader - Channel Compare/Capture Value"]
pub type CC_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `CC` writer - Channel Compare/Capture Value"]
pub type CC_W < 'a > = crate :: FieldWriter < 'a , u32 , CC_DITH6_SPEC , u32 , u32 , 18 , 6 > ; impl R { # [doc = "Bits 0:5 - Dithering Cycle Number"]
# [inline (always)]
pub fn dithercy (& self) -> DITHERCY_R { DITHERCY_R :: new ((self . bits & 0x3f) as u8) } # [doc = "Bits 6:23 - Channel Compare/Capture Value"]
# [inline (always)]
pub fn cc (& self) -> CC_R { CC_R :: new (((self . bits >> 6) & 0x0003_ffff) as u32) } } impl W { # [doc = "Bits 0:5 - Dithering Cycle Number"]
# [inline (always)]
pub fn dithercy (& mut self) -> DITHERCY_W { DITHERCY_W :: new (self) } # [doc = "Bits 6:23 - Channel Compare/Capture Value"]
# [inline (always)]
pub fn cc (& mut self) -> CC_W { CC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Compare and Capture\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cc_dith6](index.html) module"]
pub struct CC_DITH6_SPEC ; impl crate :: RegisterSpec for CC_DITH6_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [cc_dith6::R](R) reader structure"]
impl crate :: Readable for CC_DITH6_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [cc_dith6::W](W) writer structure"]
impl crate :: Writable for CC_DITH6_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CC%s_DITH6 to value 0"]
impl crate :: Resettable for CC_DITH6_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PATTB register accessor: an alias for `Reg<PATTB_SPEC>`"]
pub type PATTB = crate :: Reg < pattb :: PATTB_SPEC > ; # [doc = "Pattern Buffer"]
pub mod pattb { # [doc = "Register `PATTB` reader"]
pub struct R (crate :: R < PATTB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PATTB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PATTB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PATTB_SPEC >) -> Self { R (reader) } } # [doc = "Register `PATTB` writer"]
pub struct W (crate :: W < PATTB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PATTB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PATTB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PATTB_SPEC >) -> Self { W (writer) } } # [doc = "Field `PGEB0` reader - Pattern Generator 0 Output Enable Buffer"]
pub type PGEB0_R = crate :: BitReader < bool > ; # [doc = "Field `PGEB0` writer - Pattern Generator 0 Output Enable Buffer"]
pub type PGEB0_W < 'a > = crate :: BitWriter < 'a , u16 , PATTB_SPEC , bool , 0 > ; # [doc = "Field `PGEB1` reader - Pattern Generator 1 Output Enable Buffer"]
pub type PGEB1_R = crate :: BitReader < bool > ; # [doc = "Field `PGEB1` writer - Pattern Generator 1 Output Enable Buffer"]
pub type PGEB1_W < 'a > = crate :: BitWriter < 'a , u16 , PATTB_SPEC , bool , 1 > ; # [doc = "Field `PGEB2` reader - Pattern Generator 2 Output Enable Buffer"]
pub type PGEB2_R = crate :: BitReader < bool > ; # [doc = "Field `PGEB2` writer - Pattern Generator 2 Output Enable Buffer"]
pub type PGEB2_W < 'a > = crate :: BitWriter < 'a , u16 , PATTB_SPEC , bool , 2 > ; # [doc = "Field `PGEB3` reader - Pattern Generator 3 Output Enable Buffer"]
pub type PGEB3_R = crate :: BitReader < bool > ; # [doc = "Field `PGEB3` writer - Pattern Generator 3 Output Enable Buffer"]
pub type PGEB3_W < 'a > = crate :: BitWriter < 'a , u16 , PATTB_SPEC , bool , 3 > ; # [doc = "Field `PGEB4` reader - Pattern Generator 4 Output Enable Buffer"]
pub type PGEB4_R = crate :: BitReader < bool > ; # [doc = "Field `PGEB4` writer - Pattern Generator 4 Output Enable Buffer"]
pub type PGEB4_W < 'a > = crate :: BitWriter < 'a , u16 , PATTB_SPEC , bool , 4 > ; # [doc = "Field `PGEB5` reader - Pattern Generator 5 Output Enable Buffer"]
pub type PGEB5_R = crate :: BitReader < bool > ; # [doc = "Field `PGEB5` writer - Pattern Generator 5 Output Enable Buffer"]
pub type PGEB5_W < 'a > = crate :: BitWriter < 'a , u16 , PATTB_SPEC , bool , 5 > ; # [doc = "Field `PGEB6` reader - Pattern Generator 6 Output Enable Buffer"]
pub type PGEB6_R = crate :: BitReader < bool > ; # [doc = "Field `PGEB6` writer - Pattern Generator 6 Output Enable Buffer"]
pub type PGEB6_W < 'a > = crate :: BitWriter < 'a , u16 , PATTB_SPEC , bool , 6 > ; # [doc = "Field `PGEB7` reader - Pattern Generator 7 Output Enable Buffer"]
pub type PGEB7_R = crate :: BitReader < bool > ; # [doc = "Field `PGEB7` writer - Pattern Generator 7 Output Enable Buffer"]
pub type PGEB7_W < 'a > = crate :: BitWriter < 'a , u16 , PATTB_SPEC , bool , 7 > ; # [doc = "Field `PGVB0` reader - Pattern Generator 0 Output Enable"]
pub type PGVB0_R = crate :: BitReader < bool > ; # [doc = "Field `PGVB0` writer - Pattern Generator 0 Output Enable"]
pub type PGVB0_W < 'a > = crate :: BitWriter < 'a , u16 , PATTB_SPEC , bool , 8 > ; # [doc = "Field `PGVB1` reader - Pattern Generator 1 Output Enable"]
pub type PGVB1_R = crate :: BitReader < bool > ; # [doc = "Field `PGVB1` writer - Pattern Generator 1 Output Enable"]
pub type PGVB1_W < 'a > = crate :: BitWriter < 'a , u16 , PATTB_SPEC , bool , 9 > ; # [doc = "Field `PGVB2` reader - Pattern Generator 2 Output Enable"]
pub type PGVB2_R = crate :: BitReader < bool > ; # [doc = "Field `PGVB2` writer - Pattern Generator 2 Output Enable"]
pub type PGVB2_W < 'a > = crate :: BitWriter < 'a , u16 , PATTB_SPEC , bool , 10 > ; # [doc = "Field `PGVB3` reader - Pattern Generator 3 Output Enable"]
pub type PGVB3_R = crate :: BitReader < bool > ; # [doc = "Field `PGVB3` writer - Pattern Generator 3 Output Enable"]
pub type PGVB3_W < 'a > = crate :: BitWriter < 'a , u16 , PATTB_SPEC , bool , 11 > ; # [doc = "Field `PGVB4` reader - Pattern Generator 4 Output Enable"]
pub type PGVB4_R = crate :: BitReader < bool > ; # [doc = "Field `PGVB4` writer - Pattern Generator 4 Output Enable"]
pub type PGVB4_W < 'a > = crate :: BitWriter < 'a , u16 , PATTB_SPEC , bool , 12 > ; # [doc = "Field `PGVB5` reader - Pattern Generator 5 Output Enable"]
pub type PGVB5_R = crate :: BitReader < bool > ; # [doc = "Field `PGVB5` writer - Pattern Generator 5 Output Enable"]
pub type PGVB5_W < 'a > = crate :: BitWriter < 'a , u16 , PATTB_SPEC , bool , 13 > ; # [doc = "Field `PGVB6` reader - Pattern Generator 6 Output Enable"]
pub type PGVB6_R = crate :: BitReader < bool > ; # [doc = "Field `PGVB6` writer - Pattern Generator 6 Output Enable"]
pub type PGVB6_W < 'a > = crate :: BitWriter < 'a , u16 , PATTB_SPEC , bool , 14 > ; # [doc = "Field `PGVB7` reader - Pattern Generator 7 Output Enable"]
pub type PGVB7_R = crate :: BitReader < bool > ; # [doc = "Field `PGVB7` writer - Pattern Generator 7 Output Enable"]
pub type PGVB7_W < 'a > = crate :: BitWriter < 'a , u16 , PATTB_SPEC , bool , 15 > ; impl R { # [doc = "Bit 0 - Pattern Generator 0 Output Enable Buffer"]
# [inline (always)]
pub fn pgeb0 (& self) -> PGEB0_R { PGEB0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pattern Generator 1 Output Enable Buffer"]
# [inline (always)]
pub fn pgeb1 (& self) -> PGEB1_R { PGEB1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pattern Generator 2 Output Enable Buffer"]
# [inline (always)]
pub fn pgeb2 (& self) -> PGEB2_R { PGEB2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pattern Generator 3 Output Enable Buffer"]
# [inline (always)]
pub fn pgeb3 (& self) -> PGEB3_R { PGEB3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pattern Generator 4 Output Enable Buffer"]
# [inline (always)]
pub fn pgeb4 (& self) -> PGEB4_R { PGEB4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pattern Generator 5 Output Enable Buffer"]
# [inline (always)]
pub fn pgeb5 (& self) -> PGEB5_R { PGEB5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pattern Generator 6 Output Enable Buffer"]
# [inline (always)]
pub fn pgeb6 (& self) -> PGEB6_R { PGEB6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pattern Generator 7 Output Enable Buffer"]
# [inline (always)]
pub fn pgeb7 (& self) -> PGEB7_R { PGEB7_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Pattern Generator 0 Output Enable"]
# [inline (always)]
pub fn pgvb0 (& self) -> PGVB0_R { PGVB0_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Pattern Generator 1 Output Enable"]
# [inline (always)]
pub fn pgvb1 (& self) -> PGVB1_R { PGVB1_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Pattern Generator 2 Output Enable"]
# [inline (always)]
pub fn pgvb2 (& self) -> PGVB2_R { PGVB2_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Pattern Generator 3 Output Enable"]
# [inline (always)]
pub fn pgvb3 (& self) -> PGVB3_R { PGVB3_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Pattern Generator 4 Output Enable"]
# [inline (always)]
pub fn pgvb4 (& self) -> PGVB4_R { PGVB4_R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Pattern Generator 5 Output Enable"]
# [inline (always)]
pub fn pgvb5 (& self) -> PGVB5_R { PGVB5_R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Pattern Generator 6 Output Enable"]
# [inline (always)]
pub fn pgvb6 (& self) -> PGVB6_R { PGVB6_R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Pattern Generator 7 Output Enable"]
# [inline (always)]
pub fn pgvb7 (& self) -> PGVB7_R { PGVB7_R :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bit 0 - Pattern Generator 0 Output Enable Buffer"]
# [inline (always)]
pub fn pgeb0 (& mut self) -> PGEB0_W { PGEB0_W :: new (self) } # [doc = "Bit 1 - Pattern Generator 1 Output Enable Buffer"]
# [inline (always)]
pub fn pgeb1 (& mut self) -> PGEB1_W { PGEB1_W :: new (self) } # [doc = "Bit 2 - Pattern Generator 2 Output Enable Buffer"]
# [inline (always)]
pub fn pgeb2 (& mut self) -> PGEB2_W { PGEB2_W :: new (self) } # [doc = "Bit 3 - Pattern Generator 3 Output Enable Buffer"]
# [inline (always)]
pub fn pgeb3 (& mut self) -> PGEB3_W { PGEB3_W :: new (self) } # [doc = "Bit 4 - Pattern Generator 4 Output Enable Buffer"]
# [inline (always)]
pub fn pgeb4 (& mut self) -> PGEB4_W { PGEB4_W :: new (self) } # [doc = "Bit 5 - Pattern Generator 5 Output Enable Buffer"]
# [inline (always)]
pub fn pgeb5 (& mut self) -> PGEB5_W { PGEB5_W :: new (self) } # [doc = "Bit 6 - Pattern Generator 6 Output Enable Buffer"]
# [inline (always)]
pub fn pgeb6 (& mut self) -> PGEB6_W { PGEB6_W :: new (self) } # [doc = "Bit 7 - Pattern Generator 7 Output Enable Buffer"]
# [inline (always)]
pub fn pgeb7 (& mut self) -> PGEB7_W { PGEB7_W :: new (self) } # [doc = "Bit 8 - Pattern Generator 0 Output Enable"]
# [inline (always)]
pub fn pgvb0 (& mut self) -> PGVB0_W { PGVB0_W :: new (self) } # [doc = "Bit 9 - Pattern Generator 1 Output Enable"]
# [inline (always)]
pub fn pgvb1 (& mut self) -> PGVB1_W { PGVB1_W :: new (self) } # [doc = "Bit 10 - Pattern Generator 2 Output Enable"]
# [inline (always)]
pub fn pgvb2 (& mut self) -> PGVB2_W { PGVB2_W :: new (self) } # [doc = "Bit 11 - Pattern Generator 3 Output Enable"]
# [inline (always)]
pub fn pgvb3 (& mut self) -> PGVB3_W { PGVB3_W :: new (self) } # [doc = "Bit 12 - Pattern Generator 4 Output Enable"]
# [inline (always)]
pub fn pgvb4 (& mut self) -> PGVB4_W { PGVB4_W :: new (self) } # [doc = "Bit 13 - Pattern Generator 5 Output Enable"]
# [inline (always)]
pub fn pgvb5 (& mut self) -> PGVB5_W { PGVB5_W :: new (self) } # [doc = "Bit 14 - Pattern Generator 6 Output Enable"]
# [inline (always)]
pub fn pgvb6 (& mut self) -> PGVB6_W { PGVB6_W :: new (self) } # [doc = "Bit 15 - Pattern Generator 7 Output Enable"]
# [inline (always)]
pub fn pgvb7 (& mut self) -> PGVB7_W { PGVB7_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Pattern Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pattb](index.html) module"]
pub struct PATTB_SPEC ; impl crate :: RegisterSpec for PATTB_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [pattb::R](R) reader structure"]
impl crate :: Readable for PATTB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pattb::W](W) writer structure"]
impl crate :: Writable for PATTB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PATTB to value 0"]
impl crate :: Resettable for PATTB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "WAVEB register accessor: an alias for `Reg<WAVEB_SPEC>`"]
pub type WAVEB = crate :: Reg < waveb :: WAVEB_SPEC > ; # [doc = "Waveform Control Buffer"]
pub mod waveb { # [doc = "Register `WAVEB` reader"]
pub struct R (crate :: R < WAVEB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < WAVEB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < WAVEB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < WAVEB_SPEC >) -> Self { R (reader) } } # [doc = "Register `WAVEB` writer"]
pub struct W (crate :: W < WAVEB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < WAVEB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < WAVEB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < WAVEB_SPEC >) -> Self { W (writer) } } # [doc = "Waveform Generation Buffer\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum WAVEGENB_A { # [doc = "0: Normal frequency"]
NFRQ = 0 , # [doc = "1: Match frequency"]
MFRQ = 1 , # [doc = "2: Normal PWM"]
NPWM = 2 , # [doc = "4: Dual-slope critical"]
DSCRITICAL = 4 , # [doc = "5: Dual-slope with interrupt/event condition when COUNT reaches ZERO"]
DSBOTTOM = 5 , # [doc = "6: Dual-slope with interrupt/event condition when COUNT reaches ZERO or TOP"]
DSBOTH = 6 , # [doc = "7: Dual-slope with interrupt/event condition when COUNT reaches TOP"]
DSTOP = 7 , } impl From < WAVEGENB_A > for u8 { # [inline (always)]
fn from (variant : WAVEGENB_A) -> Self { variant as _ } } # [doc = "Field `WAVEGENB` reader - Waveform Generation Buffer"]
pub type WAVEGENB_R = crate :: FieldReader < u8 , WAVEGENB_A > ; impl WAVEGENB_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WAVEGENB_A > { match self . bits { 0 => Some (WAVEGENB_A :: NFRQ) , 1 => Some (WAVEGENB_A :: MFRQ) , 2 => Some (WAVEGENB_A :: NPWM) , 4 => Some (WAVEGENB_A :: DSCRITICAL) , 5 => Some (WAVEGENB_A :: DSBOTTOM) , 6 => Some (WAVEGENB_A :: DSBOTH) , 7 => Some (WAVEGENB_A :: DSTOP) , _ => None , } } # [doc = "Checks if the value of the field is `NFRQ`"]
# [inline (always)]
pub fn is_nfrq (& self) -> bool { * self == WAVEGENB_A :: NFRQ } # [doc = "Checks if the value of the field is `MFRQ`"]
# [inline (always)]
pub fn is_mfrq (& self) -> bool { * self == WAVEGENB_A :: MFRQ } # [doc = "Checks if the value of the field is `NPWM`"]
# [inline (always)]
pub fn is_npwm (& self) -> bool { * self == WAVEGENB_A :: NPWM } # [doc = "Checks if the value of the field is `DSCRITICAL`"]
# [inline (always)]
pub fn is_dscritical (& self) -> bool { * self == WAVEGENB_A :: DSCRITICAL } # [doc = "Checks if the value of the field is `DSBOTTOM`"]
# [inline (always)]
pub fn is_dsbottom (& self) -> bool { * self == WAVEGENB_A :: DSBOTTOM } # [doc = "Checks if the value of the field is `DSBOTH`"]
# [inline (always)]
pub fn is_dsboth (& self) -> bool { * self == WAVEGENB_A :: DSBOTH } # [doc = "Checks if the value of the field is `DSTOP`"]
# [inline (always)]
pub fn is_dstop (& self) -> bool { * self == WAVEGENB_A :: DSTOP } } # [doc = "Field `WAVEGENB` writer - Waveform Generation Buffer"]
pub type WAVEGENB_W < 'a > = crate :: FieldWriter < 'a , u32 , WAVEB_SPEC , u8 , WAVEGENB_A , 3 , 0 > ; impl < 'a > WAVEGENB_W < 'a > { # [doc = "Normal frequency"]
# [inline (always)]
pub fn nfrq (self) -> & 'a mut W { self . variant (WAVEGENB_A :: NFRQ) } # [doc = "Match frequency"]
# [inline (always)]
pub fn mfrq (self) -> & 'a mut W { self . variant (WAVEGENB_A :: MFRQ) } # [doc = "Normal PWM"]
# [inline (always)]
pub fn npwm (self) -> & 'a mut W { self . variant (WAVEGENB_A :: NPWM) } # [doc = "Dual-slope critical"]
# [inline (always)]
pub fn dscritical (self) -> & 'a mut W { self . variant (WAVEGENB_A :: DSCRITICAL) } # [doc = "Dual-slope with interrupt/event condition when COUNT reaches ZERO"]
# [inline (always)]
pub fn dsbottom (self) -> & 'a mut W { self . variant (WAVEGENB_A :: DSBOTTOM) } # [doc = "Dual-slope with interrupt/event condition when COUNT reaches ZERO or TOP"]
# [inline (always)]
pub fn dsboth (self) -> & 'a mut W { self . variant (WAVEGENB_A :: DSBOTH) } # [doc = "Dual-slope with interrupt/event condition when COUNT reaches TOP"]
# [inline (always)]
pub fn dstop (self) -> & 'a mut W { self . variant (WAVEGENB_A :: DSTOP) } } # [doc = "Ramp Mode Buffer\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum RAMPB_A { # [doc = "0: RAMP1 operation"]
RAMP1 = 0 , # [doc = "1: Alternative RAMP2 operation"]
RAMP2A = 1 , # [doc = "2: RAMP2 operation"]
RAMP2 = 2 , } impl From < RAMPB_A > for u8 { # [inline (always)]
fn from (variant : RAMPB_A) -> Self { variant as _ } } # [doc = "Field `RAMPB` reader - Ramp Mode Buffer"]
pub type RAMPB_R = crate :: FieldReader < u8 , RAMPB_A > ; impl RAMPB_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < RAMPB_A > { match self . bits { 0 => Some (RAMPB_A :: RAMP1) , 1 => Some (RAMPB_A :: RAMP2A) , 2 => Some (RAMPB_A :: RAMP2) , _ => None , } } # [doc = "Checks if the value of the field is `RAMP1`"]
# [inline (always)]
pub fn is_ramp1 (& self) -> bool { * self == RAMPB_A :: RAMP1 } # [doc = "Checks if the value of the field is `RAMP2A`"]
# [inline (always)]
pub fn is_ramp2a (& self) -> bool { * self == RAMPB_A :: RAMP2A } # [doc = "Checks if the value of the field is `RAMP2`"]
# [inline (always)]
pub fn is_ramp2 (& self) -> bool { * self == RAMPB_A :: RAMP2 } } # [doc = "Field `RAMPB` writer - Ramp Mode Buffer"]
pub type RAMPB_W < 'a > = crate :: FieldWriter < 'a , u32 , WAVEB_SPEC , u8 , RAMPB_A , 2 , 4 > ; impl < 'a > RAMPB_W < 'a > { # [doc = "RAMP1 operation"]
# [inline (always)]
pub fn ramp1 (self) -> & 'a mut W { self . variant (RAMPB_A :: RAMP1) } # [doc = "Alternative RAMP2 operation"]
# [inline (always)]
pub fn ramp2a (self) -> & 'a mut W { self . variant (RAMPB_A :: RAMP2A) } # [doc = "RAMP2 operation"]
# [inline (always)]
pub fn ramp2 (self) -> & 'a mut W { self . variant (RAMPB_A :: RAMP2) } } # [doc = "Field `CIPERENB` reader - Circular Period Enable Buffer"]
pub type CIPERENB_R = crate :: BitReader < bool > ; # [doc = "Field `CIPERENB` writer - Circular Period Enable Buffer"]
pub type CIPERENB_W < 'a > = crate :: BitWriter < 'a , u32 , WAVEB_SPEC , bool , 7 > ; # [doc = "Field `CICCENB0` reader - Circular Channel 0 Enable Buffer"]
pub type CICCENB0_R = crate :: BitReader < bool > ; # [doc = "Field `CICCENB0` writer - Circular Channel 0 Enable Buffer"]
pub type CICCENB0_W < 'a > = crate :: BitWriter < 'a , u32 , WAVEB_SPEC , bool , 8 > ; # [doc = "Field `CICCENB1` reader - Circular Channel 1 Enable Buffer"]
pub type CICCENB1_R = crate :: BitReader < bool > ; # [doc = "Field `CICCENB1` writer - Circular Channel 1 Enable Buffer"]
pub type CICCENB1_W < 'a > = crate :: BitWriter < 'a , u32 , WAVEB_SPEC , bool , 9 > ; # [doc = "Field `CICCENB2` reader - Circular Channel 2 Enable Buffer"]
pub type CICCENB2_R = crate :: BitReader < bool > ; # [doc = "Field `CICCENB2` writer - Circular Channel 2 Enable Buffer"]
pub type CICCENB2_W < 'a > = crate :: BitWriter < 'a , u32 , WAVEB_SPEC , bool , 10 > ; # [doc = "Field `CICCENB3` reader - Circular Channel 3 Enable Buffer"]
pub type CICCENB3_R = crate :: BitReader < bool > ; # [doc = "Field `CICCENB3` writer - Circular Channel 3 Enable Buffer"]
pub type CICCENB3_W < 'a > = crate :: BitWriter < 'a , u32 , WAVEB_SPEC , bool , 11 > ; # [doc = "Field `POLB0` reader - Channel 0 Polarity Buffer"]
pub type POLB0_R = crate :: BitReader < bool > ; # [doc = "Field `POLB0` writer - Channel 0 Polarity Buffer"]
pub type POLB0_W < 'a > = crate :: BitWriter < 'a , u32 , WAVEB_SPEC , bool , 16 > ; # [doc = "Field `POLB1` reader - Channel 1 Polarity Buffer"]
pub type POLB1_R = crate :: BitReader < bool > ; # [doc = "Field `POLB1` writer - Channel 1 Polarity Buffer"]
pub type POLB1_W < 'a > = crate :: BitWriter < 'a , u32 , WAVEB_SPEC , bool , 17 > ; # [doc = "Field `POLB2` reader - Channel 2 Polarity Buffer"]
pub type POLB2_R = crate :: BitReader < bool > ; # [doc = "Field `POLB2` writer - Channel 2 Polarity Buffer"]
pub type POLB2_W < 'a > = crate :: BitWriter < 'a , u32 , WAVEB_SPEC , bool , 18 > ; # [doc = "Field `POLB3` reader - Channel 3 Polarity Buffer"]
pub type POLB3_R = crate :: BitReader < bool > ; # [doc = "Field `POLB3` writer - Channel 3 Polarity Buffer"]
pub type POLB3_W < 'a > = crate :: BitWriter < 'a , u32 , WAVEB_SPEC , bool , 19 > ; # [doc = "Field `SWAPB0` reader - Swap DTI Output Pair 0 Buffer"]
pub type SWAPB0_R = crate :: BitReader < bool > ; # [doc = "Field `SWAPB0` writer - Swap DTI Output Pair 0 Buffer"]
pub type SWAPB0_W < 'a > = crate :: BitWriter < 'a , u32 , WAVEB_SPEC , bool , 24 > ; # [doc = "Field `SWAPB1` reader - Swap DTI Output Pair 1 Buffer"]
pub type SWAPB1_R = crate :: BitReader < bool > ; # [doc = "Field `SWAPB1` writer - Swap DTI Output Pair 1 Buffer"]
pub type SWAPB1_W < 'a > = crate :: BitWriter < 'a , u32 , WAVEB_SPEC , bool , 25 > ; # [doc = "Field `SWAPB2` reader - Swap DTI Output Pair 2 Buffer"]
pub type SWAPB2_R = crate :: BitReader < bool > ; # [doc = "Field `SWAPB2` writer - Swap DTI Output Pair 2 Buffer"]
pub type SWAPB2_W < 'a > = crate :: BitWriter < 'a , u32 , WAVEB_SPEC , bool , 26 > ; # [doc = "Field `SWAPB3` reader - Swap DTI Output Pair 3 Buffer"]
pub type SWAPB3_R = crate :: BitReader < bool > ; # [doc = "Field `SWAPB3` writer - Swap DTI Output Pair 3 Buffer"]
pub type SWAPB3_W < 'a > = crate :: BitWriter < 'a , u32 , WAVEB_SPEC , bool , 27 > ; impl R { # [doc = "Bits 0:2 - Waveform Generation Buffer"]
# [inline (always)]
pub fn wavegenb (& self) -> WAVEGENB_R { WAVEGENB_R :: new ((self . bits & 7) as u8) } # [doc = "Bits 4:5 - Ramp Mode Buffer"]
# [inline (always)]
pub fn rampb (& self) -> RAMPB_R { RAMPB_R :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bit 7 - Circular Period Enable Buffer"]
# [inline (always)]
pub fn ciperenb (& self) -> CIPERENB_R { CIPERENB_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Circular Channel 0 Enable Buffer"]
# [inline (always)]
pub fn ciccenb0 (& self) -> CICCENB0_R { CICCENB0_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Circular Channel 1 Enable Buffer"]
# [inline (always)]
pub fn ciccenb1 (& self) -> CICCENB1_R { CICCENB1_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Circular Channel 2 Enable Buffer"]
# [inline (always)]
pub fn ciccenb2 (& self) -> CICCENB2_R { CICCENB2_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Circular Channel 3 Enable Buffer"]
# [inline (always)]
pub fn ciccenb3 (& self) -> CICCENB3_R { CICCENB3_R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 16 - Channel 0 Polarity Buffer"]
# [inline (always)]
pub fn polb0 (& self) -> POLB0_R { POLB0_R :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Channel 1 Polarity Buffer"]
# [inline (always)]
pub fn polb1 (& self) -> POLB1_R { POLB1_R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Channel 2 Polarity Buffer"]
# [inline (always)]
pub fn polb2 (& self) -> POLB2_R { POLB2_R :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Channel 3 Polarity Buffer"]
# [inline (always)]
pub fn polb3 (& self) -> POLB3_R { POLB3_R :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 24 - Swap DTI Output Pair 0 Buffer"]
# [inline (always)]
pub fn swapb0 (& self) -> SWAPB0_R { SWAPB0_R :: new (((self . bits >> 24) & 1) != 0) } # [doc = "Bit 25 - Swap DTI Output Pair 1 Buffer"]
# [inline (always)]
pub fn swapb1 (& self) -> SWAPB1_R { SWAPB1_R :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - Swap DTI Output Pair 2 Buffer"]
# [inline (always)]
pub fn swapb2 (& self) -> SWAPB2_R { SWAPB2_R :: new (((self . bits >> 26) & 1) != 0) } # [doc = "Bit 27 - Swap DTI Output Pair 3 Buffer"]
# [inline (always)]
pub fn swapb3 (& self) -> SWAPB3_R { SWAPB3_R :: new (((self . bits >> 27) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Waveform Generation Buffer"]
# [inline (always)]
pub fn wavegenb (& mut self) -> WAVEGENB_W { WAVEGENB_W :: new (self) } # [doc = "Bits 4:5 - Ramp Mode Buffer"]
# [inline (always)]
pub fn rampb (& mut self) -> RAMPB_W { RAMPB_W :: new (self) } # [doc = "Bit 7 - Circular Period Enable Buffer"]
# [inline (always)]
pub fn ciperenb (& mut self) -> CIPERENB_W { CIPERENB_W :: new (self) } # [doc = "Bit 8 - Circular Channel 0 Enable Buffer"]
# [inline (always)]
pub fn ciccenb0 (& mut self) -> CICCENB0_W { CICCENB0_W :: new (self) } # [doc = "Bit 9 - Circular Channel 1 Enable Buffer"]
# [inline (always)]
pub fn ciccenb1 (& mut self) -> CICCENB1_W { CICCENB1_W :: new (self) } # [doc = "Bit 10 - Circular Channel 2 Enable Buffer"]
# [inline (always)]
pub fn ciccenb2 (& mut self) -> CICCENB2_W { CICCENB2_W :: new (self) } # [doc = "Bit 11 - Circular Channel 3 Enable Buffer"]
# [inline (always)]
pub fn ciccenb3 (& mut self) -> CICCENB3_W { CICCENB3_W :: new (self) } # [doc = "Bit 16 - Channel 0 Polarity Buffer"]
# [inline (always)]
pub fn polb0 (& mut self) -> POLB0_W { POLB0_W :: new (self) } # [doc = "Bit 17 - Channel 1 Polarity Buffer"]
# [inline (always)]
pub fn polb1 (& mut self) -> POLB1_W { POLB1_W :: new (self) } # [doc = "Bit 18 - Channel 2 Polarity Buffer"]
# [inline (always)]
pub fn polb2 (& mut self) -> POLB2_W { POLB2_W :: new (self) } # [doc = "Bit 19 - Channel 3 Polarity Buffer"]
# [inline (always)]
pub fn polb3 (& mut self) -> POLB3_W { POLB3_W :: new (self) } # [doc = "Bit 24 - Swap DTI Output Pair 0 Buffer"]
# [inline (always)]
pub fn swapb0 (& mut self) -> SWAPB0_W { SWAPB0_W :: new (self) } # [doc = "Bit 25 - Swap DTI Output Pair 1 Buffer"]
# [inline (always)]
pub fn swapb1 (& mut self) -> SWAPB1_W { SWAPB1_W :: new (self) } # [doc = "Bit 26 - Swap DTI Output Pair 2 Buffer"]
# [inline (always)]
pub fn swapb2 (& mut self) -> SWAPB2_W { SWAPB2_W :: new (self) } # [doc = "Bit 27 - Swap DTI Output Pair 3 Buffer"]
# [inline (always)]
pub fn swapb3 (& mut self) -> SWAPB3_W { SWAPB3_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Waveform Control Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [waveb](index.html) module"]
pub struct WAVEB_SPEC ; impl crate :: RegisterSpec for WAVEB_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [waveb::R](R) reader structure"]
impl crate :: Readable for WAVEB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [waveb::W](W) writer structure"]
impl crate :: Writable for WAVEB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets WAVEB to value 0"]
impl crate :: Resettable for WAVEB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PERB register accessor: an alias for `Reg<PERB_SPEC>`"]
pub type PERB = crate :: Reg < perb :: PERB_SPEC > ; # [doc = "Period Buffer"]
pub mod perb { # [doc = "Register `PERB` reader"]
pub struct R (crate :: R < PERB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PERB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PERB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PERB_SPEC >) -> Self { R (reader) } } # [doc = "Register `PERB` writer"]
pub struct W (crate :: W < PERB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PERB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PERB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PERB_SPEC >) -> Self { W (writer) } } # [doc = "Field `PERB` reader - Period Buffer Value"]
pub type PERB_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `PERB` writer - Period Buffer Value"]
pub type PERB_W < 'a > = crate :: FieldWriter < 'a , u32 , PERB_SPEC , u32 , u32 , 24 , 0 > ; impl R { # [doc = "Bits 0:23 - Period Buffer Value"]
# [inline (always)]
pub fn perb (& self) -> PERB_R { PERB_R :: new ((self . bits & 0x00ff_ffff) as u32) } } impl W { # [doc = "Bits 0:23 - Period Buffer Value"]
# [inline (always)]
pub fn perb (& mut self) -> PERB_W { PERB_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Period Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [perb](index.html) module"]
pub struct PERB_SPEC ; impl crate :: RegisterSpec for PERB_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [perb::R](R) reader structure"]
impl crate :: Readable for PERB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [perb::W](W) writer structure"]
impl crate :: Writable for PERB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PERB to value 0xffff_ffff"]
impl crate :: Resettable for PERB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0xffff_ffff } } } # [doc = "PERB_DITH4 register accessor: an alias for `Reg<PERB_DITH4_SPEC>`"]
pub type PERB_DITH4 = crate :: Reg < perb_dith4 :: PERB_DITH4_SPEC > ; # [doc = "Period Buffer"]
pub mod perb_dith4 { # [doc = "Register `PERB_DITH4` reader"]
pub struct R (crate :: R < PERB_DITH4_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PERB_DITH4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PERB_DITH4_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PERB_DITH4_SPEC >) -> Self { R (reader) } } # [doc = "Register `PERB_DITH4` writer"]
pub struct W (crate :: W < PERB_DITH4_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PERB_DITH4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PERB_DITH4_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PERB_DITH4_SPEC >) -> Self { W (writer) } } # [doc = "Field `DITHERCYB` reader - Dithering Buffer Cycle Number"]
pub type DITHERCYB_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DITHERCYB` writer - Dithering Buffer Cycle Number"]
pub type DITHERCYB_W < 'a > = crate :: FieldWriter < 'a , u32 , PERB_DITH4_SPEC , u8 , u8 , 4 , 0 > ; # [doc = "Field `PERB` reader - Period Buffer Value"]
pub type PERB_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `PERB` writer - Period Buffer Value"]
pub type PERB_W < 'a > = crate :: FieldWriter < 'a , u32 , PERB_DITH4_SPEC , u32 , u32 , 20 , 4 > ; impl R { # [doc = "Bits 0:3 - Dithering Buffer Cycle Number"]
# [inline (always)]
pub fn dithercyb (& self) -> DITHERCYB_R { DITHERCYB_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bits 4:23 - Period Buffer Value"]
# [inline (always)]
pub fn perb (& self) -> PERB_R { PERB_R :: new (((self . bits >> 4) & 0x000f_ffff) as u32) } } impl W { # [doc = "Bits 0:3 - Dithering Buffer Cycle Number"]
# [inline (always)]
pub fn dithercyb (& mut self) -> DITHERCYB_W { DITHERCYB_W :: new (self) } # [doc = "Bits 4:23 - Period Buffer Value"]
# [inline (always)]
pub fn perb (& mut self) -> PERB_W { PERB_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Period Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [perb_dith4](index.html) module"]
pub struct PERB_DITH4_SPEC ; impl crate :: RegisterSpec for PERB_DITH4_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [perb_dith4::R](R) reader structure"]
impl crate :: Readable for PERB_DITH4_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [perb_dith4::W](W) writer structure"]
impl crate :: Writable for PERB_DITH4_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PERB_DITH4 to value 0xffff_ffff"]
impl crate :: Resettable for PERB_DITH4_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0xffff_ffff } } } # [doc = "PERB_DITH5 register accessor: an alias for `Reg<PERB_DITH5_SPEC>`"]
pub type PERB_DITH5 = crate :: Reg < perb_dith5 :: PERB_DITH5_SPEC > ; # [doc = "Period Buffer"]
pub mod perb_dith5 { # [doc = "Register `PERB_DITH5` reader"]
pub struct R (crate :: R < PERB_DITH5_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PERB_DITH5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PERB_DITH5_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PERB_DITH5_SPEC >) -> Self { R (reader) } } # [doc = "Register `PERB_DITH5` writer"]
pub struct W (crate :: W < PERB_DITH5_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PERB_DITH5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PERB_DITH5_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PERB_DITH5_SPEC >) -> Self { W (writer) } } # [doc = "Field `DITHERCYB` reader - Dithering Buffer Cycle Number"]
pub type DITHERCYB_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DITHERCYB` writer - Dithering Buffer Cycle Number"]
pub type DITHERCYB_W < 'a > = crate :: FieldWriter < 'a , u32 , PERB_DITH5_SPEC , u8 , u8 , 5 , 0 > ; # [doc = "Field `PERB` reader - Period Buffer Value"]
pub type PERB_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `PERB` writer - Period Buffer Value"]
pub type PERB_W < 'a > = crate :: FieldWriter < 'a , u32 , PERB_DITH5_SPEC , u32 , u32 , 19 , 5 > ; impl R { # [doc = "Bits 0:4 - Dithering Buffer Cycle Number"]
# [inline (always)]
pub fn dithercyb (& self) -> DITHERCYB_R { DITHERCYB_R :: new ((self . bits & 0x1f) as u8) } # [doc = "Bits 5:23 - Period Buffer Value"]
# [inline (always)]
pub fn perb (& self) -> PERB_R { PERB_R :: new (((self . bits >> 5) & 0x0007_ffff) as u32) } } impl W { # [doc = "Bits 0:4 - Dithering Buffer Cycle Number"]
# [inline (always)]
pub fn dithercyb (& mut self) -> DITHERCYB_W { DITHERCYB_W :: new (self) } # [doc = "Bits 5:23 - Period Buffer Value"]
# [inline (always)]
pub fn perb (& mut self) -> PERB_W { PERB_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Period Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [perb_dith5](index.html) module"]
pub struct PERB_DITH5_SPEC ; impl crate :: RegisterSpec for PERB_DITH5_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [perb_dith5::R](R) reader structure"]
impl crate :: Readable for PERB_DITH5_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [perb_dith5::W](W) writer structure"]
impl crate :: Writable for PERB_DITH5_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PERB_DITH5 to value 0xffff_ffff"]
impl crate :: Resettable for PERB_DITH5_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0xffff_ffff } } } # [doc = "PERB_DITH6 register accessor: an alias for `Reg<PERB_DITH6_SPEC>`"]
pub type PERB_DITH6 = crate :: Reg < perb_dith6 :: PERB_DITH6_SPEC > ; # [doc = "Period Buffer"]
pub mod perb_dith6 { # [doc = "Register `PERB_DITH6` reader"]
pub struct R (crate :: R < PERB_DITH6_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PERB_DITH6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PERB_DITH6_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PERB_DITH6_SPEC >) -> Self { R (reader) } } # [doc = "Register `PERB_DITH6` writer"]
pub struct W (crate :: W < PERB_DITH6_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PERB_DITH6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PERB_DITH6_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PERB_DITH6_SPEC >) -> Self { W (writer) } } # [doc = "Field `DITHERCYB` reader - Dithering Buffer Cycle Number"]
pub type DITHERCYB_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DITHERCYB` writer - Dithering Buffer Cycle Number"]
pub type DITHERCYB_W < 'a > = crate :: FieldWriter < 'a , u32 , PERB_DITH6_SPEC , u8 , u8 , 6 , 0 > ; # [doc = "Field `PERB` reader - Period Buffer Value"]
pub type PERB_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `PERB` writer - Period Buffer Value"]
pub type PERB_W < 'a > = crate :: FieldWriter < 'a , u32 , PERB_DITH6_SPEC , u32 , u32 , 18 , 6 > ; impl R { # [doc = "Bits 0:5 - Dithering Buffer Cycle Number"]
# [inline (always)]
pub fn dithercyb (& self) -> DITHERCYB_R { DITHERCYB_R :: new ((self . bits & 0x3f) as u8) } # [doc = "Bits 6:23 - Period Buffer Value"]
# [inline (always)]
pub fn perb (& self) -> PERB_R { PERB_R :: new (((self . bits >> 6) & 0x0003_ffff) as u32) } } impl W { # [doc = "Bits 0:5 - Dithering Buffer Cycle Number"]
# [inline (always)]
pub fn dithercyb (& mut self) -> DITHERCYB_W { DITHERCYB_W :: new (self) } # [doc = "Bits 6:23 - Period Buffer Value"]
# [inline (always)]
pub fn perb (& mut self) -> PERB_W { PERB_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Period Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [perb_dith6](index.html) module"]
pub struct PERB_DITH6_SPEC ; impl crate :: RegisterSpec for PERB_DITH6_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [perb_dith6::R](R) reader structure"]
impl crate :: Readable for PERB_DITH6_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [perb_dith6::W](W) writer structure"]
impl crate :: Writable for PERB_DITH6_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PERB_DITH6 to value 0xffff_ffff"]
impl crate :: Resettable for PERB_DITH6_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0xffff_ffff } } } # [doc = "CCB register accessor: an alias for `Reg<CCB_SPEC>`"]
pub type CCB = crate :: Reg < ccb :: CCB_SPEC > ; # [doc = "Compare and Capture Buffer"]
pub mod ccb { # [doc = "Register `CCB%s` reader"]
pub struct R (crate :: R < CCB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCB%s` writer"]
pub struct W (crate :: W < CCB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCB_SPEC >) -> Self { W (writer) } } # [doc = "Field `CCB` reader - Channel Compare/Capture Buffer Value"]
pub type CCB_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `CCB` writer - Channel Compare/Capture Buffer Value"]
pub type CCB_W < 'a > = crate :: FieldWriter < 'a , u32 , CCB_SPEC , u32 , u32 , 24 , 0 > ; impl R { # [doc = "Bits 0:23 - Channel Compare/Capture Buffer Value"]
# [inline (always)]
pub fn ccb (& self) -> CCB_R { CCB_R :: new ((self . bits & 0x00ff_ffff) as u32) } } impl W { # [doc = "Bits 0:23 - Channel Compare/Capture Buffer Value"]
# [inline (always)]
pub fn ccb (& mut self) -> CCB_W { CCB_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Compare and Capture Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccb](index.html) module"]
pub struct CCB_SPEC ; impl crate :: RegisterSpec for CCB_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ccb::R](R) reader structure"]
impl crate :: Readable for CCB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccb::W](W) writer structure"]
impl crate :: Writable for CCB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CCB%s to value 0"]
impl crate :: Resettable for CCB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CCB_DITH4 register accessor: an alias for `Reg<CCB_DITH4_SPEC>`"]
pub type CCB_DITH4 = crate :: Reg < ccb_dith4 :: CCB_DITH4_SPEC > ; # [doc = "Compare and Capture Buffer"]
pub mod ccb_dith4 { # [doc = "Register `CCB%s_DITH4` reader"]
pub struct R (crate :: R < CCB_DITH4_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCB_DITH4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCB_DITH4_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCB_DITH4_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCB%s_DITH4` writer"]
pub struct W (crate :: W < CCB_DITH4_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCB_DITH4_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCB_DITH4_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCB_DITH4_SPEC >) -> Self { W (writer) } } # [doc = "Field `DITHERCYB` reader - Dithering Buffer Cycle Number"]
pub type DITHERCYB_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DITHERCYB` writer - Dithering Buffer Cycle Number"]
pub type DITHERCYB_W < 'a > = crate :: FieldWriter < 'a , u32 , CCB_DITH4_SPEC , u8 , u8 , 4 , 0 > ; # [doc = "Field `CCB` reader - Channel Compare/Capture Buffer Value"]
pub type CCB_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `CCB` writer - Channel Compare/Capture Buffer Value"]
pub type CCB_W < 'a > = crate :: FieldWriter < 'a , u32 , CCB_DITH4_SPEC , u32 , u32 , 20 , 4 > ; impl R { # [doc = "Bits 0:3 - Dithering Buffer Cycle Number"]
# [inline (always)]
pub fn dithercyb (& self) -> DITHERCYB_R { DITHERCYB_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bits 4:23 - Channel Compare/Capture Buffer Value"]
# [inline (always)]
pub fn ccb (& self) -> CCB_R { CCB_R :: new (((self . bits >> 4) & 0x000f_ffff) as u32) } } impl W { # [doc = "Bits 0:3 - Dithering Buffer Cycle Number"]
# [inline (always)]
pub fn dithercyb (& mut self) -> DITHERCYB_W { DITHERCYB_W :: new (self) } # [doc = "Bits 4:23 - Channel Compare/Capture Buffer Value"]
# [inline (always)]
pub fn ccb (& mut self) -> CCB_W { CCB_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Compare and Capture Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccb_dith4](index.html) module"]
pub struct CCB_DITH4_SPEC ; impl crate :: RegisterSpec for CCB_DITH4_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ccb_dith4::R](R) reader structure"]
impl crate :: Readable for CCB_DITH4_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccb_dith4::W](W) writer structure"]
impl crate :: Writable for CCB_DITH4_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CCB%s_DITH4 to value 0"]
impl crate :: Resettable for CCB_DITH4_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CCB_DITH5 register accessor: an alias for `Reg<CCB_DITH5_SPEC>`"]
pub type CCB_DITH5 = crate :: Reg < ccb_dith5 :: CCB_DITH5_SPEC > ; # [doc = "Compare and Capture Buffer"]
pub mod ccb_dith5 { # [doc = "Register `CCB%s_DITH5` reader"]
pub struct R (crate :: R < CCB_DITH5_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCB_DITH5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCB_DITH5_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCB_DITH5_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCB%s_DITH5` writer"]
pub struct W (crate :: W < CCB_DITH5_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCB_DITH5_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCB_DITH5_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCB_DITH5_SPEC >) -> Self { W (writer) } } # [doc = "Field `DITHERCYB` reader - Dithering Buffer Cycle Number"]
pub type DITHERCYB_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DITHERCYB` writer - Dithering Buffer Cycle Number"]
pub type DITHERCYB_W < 'a > = crate :: FieldWriter < 'a , u32 , CCB_DITH5_SPEC , u8 , u8 , 5 , 0 > ; # [doc = "Field `CCB` reader - Channel Compare/Capture Buffer Value"]
pub type CCB_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `CCB` writer - Channel Compare/Capture Buffer Value"]
pub type CCB_W < 'a > = crate :: FieldWriter < 'a , u32 , CCB_DITH5_SPEC , u32 , u32 , 19 , 5 > ; impl R { # [doc = "Bits 0:4 - Dithering Buffer Cycle Number"]
# [inline (always)]
pub fn dithercyb (& self) -> DITHERCYB_R { DITHERCYB_R :: new ((self . bits & 0x1f) as u8) } # [doc = "Bits 5:23 - Channel Compare/Capture Buffer Value"]
# [inline (always)]
pub fn ccb (& self) -> CCB_R { CCB_R :: new (((self . bits >> 5) & 0x0007_ffff) as u32) } } impl W { # [doc = "Bits 0:4 - Dithering Buffer Cycle Number"]
# [inline (always)]
pub fn dithercyb (& mut self) -> DITHERCYB_W { DITHERCYB_W :: new (self) } # [doc = "Bits 5:23 - Channel Compare/Capture Buffer Value"]
# [inline (always)]
pub fn ccb (& mut self) -> CCB_W { CCB_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Compare and Capture Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccb_dith5](index.html) module"]
pub struct CCB_DITH5_SPEC ; impl crate :: RegisterSpec for CCB_DITH5_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ccb_dith5::R](R) reader structure"]
impl crate :: Readable for CCB_DITH5_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccb_dith5::W](W) writer structure"]
impl crate :: Writable for CCB_DITH5_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CCB%s_DITH5 to value 0"]
impl crate :: Resettable for CCB_DITH5_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CCB_DITH6 register accessor: an alias for `Reg<CCB_DITH6_SPEC>`"]
pub type CCB_DITH6 = crate :: Reg < ccb_dith6 :: CCB_DITH6_SPEC > ; # [doc = "Compare and Capture Buffer"]
pub mod ccb_dith6 { # [doc = "Register `CCB%s_DITH6` reader"]
pub struct R (crate :: R < CCB_DITH6_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CCB_DITH6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CCB_DITH6_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CCB_DITH6_SPEC >) -> Self { R (reader) } } # [doc = "Register `CCB%s_DITH6` writer"]
pub struct W (crate :: W < CCB_DITH6_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CCB_DITH6_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CCB_DITH6_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CCB_DITH6_SPEC >) -> Self { W (writer) } } # [doc = "Field `DITHERCYB` reader - Dithering Buffer Cycle Number"]
pub type DITHERCYB_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DITHERCYB` writer - Dithering Buffer Cycle Number"]
pub type DITHERCYB_W < 'a > = crate :: FieldWriter < 'a , u32 , CCB_DITH6_SPEC , u8 , u8 , 6 , 0 > ; # [doc = "Field `CCB` reader - Channel Compare/Capture Buffer Value"]
pub type CCB_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `CCB` writer - Channel Compare/Capture Buffer Value"]
pub type CCB_W < 'a > = crate :: FieldWriter < 'a , u32 , CCB_DITH6_SPEC , u32 , u32 , 18 , 6 > ; impl R { # [doc = "Bits 0:5 - Dithering Buffer Cycle Number"]
# [inline (always)]
pub fn dithercyb (& self) -> DITHERCYB_R { DITHERCYB_R :: new ((self . bits & 0x3f) as u8) } # [doc = "Bits 6:23 - Channel Compare/Capture Buffer Value"]
# [inline (always)]
pub fn ccb (& self) -> CCB_R { CCB_R :: new (((self . bits >> 6) & 0x0003_ffff) as u32) } } impl W { # [doc = "Bits 0:5 - Dithering Buffer Cycle Number"]
# [inline (always)]
pub fn dithercyb (& mut self) -> DITHERCYB_W { DITHERCYB_W :: new (self) } # [doc = "Bits 6:23 - Channel Compare/Capture Buffer Value"]
# [inline (always)]
pub fn ccb (& mut self) -> CCB_W { CCB_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Compare and Capture Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccb_dith6](index.html) module"]
pub struct CCB_DITH6_SPEC ; impl crate :: RegisterSpec for CCB_DITH6_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [ccb_dith6::R](R) reader structure"]
impl crate :: Readable for CCB_DITH6_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ccb_dith6::W](W) writer structure"]
impl crate :: Writable for CCB_DITH6_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CCB%s_DITH6 to value 0"]
impl crate :: Resettable for CCB_DITH6_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = "Timer Counter Control 1"]
pub struct TCC1 { _marker : PhantomData < * const () > } unsafe impl Send for TCC1 { } impl TCC1 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tcc0 :: RegisterBlock = 0x4200_2400 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tcc0 :: RegisterBlock { Self :: PTR } } impl Deref for TCC1 { type Target = tcc0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TCC1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TCC1") . finish () } } # [doc = "Timer Counter Control 1"]
pub use tcc0 as tcc1 ; # [doc = "Timer Counter Control 2"]
pub struct TCC2 { _marker : PhantomData < * const () > } unsafe impl Send for TCC2 { } impl TCC2 { # [doc = r"Pointer to the register block"]
pub const PTR : * const tcc0 :: RegisterBlock = 0x4200_2800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tcc0 :: RegisterBlock { Self :: PTR } } impl Deref for TCC2 { type Target = tcc0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TCC2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TCC2") . finish () } } # [doc = "Timer Counter Control 2"]
pub use tcc0 as tcc2 ; # [doc = "Universal Serial Bus"]
pub struct USB { _marker : PhantomData < * const () > } unsafe impl Send for USB { } impl USB { # [doc = r"Pointer to the register block"]
pub const PTR : * const usb :: RegisterBlock = 0x4100_5000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usb :: RegisterBlock { Self :: PTR } } impl Deref for USB { type Target = usb :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for USB { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USB") . finish () } } # [doc = "Universal Serial Bus"]
pub mod usb { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { _reserved_0_host : [u8 ; 0x0111]
, } impl RegisterBlock { # [doc = "0x00..0x111 - USB is Host"]
# [inline (always)]
pub fn host (& self) -> & HOST { unsafe { & * (((self as * const Self) as * const u8) . add (0usize) as * const HOST) } } # [doc = "0x00..0x111 - USB is Device"]
# [inline (always)]
pub fn device (& self) -> & DEVICE { unsafe { & * (((self as * const Self) as * const u8) . add (0usize) as * const DEVICE) } } } # [doc = r"Register block"]
# [repr (C)]
pub struct DEVICE { # [doc = "0x00 - Control A"]
pub ctrla : crate :: Reg < self :: device :: ctrla :: CTRLA_SPEC > , _reserved1 : [u8 ; 0x01]
, # [doc = "0x02 - Synchronization Busy"]
pub syncbusy : crate :: Reg < self :: device :: syncbusy :: SYNCBUSY_SPEC > , # [doc = "0x03 - USB Quality Of Service"]
pub qosctrl : crate :: Reg < self :: device :: qosctrl :: QOSCTRL_SPEC > , _reserved3 : [u8 ; 0x04]
, # [doc = "0x08 - DEVICE Control B"]
pub ctrlb : crate :: Reg < self :: device :: ctrlb :: CTRLB_SPEC > , # [doc = "0x0a - DEVICE Device Address"]
pub dadd : crate :: Reg < self :: device :: dadd :: DADD_SPEC > , _reserved5 : [u8 ; 0x01]
, # [doc = "0x0c - DEVICE Status"]
pub status : crate :: Reg < self :: device :: status :: STATUS_SPEC > , # [doc = "0x0d - Finite State Machine Status"]
pub fsmstatus : crate :: Reg < self :: device :: fsmstatus :: FSMSTATUS_SPEC > , _reserved7 : [u8 ; 0x02]
, # [doc = "0x10 - DEVICE Device Frame Number"]
pub fnum : crate :: Reg < self :: device :: fnum :: FNUM_SPEC > , _reserved8 : [u8 ; 0x02]
, # [doc = "0x14 - DEVICE Device Interrupt Enable Clear"]
pub intenclr : crate :: Reg < self :: device :: intenclr :: INTENCLR_SPEC > , _reserved9 : [u8 ; 0x02]
, # [doc = "0x18 - DEVICE Device Interrupt Enable Set"]
pub intenset : crate :: Reg < self :: device :: intenset :: INTENSET_SPEC > , _reserved10 : [u8 ; 0x02]
, # [doc = "0x1c - DEVICE Device Interrupt Flag"]
pub intflag : crate :: Reg < self :: device :: intflag :: INTFLAG_SPEC > , _reserved11 : [u8 ; 0x02]
, # [doc = "0x20 - DEVICE End Point Interrupt Summary"]
pub epintsmry : crate :: Reg < self :: device :: epintsmry :: EPINTSMRY_SPEC > , _reserved12 : [u8 ; 0x02]
, # [doc = "0x24 - Descriptor Address"]
pub descadd : crate :: Reg < self :: device :: descadd :: DESCADD_SPEC > , # [doc = "0x28 - USB PAD Calibration"]
pub padcal : crate :: Reg < self :: device :: padcal :: PADCAL_SPEC > , _reserved14 : [u8 ; 0xd6]
, # [doc = "0x100 - DEVICE End Point Configuration"]
pub epcfg0 : crate :: Reg < self :: device :: epcfg :: EPCFG_SPEC > , _reserved15 : [u8 ; 0x03]
, # [doc = "0x104 - DEVICE End Point Pipe Status Clear"]
pub epstatusclr0 : crate :: Reg < self :: device :: epstatusclr :: EPSTATUSCLR_SPEC > , # [doc = "0x105 - DEVICE End Point Pipe Status Set"]
pub epstatusset0 : crate :: Reg < self :: device :: epstatusset :: EPSTATUSSET_SPEC > , # [doc = "0x106 - DEVICE End Point Pipe Status"]
pub epstatus0 : crate :: Reg < self :: device :: epstatus :: EPSTATUS_SPEC > , # [doc = "0x107 - DEVICE End Point Interrupt Flag"]
pub epintflag0 : crate :: Reg < self :: device :: epintflag :: EPINTFLAG_SPEC > , # [doc = "0x108 - DEVICE End Point Interrupt Clear Flag"]
pub epintenclr0 : crate :: Reg < self :: device :: epintenclr :: EPINTENCLR_SPEC > , # [doc = "0x109 - DEVICE End Point Interrupt Set Flag"]
pub epintenset0 : crate :: Reg < self :: device :: epintenset :: EPINTENSET_SPEC > , _reserved21 : [u8 ; 0x16]
, # [doc = "0x120 - DEVICE End Point Configuration"]
pub epcfg1 : crate :: Reg < self :: device :: epcfg :: EPCFG_SPEC > , _reserved22 : [u8 ; 0x03]
, # [doc = "0x124 - DEVICE End Point Pipe Status Clear"]
pub epstatusclr1 : crate :: Reg < self :: device :: epstatusclr :: EPSTATUSCLR_SPEC > , # [doc = "0x125 - DEVICE End Point Pipe Status Set"]
pub epstatusset1 : crate :: Reg < self :: device :: epstatusset :: EPSTATUSSET_SPEC > , # [doc = "0x126 - DEVICE End Point Pipe Status"]
pub epstatus1 : crate :: Reg < self :: device :: epstatus :: EPSTATUS_SPEC > , # [doc = "0x127 - DEVICE End Point Interrupt Flag"]
pub epintflag1 : crate :: Reg < self :: device :: epintflag :: EPINTFLAG_SPEC > , # [doc = "0x128 - DEVICE End Point Interrupt Clear Flag"]
pub epintenclr1 : crate :: Reg < self :: device :: epintenclr :: EPINTENCLR_SPEC > , # [doc = "0x129 - DEVICE End Point Interrupt Set Flag"]
pub epintenset1 : crate :: Reg < self :: device :: epintenset :: EPINTENSET_SPEC > , _reserved28 : [u8 ; 0x16]
, # [doc = "0x140 - DEVICE End Point Configuration"]
pub epcfg2 : crate :: Reg < self :: device :: epcfg :: EPCFG_SPEC > , _reserved29 : [u8 ; 0x03]
, # [doc = "0x144 - DEVICE End Point Pipe Status Clear"]
pub epstatusclr2 : crate :: Reg < self :: device :: epstatusclr :: EPSTATUSCLR_SPEC > , # [doc = "0x145 - DEVICE End Point Pipe Status Set"]
pub epstatusset2 : crate :: Reg < self :: device :: epstatusset :: EPSTATUSSET_SPEC > , # [doc = "0x146 - DEVICE End Point Pipe Status"]
pub epstatus2 : crate :: Reg < self :: device :: epstatus :: EPSTATUS_SPEC > , # [doc = "0x147 - DEVICE End Point Interrupt Flag"]
pub epintflag2 : crate :: Reg < self :: device :: epintflag :: EPINTFLAG_SPEC > , # [doc = "0x148 - DEVICE End Point Interrupt Clear Flag"]
pub epintenclr2 : crate :: Reg < self :: device :: epintenclr :: EPINTENCLR_SPEC > , # [doc = "0x149 - DEVICE End Point Interrupt Set Flag"]
pub epintenset2 : crate :: Reg < self :: device :: epintenset :: EPINTENSET_SPEC > , _reserved35 : [u8 ; 0x16]
, # [doc = "0x160 - DEVICE End Point Configuration"]
pub epcfg3 : crate :: Reg < self :: device :: epcfg :: EPCFG_SPEC > , _reserved36 : [u8 ; 0x03]
, # [doc = "0x164 - DEVICE End Point Pipe Status Clear"]
pub epstatusclr3 : crate :: Reg < self :: device :: epstatusclr :: EPSTATUSCLR_SPEC > , # [doc = "0x165 - DEVICE End Point Pipe Status Set"]
pub epstatusset3 : crate :: Reg < self :: device :: epstatusset :: EPSTATUSSET_SPEC > , # [doc = "0x166 - DEVICE End Point Pipe Status"]
pub epstatus3 : crate :: Reg < self :: device :: epstatus :: EPSTATUS_SPEC > , # [doc = "0x167 - DEVICE End Point Interrupt Flag"]
pub epintflag3 : crate :: Reg < self :: device :: epintflag :: EPINTFLAG_SPEC > , # [doc = "0x168 - DEVICE End Point Interrupt Clear Flag"]
pub epintenclr3 : crate :: Reg < self :: device :: epintenclr :: EPINTENCLR_SPEC > , # [doc = "0x169 - DEVICE End Point Interrupt Set Flag"]
pub epintenset3 : crate :: Reg < self :: device :: epintenset :: EPINTENSET_SPEC > , _reserved42 : [u8 ; 0x16]
, # [doc = "0x180 - DEVICE End Point Configuration"]
pub epcfg4 : crate :: Reg < self :: device :: epcfg :: EPCFG_SPEC > , _reserved43 : [u8 ; 0x03]
, # [doc = "0x184 - DEVICE End Point Pipe Status Clear"]
pub epstatusclr4 : crate :: Reg < self :: device :: epstatusclr :: EPSTATUSCLR_SPEC > , # [doc = "0x185 - DEVICE End Point Pipe Status Set"]
pub epstatusset4 : crate :: Reg < self :: device :: epstatusset :: EPSTATUSSET_SPEC > , # [doc = "0x186 - DEVICE End Point Pipe Status"]
pub epstatus4 : crate :: Reg < self :: device :: epstatus :: EPSTATUS_SPEC > , # [doc = "0x187 - DEVICE End Point Interrupt Flag"]
pub epintflag4 : crate :: Reg < self :: device :: epintflag :: EPINTFLAG_SPEC > , # [doc = "0x188 - DEVICE End Point Interrupt Clear Flag"]
pub epintenclr4 : crate :: Reg < self :: device :: epintenclr :: EPINTENCLR_SPEC > , # [doc = "0x189 - DEVICE End Point Interrupt Set Flag"]
pub epintenset4 : crate :: Reg < self :: device :: epintenset :: EPINTENSET_SPEC > , _reserved49 : [u8 ; 0x16]
, # [doc = "0x1a0 - DEVICE End Point Configuration"]
pub epcfg5 : crate :: Reg < self :: device :: epcfg :: EPCFG_SPEC > , _reserved50 : [u8 ; 0x03]
, # [doc = "0x1a4 - DEVICE End Point Pipe Status Clear"]
pub epstatusclr5 : crate :: Reg < self :: device :: epstatusclr :: EPSTATUSCLR_SPEC > , # [doc = "0x1a5 - DEVICE End Point Pipe Status Set"]
pub epstatusset5 : crate :: Reg < self :: device :: epstatusset :: EPSTATUSSET_SPEC > , # [doc = "0x1a6 - DEVICE End Point Pipe Status"]
pub epstatus5 : crate :: Reg < self :: device :: epstatus :: EPSTATUS_SPEC > , # [doc = "0x1a7 - DEVICE End Point Interrupt Flag"]
pub epintflag5 : crate :: Reg < self :: device :: epintflag :: EPINTFLAG_SPEC > , # [doc = "0x1a8 - DEVICE End Point Interrupt Clear Flag"]
pub epintenclr5 : crate :: Reg < self :: device :: epintenclr :: EPINTENCLR_SPEC > , # [doc = "0x1a9 - DEVICE End Point Interrupt Set Flag"]
pub epintenset5 : crate :: Reg < self :: device :: epintenset :: EPINTENSET_SPEC > , _reserved56 : [u8 ; 0x16]
, # [doc = "0x1c0 - DEVICE End Point Configuration"]
pub epcfg6 : crate :: Reg < self :: device :: epcfg :: EPCFG_SPEC > , _reserved57 : [u8 ; 0x03]
, # [doc = "0x1c4 - DEVICE End Point Pipe Status Clear"]
pub epstatusclr6 : crate :: Reg < self :: device :: epstatusclr :: EPSTATUSCLR_SPEC > , # [doc = "0x1c5 - DEVICE End Point Pipe Status Set"]
pub epstatusset6 : crate :: Reg < self :: device :: epstatusset :: EPSTATUSSET_SPEC > , # [doc = "0x1c6 - DEVICE End Point Pipe Status"]
pub epstatus6 : crate :: Reg < self :: device :: epstatus :: EPSTATUS_SPEC > , # [doc = "0x1c7 - DEVICE End Point Interrupt Flag"]
pub epintflag6 : crate :: Reg < self :: device :: epintflag :: EPINTFLAG_SPEC > , # [doc = "0x1c8 - DEVICE End Point Interrupt Clear Flag"]
pub epintenclr6 : crate :: Reg < self :: device :: epintenclr :: EPINTENCLR_SPEC > , # [doc = "0x1c9 - DEVICE End Point Interrupt Set Flag"]
pub epintenset6 : crate :: Reg < self :: device :: epintenset :: EPINTENSET_SPEC > , _reserved63 : [u8 ; 0x16]
, # [doc = "0x1e0 - DEVICE End Point Configuration"]
pub epcfg7 : crate :: Reg < self :: device :: epcfg :: EPCFG_SPEC > , _reserved64 : [u8 ; 0x03]
, # [doc = "0x1e4 - DEVICE End Point Pipe Status Clear"]
pub epstatusclr7 : crate :: Reg < self :: device :: epstatusclr :: EPSTATUSCLR_SPEC > , # [doc = "0x1e5 - DEVICE End Point Pipe Status Set"]
pub epstatusset7 : crate :: Reg < self :: device :: epstatusset :: EPSTATUSSET_SPEC > , # [doc = "0x1e6 - DEVICE End Point Pipe Status"]
pub epstatus7 : crate :: Reg < self :: device :: epstatus :: EPSTATUS_SPEC > , # [doc = "0x1e7 - DEVICE End Point Interrupt Flag"]
pub epintflag7 : crate :: Reg < self :: device :: epintflag :: EPINTFLAG_SPEC > , # [doc = "0x1e8 - DEVICE End Point Interrupt Clear Flag"]
pub epintenclr7 : crate :: Reg < self :: device :: epintenclr :: EPINTENCLR_SPEC > , # [doc = "0x1e9 - DEVICE End Point Interrupt Set Flag"]
pub epintenset7 : crate :: Reg < self :: device :: epintenset :: EPINTENSET_SPEC > , } # [doc = r"Register block"]
# [doc = "USB is Device"]
pub mod device { # [doc = "CTRLA register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWRST` reader - Software Reset"]
pub type SWRST_R = crate :: BitReader < bool > ; # [doc = "Field `SWRST` writer - Software Reset"]
pub type SWRST_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , 0 > ; # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , 1 > ; # [doc = "Field `RUNSTDBY` reader - Run in Standby Mode"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run in Standby Mode"]
pub type RUNSTDBY_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , 2 > ; # [doc = "Operating Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
pub enum MODE_A { # [doc = "0: Device Mode"]
DEVICE = 0 , # [doc = "1: Host Mode"]
HOST = 1 , } impl From < MODE_A > for bool { # [inline (always)]
fn from (variant : MODE_A) -> Self { variant as u8 != 0 } } # [doc = "Field `MODE` reader - Operating Mode"]
pub type MODE_R = crate :: BitReader < MODE_A > ; impl MODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MODE_A { match self . bits { false => MODE_A :: DEVICE , true => MODE_A :: HOST , } } # [doc = "Checks if the value of the field is `DEVICE`"]
# [inline (always)]
pub fn is_device (& self) -> bool { * self == MODE_A :: DEVICE } # [doc = "Checks if the value of the field is `HOST`"]
# [inline (always)]
pub fn is_host (& self) -> bool { * self == MODE_A :: HOST } } # [doc = "Field `MODE` writer - Operating Mode"]
pub type MODE_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , MODE_A , 7 > ; impl < 'a > MODE_W < 'a > { # [doc = "Device Mode"]
# [inline (always)]
pub fn device (self) -> & 'a mut W { self . variant (MODE_A :: DEVICE) } # [doc = "Host Mode"]
# [inline (always)]
pub fn host (self) -> & 'a mut W { self . variant (MODE_A :: HOST) } } impl R { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& self) -> SWRST_R { SWRST_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Run in Standby Mode"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 7 - Operating Mode"]
# [inline (always)]
pub fn mode (& self) -> MODE_R { MODE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& mut self) -> SWRST_W { SWRST_W :: new (self) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Bit 2 - Run in Standby Mode"]
# [inline (always)]
pub fn runstdby (& mut self) -> RUNSTDBY_W { RUNSTDBY_W :: new (self) } # [doc = "Bit 7 - Operating Mode"]
# [inline (always)]
pub fn mode (& mut self) -> MODE_W { MODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYNCBUSY register accessor: an alias for `Reg<SYNCBUSY_SPEC>`"]
pub type SYNCBUSY = crate :: Reg < syncbusy :: SYNCBUSY_SPEC > ; # [doc = "Synchronization Busy"]
pub mod syncbusy { # [doc = "Register `SYNCBUSY` reader"]
pub struct R (crate :: R < SYNCBUSY_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYNCBUSY_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYNCBUSY_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYNCBUSY_SPEC >) -> Self { R (reader) } } # [doc = "Field `SWRST` reader - Software Reset Synchronization Busy"]
pub type SWRST_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` reader - Enable Synchronization Busy"]
pub type ENABLE_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Software Reset Synchronization Busy"]
# [inline (always)]
pub fn swrst (& self) -> SWRST_R { SWRST_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Enable Synchronization Busy"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } } # [doc = "Synchronization Busy\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [syncbusy](index.html) module"]
pub struct SYNCBUSY_SPEC ; impl crate :: RegisterSpec for SYNCBUSY_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [syncbusy::R](R) reader structure"]
impl crate :: Readable for SYNCBUSY_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SYNCBUSY to value 0"]
impl crate :: Resettable for SYNCBUSY_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "QOSCTRL register accessor: an alias for `Reg<QOSCTRL_SPEC>`"]
pub type QOSCTRL = crate :: Reg < qosctrl :: QOSCTRL_SPEC > ; # [doc = "USB Quality Of Service"]
pub mod qosctrl { # [doc = "Register `QOSCTRL` reader"]
pub struct R (crate :: R < QOSCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < QOSCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < QOSCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < QOSCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `QOSCTRL` writer"]
pub struct W (crate :: W < QOSCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < QOSCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < QOSCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < QOSCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Configuration Quality of Service\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CQOS_A { # [doc = "0: Background (no sensitive operation)"]
DISABLE = 0 , # [doc = "1: Sensitive Bandwidth"]
LOW = 1 , # [doc = "2: Sensitive Latency"]
MEDIUM = 2 , # [doc = "3: Critical Latency"]
HIGH = 3 , } impl From < CQOS_A > for u8 { # [inline (always)]
fn from (variant : CQOS_A) -> Self { variant as _ } } # [doc = "Field `CQOS` reader - Configuration Quality of Service"]
pub type CQOS_R = crate :: FieldReader < u8 , CQOS_A > ; impl CQOS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CQOS_A { match self . bits { 0 => CQOS_A :: DISABLE , 1 => CQOS_A :: LOW , 2 => CQOS_A :: MEDIUM , 3 => CQOS_A :: HIGH , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DISABLE`"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == CQOS_A :: DISABLE } # [doc = "Checks if the value of the field is `LOW`"]
# [inline (always)]
pub fn is_low (& self) -> bool { * self == CQOS_A :: LOW } # [doc = "Checks if the value of the field is `MEDIUM`"]
# [inline (always)]
pub fn is_medium (& self) -> bool { * self == CQOS_A :: MEDIUM } # [doc = "Checks if the value of the field is `HIGH`"]
# [inline (always)]
pub fn is_high (& self) -> bool { * self == CQOS_A :: HIGH } } # [doc = "Field `CQOS` writer - Configuration Quality of Service"]
pub type CQOS_W < 'a > = crate :: FieldWriterSafe < 'a , u8 , QOSCTRL_SPEC , u8 , CQOS_A , 2 , 0 > ; impl < 'a > CQOS_W < 'a > { # [doc = "Background (no sensitive operation)"]
# [inline (always)]
pub fn disable (self) -> & 'a mut W { self . variant (CQOS_A :: DISABLE) } # [doc = "Sensitive Bandwidth"]
# [inline (always)]
pub fn low (self) -> & 'a mut W { self . variant (CQOS_A :: LOW) } # [doc = "Sensitive Latency"]
# [inline (always)]
pub fn medium (self) -> & 'a mut W { self . variant (CQOS_A :: MEDIUM) } # [doc = "Critical Latency"]
# [inline (always)]
pub fn high (self) -> & 'a mut W { self . variant (CQOS_A :: HIGH) } } # [doc = "Data Quality of Service\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum DQOS_A { # [doc = "0: Background (no sensitive operation)"]
DISABLE = 0 , # [doc = "1: Sensitive Bandwidth"]
LOW = 1 , # [doc = "2: Sensitive Latency"]
MEDIUM = 2 , # [doc = "3: Critical Latency"]
HIGH = 3 , } impl From < DQOS_A > for u8 { # [inline (always)]
fn from (variant : DQOS_A) -> Self { variant as _ } } # [doc = "Field `DQOS` reader - Data Quality of Service"]
pub type DQOS_R = crate :: FieldReader < u8 , DQOS_A > ; impl DQOS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DQOS_A { match self . bits { 0 => DQOS_A :: DISABLE , 1 => DQOS_A :: LOW , 2 => DQOS_A :: MEDIUM , 3 => DQOS_A :: HIGH , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DISABLE`"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == DQOS_A :: DISABLE } # [doc = "Checks if the value of the field is `LOW`"]
# [inline (always)]
pub fn is_low (& self) -> bool { * self == DQOS_A :: LOW } # [doc = "Checks if the value of the field is `MEDIUM`"]
# [inline (always)]
pub fn is_medium (& self) -> bool { * self == DQOS_A :: MEDIUM } # [doc = "Checks if the value of the field is `HIGH`"]
# [inline (always)]
pub fn is_high (& self) -> bool { * self == DQOS_A :: HIGH } } # [doc = "Field `DQOS` writer - Data Quality of Service"]
pub type DQOS_W < 'a > = crate :: FieldWriterSafe < 'a , u8 , QOSCTRL_SPEC , u8 , DQOS_A , 2 , 2 > ; impl < 'a > DQOS_W < 'a > { # [doc = "Background (no sensitive operation)"]
# [inline (always)]
pub fn disable (self) -> & 'a mut W { self . variant (DQOS_A :: DISABLE) } # [doc = "Sensitive Bandwidth"]
# [inline (always)]
pub fn low (self) -> & 'a mut W { self . variant (DQOS_A :: LOW) } # [doc = "Sensitive Latency"]
# [inline (always)]
pub fn medium (self) -> & 'a mut W { self . variant (DQOS_A :: MEDIUM) } # [doc = "Critical Latency"]
# [inline (always)]
pub fn high (self) -> & 'a mut W { self . variant (DQOS_A :: HIGH) } } impl R { # [doc = "Bits 0:1 - Configuration Quality of Service"]
# [inline (always)]
pub fn cqos (& self) -> CQOS_R { CQOS_R :: new ((self . bits & 3) as u8) } # [doc = "Bits 2:3 - Data Quality of Service"]
# [inline (always)]
pub fn dqos (& self) -> DQOS_R { DQOS_R :: new (((self . bits >> 2) & 3) as u8) } } impl W { # [doc = "Bits 0:1 - Configuration Quality of Service"]
# [inline (always)]
pub fn cqos (& mut self) -> CQOS_W { CQOS_W :: new (self) } # [doc = "Bits 2:3 - Data Quality of Service"]
# [inline (always)]
pub fn dqos (& mut self) -> DQOS_W { DQOS_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USB Quality Of Service\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [qosctrl](index.html) module"]
pub struct QOSCTRL_SPEC ; impl crate :: RegisterSpec for QOSCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [qosctrl::R](R) reader structure"]
impl crate :: Readable for QOSCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [qosctrl::W](W) writer structure"]
impl crate :: Writable for QOSCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets QOSCTRL to value 0x05"]
impl crate :: Resettable for QOSCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x05 } } } # [doc = "CTRLB register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "DEVICE Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `DETACH` reader - Detach"]
pub type DETACH_R = crate :: BitReader < bool > ; # [doc = "Field `DETACH` writer - Detach"]
pub type DETACH_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLB_SPEC , bool , 0 > ; # [doc = "Field `UPRSM` reader - Upstream Resume"]
pub type UPRSM_R = crate :: BitReader < bool > ; # [doc = "Field `UPRSM` writer - Upstream Resume"]
pub type UPRSM_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLB_SPEC , bool , 1 > ; # [doc = "Speed Configuration\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum SPDCONF_A { # [doc = "0: FS : Full Speed"]
FS = 0 , # [doc = "1: LS : Low Speed"]
LS = 1 , # [doc = "2: HS : High Speed capable"]
HS = 2 , # [doc = "3: HSTM: High Speed Test Mode (force high-speed mode for test mode)"]
HSTM = 3 , } impl From < SPDCONF_A > for u8 { # [inline (always)]
fn from (variant : SPDCONF_A) -> Self { variant as _ } } # [doc = "Field `SPDCONF` reader - Speed Configuration"]
pub type SPDCONF_R = crate :: FieldReader < u8 , SPDCONF_A > ; impl SPDCONF_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> SPDCONF_A { match self . bits { 0 => SPDCONF_A :: FS , 1 => SPDCONF_A :: LS , 2 => SPDCONF_A :: HS , 3 => SPDCONF_A :: HSTM , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `FS`"]
# [inline (always)]
pub fn is_fs (& self) -> bool { * self == SPDCONF_A :: FS } # [doc = "Checks if the value of the field is `LS`"]
# [inline (always)]
pub fn is_ls (& self) -> bool { * self == SPDCONF_A :: LS } # [doc = "Checks if the value of the field is `HS`"]
# [inline (always)]
pub fn is_hs (& self) -> bool { * self == SPDCONF_A :: HS } # [doc = "Checks if the value of the field is `HSTM`"]
# [inline (always)]
pub fn is_hstm (& self) -> bool { * self == SPDCONF_A :: HSTM } } # [doc = "Field `SPDCONF` writer - Speed Configuration"]
pub type SPDCONF_W < 'a > = crate :: FieldWriterSafe < 'a , u16 , CTRLB_SPEC , u8 , SPDCONF_A , 2 , 2 > ; impl < 'a > SPDCONF_W < 'a > { # [doc = "FS : Full Speed"]
# [inline (always)]
pub fn fs (self) -> & 'a mut W { self . variant (SPDCONF_A :: FS) } # [doc = "LS : Low Speed"]
# [inline (always)]
pub fn ls (self) -> & 'a mut W { self . variant (SPDCONF_A :: LS) } # [doc = "HS : High Speed capable"]
# [inline (always)]
pub fn hs (self) -> & 'a mut W { self . variant (SPDCONF_A :: HS) } # [doc = "HSTM: High Speed Test Mode (force high-speed mode for test mode)"]
# [inline (always)]
pub fn hstm (self) -> & 'a mut W { self . variant (SPDCONF_A :: HSTM) } } # [doc = "Field `NREPLY` reader - No Reply"]
pub type NREPLY_R = crate :: BitReader < bool > ; # [doc = "Field `NREPLY` writer - No Reply"]
pub type NREPLY_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLB_SPEC , bool , 4 > ; # [doc = "Field `TSTJ` reader - Test mode J"]
pub type TSTJ_R = crate :: BitReader < bool > ; # [doc = "Field `TSTJ` writer - Test mode J"]
pub type TSTJ_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLB_SPEC , bool , 5 > ; # [doc = "Field `TSTK` reader - Test mode K"]
pub type TSTK_R = crate :: BitReader < bool > ; # [doc = "Field `TSTK` writer - Test mode K"]
pub type TSTK_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLB_SPEC , bool , 6 > ; # [doc = "Field `TSTPCKT` reader - Test packet mode"]
pub type TSTPCKT_R = crate :: BitReader < bool > ; # [doc = "Field `TSTPCKT` writer - Test packet mode"]
pub type TSTPCKT_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLB_SPEC , bool , 7 > ; # [doc = "Field `OPMODE2` reader - Specific Operational Mode"]
pub type OPMODE2_R = crate :: BitReader < bool > ; # [doc = "Field `OPMODE2` writer - Specific Operational Mode"]
pub type OPMODE2_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLB_SPEC , bool , 8 > ; # [doc = "Field `GNAK` reader - Global NAK"]
pub type GNAK_R = crate :: BitReader < bool > ; # [doc = "Field `GNAK` writer - Global NAK"]
pub type GNAK_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLB_SPEC , bool , 9 > ; # [doc = "Link Power Management Handshake\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum LPMHDSK_A { # [doc = "0: No handshake. LPM is not supported"]
NO = 0 , # [doc = "1: ACK"]
ACK = 1 , # [doc = "2: NYET"]
NYET = 2 , # [doc = "3: STALL"]
STALL = 3 , } impl From < LPMHDSK_A > for u8 { # [inline (always)]
fn from (variant : LPMHDSK_A) -> Self { variant as _ } } # [doc = "Field `LPMHDSK` reader - Link Power Management Handshake"]
pub type LPMHDSK_R = crate :: FieldReader < u8 , LPMHDSK_A > ; impl LPMHDSK_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> LPMHDSK_A { match self . bits { 0 => LPMHDSK_A :: NO , 1 => LPMHDSK_A :: ACK , 2 => LPMHDSK_A :: NYET , 3 => LPMHDSK_A :: STALL , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `NO`"]
# [inline (always)]
pub fn is_no (& self) -> bool { * self == LPMHDSK_A :: NO } # [doc = "Checks if the value of the field is `ACK`"]
# [inline (always)]
pub fn is_ack (& self) -> bool { * self == LPMHDSK_A :: ACK } # [doc = "Checks if the value of the field is `NYET`"]
# [inline (always)]
pub fn is_nyet (& self) -> bool { * self == LPMHDSK_A :: NYET } # [doc = "Checks if the value of the field is `STALL`"]
# [inline (always)]
pub fn is_stall (& self) -> bool { * self == LPMHDSK_A :: STALL } } # [doc = "Field `LPMHDSK` writer - Link Power Management Handshake"]
pub type LPMHDSK_W < 'a > = crate :: FieldWriterSafe < 'a , u16 , CTRLB_SPEC , u8 , LPMHDSK_A , 2 , 10 > ; impl < 'a > LPMHDSK_W < 'a > { # [doc = "No handshake. LPM is not supported"]
# [inline (always)]
pub fn no (self) -> & 'a mut W { self . variant (LPMHDSK_A :: NO) } # [doc = "ACK"]
# [inline (always)]
pub fn ack (self) -> & 'a mut W { self . variant (LPMHDSK_A :: ACK) } # [doc = "NYET"]
# [inline (always)]
pub fn nyet (self) -> & 'a mut W { self . variant (LPMHDSK_A :: NYET) } # [doc = "STALL"]
# [inline (always)]
pub fn stall (self) -> & 'a mut W { self . variant (LPMHDSK_A :: STALL) } } impl R { # [doc = "Bit 0 - Detach"]
# [inline (always)]
pub fn detach (& self) -> DETACH_R { DETACH_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Upstream Resume"]
# [inline (always)]
pub fn uprsm (& self) -> UPRSM_R { UPRSM_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Speed Configuration"]
# [inline (always)]
pub fn spdconf (& self) -> SPDCONF_R { SPDCONF_R :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bit 4 - No Reply"]
# [inline (always)]
pub fn nreply (& self) -> NREPLY_R { NREPLY_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Test mode J"]
# [inline (always)]
pub fn tstj (& self) -> TSTJ_R { TSTJ_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Test mode K"]
# [inline (always)]
pub fn tstk (& self) -> TSTK_R { TSTK_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Test packet mode"]
# [inline (always)]
pub fn tstpckt (& self) -> TSTPCKT_R { TSTPCKT_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Specific Operational Mode"]
# [inline (always)]
pub fn opmode2 (& self) -> OPMODE2_R { OPMODE2_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Global NAK"]
# [inline (always)]
pub fn gnak (& self) -> GNAK_R { GNAK_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bits 10:11 - Link Power Management Handshake"]
# [inline (always)]
pub fn lpmhdsk (& self) -> LPMHDSK_R { LPMHDSK_R :: new (((self . bits >> 10) & 3) as u8) } } impl W { # [doc = "Bit 0 - Detach"]
# [inline (always)]
pub fn detach (& mut self) -> DETACH_W { DETACH_W :: new (self) } # [doc = "Bit 1 - Upstream Resume"]
# [inline (always)]
pub fn uprsm (& mut self) -> UPRSM_W { UPRSM_W :: new (self) } # [doc = "Bits 2:3 - Speed Configuration"]
# [inline (always)]
pub fn spdconf (& mut self) -> SPDCONF_W { SPDCONF_W :: new (self) } # [doc = "Bit 4 - No Reply"]
# [inline (always)]
pub fn nreply (& mut self) -> NREPLY_W { NREPLY_W :: new (self) } # [doc = "Bit 5 - Test mode J"]
# [inline (always)]
pub fn tstj (& mut self) -> TSTJ_W { TSTJ_W :: new (self) } # [doc = "Bit 6 - Test mode K"]
# [inline (always)]
pub fn tstk (& mut self) -> TSTK_W { TSTK_W :: new (self) } # [doc = "Bit 7 - Test packet mode"]
# [inline (always)]
pub fn tstpckt (& mut self) -> TSTPCKT_W { TSTPCKT_W :: new (self) } # [doc = "Bit 8 - Specific Operational Mode"]
# [inline (always)]
pub fn opmode2 (& mut self) -> OPMODE2_W { OPMODE2_W :: new (self) } # [doc = "Bit 9 - Global NAK"]
# [inline (always)]
pub fn gnak (& mut self) -> GNAK_W { GNAK_W :: new (self) } # [doc = "Bits 10:11 - Link Power Management Handshake"]
# [inline (always)]
pub fn lpmhdsk (& mut self) -> LPMHDSK_W { LPMHDSK_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "DEVICE Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLB to value 0x01"]
impl crate :: Resettable for CTRLB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x01 } } } # [doc = "DADD register accessor: an alias for `Reg<DADD_SPEC>`"]
pub type DADD = crate :: Reg < dadd :: DADD_SPEC > ; # [doc = "DEVICE Device Address"]
pub mod dadd { # [doc = "Register `DADD` reader"]
pub struct R (crate :: R < DADD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DADD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DADD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DADD_SPEC >) -> Self { R (reader) } } # [doc = "Register `DADD` writer"]
pub struct W (crate :: W < DADD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DADD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DADD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DADD_SPEC >) -> Self { W (writer) } } # [doc = "Field `DADD` reader - Device Address"]
pub type DADD_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `DADD` writer - Device Address"]
pub type DADD_W < 'a > = crate :: FieldWriter < 'a , u8 , DADD_SPEC , u8 , u8 , 7 , 0 > ; # [doc = "Field `ADDEN` reader - Device Address Enable"]
pub type ADDEN_R = crate :: BitReader < bool > ; # [doc = "Field `ADDEN` writer - Device Address Enable"]
pub type ADDEN_W < 'a > = crate :: BitWriter < 'a , u8 , DADD_SPEC , bool , 7 > ; impl R { # [doc = "Bits 0:6 - Device Address"]
# [inline (always)]
pub fn dadd (& self) -> DADD_R { DADD_R :: new ((self . bits & 0x7f) as u8) } # [doc = "Bit 7 - Device Address Enable"]
# [inline (always)]
pub fn adden (& self) -> ADDEN_R { ADDEN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:6 - Device Address"]
# [inline (always)]
pub fn dadd (& mut self) -> DADD_W { DADD_W :: new (self) } # [doc = "Bit 7 - Device Address Enable"]
# [inline (always)]
pub fn adden (& mut self) -> ADDEN_W { ADDEN_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "DEVICE Device Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dadd](index.html) module"]
pub struct DADD_SPEC ; impl crate :: RegisterSpec for DADD_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [dadd::R](R) reader structure"]
impl crate :: Readable for DADD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [dadd::W](W) writer structure"]
impl crate :: Writable for DADD_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DADD to value 0"]
impl crate :: Resettable for DADD_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATUS register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "DEVICE Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Speed Status\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum SPEED_A { # [doc = "0: Full-speed mode"]
FS = 0 , # [doc = "1: High-speed mode"]
HS = 1 , # [doc = "2: Low-speed mode"]
LS = 2 , } impl From < SPEED_A > for u8 { # [inline (always)]
fn from (variant : SPEED_A) -> Self { variant as _ } } # [doc = "Field `SPEED` reader - Speed Status"]
pub type SPEED_R = crate :: FieldReader < u8 , SPEED_A > ; impl SPEED_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SPEED_A > { match self . bits { 0 => Some (SPEED_A :: FS) , 1 => Some (SPEED_A :: HS) , 2 => Some (SPEED_A :: LS) , _ => None , } } # [doc = "Checks if the value of the field is `FS`"]
# [inline (always)]
pub fn is_fs (& self) -> bool { * self == SPEED_A :: FS } # [doc = "Checks if the value of the field is `HS`"]
# [inline (always)]
pub fn is_hs (& self) -> bool { * self == SPEED_A :: HS } # [doc = "Checks if the value of the field is `LS`"]
# [inline (always)]
pub fn is_ls (& self) -> bool { * self == SPEED_A :: LS } } # [doc = "USB Line State Status\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum LINESTATE_A { # [doc = "0: SE0/RESET"]
_0 = 0 , # [doc = "1: FS-J or LS-K State"]
_1 = 1 , # [doc = "2: FS-K or LS-J State"]
_2 = 2 , } impl From < LINESTATE_A > for u8 { # [inline (always)]
fn from (variant : LINESTATE_A) -> Self { variant as _ } } # [doc = "Field `LINESTATE` reader - USB Line State Status"]
pub type LINESTATE_R = crate :: FieldReader < u8 , LINESTATE_A > ; impl LINESTATE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < LINESTATE_A > { match self . bits { 0 => Some (LINESTATE_A :: _0) , 1 => Some (LINESTATE_A :: _1) , 2 => Some (LINESTATE_A :: _2) , _ => None , } } # [doc = "Checks if the value of the field is `_0`"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == LINESTATE_A :: _0 } # [doc = "Checks if the value of the field is `_1`"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == LINESTATE_A :: _1 } # [doc = "Checks if the value of the field is `_2`"]
# [inline (always)]
pub fn is_2 (& self) -> bool { * self == LINESTATE_A :: _2 } } impl R { # [doc = "Bits 2:3 - Speed Status"]
# [inline (always)]
pub fn speed (& self) -> SPEED_R { SPEED_R :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bits 6:7 - USB Line State Status"]
# [inline (always)]
pub fn linestate (& self) -> LINESTATE_R { LINESTATE_R :: new (((self . bits >> 6) & 3) as u8) } } # [doc = "DEVICE Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATUS to value 0x40"]
impl crate :: Resettable for STATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x40 } } } # [doc = "FSMSTATUS register accessor: an alias for `Reg<FSMSTATUS_SPEC>`"]
pub type FSMSTATUS = crate :: Reg < fsmstatus :: FSMSTATUS_SPEC > ; # [doc = "Finite State Machine Status"]
pub mod fsmstatus { # [doc = "Register `FSMSTATUS` reader"]
pub struct R (crate :: R < FSMSTATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < FSMSTATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < FSMSTATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < FSMSTATUS_SPEC >) -> Self { R (reader) } } # [doc = "Fine State Machine Status\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum FSMSTATE_A { # [doc = "1: OFF (L3). It corresponds to the powered-off, disconnected, and disabled state"]
OFF = 1 , # [doc = "2: ON (L0). It corresponds to the Idle and Active states"]
ON = 2 , # [doc = "4: SUSPEND (L2)"]
SUSPEND = 4 , # [doc = "8: SLEEP (L1)"]
SLEEP = 8 , # [doc = "16: DNRESUME. Down Stream Resume."]
DNRESUME = 16 , # [doc = "32: UPRESUME. Up Stream Resume."]
UPRESUME = 32 , # [doc = "64: RESET. USB lines Reset."]
RESET = 64 , } impl From < FSMSTATE_A > for u8 { # [inline (always)]
fn from (variant : FSMSTATE_A) -> Self { variant as _ } } # [doc = "Field `FSMSTATE` reader - Fine State Machine Status"]
pub type FSMSTATE_R = crate :: FieldReader < u8 , FSMSTATE_A > ; impl FSMSTATE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < FSMSTATE_A > { match self . bits { 1 => Some (FSMSTATE_A :: OFF) , 2 => Some (FSMSTATE_A :: ON) , 4 => Some (FSMSTATE_A :: SUSPEND) , 8 => Some (FSMSTATE_A :: SLEEP) , 16 => Some (FSMSTATE_A :: DNRESUME) , 32 => Some (FSMSTATE_A :: UPRESUME) , 64 => Some (FSMSTATE_A :: RESET) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == FSMSTATE_A :: OFF } # [doc = "Checks if the value of the field is `ON`"]
# [inline (always)]
pub fn is_on (& self) -> bool { * self == FSMSTATE_A :: ON } # [doc = "Checks if the value of the field is `SUSPEND`"]
# [inline (always)]
pub fn is_suspend (& self) -> bool { * self == FSMSTATE_A :: SUSPEND } # [doc = "Checks if the value of the field is `SLEEP`"]
# [inline (always)]
pub fn is_sleep (& self) -> bool { * self == FSMSTATE_A :: SLEEP } # [doc = "Checks if the value of the field is `DNRESUME`"]
# [inline (always)]
pub fn is_dnresume (& self) -> bool { * self == FSMSTATE_A :: DNRESUME } # [doc = "Checks if the value of the field is `UPRESUME`"]
# [inline (always)]
pub fn is_upresume (& self) -> bool { * self == FSMSTATE_A :: UPRESUME } # [doc = "Checks if the value of the field is `RESET`"]
# [inline (always)]
pub fn is_reset (& self) -> bool { * self == FSMSTATE_A :: RESET } } impl R { # [doc = "Bits 0:6 - Fine State Machine Status"]
# [inline (always)]
pub fn fsmstate (& self) -> FSMSTATE_R { FSMSTATE_R :: new ((self . bits & 0x7f) as u8) } } # [doc = "Finite State Machine Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fsmstatus](index.html) module"]
pub struct FSMSTATUS_SPEC ; impl crate :: RegisterSpec for FSMSTATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [fsmstatus::R](R) reader structure"]
impl crate :: Readable for FSMSTATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets FSMSTATUS to value 0x01"]
impl crate :: Resettable for FSMSTATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x01 } } } # [doc = "FNUM register accessor: an alias for `Reg<FNUM_SPEC>`"]
pub type FNUM = crate :: Reg < fnum :: FNUM_SPEC > ; # [doc = "DEVICE Device Frame Number"]
pub mod fnum { # [doc = "Register `FNUM` reader"]
pub struct R (crate :: R < FNUM_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < FNUM_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < FNUM_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < FNUM_SPEC >) -> Self { R (reader) } } # [doc = "Field `MFNUM` reader - Micro Frame Number"]
pub type MFNUM_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `FNUM` reader - Frame Number"]
pub type FNUM_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `FNCERR` reader - Frame Number CRC Error"]
pub type FNCERR_R = crate :: BitReader < bool > ; impl R { # [doc = "Bits 0:2 - Micro Frame Number"]
# [inline (always)]
pub fn mfnum (& self) -> MFNUM_R { MFNUM_R :: new ((self . bits & 7) as u8) } # [doc = "Bits 3:13 - Frame Number"]
# [inline (always)]
pub fn fnum (& self) -> FNUM_R { FNUM_R :: new (((self . bits >> 3) & 0x07ff) as u16) } # [doc = "Bit 15 - Frame Number CRC Error"]
# [inline (always)]
pub fn fncerr (& self) -> FNCERR_R { FNCERR_R :: new (((self . bits >> 15) & 1) != 0) } } # [doc = "DEVICE Device Frame Number\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fnum](index.html) module"]
pub struct FNUM_SPEC ; impl crate :: RegisterSpec for FNUM_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [fnum::R](R) reader structure"]
impl crate :: Readable for FNUM_SPEC { type Reader = R ; } # [doc = "`reset()` method sets FNUM to value 0"]
impl crate :: Resettable for FNUM_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENCLR register accessor: an alias for `Reg<INTENCLR_SPEC>`"]
pub type INTENCLR = crate :: Reg < intenclr :: INTENCLR_SPEC > ; # [doc = "DEVICE Device Interrupt Enable Clear"]
pub mod intenclr { # [doc = "Register `INTENCLR` reader"]
pub struct R (crate :: R < INTENCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENCLR` writer"]
pub struct W (crate :: W < INTENCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `SUSPEND` reader - Suspend Interrupt Enable"]
pub type SUSPEND_R = crate :: BitReader < bool > ; # [doc = "Field `SUSPEND` writer - Suspend Interrupt Enable"]
pub type SUSPEND_W < 'a > = crate :: BitWriter < 'a , u16 , INTENCLR_SPEC , bool , 0 > ; # [doc = "Field `MSOF` reader - Micro Start of Frame Interrupt Enable in High Speed Mode"]
pub type MSOF_R = crate :: BitReader < bool > ; # [doc = "Field `MSOF` writer - Micro Start of Frame Interrupt Enable in High Speed Mode"]
pub type MSOF_W < 'a > = crate :: BitWriter < 'a , u16 , INTENCLR_SPEC , bool , 1 > ; # [doc = "Field `SOF` reader - Start Of Frame Interrupt Enable"]
pub type SOF_R = crate :: BitReader < bool > ; # [doc = "Field `SOF` writer - Start Of Frame Interrupt Enable"]
pub type SOF_W < 'a > = crate :: BitWriter < 'a , u16 , INTENCLR_SPEC , bool , 2 > ; # [doc = "Field `EORST` reader - End of Reset Interrupt Enable"]
pub type EORST_R = crate :: BitReader < bool > ; # [doc = "Field `EORST` writer - End of Reset Interrupt Enable"]
pub type EORST_W < 'a > = crate :: BitWriter < 'a , u16 , INTENCLR_SPEC , bool , 3 > ; # [doc = "Field `WAKEUP` reader - Wake Up Interrupt Enable"]
pub type WAKEUP_R = crate :: BitReader < bool > ; # [doc = "Field `WAKEUP` writer - Wake Up Interrupt Enable"]
pub type WAKEUP_W < 'a > = crate :: BitWriter < 'a , u16 , INTENCLR_SPEC , bool , 4 > ; # [doc = "Field `EORSM` reader - End Of Resume Interrupt Enable"]
pub type EORSM_R = crate :: BitReader < bool > ; # [doc = "Field `EORSM` writer - End Of Resume Interrupt Enable"]
pub type EORSM_W < 'a > = crate :: BitWriter < 'a , u16 , INTENCLR_SPEC , bool , 5 > ; # [doc = "Field `UPRSM` reader - Upstream Resume Interrupt Enable"]
pub type UPRSM_R = crate :: BitReader < bool > ; # [doc = "Field `UPRSM` writer - Upstream Resume Interrupt Enable"]
pub type UPRSM_W < 'a > = crate :: BitWriter < 'a , u16 , INTENCLR_SPEC , bool , 6 > ; # [doc = "Field `RAMACER` reader - Ram Access Interrupt Enable"]
pub type RAMACER_R = crate :: BitReader < bool > ; # [doc = "Field `RAMACER` writer - Ram Access Interrupt Enable"]
pub type RAMACER_W < 'a > = crate :: BitWriter < 'a , u16 , INTENCLR_SPEC , bool , 7 > ; # [doc = "Field `LPMNYET` reader - Link Power Management Not Yet Interrupt Enable"]
pub type LPMNYET_R = crate :: BitReader < bool > ; # [doc = "Field `LPMNYET` writer - Link Power Management Not Yet Interrupt Enable"]
pub type LPMNYET_W < 'a > = crate :: BitWriter < 'a , u16 , INTENCLR_SPEC , bool , 8 > ; # [doc = "Field `LPMSUSP` reader - Link Power Management Suspend Interrupt Enable"]
pub type LPMSUSP_R = crate :: BitReader < bool > ; # [doc = "Field `LPMSUSP` writer - Link Power Management Suspend Interrupt Enable"]
pub type LPMSUSP_W < 'a > = crate :: BitWriter < 'a , u16 , INTENCLR_SPEC , bool , 9 > ; impl R { # [doc = "Bit 0 - Suspend Interrupt Enable"]
# [inline (always)]
pub fn suspend (& self) -> SUSPEND_R { SUSPEND_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Micro Start of Frame Interrupt Enable in High Speed Mode"]
# [inline (always)]
pub fn msof (& self) -> MSOF_R { MSOF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Start Of Frame Interrupt Enable"]
# [inline (always)]
pub fn sof (& self) -> SOF_R { SOF_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - End of Reset Interrupt Enable"]
# [inline (always)]
pub fn eorst (& self) -> EORST_R { EORST_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Wake Up Interrupt Enable"]
# [inline (always)]
pub fn wakeup (& self) -> WAKEUP_R { WAKEUP_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - End Of Resume Interrupt Enable"]
# [inline (always)]
pub fn eorsm (& self) -> EORSM_R { EORSM_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Upstream Resume Interrupt Enable"]
# [inline (always)]
pub fn uprsm (& self) -> UPRSM_R { UPRSM_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Ram Access Interrupt Enable"]
# [inline (always)]
pub fn ramacer (& self) -> RAMACER_R { RAMACER_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Link Power Management Not Yet Interrupt Enable"]
# [inline (always)]
pub fn lpmnyet (& self) -> LPMNYET_R { LPMNYET_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Link Power Management Suspend Interrupt Enable"]
# [inline (always)]
pub fn lpmsusp (& self) -> LPMSUSP_R { LPMSUSP_R :: new (((self . bits >> 9) & 1) != 0) } } impl W { # [doc = "Bit 0 - Suspend Interrupt Enable"]
# [inline (always)]
pub fn suspend (& mut self) -> SUSPEND_W { SUSPEND_W :: new (self) } # [doc = "Bit 1 - Micro Start of Frame Interrupt Enable in High Speed Mode"]
# [inline (always)]
pub fn msof (& mut self) -> MSOF_W { MSOF_W :: new (self) } # [doc = "Bit 2 - Start Of Frame Interrupt Enable"]
# [inline (always)]
pub fn sof (& mut self) -> SOF_W { SOF_W :: new (self) } # [doc = "Bit 3 - End of Reset Interrupt Enable"]
# [inline (always)]
pub fn eorst (& mut self) -> EORST_W { EORST_W :: new (self) } # [doc = "Bit 4 - Wake Up Interrupt Enable"]
# [inline (always)]
pub fn wakeup (& mut self) -> WAKEUP_W { WAKEUP_W :: new (self) } # [doc = "Bit 5 - End Of Resume Interrupt Enable"]
# [inline (always)]
pub fn eorsm (& mut self) -> EORSM_W { EORSM_W :: new (self) } # [doc = "Bit 6 - Upstream Resume Interrupt Enable"]
# [inline (always)]
pub fn uprsm (& mut self) -> UPRSM_W { UPRSM_W :: new (self) } # [doc = "Bit 7 - Ram Access Interrupt Enable"]
# [inline (always)]
pub fn ramacer (& mut self) -> RAMACER_W { RAMACER_W :: new (self) } # [doc = "Bit 8 - Link Power Management Not Yet Interrupt Enable"]
# [inline (always)]
pub fn lpmnyet (& mut self) -> LPMNYET_W { LPMNYET_W :: new (self) } # [doc = "Bit 9 - Link Power Management Suspend Interrupt Enable"]
# [inline (always)]
pub fn lpmsusp (& mut self) -> LPMSUSP_W { LPMSUSP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "DEVICE Device Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenclr](index.html) module"]
pub struct INTENCLR_SPEC ; impl crate :: RegisterSpec for INTENCLR_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [intenclr::R](R) reader structure"]
impl crate :: Readable for INTENCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenclr::W](W) writer structure"]
impl crate :: Writable for INTENCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENCLR to value 0"]
impl crate :: Resettable for INTENCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENSET register accessor: an alias for `Reg<INTENSET_SPEC>`"]
pub type INTENSET = crate :: Reg < intenset :: INTENSET_SPEC > ; # [doc = "DEVICE Device Interrupt Enable Set"]
pub mod intenset { # [doc = "Register `INTENSET` reader"]
pub struct R (crate :: R < INTENSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENSET` writer"]
pub struct W (crate :: W < INTENSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `SUSPEND` reader - Suspend Interrupt Enable"]
pub type SUSPEND_R = crate :: BitReader < bool > ; # [doc = "Field `SUSPEND` writer - Suspend Interrupt Enable"]
pub type SUSPEND_W < 'a > = crate :: BitWriter < 'a , u16 , INTENSET_SPEC , bool , 0 > ; # [doc = "Field `MSOF` reader - Micro Start of Frame Interrupt Enable in High Speed Mode"]
pub type MSOF_R = crate :: BitReader < bool > ; # [doc = "Field `MSOF` writer - Micro Start of Frame Interrupt Enable in High Speed Mode"]
pub type MSOF_W < 'a > = crate :: BitWriter < 'a , u16 , INTENSET_SPEC , bool , 1 > ; # [doc = "Field `SOF` reader - Start Of Frame Interrupt Enable"]
pub type SOF_R = crate :: BitReader < bool > ; # [doc = "Field `SOF` writer - Start Of Frame Interrupt Enable"]
pub type SOF_W < 'a > = crate :: BitWriter < 'a , u16 , INTENSET_SPEC , bool , 2 > ; # [doc = "Field `EORST` reader - End of Reset Interrupt Enable"]
pub type EORST_R = crate :: BitReader < bool > ; # [doc = "Field `EORST` writer - End of Reset Interrupt Enable"]
pub type EORST_W < 'a > = crate :: BitWriter < 'a , u16 , INTENSET_SPEC , bool , 3 > ; # [doc = "Field `WAKEUP` reader - Wake Up Interrupt Enable"]
pub type WAKEUP_R = crate :: BitReader < bool > ; # [doc = "Field `WAKEUP` writer - Wake Up Interrupt Enable"]
pub type WAKEUP_W < 'a > = crate :: BitWriter < 'a , u16 , INTENSET_SPEC , bool , 4 > ; # [doc = "Field `EORSM` reader - End Of Resume Interrupt Enable"]
pub type EORSM_R = crate :: BitReader < bool > ; # [doc = "Field `EORSM` writer - End Of Resume Interrupt Enable"]
pub type EORSM_W < 'a > = crate :: BitWriter < 'a , u16 , INTENSET_SPEC , bool , 5 > ; # [doc = "Field `UPRSM` reader - Upstream Resume Interrupt Enable"]
pub type UPRSM_R = crate :: BitReader < bool > ; # [doc = "Field `UPRSM` writer - Upstream Resume Interrupt Enable"]
pub type UPRSM_W < 'a > = crate :: BitWriter < 'a , u16 , INTENSET_SPEC , bool , 6 > ; # [doc = "Field `RAMACER` reader - Ram Access Interrupt Enable"]
pub type RAMACER_R = crate :: BitReader < bool > ; # [doc = "Field `RAMACER` writer - Ram Access Interrupt Enable"]
pub type RAMACER_W < 'a > = crate :: BitWriter < 'a , u16 , INTENSET_SPEC , bool , 7 > ; # [doc = "Field `LPMNYET` reader - Link Power Management Not Yet Interrupt Enable"]
pub type LPMNYET_R = crate :: BitReader < bool > ; # [doc = "Field `LPMNYET` writer - Link Power Management Not Yet Interrupt Enable"]
pub type LPMNYET_W < 'a > = crate :: BitWriter < 'a , u16 , INTENSET_SPEC , bool , 8 > ; # [doc = "Field `LPMSUSP` reader - Link Power Management Suspend Interrupt Enable"]
pub type LPMSUSP_R = crate :: BitReader < bool > ; # [doc = "Field `LPMSUSP` writer - Link Power Management Suspend Interrupt Enable"]
pub type LPMSUSP_W < 'a > = crate :: BitWriter < 'a , u16 , INTENSET_SPEC , bool , 9 > ; impl R { # [doc = "Bit 0 - Suspend Interrupt Enable"]
# [inline (always)]
pub fn suspend (& self) -> SUSPEND_R { SUSPEND_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Micro Start of Frame Interrupt Enable in High Speed Mode"]
# [inline (always)]
pub fn msof (& self) -> MSOF_R { MSOF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Start Of Frame Interrupt Enable"]
# [inline (always)]
pub fn sof (& self) -> SOF_R { SOF_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - End of Reset Interrupt Enable"]
# [inline (always)]
pub fn eorst (& self) -> EORST_R { EORST_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Wake Up Interrupt Enable"]
# [inline (always)]
pub fn wakeup (& self) -> WAKEUP_R { WAKEUP_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - End Of Resume Interrupt Enable"]
# [inline (always)]
pub fn eorsm (& self) -> EORSM_R { EORSM_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Upstream Resume Interrupt Enable"]
# [inline (always)]
pub fn uprsm (& self) -> UPRSM_R { UPRSM_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Ram Access Interrupt Enable"]
# [inline (always)]
pub fn ramacer (& self) -> RAMACER_R { RAMACER_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Link Power Management Not Yet Interrupt Enable"]
# [inline (always)]
pub fn lpmnyet (& self) -> LPMNYET_R { LPMNYET_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Link Power Management Suspend Interrupt Enable"]
# [inline (always)]
pub fn lpmsusp (& self) -> LPMSUSP_R { LPMSUSP_R :: new (((self . bits >> 9) & 1) != 0) } } impl W { # [doc = "Bit 0 - Suspend Interrupt Enable"]
# [inline (always)]
pub fn suspend (& mut self) -> SUSPEND_W { SUSPEND_W :: new (self) } # [doc = "Bit 1 - Micro Start of Frame Interrupt Enable in High Speed Mode"]
# [inline (always)]
pub fn msof (& mut self) -> MSOF_W { MSOF_W :: new (self) } # [doc = "Bit 2 - Start Of Frame Interrupt Enable"]
# [inline (always)]
pub fn sof (& mut self) -> SOF_W { SOF_W :: new (self) } # [doc = "Bit 3 - End of Reset Interrupt Enable"]
# [inline (always)]
pub fn eorst (& mut self) -> EORST_W { EORST_W :: new (self) } # [doc = "Bit 4 - Wake Up Interrupt Enable"]
# [inline (always)]
pub fn wakeup (& mut self) -> WAKEUP_W { WAKEUP_W :: new (self) } # [doc = "Bit 5 - End Of Resume Interrupt Enable"]
# [inline (always)]
pub fn eorsm (& mut self) -> EORSM_W { EORSM_W :: new (self) } # [doc = "Bit 6 - Upstream Resume Interrupt Enable"]
# [inline (always)]
pub fn uprsm (& mut self) -> UPRSM_W { UPRSM_W :: new (self) } # [doc = "Bit 7 - Ram Access Interrupt Enable"]
# [inline (always)]
pub fn ramacer (& mut self) -> RAMACER_W { RAMACER_W :: new (self) } # [doc = "Bit 8 - Link Power Management Not Yet Interrupt Enable"]
# [inline (always)]
pub fn lpmnyet (& mut self) -> LPMNYET_W { LPMNYET_W :: new (self) } # [doc = "Bit 9 - Link Power Management Suspend Interrupt Enable"]
# [inline (always)]
pub fn lpmsusp (& mut self) -> LPMSUSP_W { LPMSUSP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "DEVICE Device Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenset](index.html) module"]
pub struct INTENSET_SPEC ; impl crate :: RegisterSpec for INTENSET_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [intenset::R](R) reader structure"]
impl crate :: Readable for INTENSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenset::W](W) writer structure"]
impl crate :: Writable for INTENSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENSET to value 0"]
impl crate :: Resettable for INTENSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTFLAG register accessor: an alias for `Reg<INTFLAG_SPEC>`"]
pub type INTFLAG = crate :: Reg < intflag :: INTFLAG_SPEC > ; # [doc = "DEVICE Device Interrupt Flag"]
pub mod intflag { # [doc = "Register `INTFLAG` reader"]
pub struct R (crate :: R < INTFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAG` writer"]
pub struct W (crate :: W < INTFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `SUSPEND` reader - Suspend"]
pub type SUSPEND_R = crate :: BitReader < bool > ; # [doc = "Field `SUSPEND` writer - Suspend"]
pub type SUSPEND_W < 'a > = crate :: BitWriter < 'a , u16 , INTFLAG_SPEC , bool , 0 > ; # [doc = "Field `MSOF` reader - Micro Start of Frame in High Speed Mode"]
pub type MSOF_R = crate :: BitReader < bool > ; # [doc = "Field `MSOF` writer - Micro Start of Frame in High Speed Mode"]
pub type MSOF_W < 'a > = crate :: BitWriter < 'a , u16 , INTFLAG_SPEC , bool , 1 > ; # [doc = "Field `SOF` reader - Start Of Frame"]
pub type SOF_R = crate :: BitReader < bool > ; # [doc = "Field `SOF` writer - Start Of Frame"]
pub type SOF_W < 'a > = crate :: BitWriter < 'a , u16 , INTFLAG_SPEC , bool , 2 > ; # [doc = "Field `EORST` reader - End of Reset"]
pub type EORST_R = crate :: BitReader < bool > ; # [doc = "Field `EORST` writer - End of Reset"]
pub type EORST_W < 'a > = crate :: BitWriter < 'a , u16 , INTFLAG_SPEC , bool , 3 > ; # [doc = "Field `WAKEUP` reader - Wake Up"]
pub type WAKEUP_R = crate :: BitReader < bool > ; # [doc = "Field `WAKEUP` writer - Wake Up"]
pub type WAKEUP_W < 'a > = crate :: BitWriter < 'a , u16 , INTFLAG_SPEC , bool , 4 > ; # [doc = "Field `EORSM` reader - End Of Resume"]
pub type EORSM_R = crate :: BitReader < bool > ; # [doc = "Field `EORSM` writer - End Of Resume"]
pub type EORSM_W < 'a > = crate :: BitWriter < 'a , u16 , INTFLAG_SPEC , bool , 5 > ; # [doc = "Field `UPRSM` reader - Upstream Resume"]
pub type UPRSM_R = crate :: BitReader < bool > ; # [doc = "Field `UPRSM` writer - Upstream Resume"]
pub type UPRSM_W < 'a > = crate :: BitWriter < 'a , u16 , INTFLAG_SPEC , bool , 6 > ; # [doc = "Field `RAMACER` reader - Ram Access"]
pub type RAMACER_R = crate :: BitReader < bool > ; # [doc = "Field `RAMACER` writer - Ram Access"]
pub type RAMACER_W < 'a > = crate :: BitWriter < 'a , u16 , INTFLAG_SPEC , bool , 7 > ; # [doc = "Field `LPMNYET` reader - Link Power Management Not Yet"]
pub type LPMNYET_R = crate :: BitReader < bool > ; # [doc = "Field `LPMNYET` writer - Link Power Management Not Yet"]
pub type LPMNYET_W < 'a > = crate :: BitWriter < 'a , u16 , INTFLAG_SPEC , bool , 8 > ; # [doc = "Field `LPMSUSP` reader - Link Power Management Suspend"]
pub type LPMSUSP_R = crate :: BitReader < bool > ; # [doc = "Field `LPMSUSP` writer - Link Power Management Suspend"]
pub type LPMSUSP_W < 'a > = crate :: BitWriter < 'a , u16 , INTFLAG_SPEC , bool , 9 > ; impl R { # [doc = "Bit 0 - Suspend"]
# [inline (always)]
pub fn suspend (& self) -> SUSPEND_R { SUSPEND_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Micro Start of Frame in High Speed Mode"]
# [inline (always)]
pub fn msof (& self) -> MSOF_R { MSOF_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Start Of Frame"]
# [inline (always)]
pub fn sof (& self) -> SOF_R { SOF_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - End of Reset"]
# [inline (always)]
pub fn eorst (& self) -> EORST_R { EORST_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Wake Up"]
# [inline (always)]
pub fn wakeup (& self) -> WAKEUP_R { WAKEUP_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - End Of Resume"]
# [inline (always)]
pub fn eorsm (& self) -> EORSM_R { EORSM_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Upstream Resume"]
# [inline (always)]
pub fn uprsm (& self) -> UPRSM_R { UPRSM_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Ram Access"]
# [inline (always)]
pub fn ramacer (& self) -> RAMACER_R { RAMACER_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Link Power Management Not Yet"]
# [inline (always)]
pub fn lpmnyet (& self) -> LPMNYET_R { LPMNYET_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Link Power Management Suspend"]
# [inline (always)]
pub fn lpmsusp (& self) -> LPMSUSP_R { LPMSUSP_R :: new (((self . bits >> 9) & 1) != 0) } } impl W { # [doc = "Bit 0 - Suspend"]
# [inline (always)]
pub fn suspend (& mut self) -> SUSPEND_W { SUSPEND_W :: new (self) } # [doc = "Bit 1 - Micro Start of Frame in High Speed Mode"]
# [inline (always)]
pub fn msof (& mut self) -> MSOF_W { MSOF_W :: new (self) } # [doc = "Bit 2 - Start Of Frame"]
# [inline (always)]
pub fn sof (& mut self) -> SOF_W { SOF_W :: new (self) } # [doc = "Bit 3 - End of Reset"]
# [inline (always)]
pub fn eorst (& mut self) -> EORST_W { EORST_W :: new (self) } # [doc = "Bit 4 - Wake Up"]
# [inline (always)]
pub fn wakeup (& mut self) -> WAKEUP_W { WAKEUP_W :: new (self) } # [doc = "Bit 5 - End Of Resume"]
# [inline (always)]
pub fn eorsm (& mut self) -> EORSM_W { EORSM_W :: new (self) } # [doc = "Bit 6 - Upstream Resume"]
# [inline (always)]
pub fn uprsm (& mut self) -> UPRSM_W { UPRSM_W :: new (self) } # [doc = "Bit 7 - Ram Access"]
# [inline (always)]
pub fn ramacer (& mut self) -> RAMACER_W { RAMACER_W :: new (self) } # [doc = "Bit 8 - Link Power Management Not Yet"]
# [inline (always)]
pub fn lpmnyet (& mut self) -> LPMNYET_W { LPMNYET_W :: new (self) } # [doc = "Bit 9 - Link Power Management Suspend"]
# [inline (always)]
pub fn lpmsusp (& mut self) -> LPMSUSP_W { LPMSUSP_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "DEVICE Device Interrupt Flag\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflag](index.html) module"]
pub struct INTFLAG_SPEC ; impl crate :: RegisterSpec for INTFLAG_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [intflag::R](R) reader structure"]
impl crate :: Readable for INTFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflag::W](W) writer structure"]
impl crate :: Writable for INTFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTFLAG to value 0"]
impl crate :: Resettable for INTFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "EPINTSMRY register accessor: an alias for `Reg<EPINTSMRY_SPEC>`"]
pub type EPINTSMRY = crate :: Reg < epintsmry :: EPINTSMRY_SPEC > ; # [doc = "DEVICE End Point Interrupt Summary"]
pub mod epintsmry { # [doc = "Register `EPINTSMRY` reader"]
pub struct R (crate :: R < EPINTSMRY_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EPINTSMRY_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EPINTSMRY_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EPINTSMRY_SPEC >) -> Self { R (reader) } } # [doc = "Field `EPINT0` reader - End Point 0 Interrupt"]
pub type EPINT0_R = crate :: BitReader < bool > ; # [doc = "Field `EPINT1` reader - End Point 1 Interrupt"]
pub type EPINT1_R = crate :: BitReader < bool > ; # [doc = "Field `EPINT2` reader - End Point 2 Interrupt"]
pub type EPINT2_R = crate :: BitReader < bool > ; # [doc = "Field `EPINT3` reader - End Point 3 Interrupt"]
pub type EPINT3_R = crate :: BitReader < bool > ; # [doc = "Field `EPINT4` reader - End Point 4 Interrupt"]
pub type EPINT4_R = crate :: BitReader < bool > ; # [doc = "Field `EPINT5` reader - End Point 5 Interrupt"]
pub type EPINT5_R = crate :: BitReader < bool > ; # [doc = "Field `EPINT6` reader - End Point 6 Interrupt"]
pub type EPINT6_R = crate :: BitReader < bool > ; # [doc = "Field `EPINT7` reader - End Point 7 Interrupt"]
pub type EPINT7_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - End Point 0 Interrupt"]
# [inline (always)]
pub fn epint0 (& self) -> EPINT0_R { EPINT0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - End Point 1 Interrupt"]
# [inline (always)]
pub fn epint1 (& self) -> EPINT1_R { EPINT1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - End Point 2 Interrupt"]
# [inline (always)]
pub fn epint2 (& self) -> EPINT2_R { EPINT2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - End Point 3 Interrupt"]
# [inline (always)]
pub fn epint3 (& self) -> EPINT3_R { EPINT3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - End Point 4 Interrupt"]
# [inline (always)]
pub fn epint4 (& self) -> EPINT4_R { EPINT4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - End Point 5 Interrupt"]
# [inline (always)]
pub fn epint5 (& self) -> EPINT5_R { EPINT5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - End Point 6 Interrupt"]
# [inline (always)]
pub fn epint6 (& self) -> EPINT6_R { EPINT6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - End Point 7 Interrupt"]
# [inline (always)]
pub fn epint7 (& self) -> EPINT7_R { EPINT7_R :: new (((self . bits >> 7) & 1) != 0) } } # [doc = "DEVICE End Point Interrupt Summary\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [epintsmry](index.html) module"]
pub struct EPINTSMRY_SPEC ; impl crate :: RegisterSpec for EPINTSMRY_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [epintsmry::R](R) reader structure"]
impl crate :: Readable for EPINTSMRY_SPEC { type Reader = R ; } # [doc = "`reset()` method sets EPINTSMRY to value 0"]
impl crate :: Resettable for EPINTSMRY_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DESCADD register accessor: an alias for `Reg<DESCADD_SPEC>`"]
pub type DESCADD = crate :: Reg < descadd :: DESCADD_SPEC > ; # [doc = "Descriptor Address"]
pub mod descadd { # [doc = "Register `DESCADD` reader"]
pub struct R (crate :: R < DESCADD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DESCADD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DESCADD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DESCADD_SPEC >) -> Self { R (reader) } } # [doc = "Register `DESCADD` writer"]
pub struct W (crate :: W < DESCADD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DESCADD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DESCADD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DESCADD_SPEC >) -> Self { W (writer) } } # [doc = "Field `DESCADD` reader - Descriptor Address Value"]
pub type DESCADD_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `DESCADD` writer - Descriptor Address Value"]
pub type DESCADD_W < 'a > = crate :: FieldWriter < 'a , u32 , DESCADD_SPEC , u32 , u32 , 32 , 0 > ; impl R { # [doc = "Bits 0:31 - Descriptor Address Value"]
# [inline (always)]
pub fn descadd (& self) -> DESCADD_R { DESCADD_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Descriptor Address Value"]
# [inline (always)]
pub fn descadd (& mut self) -> DESCADD_W { DESCADD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Descriptor Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [descadd](index.html) module"]
pub struct DESCADD_SPEC ; impl crate :: RegisterSpec for DESCADD_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [descadd::R](R) reader structure"]
impl crate :: Readable for DESCADD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [descadd::W](W) writer structure"]
impl crate :: Writable for DESCADD_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DESCADD to value 0"]
impl crate :: Resettable for DESCADD_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PADCAL register accessor: an alias for `Reg<PADCAL_SPEC>`"]
pub type PADCAL = crate :: Reg < padcal :: PADCAL_SPEC > ; # [doc = "USB PAD Calibration"]
pub mod padcal { # [doc = "Register `PADCAL` reader"]
pub struct R (crate :: R < PADCAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PADCAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PADCAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PADCAL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PADCAL` writer"]
pub struct W (crate :: W < PADCAL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PADCAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PADCAL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PADCAL_SPEC >) -> Self { W (writer) } } # [doc = "Field `TRANSP` reader - USB Pad Transp calibration"]
pub type TRANSP_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `TRANSP` writer - USB Pad Transp calibration"]
pub type TRANSP_W < 'a > = crate :: FieldWriter < 'a , u16 , PADCAL_SPEC , u8 , u8 , 5 , 0 > ; # [doc = "Field `TRANSN` reader - USB Pad Transn calibration"]
pub type TRANSN_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `TRANSN` writer - USB Pad Transn calibration"]
pub type TRANSN_W < 'a > = crate :: FieldWriter < 'a , u16 , PADCAL_SPEC , u8 , u8 , 5 , 6 > ; # [doc = "Field `TRIM` reader - USB Pad Trim calibration"]
pub type TRIM_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `TRIM` writer - USB Pad Trim calibration"]
pub type TRIM_W < 'a > = crate :: FieldWriter < 'a , u16 , PADCAL_SPEC , u8 , u8 , 3 , 12 > ; impl R { # [doc = "Bits 0:4 - USB Pad Transp calibration"]
# [inline (always)]
pub fn transp (& self) -> TRANSP_R { TRANSP_R :: new ((self . bits & 0x1f) as u8) } # [doc = "Bits 6:10 - USB Pad Transn calibration"]
# [inline (always)]
pub fn transn (& self) -> TRANSN_R { TRANSN_R :: new (((self . bits >> 6) & 0x1f) as u8) } # [doc = "Bits 12:14 - USB Pad Trim calibration"]
# [inline (always)]
pub fn trim (& self) -> TRIM_R { TRIM_R :: new (((self . bits >> 12) & 7) as u8) } } impl W { # [doc = "Bits 0:4 - USB Pad Transp calibration"]
# [inline (always)]
pub fn transp (& mut self) -> TRANSP_W { TRANSP_W :: new (self) } # [doc = "Bits 6:10 - USB Pad Transn calibration"]
# [inline (always)]
pub fn transn (& mut self) -> TRANSN_W { TRANSN_W :: new (self) } # [doc = "Bits 12:14 - USB Pad Trim calibration"]
# [inline (always)]
pub fn trim (& mut self) -> TRIM_W { TRIM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USB PAD Calibration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [padcal](index.html) module"]
pub struct PADCAL_SPEC ; impl crate :: RegisterSpec for PADCAL_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [padcal::R](R) reader structure"]
impl crate :: Readable for PADCAL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [padcal::W](W) writer structure"]
impl crate :: Writable for PADCAL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PADCAL to value 0"]
impl crate :: Resettable for PADCAL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "EPCFG register accessor: an alias for `Reg<EPCFG_SPEC>`"]
pub type EPCFG = crate :: Reg < epcfg :: EPCFG_SPEC > ; # [doc = "DEVICE End Point Configuration"]
pub mod epcfg { # [doc = "Register `EPCFG%s` reader"]
pub struct R (crate :: R < EPCFG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EPCFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EPCFG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EPCFG_SPEC >) -> Self { R (reader) } } # [doc = "Register `EPCFG%s` writer"]
pub struct W (crate :: W < EPCFG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EPCFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EPCFG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EPCFG_SPEC >) -> Self { W (writer) } } # [doc = "Field `EPTYPE0` reader - End Point Type0"]
pub type EPTYPE0_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `EPTYPE0` writer - End Point Type0"]
pub type EPTYPE0_W < 'a > = crate :: FieldWriter < 'a , u8 , EPCFG_SPEC , u8 , u8 , 3 , 0 > ; # [doc = "Field `EPTYPE1` reader - End Point Type1"]
pub type EPTYPE1_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `EPTYPE1` writer - End Point Type1"]
pub type EPTYPE1_W < 'a > = crate :: FieldWriter < 'a , u8 , EPCFG_SPEC , u8 , u8 , 3 , 4 > ; # [doc = "Field `NYETDIS` reader - NYET Token Disable"]
pub type NYETDIS_R = crate :: BitReader < bool > ; # [doc = "Field `NYETDIS` writer - NYET Token Disable"]
pub type NYETDIS_W < 'a > = crate :: BitWriter < 'a , u8 , EPCFG_SPEC , bool , 7 > ; impl R { # [doc = "Bits 0:2 - End Point Type0"]
# [inline (always)]
pub fn eptype0 (& self) -> EPTYPE0_R { EPTYPE0_R :: new ((self . bits & 7) as u8) } # [doc = "Bits 4:6 - End Point Type1"]
# [inline (always)]
pub fn eptype1 (& self) -> EPTYPE1_R { EPTYPE1_R :: new (((self . bits >> 4) & 7) as u8) } # [doc = "Bit 7 - NYET Token Disable"]
# [inline (always)]
pub fn nyetdis (& self) -> NYETDIS_R { NYETDIS_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - End Point Type0"]
# [inline (always)]
pub fn eptype0 (& mut self) -> EPTYPE0_W { EPTYPE0_W :: new (self) } # [doc = "Bits 4:6 - End Point Type1"]
# [inline (always)]
pub fn eptype1 (& mut self) -> EPTYPE1_W { EPTYPE1_W :: new (self) } # [doc = "Bit 7 - NYET Token Disable"]
# [inline (always)]
pub fn nyetdis (& mut self) -> NYETDIS_W { NYETDIS_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "DEVICE End Point Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [epcfg](index.html) module"]
pub struct EPCFG_SPEC ; impl crate :: RegisterSpec for EPCFG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [epcfg::R](R) reader structure"]
impl crate :: Readable for EPCFG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [epcfg::W](W) writer structure"]
impl crate :: Writable for EPCFG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets EPCFG%s to value 0"]
impl crate :: Resettable for EPCFG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "EPSTATUSCLR register accessor: an alias for `Reg<EPSTATUSCLR_SPEC>`"]
pub type EPSTATUSCLR = crate :: Reg < epstatusclr :: EPSTATUSCLR_SPEC > ; # [doc = "DEVICE End Point Pipe Status Clear"]
pub mod epstatusclr { # [doc = "Register `EPSTATUSCLR%s` writer"]
pub struct W (crate :: W < EPSTATUSCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EPSTATUSCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EPSTATUSCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EPSTATUSCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `DTGLOUT` writer - Data Toggle OUT Clear"]
pub type DTGLOUT_W < 'a > = crate :: BitWriter < 'a , u8 , EPSTATUSCLR_SPEC , bool , 0 > ; # [doc = "Field `DTGLIN` writer - Data Toggle IN Clear"]
pub type DTGLIN_W < 'a > = crate :: BitWriter < 'a , u8 , EPSTATUSCLR_SPEC , bool , 1 > ; # [doc = "Field `CURBK` writer - Curren Bank Clear"]
pub type CURBK_W < 'a > = crate :: BitWriter < 'a , u8 , EPSTATUSCLR_SPEC , bool , 2 > ; # [doc = "Field `STALLRQ0` writer - Stall 0 Request Clear"]
pub type STALLRQ0_W < 'a > = crate :: BitWriter < 'a , u8 , EPSTATUSCLR_SPEC , bool , 4 > ; # [doc = "Field `STALLRQ1` writer - Stall 1 Request Clear"]
pub type STALLRQ1_W < 'a > = crate :: BitWriter < 'a , u8 , EPSTATUSCLR_SPEC , bool , 5 > ; # [doc = "Field `BK0RDY` writer - Bank 0 Ready Clear"]
pub type BK0RDY_W < 'a > = crate :: BitWriter < 'a , u8 , EPSTATUSCLR_SPEC , bool , 6 > ; # [doc = "Field `BK1RDY` writer - Bank 1 Ready Clear"]
pub type BK1RDY_W < 'a > = crate :: BitWriter < 'a , u8 , EPSTATUSCLR_SPEC , bool , 7 > ; impl W { # [doc = "Bit 0 - Data Toggle OUT Clear"]
# [inline (always)]
pub fn dtglout (& mut self) -> DTGLOUT_W { DTGLOUT_W :: new (self) } # [doc = "Bit 1 - Data Toggle IN Clear"]
# [inline (always)]
pub fn dtglin (& mut self) -> DTGLIN_W { DTGLIN_W :: new (self) } # [doc = "Bit 2 - Curren Bank Clear"]
# [inline (always)]
pub fn curbk (& mut self) -> CURBK_W { CURBK_W :: new (self) } # [doc = "Bit 4 - Stall 0 Request Clear"]
# [inline (always)]
pub fn stallrq0 (& mut self) -> STALLRQ0_W { STALLRQ0_W :: new (self) } # [doc = "Bit 5 - Stall 1 Request Clear"]
# [inline (always)]
pub fn stallrq1 (& mut self) -> STALLRQ1_W { STALLRQ1_W :: new (self) } # [doc = "Bit 6 - Bank 0 Ready Clear"]
# [inline (always)]
pub fn bk0rdy (& mut self) -> BK0RDY_W { BK0RDY_W :: new (self) } # [doc = "Bit 7 - Bank 1 Ready Clear"]
# [inline (always)]
pub fn bk1rdy (& mut self) -> BK1RDY_W { BK1RDY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "DEVICE End Point Pipe Status Clear\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [epstatusclr](index.html) module"]
pub struct EPSTATUSCLR_SPEC ; impl crate :: RegisterSpec for EPSTATUSCLR_SPEC { type Ux = u8 ; } # [doc = "`write(|w| ..)` method takes [epstatusclr::W](W) writer structure"]
impl crate :: Writable for EPSTATUSCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets EPSTATUSCLR%s to value 0"]
impl crate :: Resettable for EPSTATUSCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "EPSTATUSSET register accessor: an alias for `Reg<EPSTATUSSET_SPEC>`"]
pub type EPSTATUSSET = crate :: Reg < epstatusset :: EPSTATUSSET_SPEC > ; # [doc = "DEVICE End Point Pipe Status Set"]
pub mod epstatusset { # [doc = "Register `EPSTATUSSET%s` writer"]
pub struct W (crate :: W < EPSTATUSSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EPSTATUSSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EPSTATUSSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EPSTATUSSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `DTGLOUT` writer - Data Toggle OUT Set"]
pub type DTGLOUT_W < 'a > = crate :: BitWriter < 'a , u8 , EPSTATUSSET_SPEC , bool , 0 > ; # [doc = "Field `DTGLIN` writer - Data Toggle IN Set"]
pub type DTGLIN_W < 'a > = crate :: BitWriter < 'a , u8 , EPSTATUSSET_SPEC , bool , 1 > ; # [doc = "Field `CURBK` writer - Current Bank Set"]
pub type CURBK_W < 'a > = crate :: BitWriter < 'a , u8 , EPSTATUSSET_SPEC , bool , 2 > ; # [doc = "Field `STALLRQ0` writer - Stall 0 Request Set"]
pub type STALLRQ0_W < 'a > = crate :: BitWriter < 'a , u8 , EPSTATUSSET_SPEC , bool , 4 > ; # [doc = "Field `STALLRQ1` writer - Stall 1 Request Set"]
pub type STALLRQ1_W < 'a > = crate :: BitWriter < 'a , u8 , EPSTATUSSET_SPEC , bool , 5 > ; # [doc = "Field `BK0RDY` writer - Bank 0 Ready Set"]
pub type BK0RDY_W < 'a > = crate :: BitWriter < 'a , u8 , EPSTATUSSET_SPEC , bool , 6 > ; # [doc = "Field `BK1RDY` writer - Bank 1 Ready Set"]
pub type BK1RDY_W < 'a > = crate :: BitWriter < 'a , u8 , EPSTATUSSET_SPEC , bool , 7 > ; impl W { # [doc = "Bit 0 - Data Toggle OUT Set"]
# [inline (always)]
pub fn dtglout (& mut self) -> DTGLOUT_W { DTGLOUT_W :: new (self) } # [doc = "Bit 1 - Data Toggle IN Set"]
# [inline (always)]
pub fn dtglin (& mut self) -> DTGLIN_W { DTGLIN_W :: new (self) } # [doc = "Bit 2 - Current Bank Set"]
# [inline (always)]
pub fn curbk (& mut self) -> CURBK_W { CURBK_W :: new (self) } # [doc = "Bit 4 - Stall 0 Request Set"]
# [inline (always)]
pub fn stallrq0 (& mut self) -> STALLRQ0_W { STALLRQ0_W :: new (self) } # [doc = "Bit 5 - Stall 1 Request Set"]
# [inline (always)]
pub fn stallrq1 (& mut self) -> STALLRQ1_W { STALLRQ1_W :: new (self) } # [doc = "Bit 6 - Bank 0 Ready Set"]
# [inline (always)]
pub fn bk0rdy (& mut self) -> BK0RDY_W { BK0RDY_W :: new (self) } # [doc = "Bit 7 - Bank 1 Ready Set"]
# [inline (always)]
pub fn bk1rdy (& mut self) -> BK1RDY_W { BK1RDY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "DEVICE End Point Pipe Status Set\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [epstatusset](index.html) module"]
pub struct EPSTATUSSET_SPEC ; impl crate :: RegisterSpec for EPSTATUSSET_SPEC { type Ux = u8 ; } # [doc = "`write(|w| ..)` method takes [epstatusset::W](W) writer structure"]
impl crate :: Writable for EPSTATUSSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets EPSTATUSSET%s to value 0"]
impl crate :: Resettable for EPSTATUSSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "EPSTATUS register accessor: an alias for `Reg<EPSTATUS_SPEC>`"]
pub type EPSTATUS = crate :: Reg < epstatus :: EPSTATUS_SPEC > ; # [doc = "DEVICE End Point Pipe Status"]
pub mod epstatus { # [doc = "Register `EPSTATUS%s` reader"]
pub struct R (crate :: R < EPSTATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EPSTATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EPSTATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EPSTATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `DTGLOUT` reader - Data Toggle Out"]
pub type DTGLOUT_R = crate :: BitReader < bool > ; # [doc = "Field `DTGLIN` reader - Data Toggle In"]
pub type DTGLIN_R = crate :: BitReader < bool > ; # [doc = "Field `CURBK` reader - Current Bank"]
pub type CURBK_R = crate :: BitReader < bool > ; # [doc = "Field `STALLRQ0` reader - Stall 0 Request"]
pub type STALLRQ0_R = crate :: BitReader < bool > ; # [doc = "Field `STALLRQ1` reader - Stall 1 Request"]
pub type STALLRQ1_R = crate :: BitReader < bool > ; # [doc = "Field `BK0RDY` reader - Bank 0 ready"]
pub type BK0RDY_R = crate :: BitReader < bool > ; # [doc = "Field `BK1RDY` reader - Bank 1 ready"]
pub type BK1RDY_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Data Toggle Out"]
# [inline (always)]
pub fn dtglout (& self) -> DTGLOUT_R { DTGLOUT_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Data Toggle In"]
# [inline (always)]
pub fn dtglin (& self) -> DTGLIN_R { DTGLIN_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Current Bank"]
# [inline (always)]
pub fn curbk (& self) -> CURBK_R { CURBK_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 4 - Stall 0 Request"]
# [inline (always)]
pub fn stallrq0 (& self) -> STALLRQ0_R { STALLRQ0_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Stall 1 Request"]
# [inline (always)]
pub fn stallrq1 (& self) -> STALLRQ1_R { STALLRQ1_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Bank 0 ready"]
# [inline (always)]
pub fn bk0rdy (& self) -> BK0RDY_R { BK0RDY_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Bank 1 ready"]
# [inline (always)]
pub fn bk1rdy (& self) -> BK1RDY_R { BK1RDY_R :: new (((self . bits >> 7) & 1) != 0) } } # [doc = "DEVICE End Point Pipe Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [epstatus](index.html) module"]
pub struct EPSTATUS_SPEC ; impl crate :: RegisterSpec for EPSTATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [epstatus::R](R) reader structure"]
impl crate :: Readable for EPSTATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets EPSTATUS%s to value 0"]
impl crate :: Resettable for EPSTATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "EPINTFLAG register accessor: an alias for `Reg<EPINTFLAG_SPEC>`"]
pub type EPINTFLAG = crate :: Reg < epintflag :: EPINTFLAG_SPEC > ; # [doc = "DEVICE End Point Interrupt Flag"]
pub mod epintflag { # [doc = "Register `EPINTFLAG%s` reader"]
pub struct R (crate :: R < EPINTFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EPINTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EPINTFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EPINTFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `EPINTFLAG%s` writer"]
pub struct W (crate :: W < EPINTFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EPINTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EPINTFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EPINTFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `TRCPT0` reader - Transfer Complete 0"]
pub type TRCPT0_R = crate :: BitReader < bool > ; # [doc = "Field `TRCPT0` writer - Transfer Complete 0"]
pub type TRCPT0_W < 'a > = crate :: BitWriter < 'a , u8 , EPINTFLAG_SPEC , bool , 0 > ; # [doc = "Field `TRCPT1` reader - Transfer Complete 1"]
pub type TRCPT1_R = crate :: BitReader < bool > ; # [doc = "Field `TRCPT1` writer - Transfer Complete 1"]
pub type TRCPT1_W < 'a > = crate :: BitWriter < 'a , u8 , EPINTFLAG_SPEC , bool , 1 > ; # [doc = "Field `TRFAIL0` reader - Error Flow 0"]
pub type TRFAIL0_R = crate :: BitReader < bool > ; # [doc = "Field `TRFAIL0` writer - Error Flow 0"]
pub type TRFAIL0_W < 'a > = crate :: BitWriter < 'a , u8 , EPINTFLAG_SPEC , bool , 2 > ; # [doc = "Field `TRFAIL1` reader - Error Flow 1"]
pub type TRFAIL1_R = crate :: BitReader < bool > ; # [doc = "Field `TRFAIL1` writer - Error Flow 1"]
pub type TRFAIL1_W < 'a > = crate :: BitWriter < 'a , u8 , EPINTFLAG_SPEC , bool , 3 > ; # [doc = "Field `RXSTP` reader - Received Setup"]
pub type RXSTP_R = crate :: BitReader < bool > ; # [doc = "Field `RXSTP` writer - Received Setup"]
pub type RXSTP_W < 'a > = crate :: BitWriter < 'a , u8 , EPINTFLAG_SPEC , bool , 4 > ; # [doc = "Field `STALL0` reader - Stall 0 In/out"]
pub type STALL0_R = crate :: BitReader < bool > ; # [doc = "Field `STALL0` writer - Stall 0 In/out"]
pub type STALL0_W < 'a > = crate :: BitWriter < 'a , u8 , EPINTFLAG_SPEC , bool , 5 > ; # [doc = "Field `STALL1` reader - Stall 1 In/out"]
pub type STALL1_R = crate :: BitReader < bool > ; # [doc = "Field `STALL1` writer - Stall 1 In/out"]
pub type STALL1_W < 'a > = crate :: BitWriter < 'a , u8 , EPINTFLAG_SPEC , bool , 6 > ; impl R { # [doc = "Bit 0 - Transfer Complete 0"]
# [inline (always)]
pub fn trcpt0 (& self) -> TRCPT0_R { TRCPT0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Transfer Complete 1"]
# [inline (always)]
pub fn trcpt1 (& self) -> TRCPT1_R { TRCPT1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Error Flow 0"]
# [inline (always)]
pub fn trfail0 (& self) -> TRFAIL0_R { TRFAIL0_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Error Flow 1"]
# [inline (always)]
pub fn trfail1 (& self) -> TRFAIL1_R { TRFAIL1_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Received Setup"]
# [inline (always)]
pub fn rxstp (& self) -> RXSTP_R { RXSTP_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Stall 0 In/out"]
# [inline (always)]
pub fn stall0 (& self) -> STALL0_R { STALL0_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Stall 1 In/out"]
# [inline (always)]
pub fn stall1 (& self) -> STALL1_R { STALL1_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Transfer Complete 0"]
# [inline (always)]
pub fn trcpt0 (& mut self) -> TRCPT0_W { TRCPT0_W :: new (self) } # [doc = "Bit 1 - Transfer Complete 1"]
# [inline (always)]
pub fn trcpt1 (& mut self) -> TRCPT1_W { TRCPT1_W :: new (self) } # [doc = "Bit 2 - Error Flow 0"]
# [inline (always)]
pub fn trfail0 (& mut self) -> TRFAIL0_W { TRFAIL0_W :: new (self) } # [doc = "Bit 3 - Error Flow 1"]
# [inline (always)]
pub fn trfail1 (& mut self) -> TRFAIL1_W { TRFAIL1_W :: new (self) } # [doc = "Bit 4 - Received Setup"]
# [inline (always)]
pub fn rxstp (& mut self) -> RXSTP_W { RXSTP_W :: new (self) } # [doc = "Bit 5 - Stall 0 In/out"]
# [inline (always)]
pub fn stall0 (& mut self) -> STALL0_W { STALL0_W :: new (self) } # [doc = "Bit 6 - Stall 1 In/out"]
# [inline (always)]
pub fn stall1 (& mut self) -> STALL1_W { STALL1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "DEVICE End Point Interrupt Flag\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [epintflag](index.html) module"]
pub struct EPINTFLAG_SPEC ; impl crate :: RegisterSpec for EPINTFLAG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [epintflag::R](R) reader structure"]
impl crate :: Readable for EPINTFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [epintflag::W](W) writer structure"]
impl crate :: Writable for EPINTFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets EPINTFLAG%s to value 0"]
impl crate :: Resettable for EPINTFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "EPINTENCLR register accessor: an alias for `Reg<EPINTENCLR_SPEC>`"]
pub type EPINTENCLR = crate :: Reg < epintenclr :: EPINTENCLR_SPEC > ; # [doc = "DEVICE End Point Interrupt Clear Flag"]
pub mod epintenclr { # [doc = "Register `EPINTENCLR%s` reader"]
pub struct R (crate :: R < EPINTENCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EPINTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EPINTENCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EPINTENCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `EPINTENCLR%s` writer"]
pub struct W (crate :: W < EPINTENCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EPINTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EPINTENCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EPINTENCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `TRCPT0` reader - Transfer Complete 0 Interrupt Disable"]
pub type TRCPT0_R = crate :: BitReader < bool > ; # [doc = "Field `TRCPT0` writer - Transfer Complete 0 Interrupt Disable"]
pub type TRCPT0_W < 'a > = crate :: BitWriter < 'a , u8 , EPINTENCLR_SPEC , bool , 0 > ; # [doc = "Field `TRCPT1` reader - Transfer Complete 1 Interrupt Disable"]
pub type TRCPT1_R = crate :: BitReader < bool > ; # [doc = "Field `TRCPT1` writer - Transfer Complete 1 Interrupt Disable"]
pub type TRCPT1_W < 'a > = crate :: BitWriter < 'a , u8 , EPINTENCLR_SPEC , bool , 1 > ; # [doc = "Field `TRFAIL0` reader - Error Flow 0 Interrupt Disable"]
pub type TRFAIL0_R = crate :: BitReader < bool > ; # [doc = "Field `TRFAIL0` writer - Error Flow 0 Interrupt Disable"]
pub type TRFAIL0_W < 'a > = crate :: BitWriter < 'a , u8 , EPINTENCLR_SPEC , bool , 2 > ; # [doc = "Field `TRFAIL1` reader - Error Flow 1 Interrupt Disable"]
pub type TRFAIL1_R = crate :: BitReader < bool > ; # [doc = "Field `TRFAIL1` writer - Error Flow 1 Interrupt Disable"]
pub type TRFAIL1_W < 'a > = crate :: BitWriter < 'a , u8 , EPINTENCLR_SPEC , bool , 3 > ; # [doc = "Field `RXSTP` reader - Received Setup Interrupt Disable"]
pub type RXSTP_R = crate :: BitReader < bool > ; # [doc = "Field `RXSTP` writer - Received Setup Interrupt Disable"]
pub type RXSTP_W < 'a > = crate :: BitWriter < 'a , u8 , EPINTENCLR_SPEC , bool , 4 > ; # [doc = "Field `STALL0` reader - Stall 0 In/Out Interrupt Disable"]
pub type STALL0_R = crate :: BitReader < bool > ; # [doc = "Field `STALL0` writer - Stall 0 In/Out Interrupt Disable"]
pub type STALL0_W < 'a > = crate :: BitWriter < 'a , u8 , EPINTENCLR_SPEC , bool , 5 > ; # [doc = "Field `STALL1` reader - Stall 1 In/Out Interrupt Disable"]
pub type STALL1_R = crate :: BitReader < bool > ; # [doc = "Field `STALL1` writer - Stall 1 In/Out Interrupt Disable"]
pub type STALL1_W < 'a > = crate :: BitWriter < 'a , u8 , EPINTENCLR_SPEC , bool , 6 > ; impl R { # [doc = "Bit 0 - Transfer Complete 0 Interrupt Disable"]
# [inline (always)]
pub fn trcpt0 (& self) -> TRCPT0_R { TRCPT0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Transfer Complete 1 Interrupt Disable"]
# [inline (always)]
pub fn trcpt1 (& self) -> TRCPT1_R { TRCPT1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Error Flow 0 Interrupt Disable"]
# [inline (always)]
pub fn trfail0 (& self) -> TRFAIL0_R { TRFAIL0_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Error Flow 1 Interrupt Disable"]
# [inline (always)]
pub fn trfail1 (& self) -> TRFAIL1_R { TRFAIL1_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Received Setup Interrupt Disable"]
# [inline (always)]
pub fn rxstp (& self) -> RXSTP_R { RXSTP_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Stall 0 In/Out Interrupt Disable"]
# [inline (always)]
pub fn stall0 (& self) -> STALL0_R { STALL0_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Stall 1 In/Out Interrupt Disable"]
# [inline (always)]
pub fn stall1 (& self) -> STALL1_R { STALL1_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Transfer Complete 0 Interrupt Disable"]
# [inline (always)]
pub fn trcpt0 (& mut self) -> TRCPT0_W { TRCPT0_W :: new (self) } # [doc = "Bit 1 - Transfer Complete 1 Interrupt Disable"]
# [inline (always)]
pub fn trcpt1 (& mut self) -> TRCPT1_W { TRCPT1_W :: new (self) } # [doc = "Bit 2 - Error Flow 0 Interrupt Disable"]
# [inline (always)]
pub fn trfail0 (& mut self) -> TRFAIL0_W { TRFAIL0_W :: new (self) } # [doc = "Bit 3 - Error Flow 1 Interrupt Disable"]
# [inline (always)]
pub fn trfail1 (& mut self) -> TRFAIL1_W { TRFAIL1_W :: new (self) } # [doc = "Bit 4 - Received Setup Interrupt Disable"]
# [inline (always)]
pub fn rxstp (& mut self) -> RXSTP_W { RXSTP_W :: new (self) } # [doc = "Bit 5 - Stall 0 In/Out Interrupt Disable"]
# [inline (always)]
pub fn stall0 (& mut self) -> STALL0_W { STALL0_W :: new (self) } # [doc = "Bit 6 - Stall 1 In/Out Interrupt Disable"]
# [inline (always)]
pub fn stall1 (& mut self) -> STALL1_W { STALL1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "DEVICE End Point Interrupt Clear Flag\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [epintenclr](index.html) module"]
pub struct EPINTENCLR_SPEC ; impl crate :: RegisterSpec for EPINTENCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [epintenclr::R](R) reader structure"]
impl crate :: Readable for EPINTENCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [epintenclr::W](W) writer structure"]
impl crate :: Writable for EPINTENCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets EPINTENCLR%s to value 0"]
impl crate :: Resettable for EPINTENCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "EPINTENSET register accessor: an alias for `Reg<EPINTENSET_SPEC>`"]
pub type EPINTENSET = crate :: Reg < epintenset :: EPINTENSET_SPEC > ; # [doc = "DEVICE End Point Interrupt Set Flag"]
pub mod epintenset { # [doc = "Register `EPINTENSET%s` reader"]
pub struct R (crate :: R < EPINTENSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EPINTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EPINTENSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EPINTENSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `EPINTENSET%s` writer"]
pub struct W (crate :: W < EPINTENSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EPINTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EPINTENSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EPINTENSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `TRCPT0` reader - Transfer Complete 0 Interrupt Enable"]
pub type TRCPT0_R = crate :: BitReader < bool > ; # [doc = "Field `TRCPT0` writer - Transfer Complete 0 Interrupt Enable"]
pub type TRCPT0_W < 'a > = crate :: BitWriter < 'a , u8 , EPINTENSET_SPEC , bool , 0 > ; # [doc = "Field `TRCPT1` reader - Transfer Complete 1 Interrupt Enable"]
pub type TRCPT1_R = crate :: BitReader < bool > ; # [doc = "Field `TRCPT1` writer - Transfer Complete 1 Interrupt Enable"]
pub type TRCPT1_W < 'a > = crate :: BitWriter < 'a , u8 , EPINTENSET_SPEC , bool , 1 > ; # [doc = "Field `TRFAIL0` reader - Error Flow 0 Interrupt Enable"]
pub type TRFAIL0_R = crate :: BitReader < bool > ; # [doc = "Field `TRFAIL0` writer - Error Flow 0 Interrupt Enable"]
pub type TRFAIL0_W < 'a > = crate :: BitWriter < 'a , u8 , EPINTENSET_SPEC , bool , 2 > ; # [doc = "Field `TRFAIL1` reader - Error Flow 1 Interrupt Enable"]
pub type TRFAIL1_R = crate :: BitReader < bool > ; # [doc = "Field `TRFAIL1` writer - Error Flow 1 Interrupt Enable"]
pub type TRFAIL1_W < 'a > = crate :: BitWriter < 'a , u8 , EPINTENSET_SPEC , bool , 3 > ; # [doc = "Field `RXSTP` reader - Received Setup Interrupt Enable"]
pub type RXSTP_R = crate :: BitReader < bool > ; # [doc = "Field `RXSTP` writer - Received Setup Interrupt Enable"]
pub type RXSTP_W < 'a > = crate :: BitWriter < 'a , u8 , EPINTENSET_SPEC , bool , 4 > ; # [doc = "Field `STALL0` reader - Stall 0 In/out Interrupt enable"]
pub type STALL0_R = crate :: BitReader < bool > ; # [doc = "Field `STALL0` writer - Stall 0 In/out Interrupt enable"]
pub type STALL0_W < 'a > = crate :: BitWriter < 'a , u8 , EPINTENSET_SPEC , bool , 5 > ; # [doc = "Field `STALL1` reader - Stall 1 In/out Interrupt enable"]
pub type STALL1_R = crate :: BitReader < bool > ; # [doc = "Field `STALL1` writer - Stall 1 In/out Interrupt enable"]
pub type STALL1_W < 'a > = crate :: BitWriter < 'a , u8 , EPINTENSET_SPEC , bool , 6 > ; impl R { # [doc = "Bit 0 - Transfer Complete 0 Interrupt Enable"]
# [inline (always)]
pub fn trcpt0 (& self) -> TRCPT0_R { TRCPT0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Transfer Complete 1 Interrupt Enable"]
# [inline (always)]
pub fn trcpt1 (& self) -> TRCPT1_R { TRCPT1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Error Flow 0 Interrupt Enable"]
# [inline (always)]
pub fn trfail0 (& self) -> TRFAIL0_R { TRFAIL0_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Error Flow 1 Interrupt Enable"]
# [inline (always)]
pub fn trfail1 (& self) -> TRFAIL1_R { TRFAIL1_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Received Setup Interrupt Enable"]
# [inline (always)]
pub fn rxstp (& self) -> RXSTP_R { RXSTP_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Stall 0 In/out Interrupt enable"]
# [inline (always)]
pub fn stall0 (& self) -> STALL0_R { STALL0_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Stall 1 In/out Interrupt enable"]
# [inline (always)]
pub fn stall1 (& self) -> STALL1_R { STALL1_R :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Transfer Complete 0 Interrupt Enable"]
# [inline (always)]
pub fn trcpt0 (& mut self) -> TRCPT0_W { TRCPT0_W :: new (self) } # [doc = "Bit 1 - Transfer Complete 1 Interrupt Enable"]
# [inline (always)]
pub fn trcpt1 (& mut self) -> TRCPT1_W { TRCPT1_W :: new (self) } # [doc = "Bit 2 - Error Flow 0 Interrupt Enable"]
# [inline (always)]
pub fn trfail0 (& mut self) -> TRFAIL0_W { TRFAIL0_W :: new (self) } # [doc = "Bit 3 - Error Flow 1 Interrupt Enable"]
# [inline (always)]
pub fn trfail1 (& mut self) -> TRFAIL1_W { TRFAIL1_W :: new (self) } # [doc = "Bit 4 - Received Setup Interrupt Enable"]
# [inline (always)]
pub fn rxstp (& mut self) -> RXSTP_W { RXSTP_W :: new (self) } # [doc = "Bit 5 - Stall 0 In/out Interrupt enable"]
# [inline (always)]
pub fn stall0 (& mut self) -> STALL0_W { STALL0_W :: new (self) } # [doc = "Bit 6 - Stall 1 In/out Interrupt enable"]
# [inline (always)]
pub fn stall1 (& mut self) -> STALL1_W { STALL1_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "DEVICE End Point Interrupt Set Flag\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [epintenset](index.html) module"]
pub struct EPINTENSET_SPEC ; impl crate :: RegisterSpec for EPINTENSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [epintenset::R](R) reader structure"]
impl crate :: Readable for EPINTENSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [epintenset::W](W) writer structure"]
impl crate :: Writable for EPINTENSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets EPINTENSET%s to value 0"]
impl crate :: Resettable for EPINTENSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [doc = r"Register block"]
# [repr (C)]
pub struct HOST { # [doc = "0x00 - Control A"]
pub ctrla : crate :: Reg < self :: host :: ctrla :: CTRLA_SPEC > , _reserved1 : [u8 ; 0x01]
, # [doc = "0x02 - Synchronization Busy"]
pub syncbusy : crate :: Reg < self :: host :: syncbusy :: SYNCBUSY_SPEC > , # [doc = "0x03 - USB Quality Of Service"]
pub qosctrl : crate :: Reg < self :: host :: qosctrl :: QOSCTRL_SPEC > , _reserved3 : [u8 ; 0x04]
, # [doc = "0x08 - HOST Control B"]
pub ctrlb : crate :: Reg < self :: host :: ctrlb :: CTRLB_SPEC > , # [doc = "0x0a - HOST Host Start Of Frame Control"]
pub hsofc : crate :: Reg < self :: host :: hsofc :: HSOFC_SPEC > , _reserved5 : [u8 ; 0x01]
, # [doc = "0x0c - HOST Status"]
pub status : crate :: Reg < self :: host :: status :: STATUS_SPEC > , # [doc = "0x0d - Finite State Machine Status"]
pub fsmstatus : crate :: Reg < self :: host :: fsmstatus :: FSMSTATUS_SPEC > , _reserved7 : [u8 ; 0x02]
, # [doc = "0x10 - HOST Host Frame Number"]
pub fnum : crate :: Reg < self :: host :: fnum :: FNUM_SPEC > , # [doc = "0x12 - HOST Host Frame Length"]
pub flenhigh : crate :: Reg < self :: host :: flenhigh :: FLENHIGH_SPEC > , _reserved9 : [u8 ; 0x01]
, # [doc = "0x14 - HOST Host Interrupt Enable Clear"]
pub intenclr : crate :: Reg < self :: host :: intenclr :: INTENCLR_SPEC > , _reserved10 : [u8 ; 0x02]
, # [doc = "0x18 - HOST Host Interrupt Enable Set"]
pub intenset : crate :: Reg < self :: host :: intenset :: INTENSET_SPEC > , _reserved11 : [u8 ; 0x02]
, # [doc = "0x1c - HOST Host Interrupt Flag"]
pub intflag : crate :: Reg < self :: host :: intflag :: INTFLAG_SPEC > , _reserved12 : [u8 ; 0x02]
, # [doc = "0x20 - HOST Pipe Interrupt Summary"]
pub pintsmry : crate :: Reg < self :: host :: pintsmry :: PINTSMRY_SPEC > , _reserved13 : [u8 ; 0x02]
, # [doc = "0x24 - Descriptor Address"]
pub descadd : crate :: Reg < self :: host :: descadd :: DESCADD_SPEC > , # [doc = "0x28 - USB PAD Calibration"]
pub padcal : crate :: Reg < self :: host :: padcal :: PADCAL_SPEC > , _reserved15 : [u8 ; 0xd6]
, # [doc = "0x100 - HOST End Point Configuration"]
pub pcfg0 : crate :: Reg < self :: host :: pcfg :: PCFG_SPEC > , _reserved16 : [u8 ; 0x02]
, # [doc = "0x103 - HOST Bus Access Period of Pipe"]
pub binterval0 : crate :: Reg < self :: host :: binterval :: BINTERVAL_SPEC > , # [doc = "0x104 - HOST End Point Pipe Status Clear"]
pub pstatusclr0 : crate :: Reg < self :: host :: pstatusclr :: PSTATUSCLR_SPEC > , # [doc = "0x105 - HOST End Point Pipe Status Set"]
pub pstatusset0 : crate :: Reg < self :: host :: pstatusset :: PSTATUSSET_SPEC > , # [doc = "0x106 - HOST End Point Pipe Status"]
pub pstatus0 : crate :: Reg < self :: host :: pstatus :: PSTATUS_SPEC > , # [doc = "0x107 - HOST Pipe Interrupt Flag"]
pub pintflag0 : crate :: Reg < self :: host :: pintflag :: PINTFLAG_SPEC > , # [doc = "0x108 - HOST Pipe Interrupt Flag Clear"]
pub pintenclr0 : crate :: Reg < self :: host :: pintenclr :: PINTENCLR_SPEC > , # [doc = "0x109 - HOST Pipe Interrupt Flag Set"]
pub pintenset0 : crate :: Reg < self :: host :: pintenset :: PINTENSET_SPEC > , _reserved23 : [u8 ; 0x16]
, # [doc = "0x120 - HOST End Point Configuration"]
pub pcfg1 : crate :: Reg < self :: host :: pcfg :: PCFG_SPEC > , _reserved24 : [u8 ; 0x02]
, # [doc = "0x123 - HOST Bus Access Period of Pipe"]
pub binterval1 : crate :: Reg < self :: host :: binterval :: BINTERVAL_SPEC > , # [doc = "0x124 - HOST End Point Pipe Status Clear"]
pub pstatusclr1 : crate :: Reg < self :: host :: pstatusclr :: PSTATUSCLR_SPEC > , # [doc = "0x125 - HOST End Point Pipe Status Set"]
pub pstatusset1 : crate :: Reg < self :: host :: pstatusset :: PSTATUSSET_SPEC > , # [doc = "0x126 - HOST End Point Pipe Status"]
pub pstatus1 : crate :: Reg < self :: host :: pstatus :: PSTATUS_SPEC > , # [doc = "0x127 - HOST Pipe Interrupt Flag"]
pub pintflag1 : crate :: Reg < self :: host :: pintflag :: PINTFLAG_SPEC > , # [doc = "0x128 - HOST Pipe Interrupt Flag Clear"]
pub pintenclr1 : crate :: Reg < self :: host :: pintenclr :: PINTENCLR_SPEC > , # [doc = "0x129 - HOST Pipe Interrupt Flag Set"]
pub pintenset1 : crate :: Reg < self :: host :: pintenset :: PINTENSET_SPEC > , _reserved31 : [u8 ; 0x16]
, # [doc = "0x140 - HOST End Point Configuration"]
pub pcfg2 : crate :: Reg < self :: host :: pcfg :: PCFG_SPEC > , _reserved32 : [u8 ; 0x02]
, # [doc = "0x143 - HOST Bus Access Period of Pipe"]
pub binterval2 : crate :: Reg < self :: host :: binterval :: BINTERVAL_SPEC > , # [doc = "0x144 - HOST End Point Pipe Status Clear"]
pub pstatusclr2 : crate :: Reg < self :: host :: pstatusclr :: PSTATUSCLR_SPEC > , # [doc = "0x145 - HOST End Point Pipe Status Set"]
pub pstatusset2 : crate :: Reg < self :: host :: pstatusset :: PSTATUSSET_SPEC > , # [doc = "0x146 - HOST End Point Pipe Status"]
pub pstatus2 : crate :: Reg < self :: host :: pstatus :: PSTATUS_SPEC > , # [doc = "0x147 - HOST Pipe Interrupt Flag"]
pub pintflag2 : crate :: Reg < self :: host :: pintflag :: PINTFLAG_SPEC > , # [doc = "0x148 - HOST Pipe Interrupt Flag Clear"]
pub pintenclr2 : crate :: Reg < self :: host :: pintenclr :: PINTENCLR_SPEC > , # [doc = "0x149 - HOST Pipe Interrupt Flag Set"]
pub pintenset2 : crate :: Reg < self :: host :: pintenset :: PINTENSET_SPEC > , _reserved39 : [u8 ; 0x16]
, # [doc = "0x160 - HOST End Point Configuration"]
pub pcfg3 : crate :: Reg < self :: host :: pcfg :: PCFG_SPEC > , _reserved40 : [u8 ; 0x02]
, # [doc = "0x163 - HOST Bus Access Period of Pipe"]
pub binterval3 : crate :: Reg < self :: host :: binterval :: BINTERVAL_SPEC > , # [doc = "0x164 - HOST End Point Pipe Status Clear"]
pub pstatusclr3 : crate :: Reg < self :: host :: pstatusclr :: PSTATUSCLR_SPEC > , # [doc = "0x165 - HOST End Point Pipe Status Set"]
pub pstatusset3 : crate :: Reg < self :: host :: pstatusset :: PSTATUSSET_SPEC > , # [doc = "0x166 - HOST End Point Pipe Status"]
pub pstatus3 : crate :: Reg < self :: host :: pstatus :: PSTATUS_SPEC > , # [doc = "0x167 - HOST Pipe Interrupt Flag"]
pub pintflag3 : crate :: Reg < self :: host :: pintflag :: PINTFLAG_SPEC > , # [doc = "0x168 - HOST Pipe Interrupt Flag Clear"]
pub pintenclr3 : crate :: Reg < self :: host :: pintenclr :: PINTENCLR_SPEC > , # [doc = "0x169 - HOST Pipe Interrupt Flag Set"]
pub pintenset3 : crate :: Reg < self :: host :: pintenset :: PINTENSET_SPEC > , _reserved47 : [u8 ; 0x16]
, # [doc = "0x180 - HOST End Point Configuration"]
pub pcfg4 : crate :: Reg < self :: host :: pcfg :: PCFG_SPEC > , _reserved48 : [u8 ; 0x02]
, # [doc = "0x183 - HOST Bus Access Period of Pipe"]
pub binterval4 : crate :: Reg < self :: host :: binterval :: BINTERVAL_SPEC > , # [doc = "0x184 - HOST End Point Pipe Status Clear"]
pub pstatusclr4 : crate :: Reg < self :: host :: pstatusclr :: PSTATUSCLR_SPEC > , # [doc = "0x185 - HOST End Point Pipe Status Set"]
pub pstatusset4 : crate :: Reg < self :: host :: pstatusset :: PSTATUSSET_SPEC > , # [doc = "0x186 - HOST End Point Pipe Status"]
pub pstatus4 : crate :: Reg < self :: host :: pstatus :: PSTATUS_SPEC > , # [doc = "0x187 - HOST Pipe Interrupt Flag"]
pub pintflag4 : crate :: Reg < self :: host :: pintflag :: PINTFLAG_SPEC > , # [doc = "0x188 - HOST Pipe Interrupt Flag Clear"]
pub pintenclr4 : crate :: Reg < self :: host :: pintenclr :: PINTENCLR_SPEC > , # [doc = "0x189 - HOST Pipe Interrupt Flag Set"]
pub pintenset4 : crate :: Reg < self :: host :: pintenset :: PINTENSET_SPEC > , _reserved55 : [u8 ; 0x16]
, # [doc = "0x1a0 - HOST End Point Configuration"]
pub pcfg5 : crate :: Reg < self :: host :: pcfg :: PCFG_SPEC > , _reserved56 : [u8 ; 0x02]
, # [doc = "0x1a3 - HOST Bus Access Period of Pipe"]
pub binterval5 : crate :: Reg < self :: host :: binterval :: BINTERVAL_SPEC > , # [doc = "0x1a4 - HOST End Point Pipe Status Clear"]
pub pstatusclr5 : crate :: Reg < self :: host :: pstatusclr :: PSTATUSCLR_SPEC > , # [doc = "0x1a5 - HOST End Point Pipe Status Set"]
pub pstatusset5 : crate :: Reg < self :: host :: pstatusset :: PSTATUSSET_SPEC > , # [doc = "0x1a6 - HOST End Point Pipe Status"]
pub pstatus5 : crate :: Reg < self :: host :: pstatus :: PSTATUS_SPEC > , # [doc = "0x1a7 - HOST Pipe Interrupt Flag"]
pub pintflag5 : crate :: Reg < self :: host :: pintflag :: PINTFLAG_SPEC > , # [doc = "0x1a8 - HOST Pipe Interrupt Flag Clear"]
pub pintenclr5 : crate :: Reg < self :: host :: pintenclr :: PINTENCLR_SPEC > , # [doc = "0x1a9 - HOST Pipe Interrupt Flag Set"]
pub pintenset5 : crate :: Reg < self :: host :: pintenset :: PINTENSET_SPEC > , _reserved63 : [u8 ; 0x16]
, # [doc = "0x1c0 - HOST End Point Configuration"]
pub pcfg6 : crate :: Reg < self :: host :: pcfg :: PCFG_SPEC > , _reserved64 : [u8 ; 0x02]
, # [doc = "0x1c3 - HOST Bus Access Period of Pipe"]
pub binterval6 : crate :: Reg < self :: host :: binterval :: BINTERVAL_SPEC > , # [doc = "0x1c4 - HOST End Point Pipe Status Clear"]
pub pstatusclr6 : crate :: Reg < self :: host :: pstatusclr :: PSTATUSCLR_SPEC > , # [doc = "0x1c5 - HOST End Point Pipe Status Set"]
pub pstatusset6 : crate :: Reg < self :: host :: pstatusset :: PSTATUSSET_SPEC > , # [doc = "0x1c6 - HOST End Point Pipe Status"]
pub pstatus6 : crate :: Reg < self :: host :: pstatus :: PSTATUS_SPEC > , # [doc = "0x1c7 - HOST Pipe Interrupt Flag"]
pub pintflag6 : crate :: Reg < self :: host :: pintflag :: PINTFLAG_SPEC > , # [doc = "0x1c8 - HOST Pipe Interrupt Flag Clear"]
pub pintenclr6 : crate :: Reg < self :: host :: pintenclr :: PINTENCLR_SPEC > , # [doc = "0x1c9 - HOST Pipe Interrupt Flag Set"]
pub pintenset6 : crate :: Reg < self :: host :: pintenset :: PINTENSET_SPEC > , _reserved71 : [u8 ; 0x16]
, # [doc = "0x1e0 - HOST End Point Configuration"]
pub pcfg7 : crate :: Reg < self :: host :: pcfg :: PCFG_SPEC > , _reserved72 : [u8 ; 0x02]
, # [doc = "0x1e3 - HOST Bus Access Period of Pipe"]
pub binterval7 : crate :: Reg < self :: host :: binterval :: BINTERVAL_SPEC > , # [doc = "0x1e4 - HOST End Point Pipe Status Clear"]
pub pstatusclr7 : crate :: Reg < self :: host :: pstatusclr :: PSTATUSCLR_SPEC > , # [doc = "0x1e5 - HOST End Point Pipe Status Set"]
pub pstatusset7 : crate :: Reg < self :: host :: pstatusset :: PSTATUSSET_SPEC > , # [doc = "0x1e6 - HOST End Point Pipe Status"]
pub pstatus7 : crate :: Reg < self :: host :: pstatus :: PSTATUS_SPEC > , # [doc = "0x1e7 - HOST Pipe Interrupt Flag"]
pub pintflag7 : crate :: Reg < self :: host :: pintflag :: PINTFLAG_SPEC > , # [doc = "0x1e8 - HOST Pipe Interrupt Flag Clear"]
pub pintenclr7 : crate :: Reg < self :: host :: pintenclr :: PINTENCLR_SPEC > , # [doc = "0x1e9 - HOST Pipe Interrupt Flag Set"]
pub pintenset7 : crate :: Reg < self :: host :: pintenset :: PINTENSET_SPEC > , } # [doc = r"Register block"]
# [doc = "USB is Host"]
pub mod host { # [doc = "CTRLA register accessor: an alias for `Reg<CTRLA_SPEC>`"]
pub type CTRLA = crate :: Reg < ctrla :: CTRLA_SPEC > ; # [doc = "Control A"]
pub mod ctrla { # [doc = "Register `CTRLA` reader"]
pub struct R (crate :: R < CTRLA_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLA_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLA_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLA` writer"]
pub struct W (crate :: W < CTRLA_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLA_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLA_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLA_SPEC >) -> Self { W (writer) } } # [doc = "Field `SWRST` reader - Software Reset"]
pub type SWRST_R = crate :: BitReader < bool > ; # [doc = "Field `SWRST` writer - Software Reset"]
pub type SWRST_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , 0 > ; # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , 1 > ; # [doc = "Field `RUNSTDBY` reader - Run in Standby Mode"]
pub type RUNSTDBY_R = crate :: BitReader < bool > ; # [doc = "Field `RUNSTDBY` writer - Run in Standby Mode"]
pub type RUNSTDBY_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , bool , 2 > ; # [doc = "Operating Mode\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
pub enum MODE_A { # [doc = "0: Device Mode"]
DEVICE = 0 , # [doc = "1: Host Mode"]
HOST = 1 , } impl From < MODE_A > for bool { # [inline (always)]
fn from (variant : MODE_A) -> Self { variant as u8 != 0 } } # [doc = "Field `MODE` reader - Operating Mode"]
pub type MODE_R = crate :: BitReader < MODE_A > ; impl MODE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> MODE_A { match self . bits { false => MODE_A :: DEVICE , true => MODE_A :: HOST , } } # [doc = "Checks if the value of the field is `DEVICE`"]
# [inline (always)]
pub fn is_device (& self) -> bool { * self == MODE_A :: DEVICE } # [doc = "Checks if the value of the field is `HOST`"]
# [inline (always)]
pub fn is_host (& self) -> bool { * self == MODE_A :: HOST } } # [doc = "Field `MODE` writer - Operating Mode"]
pub type MODE_W < 'a > = crate :: BitWriter < 'a , u8 , CTRLA_SPEC , MODE_A , 7 > ; impl < 'a > MODE_W < 'a > { # [doc = "Device Mode"]
# [inline (always)]
pub fn device (self) -> & 'a mut W { self . variant (MODE_A :: DEVICE) } # [doc = "Host Mode"]
# [inline (always)]
pub fn host (self) -> & 'a mut W { self . variant (MODE_A :: HOST) } } impl R { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& self) -> SWRST_R { SWRST_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Run in Standby Mode"]
# [inline (always)]
pub fn runstdby (& self) -> RUNSTDBY_R { RUNSTDBY_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 7 - Operating Mode"]
# [inline (always)]
pub fn mode (& self) -> MODE_R { MODE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Software Reset"]
# [inline (always)]
pub fn swrst (& mut self) -> SWRST_W { SWRST_W :: new (self) } # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Bit 2 - Run in Standby Mode"]
# [inline (always)]
pub fn runstdby (& mut self) -> RUNSTDBY_W { RUNSTDBY_W :: new (self) } # [doc = "Bit 7 - Operating Mode"]
# [inline (always)]
pub fn mode (& mut self) -> MODE_W { MODE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrla](index.html) module"]
pub struct CTRLA_SPEC ; impl crate :: RegisterSpec for CTRLA_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrla::R](R) reader structure"]
impl crate :: Readable for CTRLA_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrla::W](W) writer structure"]
impl crate :: Writable for CTRLA_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLA to value 0"]
impl crate :: Resettable for CTRLA_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "SYNCBUSY register accessor: an alias for `Reg<SYNCBUSY_SPEC>`"]
pub type SYNCBUSY = crate :: Reg < syncbusy :: SYNCBUSY_SPEC > ; # [doc = "Synchronization Busy"]
pub mod syncbusy { # [doc = "Register `SYNCBUSY` reader"]
pub struct R (crate :: R < SYNCBUSY_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < SYNCBUSY_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < SYNCBUSY_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < SYNCBUSY_SPEC >) -> Self { R (reader) } } # [doc = "Field `SWRST` reader - Software Reset Synchronization Busy"]
pub type SWRST_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` reader - Enable Synchronization Busy"]
pub type ENABLE_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Software Reset Synchronization Busy"]
# [inline (always)]
pub fn swrst (& self) -> SWRST_R { SWRST_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Enable Synchronization Busy"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } } # [doc = "Synchronization Busy\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [syncbusy](index.html) module"]
pub struct SYNCBUSY_SPEC ; impl crate :: RegisterSpec for SYNCBUSY_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [syncbusy::R](R) reader structure"]
impl crate :: Readable for SYNCBUSY_SPEC { type Reader = R ; } # [doc = "`reset()` method sets SYNCBUSY to value 0"]
impl crate :: Resettable for SYNCBUSY_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "QOSCTRL register accessor: an alias for `Reg<QOSCTRL_SPEC>`"]
pub type QOSCTRL = crate :: Reg < qosctrl :: QOSCTRL_SPEC > ; # [doc = "USB Quality Of Service"]
pub mod qosctrl { # [doc = "Register `QOSCTRL` reader"]
pub struct R (crate :: R < QOSCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < QOSCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < QOSCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < QOSCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `QOSCTRL` writer"]
pub struct W (crate :: W < QOSCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < QOSCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < QOSCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < QOSCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Configuration Quality of Service\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CQOS_A { # [doc = "0: Background (no sensitive operation)"]
DISABLE = 0 , # [doc = "1: Sensitive Bandwidth"]
LOW = 1 , # [doc = "2: Sensitive Latency"]
MEDIUM = 2 , # [doc = "3: Critical Latency"]
HIGH = 3 , } impl From < CQOS_A > for u8 { # [inline (always)]
fn from (variant : CQOS_A) -> Self { variant as _ } } # [doc = "Field `CQOS` reader - Configuration Quality of Service"]
pub type CQOS_R = crate :: FieldReader < u8 , CQOS_A > ; impl CQOS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> CQOS_A { match self . bits { 0 => CQOS_A :: DISABLE , 1 => CQOS_A :: LOW , 2 => CQOS_A :: MEDIUM , 3 => CQOS_A :: HIGH , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DISABLE`"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == CQOS_A :: DISABLE } # [doc = "Checks if the value of the field is `LOW`"]
# [inline (always)]
pub fn is_low (& self) -> bool { * self == CQOS_A :: LOW } # [doc = "Checks if the value of the field is `MEDIUM`"]
# [inline (always)]
pub fn is_medium (& self) -> bool { * self == CQOS_A :: MEDIUM } # [doc = "Checks if the value of the field is `HIGH`"]
# [inline (always)]
pub fn is_high (& self) -> bool { * self == CQOS_A :: HIGH } } # [doc = "Field `CQOS` writer - Configuration Quality of Service"]
pub type CQOS_W < 'a > = crate :: FieldWriterSafe < 'a , u8 , QOSCTRL_SPEC , u8 , CQOS_A , 2 , 0 > ; impl < 'a > CQOS_W < 'a > { # [doc = "Background (no sensitive operation)"]
# [inline (always)]
pub fn disable (self) -> & 'a mut W { self . variant (CQOS_A :: DISABLE) } # [doc = "Sensitive Bandwidth"]
# [inline (always)]
pub fn low (self) -> & 'a mut W { self . variant (CQOS_A :: LOW) } # [doc = "Sensitive Latency"]
# [inline (always)]
pub fn medium (self) -> & 'a mut W { self . variant (CQOS_A :: MEDIUM) } # [doc = "Critical Latency"]
# [inline (always)]
pub fn high (self) -> & 'a mut W { self . variant (CQOS_A :: HIGH) } } # [doc = "Data Quality of Service\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum DQOS_A { # [doc = "0: Background (no sensitive operation)"]
DISABLE = 0 , # [doc = "1: Sensitive Bandwidth"]
LOW = 1 , # [doc = "2: Sensitive Latency"]
MEDIUM = 2 , # [doc = "3: Critical Latency"]
HIGH = 3 , } impl From < DQOS_A > for u8 { # [inline (always)]
fn from (variant : DQOS_A) -> Self { variant as _ } } # [doc = "Field `DQOS` reader - Data Quality of Service"]
pub type DQOS_R = crate :: FieldReader < u8 , DQOS_A > ; impl DQOS_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> DQOS_A { match self . bits { 0 => DQOS_A :: DISABLE , 1 => DQOS_A :: LOW , 2 => DQOS_A :: MEDIUM , 3 => DQOS_A :: HIGH , _ => unreachable ! () , } } # [doc = "Checks if the value of the field is `DISABLE`"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == DQOS_A :: DISABLE } # [doc = "Checks if the value of the field is `LOW`"]
# [inline (always)]
pub fn is_low (& self) -> bool { * self == DQOS_A :: LOW } # [doc = "Checks if the value of the field is `MEDIUM`"]
# [inline (always)]
pub fn is_medium (& self) -> bool { * self == DQOS_A :: MEDIUM } # [doc = "Checks if the value of the field is `HIGH`"]
# [inline (always)]
pub fn is_high (& self) -> bool { * self == DQOS_A :: HIGH } } # [doc = "Field `DQOS` writer - Data Quality of Service"]
pub type DQOS_W < 'a > = crate :: FieldWriterSafe < 'a , u8 , QOSCTRL_SPEC , u8 , DQOS_A , 2 , 2 > ; impl < 'a > DQOS_W < 'a > { # [doc = "Background (no sensitive operation)"]
# [inline (always)]
pub fn disable (self) -> & 'a mut W { self . variant (DQOS_A :: DISABLE) } # [doc = "Sensitive Bandwidth"]
# [inline (always)]
pub fn low (self) -> & 'a mut W { self . variant (DQOS_A :: LOW) } # [doc = "Sensitive Latency"]
# [inline (always)]
pub fn medium (self) -> & 'a mut W { self . variant (DQOS_A :: MEDIUM) } # [doc = "Critical Latency"]
# [inline (always)]
pub fn high (self) -> & 'a mut W { self . variant (DQOS_A :: HIGH) } } impl R { # [doc = "Bits 0:1 - Configuration Quality of Service"]
# [inline (always)]
pub fn cqos (& self) -> CQOS_R { CQOS_R :: new ((self . bits & 3) as u8) } # [doc = "Bits 2:3 - Data Quality of Service"]
# [inline (always)]
pub fn dqos (& self) -> DQOS_R { DQOS_R :: new (((self . bits >> 2) & 3) as u8) } } impl W { # [doc = "Bits 0:1 - Configuration Quality of Service"]
# [inline (always)]
pub fn cqos (& mut self) -> CQOS_W { CQOS_W :: new (self) } # [doc = "Bits 2:3 - Data Quality of Service"]
# [inline (always)]
pub fn dqos (& mut self) -> DQOS_W { DQOS_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USB Quality Of Service\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [qosctrl](index.html) module"]
pub struct QOSCTRL_SPEC ; impl crate :: RegisterSpec for QOSCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [qosctrl::R](R) reader structure"]
impl crate :: Readable for QOSCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [qosctrl::W](W) writer structure"]
impl crate :: Writable for QOSCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets QOSCTRL to value 0x05"]
impl crate :: Resettable for QOSCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x05 } } } # [doc = "CTRLB register accessor: an alias for `Reg<CTRLB_SPEC>`"]
pub type CTRLB = crate :: Reg < ctrlb :: CTRLB_SPEC > ; # [doc = "HOST Control B"]
pub mod ctrlb { # [doc = "Register `CTRLB` reader"]
pub struct R (crate :: R < CTRLB_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRLB_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRLB_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRLB` writer"]
pub struct W (crate :: W < CTRLB_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRLB_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRLB_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRLB_SPEC >) -> Self { W (writer) } } # [doc = "Field `RESUME` reader - Send USB Resume"]
pub type RESUME_R = crate :: BitReader < bool > ; # [doc = "Field `RESUME` writer - Send USB Resume"]
pub type RESUME_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLB_SPEC , bool , 1 > ; # [doc = "Speed Configuration for Host\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum SPDCONF_A { # [doc = "0: Normal mode: the host starts in full-speed mode and performs a high-speed reset to switch to the high speed mode if the downstream peripheral is high-speed capable."]
NORMAL = 0 , # [doc = "3: Full-speed: the host remains in full-speed mode whatever is the peripheral speed capability. Relevant in UTMI mode only."]
FS = 3 , } impl From < SPDCONF_A > for u8 { # [inline (always)]
fn from (variant : SPDCONF_A) -> Self { variant as _ } } # [doc = "Field `SPDCONF` reader - Speed Configuration for Host"]
pub type SPDCONF_R = crate :: FieldReader < u8 , SPDCONF_A > ; impl SPDCONF_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < SPDCONF_A > { match self . bits { 0 => Some (SPDCONF_A :: NORMAL) , 3 => Some (SPDCONF_A :: FS) , _ => None , } } # [doc = "Checks if the value of the field is `NORMAL`"]
# [inline (always)]
pub fn is_normal (& self) -> bool { * self == SPDCONF_A :: NORMAL } # [doc = "Checks if the value of the field is `FS`"]
# [inline (always)]
pub fn is_fs (& self) -> bool { * self == SPDCONF_A :: FS } } # [doc = "Field `SPDCONF` writer - Speed Configuration for Host"]
pub type SPDCONF_W < 'a > = crate :: FieldWriter < 'a , u16 , CTRLB_SPEC , u8 , SPDCONF_A , 2 , 2 > ; impl < 'a > SPDCONF_W < 'a > { # [doc = "Normal mode: the host starts in full-speed mode and performs a high-speed reset to switch to the high speed mode if the downstream peripheral is high-speed capable."]
# [inline (always)]
pub fn normal (self) -> & 'a mut W { self . variant (SPDCONF_A :: NORMAL) } # [doc = "Full-speed: the host remains in full-speed mode whatever is the peripheral speed capability. Relevant in UTMI mode only."]
# [inline (always)]
pub fn fs (self) -> & 'a mut W { self . variant (SPDCONF_A :: FS) } } # [doc = "Field `TSTJ` reader - Test mode J"]
pub type TSTJ_R = crate :: BitReader < bool > ; # [doc = "Field `TSTJ` writer - Test mode J"]
pub type TSTJ_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLB_SPEC , bool , 5 > ; # [doc = "Field `TSTK` reader - Test mode K"]
pub type TSTK_R = crate :: BitReader < bool > ; # [doc = "Field `TSTK` writer - Test mode K"]
pub type TSTK_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLB_SPEC , bool , 6 > ; # [doc = "Field `SOFE` reader - Start of Frame Generation Enable"]
pub type SOFE_R = crate :: BitReader < bool > ; # [doc = "Field `SOFE` writer - Start of Frame Generation Enable"]
pub type SOFE_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLB_SPEC , bool , 8 > ; # [doc = "Field `BUSRESET` reader - Send USB Reset"]
pub type BUSRESET_R = crate :: BitReader < bool > ; # [doc = "Field `BUSRESET` writer - Send USB Reset"]
pub type BUSRESET_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLB_SPEC , bool , 9 > ; # [doc = "Field `VBUSOK` reader - VBUS is OK"]
pub type VBUSOK_R = crate :: BitReader < bool > ; # [doc = "Field `VBUSOK` writer - VBUS is OK"]
pub type VBUSOK_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLB_SPEC , bool , 10 > ; # [doc = "Field `L1RESUME` reader - Send L1 Resume"]
pub type L1RESUME_R = crate :: BitReader < bool > ; # [doc = "Field `L1RESUME` writer - Send L1 Resume"]
pub type L1RESUME_W < 'a > = crate :: BitWriter < 'a , u16 , CTRLB_SPEC , bool , 11 > ; impl R { # [doc = "Bit 1 - Send USB Resume"]
# [inline (always)]
pub fn resume (& self) -> RESUME_R { RESUME_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:3 - Speed Configuration for Host"]
# [inline (always)]
pub fn spdconf (& self) -> SPDCONF_R { SPDCONF_R :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bit 5 - Test mode J"]
# [inline (always)]
pub fn tstj (& self) -> TSTJ_R { TSTJ_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Test mode K"]
# [inline (always)]
pub fn tstk (& self) -> TSTK_R { TSTK_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 8 - Start of Frame Generation Enable"]
# [inline (always)]
pub fn sofe (& self) -> SOFE_R { SOFE_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Send USB Reset"]
# [inline (always)]
pub fn busreset (& self) -> BUSRESET_R { BUSRESET_R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - VBUS is OK"]
# [inline (always)]
pub fn vbusok (& self) -> VBUSOK_R { VBUSOK_R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Send L1 Resume"]
# [inline (always)]
pub fn l1resume (& self) -> L1RESUME_R { L1RESUME_R :: new (((self . bits >> 11) & 1) != 0) } } impl W { # [doc = "Bit 1 - Send USB Resume"]
# [inline (always)]
pub fn resume (& mut self) -> RESUME_W { RESUME_W :: new (self) } # [doc = "Bits 2:3 - Speed Configuration for Host"]
# [inline (always)]
pub fn spdconf (& mut self) -> SPDCONF_W { SPDCONF_W :: new (self) } # [doc = "Bit 5 - Test mode J"]
# [inline (always)]
pub fn tstj (& mut self) -> TSTJ_W { TSTJ_W :: new (self) } # [doc = "Bit 6 - Test mode K"]
# [inline (always)]
pub fn tstk (& mut self) -> TSTK_W { TSTK_W :: new (self) } # [doc = "Bit 8 - Start of Frame Generation Enable"]
# [inline (always)]
pub fn sofe (& mut self) -> SOFE_W { SOFE_W :: new (self) } # [doc = "Bit 9 - Send USB Reset"]
# [inline (always)]
pub fn busreset (& mut self) -> BUSRESET_W { BUSRESET_W :: new (self) } # [doc = "Bit 10 - VBUS is OK"]
# [inline (always)]
pub fn vbusok (& mut self) -> VBUSOK_W { VBUSOK_W :: new (self) } # [doc = "Bit 11 - Send L1 Resume"]
# [inline (always)]
pub fn l1resume (& mut self) -> L1RESUME_W { L1RESUME_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "HOST Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlb](index.html) module"]
pub struct CTRLB_SPEC ; impl crate :: RegisterSpec for CTRLB_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [ctrlb::R](R) reader structure"]
impl crate :: Readable for CTRLB_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrlb::W](W) writer structure"]
impl crate :: Writable for CTRLB_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRLB to value 0"]
impl crate :: Resettable for CTRLB_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "HSOFC register accessor: an alias for `Reg<HSOFC_SPEC>`"]
pub type HSOFC = crate :: Reg < hsofc :: HSOFC_SPEC > ; # [doc = "HOST Host Start Of Frame Control"]
pub mod hsofc { # [doc = "Register `HSOFC` reader"]
pub struct R (crate :: R < HSOFC_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < HSOFC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < HSOFC_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < HSOFC_SPEC >) -> Self { R (reader) } } # [doc = "Register `HSOFC` writer"]
pub struct W (crate :: W < HSOFC_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < HSOFC_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < HSOFC_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < HSOFC_SPEC >) -> Self { W (writer) } } # [doc = "Field `FLENC` reader - Frame Length Control"]
pub type FLENC_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `FLENC` writer - Frame Length Control"]
pub type FLENC_W < 'a > = crate :: FieldWriter < 'a , u8 , HSOFC_SPEC , u8 , u8 , 4 , 0 > ; # [doc = "Field `FLENCE` reader - Frame Length Control Enable"]
pub type FLENCE_R = crate :: BitReader < bool > ; # [doc = "Field `FLENCE` writer - Frame Length Control Enable"]
pub type FLENCE_W < 'a > = crate :: BitWriter < 'a , u8 , HSOFC_SPEC , bool , 7 > ; impl R { # [doc = "Bits 0:3 - Frame Length Control"]
# [inline (always)]
pub fn flenc (& self) -> FLENC_R { FLENC_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bit 7 - Frame Length Control Enable"]
# [inline (always)]
pub fn flence (& self) -> FLENCE_R { FLENCE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bits 0:3 - Frame Length Control"]
# [inline (always)]
pub fn flenc (& mut self) -> FLENC_W { FLENC_W :: new (self) } # [doc = "Bit 7 - Frame Length Control Enable"]
# [inline (always)]
pub fn flence (& mut self) -> FLENCE_W { FLENCE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "HOST Host Start Of Frame Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [hsofc](index.html) module"]
pub struct HSOFC_SPEC ; impl crate :: RegisterSpec for HSOFC_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [hsofc::R](R) reader structure"]
impl crate :: Readable for HSOFC_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [hsofc::W](W) writer structure"]
impl crate :: Writable for HSOFC_SPEC { type Writer = W ; } # [doc = "`reset()` method sets HSOFC to value 0"]
impl crate :: Resettable for HSOFC_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATUS register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "HOST Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Register `STATUS` writer"]
pub struct W (crate :: W < STATUS_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < STATUS_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < STATUS_SPEC >) -> Self { W (writer) } } # [doc = "Field `SPEED` reader - Speed Status"]
pub type SPEED_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `SPEED` writer - Speed Status"]
pub type SPEED_W < 'a > = crate :: FieldWriter < 'a , u8 , STATUS_SPEC , u8 , u8 , 2 , 2 > ; # [doc = "Field `LINESTATE` reader - USB Line State Status"]
pub type LINESTATE_R = crate :: FieldReader < u8 , u8 > ; impl R { # [doc = "Bits 2:3 - Speed Status"]
# [inline (always)]
pub fn speed (& self) -> SPEED_R { SPEED_R :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bits 6:7 - USB Line State Status"]
# [inline (always)]
pub fn linestate (& self) -> LINESTATE_R { LINESTATE_R :: new (((self . bits >> 6) & 3) as u8) } } impl W { # [doc = "Bits 2:3 - Speed Status"]
# [inline (always)]
pub fn speed (& mut self) -> SPEED_W { SPEED_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "HOST Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [status::W](W) writer structure"]
impl crate :: Writable for STATUS_SPEC { type Writer = W ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "FSMSTATUS register accessor: an alias for `Reg<FSMSTATUS_SPEC>`"]
pub type FSMSTATUS = crate :: Reg < fsmstatus :: FSMSTATUS_SPEC > ; # [doc = "Finite State Machine Status"]
pub mod fsmstatus { # [doc = "Register `FSMSTATUS` reader"]
pub struct R (crate :: R < FSMSTATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < FSMSTATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < FSMSTATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < FSMSTATUS_SPEC >) -> Self { R (reader) } } # [doc = "Fine State Machine Status\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum FSMSTATE_A { # [doc = "1: OFF (L3). It corresponds to the powered-off, disconnected, and disabled state"]
OFF = 1 , # [doc = "2: ON (L0). It corresponds to the Idle and Active states"]
ON = 2 , # [doc = "4: SUSPEND (L2)"]
SUSPEND = 4 , # [doc = "8: SLEEP (L1)"]
SLEEP = 8 , # [doc = "16: DNRESUME. Down Stream Resume."]
DNRESUME = 16 , # [doc = "32: UPRESUME. Up Stream Resume."]
UPRESUME = 32 , # [doc = "64: RESET. USB lines Reset."]
RESET = 64 , } impl From < FSMSTATE_A > for u8 { # [inline (always)]
fn from (variant : FSMSTATE_A) -> Self { variant as _ } } # [doc = "Field `FSMSTATE` reader - Fine State Machine Status"]
pub type FSMSTATE_R = crate :: FieldReader < u8 , FSMSTATE_A > ; impl FSMSTATE_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < FSMSTATE_A > { match self . bits { 1 => Some (FSMSTATE_A :: OFF) , 2 => Some (FSMSTATE_A :: ON) , 4 => Some (FSMSTATE_A :: SUSPEND) , 8 => Some (FSMSTATE_A :: SLEEP) , 16 => Some (FSMSTATE_A :: DNRESUME) , 32 => Some (FSMSTATE_A :: UPRESUME) , 64 => Some (FSMSTATE_A :: RESET) , _ => None , } } # [doc = "Checks if the value of the field is `OFF`"]
# [inline (always)]
pub fn is_off (& self) -> bool { * self == FSMSTATE_A :: OFF } # [doc = "Checks if the value of the field is `ON`"]
# [inline (always)]
pub fn is_on (& self) -> bool { * self == FSMSTATE_A :: ON } # [doc = "Checks if the value of the field is `SUSPEND`"]
# [inline (always)]
pub fn is_suspend (& self) -> bool { * self == FSMSTATE_A :: SUSPEND } # [doc = "Checks if the value of the field is `SLEEP`"]
# [inline (always)]
pub fn is_sleep (& self) -> bool { * self == FSMSTATE_A :: SLEEP } # [doc = "Checks if the value of the field is `DNRESUME`"]
# [inline (always)]
pub fn is_dnresume (& self) -> bool { * self == FSMSTATE_A :: DNRESUME } # [doc = "Checks if the value of the field is `UPRESUME`"]
# [inline (always)]
pub fn is_upresume (& self) -> bool { * self == FSMSTATE_A :: UPRESUME } # [doc = "Checks if the value of the field is `RESET`"]
# [inline (always)]
pub fn is_reset (& self) -> bool { * self == FSMSTATE_A :: RESET } } impl R { # [doc = "Bits 0:6 - Fine State Machine Status"]
# [inline (always)]
pub fn fsmstate (& self) -> FSMSTATE_R { FSMSTATE_R :: new ((self . bits & 0x7f) as u8) } } # [doc = "Finite State Machine Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fsmstatus](index.html) module"]
pub struct FSMSTATUS_SPEC ; impl crate :: RegisterSpec for FSMSTATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [fsmstatus::R](R) reader structure"]
impl crate :: Readable for FSMSTATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets FSMSTATUS to value 0x01"]
impl crate :: Resettable for FSMSTATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x01 } } } # [doc = "FNUM register accessor: an alias for `Reg<FNUM_SPEC>`"]
pub type FNUM = crate :: Reg < fnum :: FNUM_SPEC > ; # [doc = "HOST Host Frame Number"]
pub mod fnum { # [doc = "Register `FNUM` reader"]
pub struct R (crate :: R < FNUM_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < FNUM_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < FNUM_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < FNUM_SPEC >) -> Self { R (reader) } } # [doc = "Register `FNUM` writer"]
pub struct W (crate :: W < FNUM_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < FNUM_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < FNUM_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < FNUM_SPEC >) -> Self { W (writer) } } # [doc = "Field `MFNUM` reader - Micro Frame Number"]
pub type MFNUM_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `MFNUM` writer - Micro Frame Number"]
pub type MFNUM_W < 'a > = crate :: FieldWriter < 'a , u16 , FNUM_SPEC , u8 , u8 , 3 , 0 > ; # [doc = "Field `FNUM` reader - Frame Number"]
pub type FNUM_R = crate :: FieldReader < u16 , u16 > ; # [doc = "Field `FNUM` writer - Frame Number"]
pub type FNUM_W < 'a > = crate :: FieldWriter < 'a , u16 , FNUM_SPEC , u16 , u16 , 11 , 3 > ; impl R { # [doc = "Bits 0:2 - Micro Frame Number"]
# [inline (always)]
pub fn mfnum (& self) -> MFNUM_R { MFNUM_R :: new ((self . bits & 7) as u8) } # [doc = "Bits 3:13 - Frame Number"]
# [inline (always)]
pub fn fnum (& self) -> FNUM_R { FNUM_R :: new (((self . bits >> 3) & 0x07ff) as u16) } } impl W { # [doc = "Bits 0:2 - Micro Frame Number"]
# [inline (always)]
pub fn mfnum (& mut self) -> MFNUM_W { MFNUM_W :: new (self) } # [doc = "Bits 3:13 - Frame Number"]
# [inline (always)]
pub fn fnum (& mut self) -> FNUM_W { FNUM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "HOST Host Frame Number\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fnum](index.html) module"]
pub struct FNUM_SPEC ; impl crate :: RegisterSpec for FNUM_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [fnum::R](R) reader structure"]
impl crate :: Readable for FNUM_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [fnum::W](W) writer structure"]
impl crate :: Writable for FNUM_SPEC { type Writer = W ; } # [doc = "`reset()` method sets FNUM to value 0"]
impl crate :: Resettable for FNUM_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "FLENHIGH register accessor: an alias for `Reg<FLENHIGH_SPEC>`"]
pub type FLENHIGH = crate :: Reg < flenhigh :: FLENHIGH_SPEC > ; # [doc = "HOST Host Frame Length"]
pub mod flenhigh { # [doc = "Register `FLENHIGH` reader"]
pub struct R (crate :: R < FLENHIGH_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < FLENHIGH_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < FLENHIGH_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < FLENHIGH_SPEC >) -> Self { R (reader) } } # [doc = "Field `FLENHIGH` reader - Frame Length"]
pub type FLENHIGH_R = crate :: FieldReader < u8 , u8 > ; impl R { # [doc = "Bits 0:7 - Frame Length"]
# [inline (always)]
pub fn flenhigh (& self) -> FLENHIGH_R { FLENHIGH_R :: new (self . bits) } } # [doc = "HOST Host Frame Length\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [flenhigh](index.html) module"]
pub struct FLENHIGH_SPEC ; impl crate :: RegisterSpec for FLENHIGH_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [flenhigh::R](R) reader structure"]
impl crate :: Readable for FLENHIGH_SPEC { type Reader = R ; } # [doc = "`reset()` method sets FLENHIGH to value 0"]
impl crate :: Resettable for FLENHIGH_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENCLR register accessor: an alias for `Reg<INTENCLR_SPEC>`"]
pub type INTENCLR = crate :: Reg < intenclr :: INTENCLR_SPEC > ; # [doc = "HOST Host Interrupt Enable Clear"]
pub mod intenclr { # [doc = "Register `INTENCLR` reader"]
pub struct R (crate :: R < INTENCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENCLR` writer"]
pub struct W (crate :: W < INTENCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `HSOF` reader - Host Start Of Frame Interrupt Disable"]
pub type HSOF_R = crate :: BitReader < bool > ; # [doc = "Field `HSOF` writer - Host Start Of Frame Interrupt Disable"]
pub type HSOF_W < 'a > = crate :: BitWriter < 'a , u16 , INTENCLR_SPEC , bool , 2 > ; # [doc = "Field `RST` reader - BUS Reset Interrupt Disable"]
pub type RST_R = crate :: BitReader < bool > ; # [doc = "Field `RST` writer - BUS Reset Interrupt Disable"]
pub type RST_W < 'a > = crate :: BitWriter < 'a , u16 , INTENCLR_SPEC , bool , 3 > ; # [doc = "Field `WAKEUP` reader - Wake Up Interrupt Disable"]
pub type WAKEUP_R = crate :: BitReader < bool > ; # [doc = "Field `WAKEUP` writer - Wake Up Interrupt Disable"]
pub type WAKEUP_W < 'a > = crate :: BitWriter < 'a , u16 , INTENCLR_SPEC , bool , 4 > ; # [doc = "Field `DNRSM` reader - DownStream to Device Interrupt Disable"]
pub type DNRSM_R = crate :: BitReader < bool > ; # [doc = "Field `DNRSM` writer - DownStream to Device Interrupt Disable"]
pub type DNRSM_W < 'a > = crate :: BitWriter < 'a , u16 , INTENCLR_SPEC , bool , 5 > ; # [doc = "Field `UPRSM` reader - Upstream Resume from Device Interrupt Disable"]
pub type UPRSM_R = crate :: BitReader < bool > ; # [doc = "Field `UPRSM` writer - Upstream Resume from Device Interrupt Disable"]
pub type UPRSM_W < 'a > = crate :: BitWriter < 'a , u16 , INTENCLR_SPEC , bool , 6 > ; # [doc = "Field `RAMACER` reader - Ram Access Interrupt Disable"]
pub type RAMACER_R = crate :: BitReader < bool > ; # [doc = "Field `RAMACER` writer - Ram Access Interrupt Disable"]
pub type RAMACER_W < 'a > = crate :: BitWriter < 'a , u16 , INTENCLR_SPEC , bool , 7 > ; # [doc = "Field `DCONN` reader - Device Connection Interrupt Disable"]
pub type DCONN_R = crate :: BitReader < bool > ; # [doc = "Field `DCONN` writer - Device Connection Interrupt Disable"]
pub type DCONN_W < 'a > = crate :: BitWriter < 'a , u16 , INTENCLR_SPEC , bool , 8 > ; # [doc = "Field `DDISC` reader - Device Disconnection Interrupt Disable"]
pub type DDISC_R = crate :: BitReader < bool > ; # [doc = "Field `DDISC` writer - Device Disconnection Interrupt Disable"]
pub type DDISC_W < 'a > = crate :: BitWriter < 'a , u16 , INTENCLR_SPEC , bool , 9 > ; impl R { # [doc = "Bit 2 - Host Start Of Frame Interrupt Disable"]
# [inline (always)]
pub fn hsof (& self) -> HSOF_R { HSOF_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - BUS Reset Interrupt Disable"]
# [inline (always)]
pub fn rst (& self) -> RST_R { RST_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Wake Up Interrupt Disable"]
# [inline (always)]
pub fn wakeup (& self) -> WAKEUP_R { WAKEUP_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - DownStream to Device Interrupt Disable"]
# [inline (always)]
pub fn dnrsm (& self) -> DNRSM_R { DNRSM_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Upstream Resume from Device Interrupt Disable"]
# [inline (always)]
pub fn uprsm (& self) -> UPRSM_R { UPRSM_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Ram Access Interrupt Disable"]
# [inline (always)]
pub fn ramacer (& self) -> RAMACER_R { RAMACER_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Device Connection Interrupt Disable"]
# [inline (always)]
pub fn dconn (& self) -> DCONN_R { DCONN_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Device Disconnection Interrupt Disable"]
# [inline (always)]
pub fn ddisc (& self) -> DDISC_R { DDISC_R :: new (((self . bits >> 9) & 1) != 0) } } impl W { # [doc = "Bit 2 - Host Start Of Frame Interrupt Disable"]
# [inline (always)]
pub fn hsof (& mut self) -> HSOF_W { HSOF_W :: new (self) } # [doc = "Bit 3 - BUS Reset Interrupt Disable"]
# [inline (always)]
pub fn rst (& mut self) -> RST_W { RST_W :: new (self) } # [doc = "Bit 4 - Wake Up Interrupt Disable"]
# [inline (always)]
pub fn wakeup (& mut self) -> WAKEUP_W { WAKEUP_W :: new (self) } # [doc = "Bit 5 - DownStream to Device Interrupt Disable"]
# [inline (always)]
pub fn dnrsm (& mut self) -> DNRSM_W { DNRSM_W :: new (self) } # [doc = "Bit 6 - Upstream Resume from Device Interrupt Disable"]
# [inline (always)]
pub fn uprsm (& mut self) -> UPRSM_W { UPRSM_W :: new (self) } # [doc = "Bit 7 - Ram Access Interrupt Disable"]
# [inline (always)]
pub fn ramacer (& mut self) -> RAMACER_W { RAMACER_W :: new (self) } # [doc = "Bit 8 - Device Connection Interrupt Disable"]
# [inline (always)]
pub fn dconn (& mut self) -> DCONN_W { DCONN_W :: new (self) } # [doc = "Bit 9 - Device Disconnection Interrupt Disable"]
# [inline (always)]
pub fn ddisc (& mut self) -> DDISC_W { DDISC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "HOST Host Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenclr](index.html) module"]
pub struct INTENCLR_SPEC ; impl crate :: RegisterSpec for INTENCLR_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [intenclr::R](R) reader structure"]
impl crate :: Readable for INTENCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenclr::W](W) writer structure"]
impl crate :: Writable for INTENCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENCLR to value 0"]
impl crate :: Resettable for INTENCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENSET register accessor: an alias for `Reg<INTENSET_SPEC>`"]
pub type INTENSET = crate :: Reg < intenset :: INTENSET_SPEC > ; # [doc = "HOST Host Interrupt Enable Set"]
pub mod intenset { # [doc = "Register `INTENSET` reader"]
pub struct R (crate :: R < INTENSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENSET` writer"]
pub struct W (crate :: W < INTENSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `HSOF` reader - Host Start Of Frame Interrupt Enable"]
pub type HSOF_R = crate :: BitReader < bool > ; # [doc = "Field `HSOF` writer - Host Start Of Frame Interrupt Enable"]
pub type HSOF_W < 'a > = crate :: BitWriter < 'a , u16 , INTENSET_SPEC , bool , 2 > ; # [doc = "Field `RST` reader - Bus Reset Interrupt Enable"]
pub type RST_R = crate :: BitReader < bool > ; # [doc = "Field `RST` writer - Bus Reset Interrupt Enable"]
pub type RST_W < 'a > = crate :: BitWriter < 'a , u16 , INTENSET_SPEC , bool , 3 > ; # [doc = "Field `WAKEUP` reader - Wake Up Interrupt Enable"]
pub type WAKEUP_R = crate :: BitReader < bool > ; # [doc = "Field `WAKEUP` writer - Wake Up Interrupt Enable"]
pub type WAKEUP_W < 'a > = crate :: BitWriter < 'a , u16 , INTENSET_SPEC , bool , 4 > ; # [doc = "Field `DNRSM` reader - DownStream to the Device Interrupt Enable"]
pub type DNRSM_R = crate :: BitReader < bool > ; # [doc = "Field `DNRSM` writer - DownStream to the Device Interrupt Enable"]
pub type DNRSM_W < 'a > = crate :: BitWriter < 'a , u16 , INTENSET_SPEC , bool , 5 > ; # [doc = "Field `UPRSM` reader - Upstream Resume fromthe device Interrupt Enable"]
pub type UPRSM_R = crate :: BitReader < bool > ; # [doc = "Field `UPRSM` writer - Upstream Resume fromthe device Interrupt Enable"]
pub type UPRSM_W < 'a > = crate :: BitWriter < 'a , u16 , INTENSET_SPEC , bool , 6 > ; # [doc = "Field `RAMACER` reader - Ram Access Interrupt Enable"]
pub type RAMACER_R = crate :: BitReader < bool > ; # [doc = "Field `RAMACER` writer - Ram Access Interrupt Enable"]
pub type RAMACER_W < 'a > = crate :: BitWriter < 'a , u16 , INTENSET_SPEC , bool , 7 > ; # [doc = "Field `DCONN` reader - Link Power Management Interrupt Enable"]
pub type DCONN_R = crate :: BitReader < bool > ; # [doc = "Field `DCONN` writer - Link Power Management Interrupt Enable"]
pub type DCONN_W < 'a > = crate :: BitWriter < 'a , u16 , INTENSET_SPEC , bool , 8 > ; # [doc = "Field `DDISC` reader - Device Disconnection Interrupt Enable"]
pub type DDISC_R = crate :: BitReader < bool > ; # [doc = "Field `DDISC` writer - Device Disconnection Interrupt Enable"]
pub type DDISC_W < 'a > = crate :: BitWriter < 'a , u16 , INTENSET_SPEC , bool , 9 > ; impl R { # [doc = "Bit 2 - Host Start Of Frame Interrupt Enable"]
# [inline (always)]
pub fn hsof (& self) -> HSOF_R { HSOF_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Bus Reset Interrupt Enable"]
# [inline (always)]
pub fn rst (& self) -> RST_R { RST_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Wake Up Interrupt Enable"]
# [inline (always)]
pub fn wakeup (& self) -> WAKEUP_R { WAKEUP_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - DownStream to the Device Interrupt Enable"]
# [inline (always)]
pub fn dnrsm (& self) -> DNRSM_R { DNRSM_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Upstream Resume fromthe device Interrupt Enable"]
# [inline (always)]
pub fn uprsm (& self) -> UPRSM_R { UPRSM_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Ram Access Interrupt Enable"]
# [inline (always)]
pub fn ramacer (& self) -> RAMACER_R { RAMACER_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Link Power Management Interrupt Enable"]
# [inline (always)]
pub fn dconn (& self) -> DCONN_R { DCONN_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Device Disconnection Interrupt Enable"]
# [inline (always)]
pub fn ddisc (& self) -> DDISC_R { DDISC_R :: new (((self . bits >> 9) & 1) != 0) } } impl W { # [doc = "Bit 2 - Host Start Of Frame Interrupt Enable"]
# [inline (always)]
pub fn hsof (& mut self) -> HSOF_W { HSOF_W :: new (self) } # [doc = "Bit 3 - Bus Reset Interrupt Enable"]
# [inline (always)]
pub fn rst (& mut self) -> RST_W { RST_W :: new (self) } # [doc = "Bit 4 - Wake Up Interrupt Enable"]
# [inline (always)]
pub fn wakeup (& mut self) -> WAKEUP_W { WAKEUP_W :: new (self) } # [doc = "Bit 5 - DownStream to the Device Interrupt Enable"]
# [inline (always)]
pub fn dnrsm (& mut self) -> DNRSM_W { DNRSM_W :: new (self) } # [doc = "Bit 6 - Upstream Resume fromthe device Interrupt Enable"]
# [inline (always)]
pub fn uprsm (& mut self) -> UPRSM_W { UPRSM_W :: new (self) } # [doc = "Bit 7 - Ram Access Interrupt Enable"]
# [inline (always)]
pub fn ramacer (& mut self) -> RAMACER_W { RAMACER_W :: new (self) } # [doc = "Bit 8 - Link Power Management Interrupt Enable"]
# [inline (always)]
pub fn dconn (& mut self) -> DCONN_W { DCONN_W :: new (self) } # [doc = "Bit 9 - Device Disconnection Interrupt Enable"]
# [inline (always)]
pub fn ddisc (& mut self) -> DDISC_W { DDISC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "HOST Host Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenset](index.html) module"]
pub struct INTENSET_SPEC ; impl crate :: RegisterSpec for INTENSET_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [intenset::R](R) reader structure"]
impl crate :: Readable for INTENSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenset::W](W) writer structure"]
impl crate :: Writable for INTENSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENSET to value 0"]
impl crate :: Resettable for INTENSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTFLAG register accessor: an alias for `Reg<INTFLAG_SPEC>`"]
pub type INTFLAG = crate :: Reg < intflag :: INTFLAG_SPEC > ; # [doc = "HOST Host Interrupt Flag"]
pub mod intflag { # [doc = "Register `INTFLAG` reader"]
pub struct R (crate :: R < INTFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAG` writer"]
pub struct W (crate :: W < INTFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `HSOF` reader - Host Start Of Frame"]
pub type HSOF_R = crate :: BitReader < bool > ; # [doc = "Field `HSOF` writer - Host Start Of Frame"]
pub type HSOF_W < 'a > = crate :: BitWriter < 'a , u16 , INTFLAG_SPEC , bool , 2 > ; # [doc = "Field `RST` reader - Bus Reset"]
pub type RST_R = crate :: BitReader < bool > ; # [doc = "Field `RST` writer - Bus Reset"]
pub type RST_W < 'a > = crate :: BitWriter < 'a , u16 , INTFLAG_SPEC , bool , 3 > ; # [doc = "Field `WAKEUP` reader - Wake Up"]
pub type WAKEUP_R = crate :: BitReader < bool > ; # [doc = "Field `WAKEUP` writer - Wake Up"]
pub type WAKEUP_W < 'a > = crate :: BitWriter < 'a , u16 , INTFLAG_SPEC , bool , 4 > ; # [doc = "Field `DNRSM` reader - Downstream"]
pub type DNRSM_R = crate :: BitReader < bool > ; # [doc = "Field `DNRSM` writer - Downstream"]
pub type DNRSM_W < 'a > = crate :: BitWriter < 'a , u16 , INTFLAG_SPEC , bool , 5 > ; # [doc = "Field `UPRSM` reader - Upstream Resume from the Device"]
pub type UPRSM_R = crate :: BitReader < bool > ; # [doc = "Field `UPRSM` writer - Upstream Resume from the Device"]
pub type UPRSM_W < 'a > = crate :: BitWriter < 'a , u16 , INTFLAG_SPEC , bool , 6 > ; # [doc = "Field `RAMACER` reader - Ram Access"]
pub type RAMACER_R = crate :: BitReader < bool > ; # [doc = "Field `RAMACER` writer - Ram Access"]
pub type RAMACER_W < 'a > = crate :: BitWriter < 'a , u16 , INTFLAG_SPEC , bool , 7 > ; # [doc = "Field `DCONN` reader - Device Connection"]
pub type DCONN_R = crate :: BitReader < bool > ; # [doc = "Field `DCONN` writer - Device Connection"]
pub type DCONN_W < 'a > = crate :: BitWriter < 'a , u16 , INTFLAG_SPEC , bool , 8 > ; # [doc = "Field `DDISC` reader - Device Disconnection"]
pub type DDISC_R = crate :: BitReader < bool > ; # [doc = "Field `DDISC` writer - Device Disconnection"]
pub type DDISC_W < 'a > = crate :: BitWriter < 'a , u16 , INTFLAG_SPEC , bool , 9 > ; impl R { # [doc = "Bit 2 - Host Start Of Frame"]
# [inline (always)]
pub fn hsof (& self) -> HSOF_R { HSOF_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Bus Reset"]
# [inline (always)]
pub fn rst (& self) -> RST_R { RST_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Wake Up"]
# [inline (always)]
pub fn wakeup (& self) -> WAKEUP_R { WAKEUP_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Downstream"]
# [inline (always)]
pub fn dnrsm (& self) -> DNRSM_R { DNRSM_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Upstream Resume from the Device"]
# [inline (always)]
pub fn uprsm (& self) -> UPRSM_R { UPRSM_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Ram Access"]
# [inline (always)]
pub fn ramacer (& self) -> RAMACER_R { RAMACER_R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Device Connection"]
# [inline (always)]
pub fn dconn (& self) -> DCONN_R { DCONN_R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Device Disconnection"]
# [inline (always)]
pub fn ddisc (& self) -> DDISC_R { DDISC_R :: new (((self . bits >> 9) & 1) != 0) } } impl W { # [doc = "Bit 2 - Host Start Of Frame"]
# [inline (always)]
pub fn hsof (& mut self) -> HSOF_W { HSOF_W :: new (self) } # [doc = "Bit 3 - Bus Reset"]
# [inline (always)]
pub fn rst (& mut self) -> RST_W { RST_W :: new (self) } # [doc = "Bit 4 - Wake Up"]
# [inline (always)]
pub fn wakeup (& mut self) -> WAKEUP_W { WAKEUP_W :: new (self) } # [doc = "Bit 5 - Downstream"]
# [inline (always)]
pub fn dnrsm (& mut self) -> DNRSM_W { DNRSM_W :: new (self) } # [doc = "Bit 6 - Upstream Resume from the Device"]
# [inline (always)]
pub fn uprsm (& mut self) -> UPRSM_W { UPRSM_W :: new (self) } # [doc = "Bit 7 - Ram Access"]
# [inline (always)]
pub fn ramacer (& mut self) -> RAMACER_W { RAMACER_W :: new (self) } # [doc = "Bit 8 - Device Connection"]
# [inline (always)]
pub fn dconn (& mut self) -> DCONN_W { DCONN_W :: new (self) } # [doc = "Bit 9 - Device Disconnection"]
# [inline (always)]
pub fn ddisc (& mut self) -> DDISC_W { DDISC_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "HOST Host Interrupt Flag\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflag](index.html) module"]
pub struct INTFLAG_SPEC ; impl crate :: RegisterSpec for INTFLAG_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [intflag::R](R) reader structure"]
impl crate :: Readable for INTFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflag::W](W) writer structure"]
impl crate :: Writable for INTFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTFLAG to value 0"]
impl crate :: Resettable for INTFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PINTSMRY register accessor: an alias for `Reg<PINTSMRY_SPEC>`"]
pub type PINTSMRY = crate :: Reg < pintsmry :: PINTSMRY_SPEC > ; # [doc = "HOST Pipe Interrupt Summary"]
pub mod pintsmry { # [doc = "Register `PINTSMRY` reader"]
pub struct R (crate :: R < PINTSMRY_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PINTSMRY_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PINTSMRY_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PINTSMRY_SPEC >) -> Self { R (reader) } } # [doc = "Field `EPINT0` reader - Pipe 0 Interrupt"]
pub type EPINT0_R = crate :: BitReader < bool > ; # [doc = "Field `EPINT1` reader - Pipe 1 Interrupt"]
pub type EPINT1_R = crate :: BitReader < bool > ; # [doc = "Field `EPINT2` reader - Pipe 2 Interrupt"]
pub type EPINT2_R = crate :: BitReader < bool > ; # [doc = "Field `EPINT3` reader - Pipe 3 Interrupt"]
pub type EPINT3_R = crate :: BitReader < bool > ; # [doc = "Field `EPINT4` reader - Pipe 4 Interrupt"]
pub type EPINT4_R = crate :: BitReader < bool > ; # [doc = "Field `EPINT5` reader - Pipe 5 Interrupt"]
pub type EPINT5_R = crate :: BitReader < bool > ; # [doc = "Field `EPINT6` reader - Pipe 6 Interrupt"]
pub type EPINT6_R = crate :: BitReader < bool > ; # [doc = "Field `EPINT7` reader - Pipe 7 Interrupt"]
pub type EPINT7_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Pipe 0 Interrupt"]
# [inline (always)]
pub fn epint0 (& self) -> EPINT0_R { EPINT0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Pipe 1 Interrupt"]
# [inline (always)]
pub fn epint1 (& self) -> EPINT1_R { EPINT1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Pipe 2 Interrupt"]
# [inline (always)]
pub fn epint2 (& self) -> EPINT2_R { EPINT2_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pipe 3 Interrupt"]
# [inline (always)]
pub fn epint3 (& self) -> EPINT3_R { EPINT3_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Pipe 4 Interrupt"]
# [inline (always)]
pub fn epint4 (& self) -> EPINT4_R { EPINT4_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Pipe 5 Interrupt"]
# [inline (always)]
pub fn epint5 (& self) -> EPINT5_R { EPINT5_R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Pipe 6 Interrupt"]
# [inline (always)]
pub fn epint6 (& self) -> EPINT6_R { EPINT6_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Pipe 7 Interrupt"]
# [inline (always)]
pub fn epint7 (& self) -> EPINT7_R { EPINT7_R :: new (((self . bits >> 7) & 1) != 0) } } # [doc = "HOST Pipe Interrupt Summary\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pintsmry](index.html) module"]
pub struct PINTSMRY_SPEC ; impl crate :: RegisterSpec for PINTSMRY_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [pintsmry::R](R) reader structure"]
impl crate :: Readable for PINTSMRY_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PINTSMRY to value 0"]
impl crate :: Resettable for PINTSMRY_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "DESCADD register accessor: an alias for `Reg<DESCADD_SPEC>`"]
pub type DESCADD = crate :: Reg < descadd :: DESCADD_SPEC > ; # [doc = "Descriptor Address"]
pub mod descadd { # [doc = "Register `DESCADD` reader"]
pub struct R (crate :: R < DESCADD_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < DESCADD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < DESCADD_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < DESCADD_SPEC >) -> Self { R (reader) } } # [doc = "Register `DESCADD` writer"]
pub struct W (crate :: W < DESCADD_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < DESCADD_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < DESCADD_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < DESCADD_SPEC >) -> Self { W (writer) } } # [doc = "Field `DESCADD` reader - Descriptor Address Value"]
pub type DESCADD_R = crate :: FieldReader < u32 , u32 > ; # [doc = "Field `DESCADD` writer - Descriptor Address Value"]
pub type DESCADD_W < 'a > = crate :: FieldWriter < 'a , u32 , DESCADD_SPEC , u32 , u32 , 32 , 0 > ; impl R { # [doc = "Bits 0:31 - Descriptor Address Value"]
# [inline (always)]
pub fn descadd (& self) -> DESCADD_R { DESCADD_R :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Descriptor Address Value"]
# [inline (always)]
pub fn descadd (& mut self) -> DESCADD_W { DESCADD_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u32) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Descriptor Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [descadd](index.html) module"]
pub struct DESCADD_SPEC ; impl crate :: RegisterSpec for DESCADD_SPEC { type Ux = u32 ; } # [doc = "`read()` method returns [descadd::R](R) reader structure"]
impl crate :: Readable for DESCADD_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [descadd::W](W) writer structure"]
impl crate :: Writable for DESCADD_SPEC { type Writer = W ; } # [doc = "`reset()` method sets DESCADD to value 0"]
impl crate :: Resettable for DESCADD_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PADCAL register accessor: an alias for `Reg<PADCAL_SPEC>`"]
pub type PADCAL = crate :: Reg < padcal :: PADCAL_SPEC > ; # [doc = "USB PAD Calibration"]
pub mod padcal { # [doc = "Register `PADCAL` reader"]
pub struct R (crate :: R < PADCAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PADCAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PADCAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PADCAL_SPEC >) -> Self { R (reader) } } # [doc = "Register `PADCAL` writer"]
pub struct W (crate :: W < PADCAL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PADCAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PADCAL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PADCAL_SPEC >) -> Self { W (writer) } } # [doc = "Field `TRANSP` reader - USB Pad Transp calibration"]
pub type TRANSP_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `TRANSP` writer - USB Pad Transp calibration"]
pub type TRANSP_W < 'a > = crate :: FieldWriter < 'a , u16 , PADCAL_SPEC , u8 , u8 , 5 , 0 > ; # [doc = "Field `TRANSN` reader - USB Pad Transn calibration"]
pub type TRANSN_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `TRANSN` writer - USB Pad Transn calibration"]
pub type TRANSN_W < 'a > = crate :: FieldWriter < 'a , u16 , PADCAL_SPEC , u8 , u8 , 5 , 6 > ; # [doc = "Field `TRIM` reader - USB Pad Trim calibration"]
pub type TRIM_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `TRIM` writer - USB Pad Trim calibration"]
pub type TRIM_W < 'a > = crate :: FieldWriter < 'a , u16 , PADCAL_SPEC , u8 , u8 , 3 , 12 > ; impl R { # [doc = "Bits 0:4 - USB Pad Transp calibration"]
# [inline (always)]
pub fn transp (& self) -> TRANSP_R { TRANSP_R :: new ((self . bits & 0x1f) as u8) } # [doc = "Bits 6:10 - USB Pad Transn calibration"]
# [inline (always)]
pub fn transn (& self) -> TRANSN_R { TRANSN_R :: new (((self . bits >> 6) & 0x1f) as u8) } # [doc = "Bits 12:14 - USB Pad Trim calibration"]
# [inline (always)]
pub fn trim (& self) -> TRIM_R { TRIM_R :: new (((self . bits >> 12) & 7) as u8) } } impl W { # [doc = "Bits 0:4 - USB Pad Transp calibration"]
# [inline (always)]
pub fn transp (& mut self) -> TRANSP_W { TRANSP_W :: new (self) } # [doc = "Bits 6:10 - USB Pad Transn calibration"]
# [inline (always)]
pub fn transn (& mut self) -> TRANSN_W { TRANSN_W :: new (self) } # [doc = "Bits 12:14 - USB Pad Trim calibration"]
# [inline (always)]
pub fn trim (& mut self) -> TRIM_W { TRIM_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u16) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "USB PAD Calibration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [padcal](index.html) module"]
pub struct PADCAL_SPEC ; impl crate :: RegisterSpec for PADCAL_SPEC { type Ux = u16 ; } # [doc = "`read()` method returns [padcal::R](R) reader structure"]
impl crate :: Readable for PADCAL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [padcal::W](W) writer structure"]
impl crate :: Writable for PADCAL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PADCAL to value 0"]
impl crate :: Resettable for PADCAL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PCFG register accessor: an alias for `Reg<PCFG_SPEC>`"]
pub type PCFG = crate :: Reg < pcfg :: PCFG_SPEC > ; # [doc = "HOST End Point Configuration"]
pub mod pcfg { # [doc = "Register `PCFG%s` reader"]
pub struct R (crate :: R < PCFG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PCFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PCFG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PCFG_SPEC >) -> Self { R (reader) } } # [doc = "Register `PCFG%s` writer"]
pub struct W (crate :: W < PCFG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PCFG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PCFG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PCFG_SPEC >) -> Self { W (writer) } } # [doc = "Field `PTOKEN` reader - Pipe Token"]
pub type PTOKEN_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `PTOKEN` writer - Pipe Token"]
pub type PTOKEN_W < 'a > = crate :: FieldWriter < 'a , u8 , PCFG_SPEC , u8 , u8 , 2 , 0 > ; # [doc = "Field `BK` reader - Pipe Bank"]
pub type BK_R = crate :: BitReader < bool > ; # [doc = "Field `BK` writer - Pipe Bank"]
pub type BK_W < 'a > = crate :: BitWriter < 'a , u8 , PCFG_SPEC , bool , 2 > ; # [doc = "Field `PTYPE` reader - Pipe Type"]
pub type PTYPE_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `PTYPE` writer - Pipe Type"]
pub type PTYPE_W < 'a > = crate :: FieldWriter < 'a , u8 , PCFG_SPEC , u8 , u8 , 3 , 3 > ; impl R { # [doc = "Bits 0:1 - Pipe Token"]
# [inline (always)]
pub fn ptoken (& self) -> PTOKEN_R { PTOKEN_R :: new ((self . bits & 3) as u8) } # [doc = "Bit 2 - Pipe Bank"]
# [inline (always)]
pub fn bk (& self) -> BK_R { BK_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 3:5 - Pipe Type"]
# [inline (always)]
pub fn ptype (& self) -> PTYPE_R { PTYPE_R :: new (((self . bits >> 3) & 7) as u8) } } impl W { # [doc = "Bits 0:1 - Pipe Token"]
# [inline (always)]
pub fn ptoken (& mut self) -> PTOKEN_W { PTOKEN_W :: new (self) } # [doc = "Bit 2 - Pipe Bank"]
# [inline (always)]
pub fn bk (& mut self) -> BK_W { BK_W :: new (self) } # [doc = "Bits 3:5 - Pipe Type"]
# [inline (always)]
pub fn ptype (& mut self) -> PTYPE_W { PTYPE_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "HOST End Point Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pcfg](index.html) module"]
pub struct PCFG_SPEC ; impl crate :: RegisterSpec for PCFG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pcfg::R](R) reader structure"]
impl crate :: Readable for PCFG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pcfg::W](W) writer structure"]
impl crate :: Writable for PCFG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PCFG%s to value 0"]
impl crate :: Resettable for PCFG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "BINTERVAL register accessor: an alias for `Reg<BINTERVAL_SPEC>`"]
pub type BINTERVAL = crate :: Reg < binterval :: BINTERVAL_SPEC > ; # [doc = "HOST Bus Access Period of Pipe"]
pub mod binterval { # [doc = "Register `BINTERVAL%s` reader"]
pub struct R (crate :: R < BINTERVAL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < BINTERVAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < BINTERVAL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < BINTERVAL_SPEC >) -> Self { R (reader) } } # [doc = "Register `BINTERVAL%s` writer"]
pub struct W (crate :: W < BINTERVAL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < BINTERVAL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < BINTERVAL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < BINTERVAL_SPEC >) -> Self { W (writer) } } # [doc = "Field `BITINTERVAL` reader - Bit Interval"]
pub type BITINTERVAL_R = crate :: FieldReader < u8 , u8 > ; # [doc = "Field `BITINTERVAL` writer - Bit Interval"]
pub type BITINTERVAL_W < 'a > = crate :: FieldWriter < 'a , u8 , BINTERVAL_SPEC , u8 , u8 , 8 , 0 > ; impl R { # [doc = "Bits 0:7 - Bit Interval"]
# [inline (always)]
pub fn bitinterval (& self) -> BITINTERVAL_R { BITINTERVAL_R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Bit Interval"]
# [inline (always)]
pub fn bitinterval (& mut self) -> BITINTERVAL_W { BITINTERVAL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "HOST Bus Access Period of Pipe\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [binterval](index.html) module"]
pub struct BINTERVAL_SPEC ; impl crate :: RegisterSpec for BINTERVAL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [binterval::R](R) reader structure"]
impl crate :: Readable for BINTERVAL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [binterval::W](W) writer structure"]
impl crate :: Writable for BINTERVAL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets BINTERVAL%s to value 0"]
impl crate :: Resettable for BINTERVAL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PSTATUSCLR register accessor: an alias for `Reg<PSTATUSCLR_SPEC>`"]
pub type PSTATUSCLR = crate :: Reg < pstatusclr :: PSTATUSCLR_SPEC > ; # [doc = "HOST End Point Pipe Status Clear"]
pub mod pstatusclr { # [doc = "Register `PSTATUSCLR%s` writer"]
pub struct W (crate :: W < PSTATUSCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PSTATUSCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PSTATUSCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PSTATUSCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `CURBK` writer - Curren Bank clear"]
pub type CURBK_W < 'a > = crate :: BitWriter < 'a , u8 , PSTATUSCLR_SPEC , bool , 2 > ; # [doc = "Field `PFREEZE` writer - Pipe Freeze Clear"]
pub type PFREEZE_W < 'a > = crate :: BitWriter < 'a , u8 , PSTATUSCLR_SPEC , bool , 4 > ; # [doc = "Field `BK0RDY` writer - Bank 0 Ready Clear"]
pub type BK0RDY_W < 'a > = crate :: BitWriter < 'a , u8 , PSTATUSCLR_SPEC , bool , 6 > ; # [doc = "Field `BK1RDY` writer - Bank 1 Ready Clear"]
pub type BK1RDY_W < 'a > = crate :: BitWriter < 'a , u8 , PSTATUSCLR_SPEC , bool , 7 > ; impl W { # [doc = "Bit 2 - Curren Bank clear"]
# [inline (always)]
pub fn curbk (& mut self) -> CURBK_W { CURBK_W :: new (self) } # [doc = "Bit 4 - Pipe Freeze Clear"]
# [inline (always)]
pub fn pfreeze (& mut self) -> PFREEZE_W { PFREEZE_W :: new (self) } # [doc = "Bit 6 - Bank 0 Ready Clear"]
# [inline (always)]
pub fn bk0rdy (& mut self) -> BK0RDY_W { BK0RDY_W :: new (self) } # [doc = "Bit 7 - Bank 1 Ready Clear"]
# [inline (always)]
pub fn bk1rdy (& mut self) -> BK1RDY_W { BK1RDY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "HOST End Point Pipe Status Clear\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pstatusclr](index.html) module"]
pub struct PSTATUSCLR_SPEC ; impl crate :: RegisterSpec for PSTATUSCLR_SPEC { type Ux = u8 ; } # [doc = "`write(|w| ..)` method takes [pstatusclr::W](W) writer structure"]
impl crate :: Writable for PSTATUSCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PSTATUSCLR%s to value 0"]
impl crate :: Resettable for PSTATUSCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PSTATUSSET register accessor: an alias for `Reg<PSTATUSSET_SPEC>`"]
pub type PSTATUSSET = crate :: Reg < pstatusset :: PSTATUSSET_SPEC > ; # [doc = "HOST End Point Pipe Status Set"]
pub mod pstatusset { # [doc = "Register `PSTATUSSET%s` writer"]
pub struct W (crate :: W < PSTATUSSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PSTATUSSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PSTATUSSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PSTATUSSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `DTGL` writer - Data Toggle Set"]
pub type DTGL_W < 'a > = crate :: BitWriter < 'a , u8 , PSTATUSSET_SPEC , bool , 0 > ; # [doc = "Field `CURBK` writer - Current Bank Set"]
pub type CURBK_W < 'a > = crate :: BitWriter < 'a , u8 , PSTATUSSET_SPEC , bool , 2 > ; # [doc = "Field `PFREEZE` writer - Pipe Freeze Set"]
pub type PFREEZE_W < 'a > = crate :: BitWriter < 'a , u8 , PSTATUSSET_SPEC , bool , 4 > ; # [doc = "Field `BK0RDY` writer - Bank 0 Ready Set"]
pub type BK0RDY_W < 'a > = crate :: BitWriter < 'a , u8 , PSTATUSSET_SPEC , bool , 6 > ; # [doc = "Field `BK1RDY` writer - Bank 1 Ready Set"]
pub type BK1RDY_W < 'a > = crate :: BitWriter < 'a , u8 , PSTATUSSET_SPEC , bool , 7 > ; impl W { # [doc = "Bit 0 - Data Toggle Set"]
# [inline (always)]
pub fn dtgl (& mut self) -> DTGL_W { DTGL_W :: new (self) } # [doc = "Bit 2 - Current Bank Set"]
# [inline (always)]
pub fn curbk (& mut self) -> CURBK_W { CURBK_W :: new (self) } # [doc = "Bit 4 - Pipe Freeze Set"]
# [inline (always)]
pub fn pfreeze (& mut self) -> PFREEZE_W { PFREEZE_W :: new (self) } # [doc = "Bit 6 - Bank 0 Ready Set"]
# [inline (always)]
pub fn bk0rdy (& mut self) -> BK0RDY_W { BK0RDY_W :: new (self) } # [doc = "Bit 7 - Bank 1 Ready Set"]
# [inline (always)]
pub fn bk1rdy (& mut self) -> BK1RDY_W { BK1RDY_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "HOST End Point Pipe Status Set\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pstatusset](index.html) module"]
pub struct PSTATUSSET_SPEC ; impl crate :: RegisterSpec for PSTATUSSET_SPEC { type Ux = u8 ; } # [doc = "`write(|w| ..)` method takes [pstatusset::W](W) writer structure"]
impl crate :: Writable for PSTATUSSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PSTATUSSET%s to value 0"]
impl crate :: Resettable for PSTATUSSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PSTATUS register accessor: an alias for `Reg<PSTATUS_SPEC>`"]
pub type PSTATUS = crate :: Reg < pstatus :: PSTATUS_SPEC > ; # [doc = "HOST End Point Pipe Status"]
pub mod pstatus { # [doc = "Register `PSTATUS%s` reader"]
pub struct R (crate :: R < PSTATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PSTATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PSTATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PSTATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `DTGL` reader - Data Toggle"]
pub type DTGL_R = crate :: BitReader < bool > ; # [doc = "Field `CURBK` reader - Current Bank"]
pub type CURBK_R = crate :: BitReader < bool > ; # [doc = "Field `PFREEZE` reader - Pipe Freeze"]
pub type PFREEZE_R = crate :: BitReader < bool > ; # [doc = "Field `BK0RDY` reader - Bank 0 ready"]
pub type BK0RDY_R = crate :: BitReader < bool > ; # [doc = "Field `BK1RDY` reader - Bank 1 ready"]
pub type BK1RDY_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 0 - Data Toggle"]
# [inline (always)]
pub fn dtgl (& self) -> DTGL_R { DTGL_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - Current Bank"]
# [inline (always)]
pub fn curbk (& self) -> CURBK_R { CURBK_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 4 - Pipe Freeze"]
# [inline (always)]
pub fn pfreeze (& self) -> PFREEZE_R { PFREEZE_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - Bank 0 ready"]
# [inline (always)]
pub fn bk0rdy (& self) -> BK0RDY_R { BK0RDY_R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Bank 1 ready"]
# [inline (always)]
pub fn bk1rdy (& self) -> BK1RDY_R { BK1RDY_R :: new (((self . bits >> 7) & 1) != 0) } } # [doc = "HOST End Point Pipe Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pstatus](index.html) module"]
pub struct PSTATUS_SPEC ; impl crate :: RegisterSpec for PSTATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pstatus::R](R) reader structure"]
impl crate :: Readable for PSTATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets PSTATUS%s to value 0"]
impl crate :: Resettable for PSTATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PINTFLAG register accessor: an alias for `Reg<PINTFLAG_SPEC>`"]
pub type PINTFLAG = crate :: Reg < pintflag :: PINTFLAG_SPEC > ; # [doc = "HOST Pipe Interrupt Flag"]
pub mod pintflag { # [doc = "Register `PINTFLAG%s` reader"]
pub struct R (crate :: R < PINTFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PINTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PINTFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PINTFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `PINTFLAG%s` writer"]
pub struct W (crate :: W < PINTFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PINTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PINTFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PINTFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `TRCPT0` reader - Transfer Complete 0 Interrupt Flag"]
pub type TRCPT0_R = crate :: BitReader < bool > ; # [doc = "Field `TRCPT0` writer - Transfer Complete 0 Interrupt Flag"]
pub type TRCPT0_W < 'a > = crate :: BitWriter < 'a , u8 , PINTFLAG_SPEC , bool , 0 > ; # [doc = "Field `TRCPT1` reader - Transfer Complete 1 Interrupt Flag"]
pub type TRCPT1_R = crate :: BitReader < bool > ; # [doc = "Field `TRCPT1` writer - Transfer Complete 1 Interrupt Flag"]
pub type TRCPT1_W < 'a > = crate :: BitWriter < 'a , u8 , PINTFLAG_SPEC , bool , 1 > ; # [doc = "Field `TRFAIL` reader - Error Flow Interrupt Flag"]
pub type TRFAIL_R = crate :: BitReader < bool > ; # [doc = "Field `TRFAIL` writer - Error Flow Interrupt Flag"]
pub type TRFAIL_W < 'a > = crate :: BitWriter < 'a , u8 , PINTFLAG_SPEC , bool , 2 > ; # [doc = "Field `PERR` reader - Pipe Error Interrupt Flag"]
pub type PERR_R = crate :: BitReader < bool > ; # [doc = "Field `PERR` writer - Pipe Error Interrupt Flag"]
pub type PERR_W < 'a > = crate :: BitWriter < 'a , u8 , PINTFLAG_SPEC , bool , 3 > ; # [doc = "Field `TXSTP` reader - Transmit Setup Interrupt Flag"]
pub type TXSTP_R = crate :: BitReader < bool > ; # [doc = "Field `TXSTP` writer - Transmit Setup Interrupt Flag"]
pub type TXSTP_W < 'a > = crate :: BitWriter < 'a , u8 , PINTFLAG_SPEC , bool , 4 > ; # [doc = "Field `STALL` reader - Stall Interrupt Flag"]
pub type STALL_R = crate :: BitReader < bool > ; # [doc = "Field `STALL` writer - Stall Interrupt Flag"]
pub type STALL_W < 'a > = crate :: BitWriter < 'a , u8 , PINTFLAG_SPEC , bool , 5 > ; impl R { # [doc = "Bit 0 - Transfer Complete 0 Interrupt Flag"]
# [inline (always)]
pub fn trcpt0 (& self) -> TRCPT0_R { TRCPT0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Transfer Complete 1 Interrupt Flag"]
# [inline (always)]
pub fn trcpt1 (& self) -> TRCPT1_R { TRCPT1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Error Flow Interrupt Flag"]
# [inline (always)]
pub fn trfail (& self) -> TRFAIL_R { TRFAIL_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pipe Error Interrupt Flag"]
# [inline (always)]
pub fn perr (& self) -> PERR_R { PERR_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Transmit Setup Interrupt Flag"]
# [inline (always)]
pub fn txstp (& self) -> TXSTP_R { TXSTP_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Stall Interrupt Flag"]
# [inline (always)]
pub fn stall (& self) -> STALL_R { STALL_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Transfer Complete 0 Interrupt Flag"]
# [inline (always)]
pub fn trcpt0 (& mut self) -> TRCPT0_W { TRCPT0_W :: new (self) } # [doc = "Bit 1 - Transfer Complete 1 Interrupt Flag"]
# [inline (always)]
pub fn trcpt1 (& mut self) -> TRCPT1_W { TRCPT1_W :: new (self) } # [doc = "Bit 2 - Error Flow Interrupt Flag"]
# [inline (always)]
pub fn trfail (& mut self) -> TRFAIL_W { TRFAIL_W :: new (self) } # [doc = "Bit 3 - Pipe Error Interrupt Flag"]
# [inline (always)]
pub fn perr (& mut self) -> PERR_W { PERR_W :: new (self) } # [doc = "Bit 4 - Transmit Setup Interrupt Flag"]
# [inline (always)]
pub fn txstp (& mut self) -> TXSTP_W { TXSTP_W :: new (self) } # [doc = "Bit 5 - Stall Interrupt Flag"]
# [inline (always)]
pub fn stall (& mut self) -> STALL_W { STALL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "HOST Pipe Interrupt Flag\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pintflag](index.html) module"]
pub struct PINTFLAG_SPEC ; impl crate :: RegisterSpec for PINTFLAG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pintflag::R](R) reader structure"]
impl crate :: Readable for PINTFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pintflag::W](W) writer structure"]
impl crate :: Writable for PINTFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PINTFLAG%s to value 0"]
impl crate :: Resettable for PINTFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PINTENCLR register accessor: an alias for `Reg<PINTENCLR_SPEC>`"]
pub type PINTENCLR = crate :: Reg < pintenclr :: PINTENCLR_SPEC > ; # [doc = "HOST Pipe Interrupt Flag Clear"]
pub mod pintenclr { # [doc = "Register `PINTENCLR%s` reader"]
pub struct R (crate :: R < PINTENCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PINTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PINTENCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PINTENCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `PINTENCLR%s` writer"]
pub struct W (crate :: W < PINTENCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PINTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PINTENCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PINTENCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `TRCPT0` reader - Transfer Complete 0 Disable"]
pub type TRCPT0_R = crate :: BitReader < bool > ; # [doc = "Field `TRCPT0` writer - Transfer Complete 0 Disable"]
pub type TRCPT0_W < 'a > = crate :: BitWriter < 'a , u8 , PINTENCLR_SPEC , bool , 0 > ; # [doc = "Field `TRCPT1` reader - Transfer Complete 1 Disable"]
pub type TRCPT1_R = crate :: BitReader < bool > ; # [doc = "Field `TRCPT1` writer - Transfer Complete 1 Disable"]
pub type TRCPT1_W < 'a > = crate :: BitWriter < 'a , u8 , PINTENCLR_SPEC , bool , 1 > ; # [doc = "Field `TRFAIL` reader - Error Flow Interrupt Disable"]
pub type TRFAIL_R = crate :: BitReader < bool > ; # [doc = "Field `TRFAIL` writer - Error Flow Interrupt Disable"]
pub type TRFAIL_W < 'a > = crate :: BitWriter < 'a , u8 , PINTENCLR_SPEC , bool , 2 > ; # [doc = "Field `PERR` reader - Pipe Error Interrupt Disable"]
pub type PERR_R = crate :: BitReader < bool > ; # [doc = "Field `PERR` writer - Pipe Error Interrupt Disable"]
pub type PERR_W < 'a > = crate :: BitWriter < 'a , u8 , PINTENCLR_SPEC , bool , 3 > ; # [doc = "Field `TXSTP` reader - Transmit Setup Interrupt Disable"]
pub type TXSTP_R = crate :: BitReader < bool > ; # [doc = "Field `TXSTP` writer - Transmit Setup Interrupt Disable"]
pub type TXSTP_W < 'a > = crate :: BitWriter < 'a , u8 , PINTENCLR_SPEC , bool , 4 > ; # [doc = "Field `STALL` reader - Stall Interrupt Disable"]
pub type STALL_R = crate :: BitReader < bool > ; # [doc = "Field `STALL` writer - Stall Interrupt Disable"]
pub type STALL_W < 'a > = crate :: BitWriter < 'a , u8 , PINTENCLR_SPEC , bool , 5 > ; impl R { # [doc = "Bit 0 - Transfer Complete 0 Disable"]
# [inline (always)]
pub fn trcpt0 (& self) -> TRCPT0_R { TRCPT0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Transfer Complete 1 Disable"]
# [inline (always)]
pub fn trcpt1 (& self) -> TRCPT1_R { TRCPT1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Error Flow Interrupt Disable"]
# [inline (always)]
pub fn trfail (& self) -> TRFAIL_R { TRFAIL_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pipe Error Interrupt Disable"]
# [inline (always)]
pub fn perr (& self) -> PERR_R { PERR_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Transmit Setup Interrupt Disable"]
# [inline (always)]
pub fn txstp (& self) -> TXSTP_R { TXSTP_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Stall Interrupt Disable"]
# [inline (always)]
pub fn stall (& self) -> STALL_R { STALL_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Transfer Complete 0 Disable"]
# [inline (always)]
pub fn trcpt0 (& mut self) -> TRCPT0_W { TRCPT0_W :: new (self) } # [doc = "Bit 1 - Transfer Complete 1 Disable"]
# [inline (always)]
pub fn trcpt1 (& mut self) -> TRCPT1_W { TRCPT1_W :: new (self) } # [doc = "Bit 2 - Error Flow Interrupt Disable"]
# [inline (always)]
pub fn trfail (& mut self) -> TRFAIL_W { TRFAIL_W :: new (self) } # [doc = "Bit 3 - Pipe Error Interrupt Disable"]
# [inline (always)]
pub fn perr (& mut self) -> PERR_W { PERR_W :: new (self) } # [doc = "Bit 4 - Transmit Setup Interrupt Disable"]
# [inline (always)]
pub fn txstp (& mut self) -> TXSTP_W { TXSTP_W :: new (self) } # [doc = "Bit 5 - Stall Interrupt Disable"]
# [inline (always)]
pub fn stall (& mut self) -> STALL_W { STALL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "HOST Pipe Interrupt Flag Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pintenclr](index.html) module"]
pub struct PINTENCLR_SPEC ; impl crate :: RegisterSpec for PINTENCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pintenclr::R](R) reader structure"]
impl crate :: Readable for PINTENCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pintenclr::W](W) writer structure"]
impl crate :: Writable for PINTENCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PINTENCLR%s to value 0"]
impl crate :: Resettable for PINTENCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "PINTENSET register accessor: an alias for `Reg<PINTENSET_SPEC>`"]
pub type PINTENSET = crate :: Reg < pintenset :: PINTENSET_SPEC > ; # [doc = "HOST Pipe Interrupt Flag Set"]
pub mod pintenset { # [doc = "Register `PINTENSET%s` reader"]
pub struct R (crate :: R < PINTENSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < PINTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < PINTENSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < PINTENSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `PINTENSET%s` writer"]
pub struct W (crate :: W < PINTENSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < PINTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < PINTENSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < PINTENSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `TRCPT0` reader - Transfer Complete 0 Interrupt Enable"]
pub type TRCPT0_R = crate :: BitReader < bool > ; # [doc = "Field `TRCPT0` writer - Transfer Complete 0 Interrupt Enable"]
pub type TRCPT0_W < 'a > = crate :: BitWriter < 'a , u8 , PINTENSET_SPEC , bool , 0 > ; # [doc = "Field `TRCPT1` reader - Transfer Complete 1 Interrupt Enable"]
pub type TRCPT1_R = crate :: BitReader < bool > ; # [doc = "Field `TRCPT1` writer - Transfer Complete 1 Interrupt Enable"]
pub type TRCPT1_W < 'a > = crate :: BitWriter < 'a , u8 , PINTENSET_SPEC , bool , 1 > ; # [doc = "Field `TRFAIL` reader - Error Flow Interrupt Enable"]
pub type TRFAIL_R = crate :: BitReader < bool > ; # [doc = "Field `TRFAIL` writer - Error Flow Interrupt Enable"]
pub type TRFAIL_W < 'a > = crate :: BitWriter < 'a , u8 , PINTENSET_SPEC , bool , 2 > ; # [doc = "Field `PERR` reader - Pipe Error Interrupt Enable"]
pub type PERR_R = crate :: BitReader < bool > ; # [doc = "Field `PERR` writer - Pipe Error Interrupt Enable"]
pub type PERR_W < 'a > = crate :: BitWriter < 'a , u8 , PINTENSET_SPEC , bool , 3 > ; # [doc = "Field `TXSTP` reader - Transmit Setup Interrupt Enable"]
pub type TXSTP_R = crate :: BitReader < bool > ; # [doc = "Field `TXSTP` writer - Transmit Setup Interrupt Enable"]
pub type TXSTP_W < 'a > = crate :: BitWriter < 'a , u8 , PINTENSET_SPEC , bool , 4 > ; # [doc = "Field `STALL` reader - Stall Interrupt Enable"]
pub type STALL_R = crate :: BitReader < bool > ; # [doc = "Field `STALL` writer - Stall Interrupt Enable"]
pub type STALL_W < 'a > = crate :: BitWriter < 'a , u8 , PINTENSET_SPEC , bool , 5 > ; impl R { # [doc = "Bit 0 - Transfer Complete 0 Interrupt Enable"]
# [inline (always)]
pub fn trcpt0 (& self) -> TRCPT0_R { TRCPT0_R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Transfer Complete 1 Interrupt Enable"]
# [inline (always)]
pub fn trcpt1 (& self) -> TRCPT1_R { TRCPT1_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Error Flow Interrupt Enable"]
# [inline (always)]
pub fn trfail (& self) -> TRFAIL_R { TRFAIL_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Pipe Error Interrupt Enable"]
# [inline (always)]
pub fn perr (& self) -> PERR_R { PERR_R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Transmit Setup Interrupt Enable"]
# [inline (always)]
pub fn txstp (& self) -> TXSTP_R { TXSTP_R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Stall Interrupt Enable"]
# [inline (always)]
pub fn stall (& self) -> STALL_R { STALL_R :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Transfer Complete 0 Interrupt Enable"]
# [inline (always)]
pub fn trcpt0 (& mut self) -> TRCPT0_W { TRCPT0_W :: new (self) } # [doc = "Bit 1 - Transfer Complete 1 Interrupt Enable"]
# [inline (always)]
pub fn trcpt1 (& mut self) -> TRCPT1_W { TRCPT1_W :: new (self) } # [doc = "Bit 2 - Error Flow Interrupt Enable"]
# [inline (always)]
pub fn trfail (& mut self) -> TRFAIL_W { TRFAIL_W :: new (self) } # [doc = "Bit 3 - Pipe Error Interrupt Enable"]
# [inline (always)]
pub fn perr (& mut self) -> PERR_W { PERR_W :: new (self) } # [doc = "Bit 4 - Transmit Setup Interrupt Enable"]
# [inline (always)]
pub fn txstp (& mut self) -> TXSTP_W { TXSTP_W :: new (self) } # [doc = "Bit 5 - Stall Interrupt Enable"]
# [inline (always)]
pub fn stall (& mut self) -> STALL_W { STALL_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "HOST Pipe Interrupt Flag Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pintenset](index.html) module"]
pub struct PINTENSET_SPEC ; impl crate :: RegisterSpec for PINTENSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [pintenset::R](R) reader structure"]
impl crate :: Readable for PINTENSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [pintenset::W](W) writer structure"]
impl crate :: Writable for PINTENSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets PINTENSET%s to value 0"]
impl crate :: Resettable for PINTENSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } } # [doc = "Watchdog Timer"]
pub struct WDT { _marker : PhantomData < * const () > } unsafe impl Send for WDT { } impl WDT { # [doc = r"Pointer to the register block"]
pub const PTR : * const wdt :: RegisterBlock = 0x4000_1000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const wdt :: RegisterBlock { Self :: PTR } } impl Deref for WDT { type Target = wdt :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for WDT { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("WDT") . finish () } } # [doc = "Watchdog Timer"]
pub mod wdt { # [doc = r"Register block"]
# [repr (C)]
pub struct RegisterBlock { # [doc = "0x00 - Control"]
pub ctrl : crate :: Reg < ctrl :: CTRL_SPEC > , # [doc = "0x01 - Configuration"]
pub config : crate :: Reg < config :: CONFIG_SPEC > , # [doc = "0x02 - Early Warning Interrupt Control"]
pub ewctrl : crate :: Reg < ewctrl :: EWCTRL_SPEC > , _reserved3 : [u8 ; 0x01]
, # [doc = "0x04 - Interrupt Enable Clear"]
pub intenclr : crate :: Reg < intenclr :: INTENCLR_SPEC > , # [doc = "0x05 - Interrupt Enable Set"]
pub intenset : crate :: Reg < intenset :: INTENSET_SPEC > , # [doc = "0x06 - Interrupt Flag Status and Clear"]
pub intflag : crate :: Reg < intflag :: INTFLAG_SPEC > , # [doc = "0x07 - Status"]
pub status : crate :: Reg < status :: STATUS_SPEC > , # [doc = "0x08 - Clear"]
pub clear : crate :: Reg < clear :: CLEAR_SPEC > , } # [doc = "CTRL register accessor: an alias for `Reg<CTRL_SPEC>`"]
pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ; # [doc = "Control"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub struct R (crate :: R < CTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `CTRL` writer"]
pub struct W (crate :: W < CTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CTRL_SPEC >) -> Self { W (writer) } } # [doc = "Field `ENABLE` reader - Enable"]
pub type ENABLE_R = crate :: BitReader < bool > ; # [doc = "Field `ENABLE` writer - Enable"]
pub type ENABLE_W < 'a > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , 1 > ; # [doc = "Field `WEN` reader - Watchdog Timer Window Mode Enable"]
pub type WEN_R = crate :: BitReader < bool > ; # [doc = "Field `WEN` writer - Watchdog Timer Window Mode Enable"]
pub type WEN_W < 'a > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , 2 > ; # [doc = "Field `ALWAYSON` reader - Always-On"]
pub type ALWAYSON_R = crate :: BitReader < bool > ; # [doc = "Field `ALWAYSON` writer - Always-On"]
pub type ALWAYSON_W < 'a > = crate :: BitWriter < 'a , u8 , CTRL_SPEC , bool , 7 > ; impl R { # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& self) -> ENABLE_R { ENABLE_R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Watchdog Timer Window Mode Enable"]
# [inline (always)]
pub fn wen (& self) -> WEN_R { WEN_R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 7 - Always-On"]
# [inline (always)]
pub fn alwayson (& self) -> ALWAYSON_R { ALWAYSON_R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 1 - Enable"]
# [inline (always)]
pub fn enable (& mut self) -> ENABLE_W { ENABLE_W :: new (self) } # [doc = "Bit 2 - Watchdog Timer Window Mode Enable"]
# [inline (always)]
pub fn wen (& mut self) -> WEN_W { WEN_W :: new (self) } # [doc = "Bit 7 - Always-On"]
# [inline (always)]
pub fn alwayson (& mut self) -> ALWAYSON_W { ALWAYSON_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](index.html) module"]
pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ctrl::R](R) reader structure"]
impl crate :: Readable for CTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ctrl::W](W) writer structure"]
impl crate :: Writable for CTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CONFIG register accessor: an alias for `Reg<CONFIG_SPEC>`"]
pub type CONFIG = crate :: Reg < config :: CONFIG_SPEC > ; # [doc = "Configuration"]
pub mod config { # [doc = "Register `CONFIG` reader"]
pub struct R (crate :: R < CONFIG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < CONFIG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < CONFIG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < CONFIG_SPEC >) -> Self { R (reader) } } # [doc = "Register `CONFIG` writer"]
pub struct W (crate :: W < CONFIG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CONFIG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CONFIG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CONFIG_SPEC >) -> Self { W (writer) } } # [doc = "Time-Out Period\n\nValue on reset: 11"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum PER_A { # [doc = "0: 8 clock cycles"]
_8 = 0 , # [doc = "1: 16 clock cycles"]
_16 = 1 , # [doc = "2: 32 clock cycles"]
_32 = 2 , # [doc = "3: 64 clock cycles"]
_64 = 3 , # [doc = "4: 128 clock cycles"]
_128 = 4 , # [doc = "5: 256 clock cycles"]
_256 = 5 , # [doc = "6: 512 clock cycles"]
_512 = 6 , # [doc = "7: 1024 clock cycles"]
_1K = 7 , # [doc = "8: 2048 clock cycles"]
_2K = 8 , # [doc = "9: 4096 clock cycles"]
_4K = 9 , # [doc = "10: 8192 clock cycles"]
_8K = 10 , # [doc = "11: 16384 clock cycles"]
_16K = 11 , } impl From < PER_A > for u8 { # [inline (always)]
fn from (variant : PER_A) -> Self { variant as _ } } # [doc = "Field `PER` reader - Time-Out Period"]
pub type PER_R = crate :: FieldReader < u8 , PER_A > ; impl PER_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < PER_A > { match self . bits { 0 => Some (PER_A :: _8) , 1 => Some (PER_A :: _16) , 2 => Some (PER_A :: _32) , 3 => Some (PER_A :: _64) , 4 => Some (PER_A :: _128) , 5 => Some (PER_A :: _256) , 6 => Some (PER_A :: _512) , 7 => Some (PER_A :: _1K) , 8 => Some (PER_A :: _2K) , 9 => Some (PER_A :: _4K) , 10 => Some (PER_A :: _8K) , 11 => Some (PER_A :: _16K) , _ => None , } } # [doc = "Checks if the value of the field is `_8`"]
# [inline (always)]
pub fn is_8 (& self) -> bool { * self == PER_A :: _8 } # [doc = "Checks if the value of the field is `_16`"]
# [inline (always)]
pub fn is_16 (& self) -> bool { * self == PER_A :: _16 } # [doc = "Checks if the value of the field is `_32`"]
# [inline (always)]
pub fn is_32 (& self) -> bool { * self == PER_A :: _32 } # [doc = "Checks if the value of the field is `_64`"]
# [inline (always)]
pub fn is_64 (& self) -> bool { * self == PER_A :: _64 } # [doc = "Checks if the value of the field is `_128`"]
# [inline (always)]
pub fn is_128 (& self) -> bool { * self == PER_A :: _128 } # [doc = "Checks if the value of the field is `_256`"]
# [inline (always)]
pub fn is_256 (& self) -> bool { * self == PER_A :: _256 } # [doc = "Checks if the value of the field is `_512`"]
# [inline (always)]
pub fn is_512 (& self) -> bool { * self == PER_A :: _512 } # [doc = "Checks if the value of the field is `_1K`"]
# [inline (always)]
pub fn is_1k (& self) -> bool { * self == PER_A :: _1K } # [doc = "Checks if the value of the field is `_2K`"]
# [inline (always)]
pub fn is_2k (& self) -> bool { * self == PER_A :: _2K } # [doc = "Checks if the value of the field is `_4K`"]
# [inline (always)]
pub fn is_4k (& self) -> bool { * self == PER_A :: _4K } # [doc = "Checks if the value of the field is `_8K`"]
# [inline (always)]
pub fn is_8k (& self) -> bool { * self == PER_A :: _8K } # [doc = "Checks if the value of the field is `_16K`"]
# [inline (always)]
pub fn is_16k (& self) -> bool { * self == PER_A :: _16K } } # [doc = "Field `PER` writer - Time-Out Period"]
pub type PER_W < 'a > = crate :: FieldWriter < 'a , u8 , CONFIG_SPEC , u8 , PER_A , 4 , 0 > ; impl < 'a > PER_W < 'a > { # [doc = "8 clock cycles"]
# [inline (always)]
pub fn _8 (self) -> & 'a mut W { self . variant (PER_A :: _8) } # [doc = "16 clock cycles"]
# [inline (always)]
pub fn _16 (self) -> & 'a mut W { self . variant (PER_A :: _16) } # [doc = "32 clock cycles"]
# [inline (always)]
pub fn _32 (self) -> & 'a mut W { self . variant (PER_A :: _32) } # [doc = "64 clock cycles"]
# [inline (always)]
pub fn _64 (self) -> & 'a mut W { self . variant (PER_A :: _64) } # [doc = "128 clock cycles"]
# [inline (always)]
pub fn _128 (self) -> & 'a mut W { self . variant (PER_A :: _128) } # [doc = "256 clock cycles"]
# [inline (always)]
pub fn _256 (self) -> & 'a mut W { self . variant (PER_A :: _256) } # [doc = "512 clock cycles"]
# [inline (always)]
pub fn _512 (self) -> & 'a mut W { self . variant (PER_A :: _512) } # [doc = "1024 clock cycles"]
# [inline (always)]
pub fn _1k (self) -> & 'a mut W { self . variant (PER_A :: _1K) } # [doc = "2048 clock cycles"]
# [inline (always)]
pub fn _2k (self) -> & 'a mut W { self . variant (PER_A :: _2K) } # [doc = "4096 clock cycles"]
# [inline (always)]
pub fn _4k (self) -> & 'a mut W { self . variant (PER_A :: _4K) } # [doc = "8192 clock cycles"]
# [inline (always)]
pub fn _8k (self) -> & 'a mut W { self . variant (PER_A :: _8K) } # [doc = "16384 clock cycles"]
# [inline (always)]
pub fn _16k (self) -> & 'a mut W { self . variant (PER_A :: _16K) } } # [doc = "Window Mode Time-Out Period\n\nValue on reset: 11"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum WINDOW_A { # [doc = "0: 8 clock cycles"]
_8 = 0 , # [doc = "1: 16 clock cycles"]
_16 = 1 , # [doc = "2: 32 clock cycles"]
_32 = 2 , # [doc = "3: 64 clock cycles"]
_64 = 3 , # [doc = "4: 128 clock cycles"]
_128 = 4 , # [doc = "5: 256 clock cycles"]
_256 = 5 , # [doc = "6: 512 clock cycles"]
_512 = 6 , # [doc = "7: 1024 clock cycles"]
_1K = 7 , # [doc = "8: 2048 clock cycles"]
_2K = 8 , # [doc = "9: 4096 clock cycles"]
_4K = 9 , # [doc = "10: 8192 clock cycles"]
_8K = 10 , # [doc = "11: 16384 clock cycles"]
_16K = 11 , } impl From < WINDOW_A > for u8 { # [inline (always)]
fn from (variant : WINDOW_A) -> Self { variant as _ } } # [doc = "Field `WINDOW` reader - Window Mode Time-Out Period"]
pub type WINDOW_R = crate :: FieldReader < u8 , WINDOW_A > ; impl WINDOW_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < WINDOW_A > { match self . bits { 0 => Some (WINDOW_A :: _8) , 1 => Some (WINDOW_A :: _16) , 2 => Some (WINDOW_A :: _32) , 3 => Some (WINDOW_A :: _64) , 4 => Some (WINDOW_A :: _128) , 5 => Some (WINDOW_A :: _256) , 6 => Some (WINDOW_A :: _512) , 7 => Some (WINDOW_A :: _1K) , 8 => Some (WINDOW_A :: _2K) , 9 => Some (WINDOW_A :: _4K) , 10 => Some (WINDOW_A :: _8K) , 11 => Some (WINDOW_A :: _16K) , _ => None , } } # [doc = "Checks if the value of the field is `_8`"]
# [inline (always)]
pub fn is_8 (& self) -> bool { * self == WINDOW_A :: _8 } # [doc = "Checks if the value of the field is `_16`"]
# [inline (always)]
pub fn is_16 (& self) -> bool { * self == WINDOW_A :: _16 } # [doc = "Checks if the value of the field is `_32`"]
# [inline (always)]
pub fn is_32 (& self) -> bool { * self == WINDOW_A :: _32 } # [doc = "Checks if the value of the field is `_64`"]
# [inline (always)]
pub fn is_64 (& self) -> bool { * self == WINDOW_A :: _64 } # [doc = "Checks if the value of the field is `_128`"]
# [inline (always)]
pub fn is_128 (& self) -> bool { * self == WINDOW_A :: _128 } # [doc = "Checks if the value of the field is `_256`"]
# [inline (always)]
pub fn is_256 (& self) -> bool { * self == WINDOW_A :: _256 } # [doc = "Checks if the value of the field is `_512`"]
# [inline (always)]
pub fn is_512 (& self) -> bool { * self == WINDOW_A :: _512 } # [doc = "Checks if the value of the field is `_1K`"]
# [inline (always)]
pub fn is_1k (& self) -> bool { * self == WINDOW_A :: _1K } # [doc = "Checks if the value of the field is `_2K`"]
# [inline (always)]
pub fn is_2k (& self) -> bool { * self == WINDOW_A :: _2K } # [doc = "Checks if the value of the field is `_4K`"]
# [inline (always)]
pub fn is_4k (& self) -> bool { * self == WINDOW_A :: _4K } # [doc = "Checks if the value of the field is `_8K`"]
# [inline (always)]
pub fn is_8k (& self) -> bool { * self == WINDOW_A :: _8K } # [doc = "Checks if the value of the field is `_16K`"]
# [inline (always)]
pub fn is_16k (& self) -> bool { * self == WINDOW_A :: _16K } } # [doc = "Field `WINDOW` writer - Window Mode Time-Out Period"]
pub type WINDOW_W < 'a > = crate :: FieldWriter < 'a , u8 , CONFIG_SPEC , u8 , WINDOW_A , 4 , 4 > ; impl < 'a > WINDOW_W < 'a > { # [doc = "8 clock cycles"]
# [inline (always)]
pub fn _8 (self) -> & 'a mut W { self . variant (WINDOW_A :: _8) } # [doc = "16 clock cycles"]
# [inline (always)]
pub fn _16 (self) -> & 'a mut W { self . variant (WINDOW_A :: _16) } # [doc = "32 clock cycles"]
# [inline (always)]
pub fn _32 (self) -> & 'a mut W { self . variant (WINDOW_A :: _32) } # [doc = "64 clock cycles"]
# [inline (always)]
pub fn _64 (self) -> & 'a mut W { self . variant (WINDOW_A :: _64) } # [doc = "128 clock cycles"]
# [inline (always)]
pub fn _128 (self) -> & 'a mut W { self . variant (WINDOW_A :: _128) } # [doc = "256 clock cycles"]
# [inline (always)]
pub fn _256 (self) -> & 'a mut W { self . variant (WINDOW_A :: _256) } # [doc = "512 clock cycles"]
# [inline (always)]
pub fn _512 (self) -> & 'a mut W { self . variant (WINDOW_A :: _512) } # [doc = "1024 clock cycles"]
# [inline (always)]
pub fn _1k (self) -> & 'a mut W { self . variant (WINDOW_A :: _1K) } # [doc = "2048 clock cycles"]
# [inline (always)]
pub fn _2k (self) -> & 'a mut W { self . variant (WINDOW_A :: _2K) } # [doc = "4096 clock cycles"]
# [inline (always)]
pub fn _4k (self) -> & 'a mut W { self . variant (WINDOW_A :: _4K) } # [doc = "8192 clock cycles"]
# [inline (always)]
pub fn _8k (self) -> & 'a mut W { self . variant (WINDOW_A :: _8K) } # [doc = "16384 clock cycles"]
# [inline (always)]
pub fn _16k (self) -> & 'a mut W { self . variant (WINDOW_A :: _16K) } } impl R { # [doc = "Bits 0:3 - Time-Out Period"]
# [inline (always)]
pub fn per (& self) -> PER_R { PER_R :: new ((self . bits & 0x0f) as u8) } # [doc = "Bits 4:7 - Window Mode Time-Out Period"]
# [inline (always)]
pub fn window (& self) -> WINDOW_R { WINDOW_R :: new (((self . bits >> 4) & 0x0f) as u8) } } impl W { # [doc = "Bits 0:3 - Time-Out Period"]
# [inline (always)]
pub fn per (& mut self) -> PER_W { PER_W :: new (self) } # [doc = "Bits 4:7 - Window Mode Time-Out Period"]
# [inline (always)]
pub fn window (& mut self) -> WINDOW_W { WINDOW_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [config](index.html) module"]
pub struct CONFIG_SPEC ; impl crate :: RegisterSpec for CONFIG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [config::R](R) reader structure"]
impl crate :: Readable for CONFIG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [config::W](W) writer structure"]
impl crate :: Writable for CONFIG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CONFIG to value 0xbb"]
impl crate :: Resettable for CONFIG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0xbb } } } # [doc = "EWCTRL register accessor: an alias for `Reg<EWCTRL_SPEC>`"]
pub type EWCTRL = crate :: Reg < ewctrl :: EWCTRL_SPEC > ; # [doc = "Early Warning Interrupt Control"]
pub mod ewctrl { # [doc = "Register `EWCTRL` reader"]
pub struct R (crate :: R < EWCTRL_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < EWCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < EWCTRL_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < EWCTRL_SPEC >) -> Self { R (reader) } } # [doc = "Register `EWCTRL` writer"]
pub struct W (crate :: W < EWCTRL_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < EWCTRL_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < EWCTRL_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < EWCTRL_SPEC >) -> Self { W (writer) } } # [doc = "Early Warning Interrupt Time Offset\n\nValue on reset: 11"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum EWOFFSET_A { # [doc = "0: 8 clock cycles"]
_8 = 0 , # [doc = "1: 16 clock cycles"]
_16 = 1 , # [doc = "2: 32 clock cycles"]
_32 = 2 , # [doc = "3: 64 clock cycles"]
_64 = 3 , # [doc = "4: 128 clock cycles"]
_128 = 4 , # [doc = "5: 256 clock cycles"]
_256 = 5 , # [doc = "6: 512 clock cycles"]
_512 = 6 , # [doc = "7: 1024 clock cycles"]
_1K = 7 , # [doc = "8: 2048 clock cycles"]
_2K = 8 , # [doc = "9: 4096 clock cycles"]
_4K = 9 , # [doc = "10: 8192 clock cycles"]
_8K = 10 , # [doc = "11: 16384 clock cycles"]
_16K = 11 , } impl From < EWOFFSET_A > for u8 { # [inline (always)]
fn from (variant : EWOFFSET_A) -> Self { variant as _ } } # [doc = "Field `EWOFFSET` reader - Early Warning Interrupt Time Offset"]
pub type EWOFFSET_R = crate :: FieldReader < u8 , EWOFFSET_A > ; impl EWOFFSET_R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub fn variant (& self) -> Option < EWOFFSET_A > { match self . bits { 0 => Some (EWOFFSET_A :: _8) , 1 => Some (EWOFFSET_A :: _16) , 2 => Some (EWOFFSET_A :: _32) , 3 => Some (EWOFFSET_A :: _64) , 4 => Some (EWOFFSET_A :: _128) , 5 => Some (EWOFFSET_A :: _256) , 6 => Some (EWOFFSET_A :: _512) , 7 => Some (EWOFFSET_A :: _1K) , 8 => Some (EWOFFSET_A :: _2K) , 9 => Some (EWOFFSET_A :: _4K) , 10 => Some (EWOFFSET_A :: _8K) , 11 => Some (EWOFFSET_A :: _16K) , _ => None , } } # [doc = "Checks if the value of the field is `_8`"]
# [inline (always)]
pub fn is_8 (& self) -> bool { * self == EWOFFSET_A :: _8 } # [doc = "Checks if the value of the field is `_16`"]
# [inline (always)]
pub fn is_16 (& self) -> bool { * self == EWOFFSET_A :: _16 } # [doc = "Checks if the value of the field is `_32`"]
# [inline (always)]
pub fn is_32 (& self) -> bool { * self == EWOFFSET_A :: _32 } # [doc = "Checks if the value of the field is `_64`"]
# [inline (always)]
pub fn is_64 (& self) -> bool { * self == EWOFFSET_A :: _64 } # [doc = "Checks if the value of the field is `_128`"]
# [inline (always)]
pub fn is_128 (& self) -> bool { * self == EWOFFSET_A :: _128 } # [doc = "Checks if the value of the field is `_256`"]
# [inline (always)]
pub fn is_256 (& self) -> bool { * self == EWOFFSET_A :: _256 } # [doc = "Checks if the value of the field is `_512`"]
# [inline (always)]
pub fn is_512 (& self) -> bool { * self == EWOFFSET_A :: _512 } # [doc = "Checks if the value of the field is `_1K`"]
# [inline (always)]
pub fn is_1k (& self) -> bool { * self == EWOFFSET_A :: _1K } # [doc = "Checks if the value of the field is `_2K`"]
# [inline (always)]
pub fn is_2k (& self) -> bool { * self == EWOFFSET_A :: _2K } # [doc = "Checks if the value of the field is `_4K`"]
# [inline (always)]
pub fn is_4k (& self) -> bool { * self == EWOFFSET_A :: _4K } # [doc = "Checks if the value of the field is `_8K`"]
# [inline (always)]
pub fn is_8k (& self) -> bool { * self == EWOFFSET_A :: _8K } # [doc = "Checks if the value of the field is `_16K`"]
# [inline (always)]
pub fn is_16k (& self) -> bool { * self == EWOFFSET_A :: _16K } } # [doc = "Field `EWOFFSET` writer - Early Warning Interrupt Time Offset"]
pub type EWOFFSET_W < 'a > = crate :: FieldWriter < 'a , u8 , EWCTRL_SPEC , u8 , EWOFFSET_A , 4 , 0 > ; impl < 'a > EWOFFSET_W < 'a > { # [doc = "8 clock cycles"]
# [inline (always)]
pub fn _8 (self) -> & 'a mut W { self . variant (EWOFFSET_A :: _8) } # [doc = "16 clock cycles"]
# [inline (always)]
pub fn _16 (self) -> & 'a mut W { self . variant (EWOFFSET_A :: _16) } # [doc = "32 clock cycles"]
# [inline (always)]
pub fn _32 (self) -> & 'a mut W { self . variant (EWOFFSET_A :: _32) } # [doc = "64 clock cycles"]
# [inline (always)]
pub fn _64 (self) -> & 'a mut W { self . variant (EWOFFSET_A :: _64) } # [doc = "128 clock cycles"]
# [inline (always)]
pub fn _128 (self) -> & 'a mut W { self . variant (EWOFFSET_A :: _128) } # [doc = "256 clock cycles"]
# [inline (always)]
pub fn _256 (self) -> & 'a mut W { self . variant (EWOFFSET_A :: _256) } # [doc = "512 clock cycles"]
# [inline (always)]
pub fn _512 (self) -> & 'a mut W { self . variant (EWOFFSET_A :: _512) } # [doc = "1024 clock cycles"]
# [inline (always)]
pub fn _1k (self) -> & 'a mut W { self . variant (EWOFFSET_A :: _1K) } # [doc = "2048 clock cycles"]
# [inline (always)]
pub fn _2k (self) -> & 'a mut W { self . variant (EWOFFSET_A :: _2K) } # [doc = "4096 clock cycles"]
# [inline (always)]
pub fn _4k (self) -> & 'a mut W { self . variant (EWOFFSET_A :: _4K) } # [doc = "8192 clock cycles"]
# [inline (always)]
pub fn _8k (self) -> & 'a mut W { self . variant (EWOFFSET_A :: _8K) } # [doc = "16384 clock cycles"]
# [inline (always)]
pub fn _16k (self) -> & 'a mut W { self . variant (EWOFFSET_A :: _16K) } } impl R { # [doc = "Bits 0:3 - Early Warning Interrupt Time Offset"]
# [inline (always)]
pub fn ewoffset (& self) -> EWOFFSET_R { EWOFFSET_R :: new ((self . bits & 0x0f) as u8) } } impl W { # [doc = "Bits 0:3 - Early Warning Interrupt Time Offset"]
# [inline (always)]
pub fn ewoffset (& mut self) -> EWOFFSET_W { EWOFFSET_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Early Warning Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ewctrl](index.html) module"]
pub struct EWCTRL_SPEC ; impl crate :: RegisterSpec for EWCTRL_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [ewctrl::R](R) reader structure"]
impl crate :: Readable for EWCTRL_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [ewctrl::W](W) writer structure"]
impl crate :: Writable for EWCTRL_SPEC { type Writer = W ; } # [doc = "`reset()` method sets EWCTRL to value 0x0b"]
impl crate :: Resettable for EWCTRL_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0x0b } } } # [doc = "INTENCLR register accessor: an alias for `Reg<INTENCLR_SPEC>`"]
pub type INTENCLR = crate :: Reg < intenclr :: INTENCLR_SPEC > ; # [doc = "Interrupt Enable Clear"]
pub mod intenclr { # [doc = "Register `INTENCLR` reader"]
pub struct R (crate :: R < INTENCLR_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENCLR_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENCLR_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENCLR` writer"]
pub struct W (crate :: W < INTENCLR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENCLR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENCLR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENCLR_SPEC >) -> Self { W (writer) } } # [doc = "Field `EW` reader - Early Warning Interrupt Enable"]
pub type EW_R = crate :: BitReader < bool > ; # [doc = "Field `EW` writer - Early Warning Interrupt Enable"]
pub type EW_W < 'a > = crate :: BitWriter < 'a , u8 , INTENCLR_SPEC , bool , 0 > ; impl R { # [doc = "Bit 0 - Early Warning Interrupt Enable"]
# [inline (always)]
pub fn ew (& self) -> EW_R { EW_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Early Warning Interrupt Enable"]
# [inline (always)]
pub fn ew (& mut self) -> EW_W { EW_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenclr](index.html) module"]
pub struct INTENCLR_SPEC ; impl crate :: RegisterSpec for INTENCLR_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenclr::R](R) reader structure"]
impl crate :: Readable for INTENCLR_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenclr::W](W) writer structure"]
impl crate :: Writable for INTENCLR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENCLR to value 0"]
impl crate :: Resettable for INTENCLR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTENSET register accessor: an alias for `Reg<INTENSET_SPEC>`"]
pub type INTENSET = crate :: Reg < intenset :: INTENSET_SPEC > ; # [doc = "Interrupt Enable Set"]
pub mod intenset { # [doc = "Register `INTENSET` reader"]
pub struct R (crate :: R < INTENSET_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTENSET_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTENSET_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTENSET` writer"]
pub struct W (crate :: W < INTENSET_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTENSET_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTENSET_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTENSET_SPEC >) -> Self { W (writer) } } # [doc = "Field `EW` reader - Early Warning Interrupt Enable"]
pub type EW_R = crate :: BitReader < bool > ; # [doc = "Field `EW` writer - Early Warning Interrupt Enable"]
pub type EW_W < 'a > = crate :: BitWriter < 'a , u8 , INTENSET_SPEC , bool , 0 > ; impl R { # [doc = "Bit 0 - Early Warning Interrupt Enable"]
# [inline (always)]
pub fn ew (& self) -> EW_R { EW_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Early Warning Interrupt Enable"]
# [inline (always)]
pub fn ew (& mut self) -> EW_W { EW_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intenset](index.html) module"]
pub struct INTENSET_SPEC ; impl crate :: RegisterSpec for INTENSET_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intenset::R](R) reader structure"]
impl crate :: Readable for INTENSET_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intenset::W](W) writer structure"]
impl crate :: Writable for INTENSET_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTENSET to value 0"]
impl crate :: Resettable for INTENSET_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "INTFLAG register accessor: an alias for `Reg<INTFLAG_SPEC>`"]
pub type INTFLAG = crate :: Reg < intflag :: INTFLAG_SPEC > ; # [doc = "Interrupt Flag Status and Clear"]
pub mod intflag { # [doc = "Register `INTFLAG` reader"]
pub struct R (crate :: R < INTFLAG_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < INTFLAG_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < INTFLAG_SPEC >) -> Self { R (reader) } } # [doc = "Register `INTFLAG` writer"]
pub struct W (crate :: W < INTFLAG_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < INTFLAG_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < INTFLAG_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < INTFLAG_SPEC >) -> Self { W (writer) } } # [doc = "Field `EW` reader - Early Warning"]
pub type EW_R = crate :: BitReader < bool > ; # [doc = "Field `EW` writer - Early Warning"]
pub type EW_W < 'a > = crate :: BitWriter < 'a , u8 , INTFLAG_SPEC , bool , 0 > ; impl R { # [doc = "Bit 0 - Early Warning"]
# [inline (always)]
pub fn ew (& self) -> EW_R { EW_R :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Early Warning"]
# [inline (always)]
pub fn ew (& mut self) -> EW_W { EW_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intflag](index.html) module"]
pub struct INTFLAG_SPEC ; impl crate :: RegisterSpec for INTFLAG_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [intflag::R](R) reader structure"]
impl crate :: Readable for INTFLAG_SPEC { type Reader = R ; } # [doc = "`write(|w| ..)` method takes [intflag::W](W) writer structure"]
impl crate :: Writable for INTFLAG_SPEC { type Writer = W ; } # [doc = "`reset()` method sets INTFLAG to value 0"]
impl crate :: Resettable for INTFLAG_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "STATUS register accessor: an alias for `Reg<STATUS_SPEC>`"]
pub type STATUS = crate :: Reg < status :: STATUS_SPEC > ; # [doc = "Status"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub struct R (crate :: R < STATUS_SPEC >) ; impl core :: ops :: Deref for R { type Target = crate :: R < STATUS_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl From < crate :: R < STATUS_SPEC >> for R { # [inline (always)]
fn from (reader : crate :: R < STATUS_SPEC >) -> Self { R (reader) } } # [doc = "Field `SYNCBUSY` reader - Synchronization Busy"]
pub type SYNCBUSY_R = crate :: BitReader < bool > ; impl R { # [doc = "Bit 7 - Synchronization Busy"]
# [inline (always)]
pub fn syncbusy (& self) -> SYNCBUSY_R { SYNCBUSY_R :: new (((self . bits >> 7) & 1) != 0) } } # [doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](index.html) module"]
pub struct STATUS_SPEC ; impl crate :: RegisterSpec for STATUS_SPEC { type Ux = u8 ; } # [doc = "`read()` method returns [status::R](R) reader structure"]
impl crate :: Readable for STATUS_SPEC { type Reader = R ; } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for STATUS_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } # [doc = "CLEAR register accessor: an alias for `Reg<CLEAR_SPEC>`"]
pub type CLEAR = crate :: Reg < clear :: CLEAR_SPEC > ; # [doc = "Clear"]
pub mod clear { # [doc = "Register `CLEAR` writer"]
pub struct W (crate :: W < CLEAR_SPEC >) ; impl core :: ops :: Deref for W { type Target = crate :: W < CLEAR_SPEC > ; # [inline (always)]
fn deref (& self) -> & Self :: Target { & self . 0 } } impl core :: ops :: DerefMut for W { # [inline (always)]
fn deref_mut (& mut self) -> & mut Self :: Target { & mut self . 0 } } impl From < crate :: W < CLEAR_SPEC >> for W { # [inline (always)]
fn from (writer : crate :: W < CLEAR_SPEC >) -> Self { W (writer) } } # [doc = "Watchdog Clear\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq)]
# [repr (u8)]
pub enum CLEAR_AW { # [doc = "165: Clear Key"]
KEY = 165 , } impl From < CLEAR_AW > for u8 { # [inline (always)]
fn from (variant : CLEAR_AW) -> Self { variant as _ } } # [doc = "Field `CLEAR` writer - Watchdog Clear"]
pub type CLEAR_W < 'a > = crate :: FieldWriter < 'a , u8 , CLEAR_SPEC , u8 , CLEAR_AW , 8 , 0 > ; impl < 'a > CLEAR_W < 'a > { # [doc = "Clear Key"]
# [inline (always)]
pub fn key (self) -> & 'a mut W { self . variant (CLEAR_AW :: KEY) } } impl W { # [doc = "Bits 0:7 - Watchdog Clear"]
# [inline (always)]
pub fn clear (& mut self) -> CLEAR_W { CLEAR_W :: new (self) } # [doc = "Writes raw bits to the register."]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : u8) -> & mut Self { self . 0 . bits (bits) ; self } } # [doc = "Clear\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clear](index.html) module"]
pub struct CLEAR_SPEC ; impl crate :: RegisterSpec for CLEAR_SPEC { type Ux = u8 ; } # [doc = "`write(|w| ..)` method takes [clear::W](W) writer structure"]
impl crate :: Writable for CLEAR_SPEC { type Writer = W ; } # [doc = "`reset()` method sets CLEAR to value 0"]
impl crate :: Resettable for CLEAR_SPEC { # [inline (always)]
fn reset_value () -> Self :: Ux { 0 } } } } # [no_mangle]
static mut DEVICE_PERIPHERALS : bool = false ; # [doc = r"All the peripherals"]
# [allow (non_snake_case)]
pub struct Peripherals { # [doc = "AC"]
pub AC : AC , # [doc = "ADC"]
pub ADC : ADC , # [doc = "DAC"]
pub DAC : DAC , # [doc = "DMAC"]
pub DMAC : DMAC , # [doc = "DSU"]
pub DSU : DSU , # [doc = "EIC"]
pub EIC : EIC , # [doc = "EVSYS"]
pub EVSYS : EVSYS , # [doc = "GCLK"]
pub GCLK : GCLK , # [doc = "HMATRIX"]
pub HMATRIX : HMATRIX , # [doc = "I2S"]
pub I2S : I2S , # [doc = "MTB"]
pub MTB : MTB , # [doc = "NVMCTRL"]
pub NVMCTRL : NVMCTRL , # [doc = "PAC0"]
pub PAC0 : PAC0 , # [doc = "PAC1"]
pub PAC1 : PAC1 , # [doc = "PAC2"]
pub PAC2 : PAC2 , # [doc = "PM"]
pub PM : PM , # [doc = "PORT"]
pub PORT : PORT , # [doc = "PORT_IOBUS"]
pub PORT_IOBUS : PORT_IOBUS , # [doc = "RTC"]
pub RTC : RTC , # [doc = "SERCOM0"]
pub SERCOM0 : SERCOM0 , # [doc = "SERCOM1"]
pub SERCOM1 : SERCOM1 , # [doc = "SERCOM2"]
pub SERCOM2 : SERCOM2 , # [doc = "SERCOM3"]
pub SERCOM3 : SERCOM3 , # [doc = "SERCOM4"]
pub SERCOM4 : SERCOM4 , # [doc = "SERCOM5"]
pub SERCOM5 : SERCOM5 , # [doc = "SYSCTRL"]
pub SYSCTRL : SYSCTRL , # [doc = "TC3"]
pub TC3 : TC3 , # [doc = "TC4"]
pub TC4 : TC4 , # [doc = "TC5"]
pub TC5 : TC5 , # [doc = "TC6"]
pub TC6 : TC6 , # [doc = "TC7"]
pub TC7 : TC7 , # [doc = "TCC0"]
pub TCC0 : TCC0 , # [doc = "TCC1"]
pub TCC1 : TCC1 , # [doc = "TCC2"]
pub TCC2 : TCC2 , # [doc = "USB"]
pub USB : USB , # [doc = "WDT"]
pub WDT : WDT , } impl Peripherals { # [doc = r"Returns all the peripherals *once*"]
# [inline]
pub fn take () -> Option < Self > { cortex_m :: interrupt :: free (| _ | { if unsafe { DEVICE_PERIPHERALS } { None } else { Some (unsafe { Peripherals :: steal () }) } }) } # [doc = r"Unchecked version of `Peripherals::take`"]
# [inline]
pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { AC : AC { _marker : PhantomData } , ADC : ADC { _marker : PhantomData } , DAC : DAC { _marker : PhantomData } , DMAC : DMAC { _marker : PhantomData } , DSU : DSU { _marker : PhantomData } , EIC : EIC { _marker : PhantomData } , EVSYS : EVSYS { _marker : PhantomData } , GCLK : GCLK { _marker : PhantomData } , HMATRIX : HMATRIX { _marker : PhantomData } , I2S : I2S { _marker : PhantomData } , MTB : MTB { _marker : PhantomData } , NVMCTRL : NVMCTRL { _marker : PhantomData } , PAC0 : PAC0 { _marker : PhantomData } , PAC1 : PAC1 { _marker : PhantomData } , PAC2 : PAC2 { _marker : PhantomData } , PM : PM { _marker : PhantomData } , PORT : PORT { _marker : PhantomData } , PORT_IOBUS : PORT_IOBUS { _marker : PhantomData } , RTC : RTC { _marker : PhantomData } , SERCOM0 : SERCOM0 { _marker : PhantomData } , SERCOM1 : SERCOM1 { _marker : PhantomData } , SERCOM2 : SERCOM2 { _marker : PhantomData } , SERCOM3 : SERCOM3 { _marker : PhantomData } , SERCOM4 : SERCOM4 { _marker : PhantomData } , SERCOM5 : SERCOM5 { _marker : PhantomData } , SYSCTRL : SYSCTRL { _marker : PhantomData } , TC3 : TC3 { _marker : PhantomData } , TC4 : TC4 { _marker : PhantomData } , TC5 : TC5 { _marker : PhantomData } , TC6 : TC6 { _marker : PhantomData } , TC7 : TC7 { _marker : PhantomData } , TCC0 : TCC0 { _marker : PhantomData } , TCC1 : TCC1 { _marker : PhantomData } , TCC2 : TCC2 { _marker : PhantomData } , USB : USB { _marker : PhantomData } , WDT : WDT { _marker : PhantomData } , } } }